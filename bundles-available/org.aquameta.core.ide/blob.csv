 \\255\\333\\245"Z\\353\\344\\353\\355fF\\354)\\267+\\224\\013\\017\\335\\255*}{}\\213U/\\237\\265\\213)	3200bd8c-3230-4df0-b035-78d53aae2aaf
!'\\374\\356Y\\013\\3609|\\244\\241\\012\\0007\\210\\377~\\357b\\005l\\323\\300\\202\\302\\302\\353J6\\034\\247\\022	var w = $("#"+id);\n\n\nvar rel_name = row.relation.schema.name + '.' + row.relation.name;\n\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    w.find('.section_content').append(widget('semantics/form_field', row.field('content')));\n    \n    w.find('.path').append(widget('semantics/form_field', row.field('path')));\n    w.find('.path_link').attr('href', row.get('path'));\n    w.find('.path_button').text(row.get('path'));\n\n    // SAVE\n    function save() {\n        row.update()\n        .then(function() {\n            w.trigger('status', ['Resource saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n        });\n    }\n\n\n    w.find('.save').on('click', save);\n    w.on('keydown', jwerty.event('ctrl+s', save));\n\n\n    // DELETE\n    w.find('.delete').on('click', function() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Resource deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    });\n    \n\n\n    // COPY\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_path = row.get('path') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('path', new_path);\n\n            row.relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Resource copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n\n});
!P\\226\\364J\\265\\362z4B\\305\\2728I\\255\\351A"\\336T\\232\\265\\215\\025\\314'\\031Y\\036n\\222\\371	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('name') + ' ' + row.get('version') }}\n</li>
!\\243#\\016\\003w*X\\257\\361\\263p\\232\\236#(P\\221c7\\341\\373\\251\\\\C@v\\266f\\214n\\010	workspace
"z\\345[\\330i\\356\\337\\232\\373\\301}\\374J\\240\\344r'%A:\\345\\363\\375j\\330dO\\216\\035\\344\\366	c7e98fc9-4324-4006-9738-ac3d869201ba
#\\235\\362\\336:?\\344\\030\\336\\211hU\\027k\\367i\\257R\\310J9\\024\\363\\225V\\204}\\245\\334\\207\\265(	<div id="{{= id }}" class="{{= name }}">\n    <ul class='join_rows'></ul>\n    <button class='new'>New</button>\n</div>
#\\306\\225\\367u\\377\\226\\035C\\000\\234\\250=\\2656\\017\\246\\025\\343a\\370\\274\\213_\\316\\022\\033#@v\\377\\255	stage_field_changed_diff
#\\346\\012\\245\\275\\221A\\263\\327)\\024\\226in\\202\\\\(\\313n\\303s\\007\\355V\\276\\010\\353\\230\\241"\\360\\363	d442d653-5e64-4cf7-bd6a-b38ee8a60c42
#\\366\\256a\\301\\367\\005\\271\\350s\\373\\250\\321\\352\\027U.\\234m\\342\\242\\245g\\022\\206\\252cl\\235\\004\\352d	var w = $("#"+id);\n\nconsole.log('comparison: ', comparison);
$.\\014\\231\\215\\314\\212\\033\\211s\\217\\242g\\377v\\217\\312)Bv\\210\\251\\367I\\012+Pm\\324\\206RZ	<div id="{{= id }}" class="{{= name }}">\n    <h1>Stage</h1>\n    \n    <table border=1 class='changes'>\n        <tr><th>row</th><th>change</th><th>unstaged</th><th>staged</th><th>row exists</th></tr>\n    </table>\n\n    <button class='stage_all'>stage all unstaged</button>\n    <button class='untrack_all'>untrack all tracked</button>\n\n    <p><button class='do_commit'>commit staged changes</button></p>\n</div>
$\\215\\321\\276\\220\\255\\334\\262\\036\\036\\330\\036\\334z\\027\\357\\333\\225\\306\\217y:w1\\017\\211\\347\\332\\351\\233Y\\233	var w = $("#"+id);\n\nvar schema_name = row.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = row.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = row.get('row_id').pk_column_id.name;\nvar pk_value = row.get('row_id').pk_value;\n\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n    \n    w.html(widget('semantics/text_identifier', real_row ));\n});\n    \n\n\nw.find('.button').click(function(event) {\n    event.stopPropagation();\n    alert('coming soon');\n\n/*    var row_id = row.get('row_id');\n\n    endpoint.schema('bundle').function('stage_row_add').args({\n        'bundle_name':    bundle.get('name'),\n        'schema_name':    row_id.pk_column_id.relation_id.schema_id.name,\n        'relation_name':  row_id.pk_column_id.relation_id.name,\n        'pk_column_name': row_id.pk_column_id.name,\n        'pk_value':       row_id.pk_value\n\n    }).done(function() {\n        alert('ok');\n    }).fail(function(message) {\n        alert('bad');\n    });\n*/        \n});\n\n
$\\225B\\246\\205\\211\\002\\274\\240R$\\314\\037\\351N4\\243N\\016fb\\207\\354\\024\\216\\177\\3653\\203\\226<\\313	89a53440-2cd0-4dca-a500-24569c49f29c
$\\236\\035\\012p\\267D\\\\\\030#_E\\265\\364\\245\\037m\\314U\\027\\311\\227h\\236\\227\\231\\210+\\211]~\\201	.{{= name }} {\n}\n\n.{{= name }} .tab {\n    display: inline-block;\n    border: 1px 1px 1px 0px solid green;\n}\n\n.{{= name }} .tab:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n
% \\370\\201d92\\274\\025E\\214\\242\\261\\361\\307\\211l\\262\\257v\\264\\245\\232T\\036t\\270\\230\\325\\205\\000W	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('ide:code_editor', { field: field, language: 'htmlmixed' }) }}\n</div>
%+\\217\\370\\2152\\001\\316\\035\\273\\364sp0\\214^\\231\\236z\\033\\255zv\\233\\366\\347\\013\\250\\321\\330\\345\\015	.{{= name }} {\n\theight: 100%;\n    width: 100%;\n    color: white;\n    /*\n    display: flex;\n    flex-flow: column nowrap;\n    position: relative;\n    */\n}\n\n.{{= name }} > nav {\n    border-bottom: 0.2rem solid #333;\n    flex: 1.5em 0 0;\n}\n\n.{{= name }} > nav a {\n    color: #555;\n    cursor: pointer;\n    padding: 0 .5em 1px 0.5em;\n    display: inline-block;\n    transition: background 0.15s ease-in;\n}\n\n.{{= name }} > nav a.selected {\n    background: #444;\n    color: white;\n}\n\n.{{= name }} > .content {\n    /* flex: 0px 1; */\n    height: 95%;\n}\n\n\n.{{= name }} > .content > div {\n    height: 100%;\n}\n\n\n.{{= name }} > .content > div.selected {\n    display: block;\n}\n
%;\\302{\\243n\\036\\200P=\\216s^\\376\\236\\267\\367\\214\\222\\0049S\\364\\237\\221/\\250\\201Dp\\321\\204	var w = $("#"+id);\n\n\nfor (var i=0;i<offstage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:stage_dialog_unstaged_field', {\n        field: offstage_field_changes[i],\n        old_val: offstage_field_changes_old_vals[i],\n        new_val: offstage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}\n
%_\\317\\302\\345kQB\\322K\\367.\\3354P\\247\\232\\327ff\\023E\\211\\206\\232M\\255\\321\\365\\233\\360&	var w = $("#"+id);\n\n\n// changes\nbundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    /* first staged, then unstaged modified, then unstaged deleted */\n    order_by: [{\n        column: 'staged'\n    }, {\n        column: 'change_type'\n    }]\n}).then(function(changes) {\n    widget.sync(changes, w.find('.changes'), function(change) {\n        return widget('ide:stage_dialog_changed_row', { bundle: bundle, change: change });\n    });\n});\n\n// commit button handler\nw.find('button.do_commit').click(function() {\n    var message;\n    if (message = prompt('enter a commit message')) {\n        endpoint.schema('bundle').function('commit', [bundle.get('name'), message])\n        .then(function() {\n            w.trigger('close_tab', { tab_id: 'stage' });\n        }).catch(function(e) {\n            alert ('fail! '+e);\n        });\n    }\n});\n\nw.find('button.stage_all').click(function() {\n    w.find('button.stage').click();\n});\n\nw.find('button.untrack_all').click(function() {\n    w.find('button.untrack').click();\n});\n\n// untracked rows\n/*\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\n\nwidget.sync(untracked_rows, w.find('.untracked_rows'), function(schema) {\n    return widget('ide:bundle_untracked_row_by_schema', { schema: schema, bundle: bundle });\n});\n*/\n\nw.bind('reload_stage_dialog', function() {\n    w.replaceWith(widget('ide:stage_dialog', { bundle: bundle }));\n});\n\n
'VO f\\2451\\275c\\227\\024\\342H\\237h\\325\\011+(\\000\\370iosH\\322\\310\\334\\301\\331~1	df6d1b09-280a-436e-8b89-8d41feb95173
(;\\242\\335\\030W/X\\346\\236\\226%y\\243\\261\\334\\224\\213\\373f\\305\\313\\3020\\030R\\317\\373\\345\\000T\\002	e9bf57c1-8616-4407-96c4-29cd79208868
(D\\275\\025\\231\\353\\227\\226\\020\\312\\017\\232\\323\\342\\214\\350\\337\\307\\313\\365\\344\\027\\326-\\367\\322\\021\\023X\\343\\011\\356	<div id="{{= id }}" class="{{= name }}">\n    \n    <h3>Import a Bundle from the Filesystem</h3>\n    \n    bundle directory: <input type='text' size=100 class='directory' value='/opt/aquameta/bundles-available/NAME'><br>\n    <button class='import'>import</button>\n</div>
(\\336\\354\\000\\001\\022\\370\\016\\272\\004\\335R\\373m9{f\\372\\343\\003#\\200\\217\\035G\\372J\\346\\345\\007\\326\\255	debugger3
)\\223\\271~\\307\\350\\016\\350\\222\\347\\033\\324e}\\032OH"P\\257\\350j\\370~~\\254\\317\\372\\230\\343\\264Q	template_route
)\\275\\217\\012`e\\215\\2603\\310\\356m\\034)\\241Pn\\256\\370\\344K,}\\034S\\256\\237\\325\\343U\\2759	c307d345-15c6-4690-a152-10b272fd8589
)\\311\\036\\034\\242\\232w\\037\\266\\221\\356Q\\207\\031\\327z\\262\\273}\\012?\\221D\\306\\215\\366l\\212\\231\\331<\\356	var w = $("#"+id);\n\nw.find('button.create').click(function() {\n    endpoint.schema('endpoint').table('remote_endpoint').insert({\n        name: w.find('input.name').val(),\n        url: w.find('input.url').val()\n    }).then(function(remote_endpoint) {\n        \n\n        endpoint.schema('bundle').table('remote').insert({\n            endpoint_id: remote_endpoint.get('id'),\n            bundle_id: bundle.get('id')\n        }).then(function() {\n            alert ('ok');\n            w.trigger('close_modal');\n        }).catch(function(e, o) {\n            alert('fail: ' + e);\n            w.trigger('close_modal');\n        });        \n        \n    }).catch(function(e, o) {\n        alert('fail: ' + e);\n        w.trigger('close_modal');\n    });\n});\n\nw.find('button.cancel').click(function() {\n    w.trigger('close_modal');\n});
**\\232oD\\000\\217`\\224\\212\\273\\037\\213\\354\\300Y\\265U\\204\\027\\247/\\232\\\\\\275\\235f-M\\227\\365\\367	<div id="{{= id }}" class="{{= name }}">\n    <h3>Untracked Rows</h3>\n\n    <button class='refresh'>&#8635;refresh</button>\n\n    <div class='bulk_action'>\n        <input type='checkbox' class='checkall'>\n        <span class='actions'>\n            <button class='ignore'>ignore</button>\n            <button class='track'>add to {{= bundle.get('name') }}</button>\n            <button class='delete'>delete</button>\n        </span>\n    </div>\n    <div class='rows'>\n    </div>\n</div>
*R%\\204/Z<\\301\\222\\341G)h1\\202K\\012\\207{\\020\\330\\2009x\\017<\\011\\336\\372\\343$\\201	This is the top level widget for the Spacebase IDE.\n
*\\342]\\252K!\\037\\241\\277L\\331\\227\\200\\247\\245\\351\\003\\3320q\\014\\005\\250\\304\\351t\\002 \\020\\206\\261\\352	ee265dda-bb3b-4c27-9270-d91cdf8eda75
+\\204\\007\\2163{\\275\\276\\2048\\314\\033\\257KU\\226\\214)\\345\\012-0\\205\\027\\037O\\246\\246(\\262=\\245	ce5ce449-1c74-40ee-85f8-316d60eb8d9a
+\\333\\322\\265,\\3644E\\327\\265\\012\\331\\3106\\304\\177PW7\\012\\231\\377\\037\\216\\261\\323k\\010[\\337\\203\\232	cfac112c-8b9a-4c30-a97d-05761c9be92c
+k\\265E-[\\252\\204\\217\\262[\\036\\0162\\361B\\315\\300YXo+\\021O\\321\\265\\365J?\\022\\326\\264	var w = $('#'+id);\nw.find('.content').append(content);\n\nfunction dismiss(event) {\n    w.fadeOut('fast').remove(); \n    return false;\n}\n\n/*\nwtf is this:  screwing up form elements in modals.\nfunction stop_event(event) {\n    event.stopPropagation();\n    return false;\n}\nw.find('> .content > *').click(stop_event);\n*/\n\nw.on('dismiss', dismiss);\n\nw.find('> .overlay').click(dismiss);\nw.on('done', dismiss);\nw.bind('close_modal', dismiss); // redundant to above?\njwerty.key('esc', dismiss);
,\\360\\34335\\236lG\\306\\226\\337\\036\\375\\247\\313\\254wI\\232_p\\217\\337\\247\\313\\013\\022\\013\\272:\\343Q	sem_fkey_autocomplete
,x\\037\\201\\332Vkia\\\\\\022\\306\\273kT\\262\\267\\3647\\232H\\254\\234\\0345w\\017\\307,Z'\\205	f38dce36-f77b-43e9-9a2c-4da393c04e6b
-\\377\\202T\\326\\270\\365#\\363u'\\2309\\304\\013Y\\003\\025\\324%\\362\\345.\\240y\\200\\266\\014\\026d]b	var w = $("#"+id);\n\nw.find('button.import').click(function() {\n    var dir = w.find('input.directory').val();\n\n    endpoint.schema('bundle').function('bundle_import_csv', [ dir ])\n    .then(function() {\n        alert ('success');\n    })\n    .catch(function(e) {\n        alert('failed:'+e);\n    });\n});
-j\\324F\\3709\\367\\340n\\273\\325\\273O\\323\\344N@jN\\221\\227\\363:\\017\\017\\261?\\016W|\\262R	3dfc84e2-9482-418a-b78a-0f78da1a62c0
-z\\2376\\342\\007yd\\335\\362\\231\\006I\\253\\350\\016\\020.o\\332\\354\\305\\332\\323\\206[\\276\\360R\\013\\220\\257	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\nvar fkeys;\nvar where_obj = {};\nwhere_obj[to_column] = from_row.get(from_column);\nfunction load_fkeys() {\n    \n    w.find('.fkeys').empty();\n    \n    fkeys = order_by_function(to_relation.rows().where(where_obj));\n    \n    widget.sync(fkeys, w.find('.fkeys'), function(row) {\n        return widget('sem_fkey_one_to_many_li', { \n            row: row,\n            to_column: to_column,\n            label_function: label_function\n        });\n    });\n    \n}\nload_fkeys();\n\n\n// Find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    name: to_relation.name,\n    schema_name: to_relation.schema.name\n}).result(function(to_relation_obj) {\n    \n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n    \n    context_data[to_column] = from_row.get(from_column);\n    \n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n    \n    w.find('.new').click(function() {\n        w.append(widget('modal_overlay', {\n            content: widget(new_row_widget, {\n                relation: to_relation_obj,\n                context_data: context_data\n            })\n        }));\n    });\n\n});\n\nw.on('reload', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});\n\nw.on('fkey_updated', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});\n\nw.on('fkey_deleted', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});
/\\350\\345;x\\013\\354\\261\\337\\007"\\265\\244\\014\\273\\023\\333\\262\\033.""\\234S\\035\\346w\\\\\\013\\342\\225W	.{{= name }} {\n}\n\n.{{= name }} .new_row_button {\n    display: inline-block;\n    text-align: center;\n    border-style: solid;\n    border-width: 1px;\n    padding: 10px;\n    margin: 5px;\n    min-height: 75px;\n    min-width: 100px;\n    vertical-align: top;\n    cursor: pointer;\n}\n\n.{{= name }} .new_row_button:hover {\n    background-color: gray;\n}\n\n.{{= name }} .new_row_button:active {\n    background-color: green;\n}\n\n.{{= name }} .new_row_icon {\n    min-height: 27px;\n}
0;\\337\\030\\240\\227\\212\\023\\374\\311\\203gx\\377\\036\\203\\335\\230\\200\\324a\\333l\\220z\\320g\\375\\260\\011\\316\\214	jwerty
0\\363\\267\\337\\264l\\321O\\373\\373\\362\\2302\\263P\\025QI\\320\\3474\\022x|\\000\\203\\315I\\271\\234\\011R	/*jshint smarttabs:true */\n\n/**\n * closestDescendant - 0.1.1 - 2013-04-09\n * https://github.com/tlindig/jquery-closest-descendant \n *\n * Copyright (c) 2013 Tobias Lindig\n * http://tlindig.de/ \n *\n * Licensed MIT\n */\n(function( $ ) {\n    \n    /**\n\t * Get the first element(s) that matches the selector by traversing down\n\t * through descendants in the DOM tree level by level. It use a breadth\n\t * first search (BFS), that mean it will stop search and not going deeper in\n\t * the current subtree if the first matching descendant was found.\n\t *\n\t * @param  {selectors} selector -required- a jQuery selector\n\t * @param  {boolean} findAll -optional- default is false, if true, every\n\t *                           subtree will be visited until first match\n\t * @return {jQuery} matched element(s)\n\t */\n    $.fn.closestDescendant = function(selector, findAll) {\n        \n        if (!selector || selector === '') {\n            return $();\n        }\n        \n        findAll = findAll ? true : false;\n        \n        var resultSet = $();\n        \n        this.each(function() {\n            \n            var $this = $(this);\n            \n            // breadth first search for every matched node,\n            // go deeper, until a child was found in the current subtree or the leave was reached.\n            var queue = [];\n            queue.push( $this );\n            while ( queue.length > 0 ) {\n                var node = queue.shift();\n                var children = node.children();\n                for ( var i = 0; i < children.length; ++i ) {\n                    var $child = $(children[i]);\n                    if ( $child.is( selector ) ) {\n                        resultSet.push( $child[0] ); //well, we found one\n                        if ( ! findAll ) {\n                            return false;//stop processing\n                        }\n                    } else {\n                        queue.push( $child ); //go deeper\n                    }\n                }\n            }\n        });\n        \n        return resultSet;\n    };\n})($);\n\n\n
1x1\\323\\323\\213[x\\346\\372@=\\351\\320\\346\\300\\273\\370\\346\\215\\031\\313\\253\\177\\313>\\267\\027\\203^\\024\\034	<div id="{{= id }}" class="{{= name }}">\n    <span>Logged in</span>\n    <div class='dropdown'>\n        <div class='username'></div>\n        <div class='logout'>Logout</div>\n    </div>\n</div>
25\\025\\242v\\305C\\202Z@>\\361\\337\\252+\\321\\242\\0064\\007\\325\\301\\312F\\200\\304x\\377Z\\213\\343/	.{{= name }} {\n\n}\n\n.{{= name }} { position: relative; } \n
2\\235\\341\\232Pg\\307\\030"\\024r\\260\\370\\271^i="6r\\017\\3369\\245D\\017Ls\\030r\\264\\304	bundle_remote_commit_comparison_row
3\\\\\\231iq\\256(\\000F\\363\\002S\\3468\\034\\026\\030\\243N\\230|\\244\\364\\352:\\252D!K\\202\\233%	.{{= name }} {\n  \tbackground: #000;\n    color: white;\n    \n   \tcursor: pointer;\n  \topacity: 0.9;\n\n    height: 100%;\n    width: 100%; \n    \n    position: fixed;\n    left: 0;\n    top: 0;\n    \n    z-index: 9;\n    \n    display: table;\n\n}\n\n.{{= name }} > .content {\n    position: absolute;\n    \n    width: 100%;\n    height: 100%;\n    \n    overflow-y: auto;\n        \n    left: 0;\n    top: 0;\n        \n    text-align: center;\n    display: table-cell;\n    vertical-align: middle;\n}\n\n
4\\353\\002\\242\\354ms\\360\\257j_\\247\\361\\215\\251\\037\\213\\265B\\271\\221j\\255Zs"\\361\\321\\303\\333\\222\\202	sem_fkey_autocomplete_form
4ad9\\177\\177\\004%\\304\\266\\316\\225\\332*w\\242`\\345\\212\\323B\\023\\305{\\006#\\227\\254uN\\030\\331	var w = $('#'+id);\n
4}\\325\\004-\\206\\246\\002sj\\272\\200\\030(f\\271W\\033V\\350\\214tVzQBbAy\\363]\\350	row_detail_tabbed
6:\\016H\\212\\366\\274\\210\\202\\357b9[\\225P\\250\\247D\\020{]\\006\\320\\314!'\\224:\\204\\013f.	a7ec4e00-8bc5-4901-aa20-fe3d31f44705
6<\\346\\267NbB\\253\\327O\\327\\344\\236\\201\\023\\362\\260\\372\\266\\230*\\376]E\\353\\357B\\242\\011\\317\\017\\202	c5ca1ee1-932d-4802-93f1-ebb97de837ff
6\\004B\\327%\\363S\\223\\260\\354*\\266\\212\\326LM\\326IZZD\\226\\304\\22459\\322\\372\\232\\243\\006\\013	bb20fbd6-05bc-45df-b6b4-669e58d0b47a
6\\347\\344\\2171\\305\\375\\232\\324\\367\\245hB\\321%?\\303t\\367\\372\\004\\203\\3625\\260X\\020a\\011Af\\001	19719263-ddf4-448b-9851-deddd1a92e21
7]u\\0167\\342\\316\\277\\322\\220\\236\\223\\365\\266P\\177\\322M/\\027Le\\237&6p\\213!h\\261q\\263	.{{= name }} {\n    position: relative;\n\tbottom: 0;\n    top: 0;\n    height: 100px;\n}\n\n.{{= name }} .new_widget {\n    padding-top: 10px;\n    color: red;\n}\n\n\n
8\\272\\337\\235\\007\\016\\263\\255LJ\\377E@Jk\\205\\251D$\\025\\270\\354\\353\\365\\330E<*\\320\\301\\250\\007	bundle_remotes
8\\342t\\312\\251\\216\\034\\201\\357\\2549\\3519j \\377\\2706\\300a9\\177\\266\\353\\337\\001|\\367OK7^	bf19b949-74d3-4938-ab5d-ad092884053d
9J\\225\\223\\265\\201\\017]\\036\\257\\373OT#*Yi\\326\\033a\\245\\321;s^I\\311c\\202E\\2224	var w = $("#"+id);\n\n\nvar show_bundles = function() {\n\n    var retrieved = false;\n\n    return function() {\n        \n        w.removeClass('bundle_edit');\n\n        if (!retrieved) {\n            retrieved = true;\n            endpoint.schema('bundle').table('bundle').rows({ order_by: {\n                column: 'name',\n                direction: 'asc'\n            }}).then(function(bundles) {\n                w.find('.bundle_list').append(widget('ide:list_view_gateway', {\n                    datum: bundles\n                }));\n            });\n        }\n    };\n}();\n\n\n\n/* URL */\n// When continue button in list_view_gateway is pressed,\n//   get the bundles and place in url\nw.on('list_view_select', function(e, bundles) {\n    var bundle_names = bundles.map(function(e) {\n        return e.get('name');\n    }).sort().join(',');\n    window.location.href = '#/' + encodeURIComponent(bundle_names);\n});\n\nvar current_state = null;\n    \nfunction select_state() {\n    \n    var slugs = window.location.hash.split('/').slice(1);\n    var new_state = null;\n    if (slugs.length) {\n        new_state = decodeURIComponent(slugs[0]);\n    }\n\n    if (new_state == null) {\n        w.data('bundles', null);\n        return show_bundles();\n    }\n    \n    w.addClass('bundle_edit');\n    if (new_state != current_state) {\n        \n        var bundles = new_state.split(',');\n        w.data('bundles', bundles);\n        \n        w.find('> .bundle_workspace').empty().html(\n            widget('dev_workspace', { base_url: '#/' + slugs[0], url_parts: slugs.slice(1) })\n        );\n        w.find('.bundle_manager_container').empty().append(\n            widget('bundle', { bundles: bundles })\n        );\n        current_state = new_state;\n    }\n\n    $('html, body').animate({\n        scrollTop: 0\n    }, 'fast');\n    \n    // Do nothing if states are the same\n    // Let the widget handle back/forward within itself\n    \n}\n$(window).on('popstate', select_state);\nselect_state();\n\n\nw.find('.select_bundles').on('click', show_bundles);\n\n\n\n/* STATUS */\nw.on('status', add_status);\n\nfunction add_status(e, message, type) {\n    e.stopPropagation();\n    w.find('.status_container').append(widget('status', { message: message, type, type }));\n}\n\n
9\\223\\036\\314\\274"\\323m\\322\\012\\020#-E\\347GJ\\302\\302#\\230\\317\\210\\000K\\205}\\250\\234m\\265Y	.{{= name }} {\r\n}
:\\274\\277\\342\\342\\253u\\312\\313R\\343\\002\\222N+\\332\\005P\\276\\2170\\276\\315\\225\\337\\355n\\253\\275\\236\\246\\305	<div id="{{= id }}" class="{{= name }}">\n    Bundle manager\n</div>
<\\202k\\2209{\\330}%\\214Z\\203\\342\\007\\032\\351v\\337\\334\\350\\272[Wk\\275\\000B\\313I\\263\\365\\373	<div id="{{= id }}" class="{{= name }}">\n    <h3>diff!</h3>\n    \n</div>
<n\\342#7;\\375 \\031\\264j\\315\\\\t\\263[6\\232d\\247\\017/\\350uRf\\374f{\\3047\\253	code_editor
=Z\\345\\360\\301f\\350C\\211V\\220.\\3178^\\370\\210\\232\\273\\204\\341\\375bF\\366\\323F\\317\\231\\310\\037w	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td class='change_type'>\n        <span title='This row has been modified' class='icon modified'>&Delta;<span class='modified_link'>(diff)</span></span>\n        <span title='This row has been deleted' class='icon deleted'>-</span>\n        <span title='This row has been added' class='icon added'>+</span>\n        <span title='This row has been tracked' class='icon tracked'>&#128065;</span>\n    </td>\n    <td>\n        <div class='unstaged'>\n            <button class='stage'>stage →</button>\n        </div>\n        <div class='unstaged_fields'>\n        </div>\n    </td>    \n    <td>\n        <div class='staged'>\n            <button class='unstage'>← unstage</button>\n        </div>\n        <div class='staged_fields'>\n        </div>\n    </td>\n    <td>{{= change.get('row_exists') }}</td>\n    <td><button class='untrack'>untrack</button></td>\n</tr>
=\\005\\262'\\027\\214\\245\\242\\224\\266~8\\177l\\005V\\012\\203&\\241\\001a\\375\\350|\\243_\\0151 \\016x	debugger3_manager
=\\236f\\227\\370\\007\\032d\\330\\232^e\\302\\350\\000\\343\\204\\220nmI\\215\\\\&\\255\\326\\366X\\376qP\\211	<div id="{{= id }}" class="{{= name }}">\n    <nobr>\n        <input type='checkbox' class='action'><span class='label'></span>\n    </nobr>\n</div>
>(C\\233\\274\\361so\\177\\345Y?M\\3671\\257\\322\\347\\273mPP\\271\\343w\\335\\214\\240\\223R\\022\\325	<div id="{{= id }}" class="{{= name }}">\n    <div class="content"></div>\n</div>
>2\\307\\220h-\\303Y\\251\\321"\\345|\\264@\\215\\211\\245\\352\\021*\\006{\\334\\366\\034Gf\\0362e8	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('schema_name') + '.' + row.get('name') }}\n</li>
>H\\244S\\005\\262\\366\\276\\326\\\\\\221\\201`\\305\\353\\233\\256\\362\\273\\3228\\017^Pk^c\\030%x\\356\\267	33a37d92-671d-4988-93c6-e18742636808
>\\007\\322\\\\\\275w\\034\\347K\\001P~\\2024\\025\\037\\335\\365\\336\\207\\243\\011\\272\\245\\210_\\304\\215\\314)\\261\\243	<div id="{{= id }}" class="{{= name }}">\n    <div class="show_all">show all</div>\n    <div class="tree_container">\n        \n    </div>\n</div>
>\\013\\340\\367ENW\\304\\021\\005g\\350\\244\\306iQ<\\253\\010J?\\317\\206\\2609\\306\\020\\257\\3123]\\034	abd67d40-5fcc-499d-be81-8f23eed50855
>\\257Y?\\225\\012)\\263\\213\\331\\355g\\252\\331<\\255\\014{\\352Iz\\2063\\222*X\\3774\\375p\\032\\263	.{{= name }} {\n}\n\n.{{= name }} > .fkeys {\n    list-style: none;\n}
>\\325\\234\\256\\203X\\377Kf\\034\\011-+\\224\\360\\325*\\177\\010\\325\\241\\354\\326\\223\\306\\361\\362)\\331\\322qY	8e0abc5c-3346-493c-895c-c3236d18ff33
@\\247\\305?\\363\\343\\017\\237\\327\\230\\265\\030q\\224\\251 \\031\\223\\256\\372j_\\304Y'\\276\\372@O\\271p\\\\	<tr id="{{= id }}" class="{{= name }}">\n    <td class="local comp">\n        {{= comparison.row.local_commit_id }}\n    </td>\n    \n    <td class="remote comp">\n        {{= comparison.row.remote_commit_id }}\n    </td>\n</tr>
A\\301\\213\\222\\011\\024\\016\\026\\334/Z\\354t\\317\\177b}\\335\\272\\036T\\267W\\242h7>T\\313:\\323G	fkey_test
B\\\\<\\2033\\232\\255]\\344X\\367d\\256[\\373\\213\\324~a\\312!!\\007Ay\\210\\234\\014_\\361\\307\\252	<div id="{{= id }}" class="{{= name }}">\n    <h2>New row</h2>\n    <input class='name' type='text' placeholder='New name'>\n    <button class='save'>Create</button>\n    <button class='save_as_null'>Save as null</button>\n</div>
C+\\032Z\\242\\316\\020Q\\030\\2463\\343"c:$\\255\\3247w\\255\\226\\221\\262\\205\\031J\\260\\021\\213_\\370	var w = $("#"+id);\n\nvar change = commit_row.get('change_type');\n\nif (change != 'same') {\n    if (change == 'added')\n\t    w.find('.added').show();\n    else if (change == 'deleted')\n\t    w.find('.deleted').show();\n    else if (change == 'modified')\n\t    w.find('.modified').show();\n    else if (change == 'tracked')\n\t    w.find('.tracked').show();\n    else w.append('UNKNOWN CHANGE TYPE: '+change);\n}\n\nvar exists = commit_row.get('row_exists');\nif (exists == false) {\n    w.find('.doesnt_exist').show();\n}\n\nvar schema_name = commit_row.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = commit_row.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = commit_row.get('row_id').pk_column_id.name;\nvar pk_value = commit_row.get('row_id').pk_value;\n\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n    \n    w.find('.label').html(widget('semantics/text_identifier', real_row ));\n    \n\t// click handler needs real_row, so put the handler in here after real_row is loaded\n    w.click(function() {\n        w.trigger('bundle_row_open', { row_id: commit_row.get('row_id'), row: real_row });\n    });\n    return real_row;\n\n}).catch(function(e) {\n    console.log(e);\n\tw.find('.label').html(schema_name+'.'+relation_name+'.'+pk_value);\n}).then(function() {\n    //w.show();\n    w.find('.label > *').ready(function() {\n        w.show();\n    });\n});\n\n\n
C\\2732BeBu\\263+\\370\\273M\\334ny\\237z\\307%\\201Q\\2427\\011\\016\\011 CP\\177\\002\\036	var w = $("#"+id);\n\n\nfor (var i=0;i<stage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:stage_dialog_staged_field', {\n        field: stage_field_changes[i],\n        old_val: stage_field_changes_old_vals[i],\n        new_val: stage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}\n
EY\\241\\277Zi\\346\\255\\262E\\012![\\010g\\320\\372%\\213p\\330*$\\222a0\\257aj\\341<z	var w = $("#"+id);\n\nw.click(function(event) {\n    event.stopPropagation();\n\n    w.find('> ul').toggleClass('open');\n    if (!w.find('> ul').hasClass('open')) {\n        w.find('> ul').empty();\n    } else {\n        var relations = schema.related_rows('schema_id','bundle.untracked_row_by_relation','schema_id');\n        widget.sync(relations, w.find('ul'), function(relation) {\n            return widget('bundle_untracked_row_by_relation', { relation: relation })\n        });\n    }\n});
F\\020\\011\\246\\260\\270PGz\\320\\261\\326a\\324Cz\\274H8\\311\\375\\010\\277js\\034g\\274\\373\\036\\245:	.{{= name }} button.stage {\n    float: right;\n}
F\\227SD\\356m\\215|W\\017\\032\\353\\362\\371\\222f\\203\\322\\031\\363\\245W\\237\\011\\275\\033k\\345\\340)\\011\\335	.{{= name }} {\n    height: 100%;\n}\n\n.{{= name }} .tabs {\n    height: 100%;\n}
Fr\\017n\\241]3\\340W\\023\\323\\254\\215\\356u\\215\\350\\360\\036t\\312c\\334\\355\\365i\\305\\231]v\\313\\007	row_list
H\\022\\273`\\256\\354$\\000\\2462E\\362\\\\\\331b~\\212\\341\\023\\230Y%80t\\224\\2628\\002\\0262l	<div id="{{= id }}" class="{{= name }}">\n    <div class='fields'>\n    </div>\n</div>
I88\\217\\014he\\012! \\253\\003\\337\\277\\2169\\260\\216\\334\\240\\320\\206\\263\\303\\375\\002\\350NP\\032_\\253	var w = $("#"+id);
I\\355\\204\\320[Y\\324\\311m\\301\\226\\030.\\265B\\022\\363m\\300\\254\\012\\255N\\252\\302\\204!,\\362\\353\\350|	if (typeof data_name != 'undefined' && typeof data != 'undefined') {\n    $('#'+id).data(data_name, data);\n}
J\\331[@L\\012c\\017\\237s\\334\\360\\270\\236\\352S\\324|\\211\\017\\336\\034\\005\\333\\307\\000\\276\\217j\\210\\015\\361	6c743b6f-ac9a-4c49-bf56-9903254d6643
M+G\\223\\245\\364^\\024\\003i8\\223{\\261\\315@\\226\\035\\015\\014\\316\\375V\\240\\247\\325\\012Z_gD\\331	workspace_tab_header
M\\251c\\221\\216]\\330\\275\\220\\317*p\\000\\330\\200\\373\\372R\\322\\210(\\3307\\275\\257\\257\\235\\273\\031\\261\\255\\026	bundle_ignored_schema
Nhv\\266\\335\\355+'\\335\\307\\367\\346\\027P\\032\\035\\244\\257\\015k5$\\243\\004\\003p#\\005\\300\\306\\022\\312	stage_dialog_changed_row
Pyi\\330\\\\\\340\\270,L:\\323\\352W\\333\\264\\032\\350O{[\\244G}[P\\012\\231\\032\\312\\006\\254\\016	.{{= name }} {\n    border: 2px dotted red;\n    padding: 5px;\n    margin: 5px;\n}
R\\240E\\211\\350\\340\\325\\303x\\342w\\3633\\206j\\354z\\005c\\363\\201\\204B\\276\\177Bh\\353\\214/\\332\\275	a4d101f6-3d5f-464b-87d6-637525254ed8
R\\275\\026!~\\213\\220\\211G\\003\\361\\217x\\2767\\354\\260\\277\\377\\016\\030s\\021OC\\366\\312\\035\\247\\036\\266}	var w = $("#"+id);\n\n\nvar rel_name = row.relation.schema.name + '.' + row.relation.name;\n\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    w.find('.section_content').append(widget('semantics/form_field', row.field('content')));\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    w.find('.version').append(widget('semantics/form_field', row.field('version')));\n\n    // SAVE\n    function save() {\n        row.update()\n        .then(function() {\n            w.trigger('status', ['Dependency saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n        });\n    }\n\n\n    w.find('.save').on('click', save);\n    w.on('keydown', jwerty.event('ctrl+s', save));\n\n\n    // DELETE\n    w.find('.delete').on('click', function() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Dependency deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    });\n    \n\n\n    // COPY\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n            row.relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Dependency copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n\n});
SW\\230\\327\\272\\250\\247\\016\\3758\\030>\\231|\\241\\325\\321\\256!N\\326\\213\\354\\012\\230Z\\260\\377\\322\\026ym	<div id="{{= id }}" class="{{= name }}">\n    <h2>New Row</h2>\n    <hr/>\n    \n    <h3>Development</h3>\n    <div class="new_row_buttons">\n        <div id="widget" class="new_row_button">\n            <div class="new_row_icon">⚙</div>\n            <div class="new_row_name">Widget</div>\n        </div>\n        <div id="resource" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Resource</div>\n        </div>\n        <div id="template" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Template</div>\n        </div>        \n        <div id="dependency_js" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Javascript Library</div>\n        </div>\n        <div id="table" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Table</div>\n        </div>\n        <div id="view" class="new_row_button">\n            <div class="new_row_icon">⌕</div>\n            <div class="new_row_name">View</div>\n        </div>\n        <div id="function" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Function</div>\n        </div>\n        <div id="resource_binary" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Binary</div>\n        </div>\n        <div id="fdw" class="new_row_button">\n            <div class="new_row_icon">&#8599;</div>\n            <div class="new_row_name">Foreign Table</div>\n        </div>\n    </div>\n    \n    <h3>Bundle</h3>\n    \n    <h3>Everything</h3>\n</div>
SX\\377Sh\\020V\\256\\003VF*\\3438}c\\326x\\324\\324\\266IXe\\011\\375\\242\\345\\341Po\\250	fcda24f0-1c2a-4b7d-a488-da24c13fef6c
S\\270?\\311\\303\\335\\001b\\035,\\006\\203\\364\\231\\033\\266%%O\\2203\\247\\326\\330\\264j\\372\\001<\\300\\330~	bundle_untracked_browser
S\\350`\\036\\220s\\3720\\031\\264\\014\\334]%t\\006eS\\\\\\222\\222\\207\\266\\346}\\234\\204\\000\\001\\205\\177\\240	file_input
U\\242\\305\\014&\\201\\023\\305\\211\\026m\\254\\265<O\\232\\250\\335<\\276U\\032\\254\\027s.9d\\276\\242\\347\\325	8ab2e8c6-93be-4367-b5ee-1e2c14579929
W\\003\\367tV\\007v\\027XC\\300\\001X\\035\\011\\231]f\\204\\221S\\0254\\242\\317\\336\\247\\274V\\265\\036z	<div id="{{= id }}" class="{{= name }}">\n    <div class='tools'>\n    </div>\n    <div class='tabs'></div>\n\n</div>
W\\256\\026\\022\\271i \\024HIS\\317\\340\\332\\222\\026C+\\323r\\253\\204\\241\\270\\004\\034\\363\\271\\221\\374\\232\\207	506990f8-99c0-4441-a3fd-04ec402d7e22
W\\320.1\\241\\\\\\300F4\\006@\\023\\371N\\331F\\224\\253\\222\\014g0_Lr\\243\\317\\202\\005\\201$\\012	f71fad4d-4284-47f5-9dbf-bffdded7973b
W\\351#\\200\\021k\\177\\372\\216\\017\\317b\\025*\\317f\\243\\365\\262\\177k[\\244\\216t\\360\\344\\016\\251\\237s\\003	bundle_ignored
XP\\002To\\250\\263\\007q\\354D\\215\\307Y\\255\\257Z\\217\\257B\\301Mo@1g\\030\\256?\\300RC	debugger3_widgets
Y\\306\\371@\\030\\257\\256\\313Ch{\\243o\\333\\223<\\314\\244\\371">\\315r5m\\230#%.\\015Y\\307	.{{= name }} {\n    height: 100%;\n}
Z\\237\\327\\360\\023\\307,\\007\\367+\\341e\\014\\210\\231\\234\\033("\\231\\243J\\357\\231\\242\\256\\002\\033\\345\\024\\372\\010	.{{= name }} {\n    border-top: 1px solid white;\n    height: 100%;\n    overflow: auto;\n    padding: 10px;\n}
Z\\316=%\\316e\\220\\245\\351|\\321\\264\\202\\311z\\214\\2003\\010\\357@\\244\\311\\2465\\035\\254\\216\\325\\024\\250\\257	b6638ea9-df8f-409e-990b-34ffee6ab4f3
[4\\306\\245\\020\\253\\235\\012\\376\\352AG\\234D\\376"\\032\\340\\217\\350\\272M4\\223-1(\\273\\263\\361\\236\\331	resource_binary_upload
[\\212\\316z\\035\\354sQ\\203\\331\\277\\346+\\024h\\372\\2509\\036dX\\225\\240>\\326Y\\343\\355^4\\367N	var w = $("#"+id);\n\n\nfunction new_tab(tab_id, label, content) {\n    // console.log('opening new tab');\n    // create the header\n    w.find('.tab_headers').append(widget('ide:workspace_tab_header', {\n        label: label,\n        tab_id: tab_id\n    }));\n\n\n    // create the tab\n    w.find('> .tab_contents').append(widget('ide:workspace_tab', {\n        content: content,\n        tab_id: tab_id\n    }));\n\n    // focus\n    show_tab(tab_id);\n}\n\nfunction current_tab() {\n    return w.find('.workspace_tab_header.highlighted').first().data('tab_id');\n}\n\nfunction show_tab(tab_id) {\n    // console.log('show tab ', tab_id);\n    // show the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).show();\n        } else {\n            $(this).hide();\n        }\n    })\n\n    // highlight the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).addClass('highlighted');\n        } else {\n            $(this).removeClass('highlighted');\n        }\n    })\n}\n\nfunction close_tab(tab_id) {\n    /*\n    why doesn't this work?\n    w.find('.workspace_tab[data-tab_id="'+tab_id+'"]').remove();\n    w.find('.workspace_tab_header[data-tab_id="'+tab_id+'"]').remove();\n    */\n    \n    var current_tab_closed = false;\n    if (tab_id == current_tab()) {\n        current_tab_closed = true;\n    }\n    \n    // remove the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // remove the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // if the current tab is closed, replace it with another\n    if (current_tab_closed) {\n        var last_tab = w.find('.workspace_tab').last();\n        if (last_tab) {\n            show_tab(last_tab.data('tab_id'));\n        }\n    }\n}\n\nfunction tab_is_open(tab_id) {\n    // check to see if it's already open\n    var is_open = false;\n    var tabs = w.find('.workspace_tab');\n    for (var i=0;i<tabs.length;i++) {\n        var this_tab_id = $(tabs[i]).data('tab_id');\n\n        // console.log('comparing '+this_tab_id +' to ' + tab_id);\n        if (this_tab_id == tab_id) {\n            // console.log('already open');\n            return true;\n        }\n    };\n    return false;\n}\n\nw.closest('.ide').bind('close_tab', function(e,o) {\n    close_tab(o.tab_id);\n});\n\nw.closest('.ide').bind('show_tab', function(e,o) {\n    show_tab(o.tab_id);\n});\n\nconsole.log(endpoint);\n// handler for row clicked event\nw.closest('.ide').bind('bundle_row_open', function(e, o) {\n    // console.log('bundle_row_clicked', e, o);\n\n    var row_id = o.row_id;\n    var row = o.row;\n\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_val = row_id.pk_value;\n    var label = widget('semantics/text_identifier', row);\n    var tab_id = schema_name + '.' + relation_name + '.' + pk_val;\n\n    if (!tab_is_open(tab_id)) {\n        console.log(endpoint);\n        // open a new tab for this row\n        endpoint\n        .schema(schema_name)\n        .table(relation_name)\n        .row(pk_column_name, pk_val).then(function(real_row) {\n            new_tab(tab_id, label, widget('semantics/row_detail', real_row));\n        }).catch(function(e) {\n            console.log('error: ',e);\n        });\n    } else {\n        // send to front\n        show_tab(tab_id);\n    }\n\n\n});\n\n// new generic dialog handler\nw.closest('.ide').bind('open_tab', function(e,o) {\n    var tab_id = o.tab_id;\n\n    if (tab_is_open(tab_id)) {\n        show_tab(tab_id);\n    } else {\n        switch (tab_id) {\n            case 'new_row':\n                new_tab('new_row', 'New Row', widget('ide:new_row_dialog', { bundle: bundle }));\n                break;\n            case 'stage':\n                new_tab('stage', 'Stage', widget('ide:stage_dialog', { bundle: bundle }));\n                break;\n            case 'commit_log':\n                new_tab('commit_log', 'Commit History', widget('ide:commit_history_dialog', { bundle: bundle }));\n                break;\n            case 'bundle_config':\n                new_tab('bundle_config', 'Bundle Config', widget('ide:bundle_config_dialog', { bundle: bundle }));\n                break;\n            case 'push_pull':\n                new_tab('push_pull', 'Push Pull', widget('ide:bundle_push_pull', { bundle: bundle }));\n                break;\n            case 'untracked':\n                new_tab('untracked', 'Untracked Rows', widget('ide:bundle_untracked', { bundle: bundle }));\n                break;\n            case 'export':\n                new_tab('export', 'Export', widget('ide:bundle_export', { bundle: bundle }));\n                break;\n            case 'resource_binary_upload':\n                new_tab('resource_binary_upload', 'Resource Binary Upload', widget('ide:resource_binary_upload', { bundle: bundle }));\n                break;\n            case 'ignored':\n                new_tab('ignored', 'Ignored', widget('ide:bundle_ignored', { bundle: bundle }));\n                break;\n            default:\n                alert ('internal error: no such dialog as '+tab_id);\n        }\n    }\n});\n\n// close generic dialog\nw.closest('.ide').bind('close_tab', function(e,o) {\n    var tab_id = o.tab_id;\n    close_tab(o.tab_id);\n});\n\n\n\n\n\n
[\\251\\227\\350Q\\210\\330\\2055\\213\\276\\267\\221\\267\\033\\033\\250e\\013\\262\\027\\243\\341\\324\\366a\\376\\256h\\360\\227\\271	codemirror
[\\256);\\257\\010W\\036O\\364\\345w\\221q\\310/h\\321^\\210GZ\\264\\243\\000\\030\\014\\204\\317\\340\\303\\025	.{{= name }} h3 {\n    text-decoration: underline;\n}
[\\321nk\\273$\\261"C\\263e\\244]S\\027*S\\276\\230\\246\\007Q\\364\\341B\\347\\341\\347i[\\275\\346	.{{= name }} {\n    padding: 1px;\n    margin-bottom: 1px;\n}\n\n\n.{{= name }}:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n\n\n.{{= name }} .button {\n    float: right;\n\tborder-radius: 50%;\n    width: 1.5ex;\n    height: 1.5ex;\n    background-color: white;\n    color: black;\n}
\\000\\246`Oq\\0339Q\\251\\311\\271*\\322\\023\\361\\357\\236\\327\\220zG6\\337\\025\\310\\233\\027H\\003\\216Kc	793960f9-5522-499b-a36e-144f80c8a741
\\001\\004\\004\\274\\273\\353\\241\\237\\005WHU\\367#`WQr|\\254\\207\\214\\2123zN\\252\\201J\\317\\252\\334	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .top .title {\n    padding: 0;\n    margin: 0;\n    font-size: 1.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    float: right;\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\001\\304\\033\\236\\021\\275\\341|\\224,c\\262\\013\\353\\274\\340\\344\\023\\327\\316\\2026\\261c6=\\376\\250\\202\\317\\253\\313	bundle_untracked_row_by_relation
\\001\\327z\\376W\\013\\345\\315\\222%f\\250\\350\\345\\377G\\254ix\\204\\262\\223\\350@!r\\327\\222c\\207[\\236	<span id="{{= id }}" class="{{= name }}">\n\tlist_item_identifier\t\n</span>\n
\\003\\022a2\\376\\353\\323#\\266\\033\\361\\217\\342\\001}\\305\\357\\023\\335\\027\\3758e\\020\\375\\350\\347\\223\\015\\366\\304)	.{{= name }} {\n    display: inline-block;\n    height: 100%;\n}\n\n.{{= name }} > .dropdown {\n    display: none;\n    position: absolute;\n    z-index: 5;\n    top: 1.5rem;\n    right: 0;\n    background-color: black;\n    opacity: 0.9;\n    border-bottom: 0.25rem solid #333;\n    border-left: 0.25rem solid #333;\n}\n\n.{{= name }} > .dropdown > div {\n    width: 100%;\n    padding: 1rem;\n    text-align: left;\n    color: white;\n}\n\n.{{= name }}:hover > .dropdown {\n    display: block;\n}\n\n.{{= name }} > .dropdown > .logout {\n    cursor: pointer;\n}\n\n.{{= name }} > .dropdown > .logout:hover {\n    background-color: #333;\n}\n\n.{{= name }} > .dropdown > .logout:active {\n    background-color: #666;\n}\n
\\003\\277%\\311\\215Ew\\021\\301\\350\\247\\3567\\210\\337VP\\362\\247u2\\3333\\213\\317\\333\\347@F[bq	fae0b7d9-080e-4637-90dc-95a75a74af02
\\003\\324P\\310\\213su\\257\\021J\\371\\03168&\\017\\206#\\264\\030s\\212\\005!\\377.jbl\\323<i	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('name') || row.get('id') }}<button class='edit'>Edit</button>\n</li>
\\003d\\2712~\\237m\\270\\244\\314f[f\\244xQ\\206\\303y2.-i\\257\\373\\337)\\2779/hr	3.21
\\005\\252Q;\\211\\033\\27674\\31302\\3608\\344\\256\\261\\255{)\\023P\\272\\302\\355\\261l\\226\\025\\232\\327\\021	sem_fkey_select
\\005\\325?R\\304%\\342\\242\\331\\311\\032\\232\\263i\\342\\034\\375TzI`\\236aN\\0263-\\220\\325/\\302\\235	54461126-acc3-4f77-a3ab-e2b89045828c
\\0070\\321m3U\\340y{\\357j\\243\\205\\205\\252\\263(S\\246\\225\\177\\374KK\\210\\245HB\\360C6\\212	.{{= name }} {\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    \n   \tcursor: pointer;\n  \topacity: 0.95;\n    z-index: 10;\n    overflow: auto;\n    \n  \tbackground-color: black;\n    color: white;\n    font-size: initial;\n    text-align: center;\n}\n\n.{{= name }} > .content {\n    display: inline;\n    cursor: auto;\n}\n
\\007<\\0264\\304\\226\\315\\266I\\321\\257\\340\\243\\022\\273\\264\\267\\341t\\033'\\025B\\344\\2446\\303\\270\\202K\\027a	status
\\007\\261\\316\\270\\345\\200\\253\\252\\337\\363\\314\\250\\221\\223?\\227\\007\\332\\031\\234\\257\\210wR\\265\\327a\\241=\\331\\220\\267	var w = $("#"+id);\nvar username = false;\n\n\nfunction get_session_cookie() {\n    return document.cookie.replace(/(?:(?:^|.*;\\s*)SESSION\\s*\\=\\s*([^;]*).*$)|^.*$/, "$1");\n}\n\nfunction logout_and_redirect(url) {\n    // remove session cookie\n    document.cookie='SESSION=';\n\n    // redirect after a timeout\n    setTimeout(function() {\n        w.trigger('auth');\n        //location.reload(true);\n        location.assign(url || '/');\n    }, 1000);\n}\n\n\nendpoint.schema('endpoint').table('current_user').row()\n.then(function(row) {\n\n    var role_name = row.get('current_user');\n    var role_id = { name: role_name };\n    console.log('role name', role_name);\n\n    if (role_name == 'anonymous') {\n        throw 'Not logged in';\n    }\n    if (role_name == 'postgres') {\n        alert('You\\'re logged in as postgres, that\\'s not right, call mickey');\n    }\n\n    return endpoint.schema('endpoint').table('user').row('role_id', role_id);\n\n}).then(function(row) {\n    username = row.get('name') || row.get('email');\n    w.find('.username').html(username);\n}).catch(function(e) {\n    console.log('not logged in:', e);\n    logout_and_redirect();\n});\n\n\n\nw.find('.logout').click(function() {\n\n    var cookie = get_session_cookie('SESSION');\n    if (cookie != null) {\n\n        // there exists a session cookie\n        // look for session in table\n        endpoint.schema('endpoint').table('session').row('id', cookie)\n        .then(function(session) {\n\n            if(!session) {\n                // not logged in\n                return logout_and_redirect();\n            }\n            session.delete().then(function() {\n                // logged out now\n                // redirect\n                logout_and_redirect();\n            });\n        });\n\n    }\n    else {\n        // there is no session cookie\n        logout_and_redirect();\n    }\n});
\\007\\270\\0341\\3573\\353\\274t\\333\\264\\243\\010\\340\\265\\303P\\332\\212\\024\\244\\011\\340\\340\\257\\274es\\021\\366pG	89fb8792-4291-4712-b470-6ff89a016f4a
\\010:'h\\365\\027\\235\\226\\361\\033\\211+K\\271\\025\\237\\306\\341\\373\\320\\025\\254\\355\\311\\2300w\\212\\205]\\334I	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}
\\010\\014\\301\\223\\332%\\304i\\243_\\351ym\\331\\241\\0378\\034\\227\\326\\233\\265\\240\\326\\315\\224\\276WI\\330l\\353	6702454c-5f3c-4dd1-8b74-f854fad327ae
\\010\\277\\020\\206yj\\025B\\250\\025\\215\\222\\264i\\227\\020\\012\\315x\\327\\260_\\375dn\\313\\005\\360\\241)\\276\\275	var w = $("#"+id);\n\n// auth_manager\nw.find('.auth').html(widget('auth:auth_manager'));\n\n\n// redirect if necessary\nvar bundle_name = window.location.hash.split('#')[1];\n\nif (typeof bundle_name == 'undefined') {\n    w.find('.row_list_section').html(widget('ide:bundle_selector'));\n    w.on('bundle_selected', function(e, payload) {\n        \n        w.find('.bundle_selector').remove();\n        bundle_name = payload.bundle_name;\n        window.location.hash = bundle_name;\n        show_bundle();\n    });\n}\nelse {\n    show_bundle();\n}\n\nfunction show_bundle() {\n    endpoint.schema('bundle').table('bundle').row({\n        where: {\n            name: 'name',\n            op: '=',\n            value: bundle_name\n        }\n    }).then(function(bundle) {\n        // load the workspace\n        w.find('.workspace_section').html(widget('ide:workspace', { bundle: bundle }));\n        w.find('.row_list_section').html(widget('ide:row_list', { bundle: bundle }));\n        w.find('header .title').html(bundle.get('name'));\n    });\n\n}
\\011\\247~\\273\\251y\\205\\350\\005+H\\022\\223\\026>gD\\001\\216\\255j\\210#\\214\\373\\261\\306a\\321\\373\\004\\031	var w = $("#"+id);\n\nw.data('row_id', row.get('row_id'));\n\nvar schema_name = row.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = row.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = row.get('row_id').pk_column_id.name;\nvar pk_value = row.get('row_id').pk_value;\n\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n    \n    w.find('.label').html(widget('semantics/text_identifier', real_row ));\n    \n\t// click handler needs real_row, so put the handler in here after real_row is loaded\n    w.find('.label').click(function() {\n        w.trigger('bundle_row_open', { row_id: row.get('row_id'), row: real_row });\n    });\n    return real_row;\n\n}).catch(function(e) {\n    console.log(e);\n\tw.find('.label').html(schema_name+'.'+relation_name+'.'+pk_value);\n}).then(function() {\n    //w.show();\n    w.find('.label > *').ready(function() {\n        w.show();\n    });\n});\n\n\n
\\011\\355i*U\\202\\324c-d\\230\\027\\012\\204\\244\\347\\221g\\327\\243\\252.^S\\320\\374\\227\\214\\263g\\377a	row_detail_template
\\011x|G"i"\\342r\\263\\271tgt\\2211\\271\\222'\\030_\\303"\\023=\\215j\\325\\356\\305\\271\\374	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .title {\n    padding: 1.5rem 0;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .title > span:nth-child(2) {\n    padding: 0 1rem;\n    font-size: 1rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\012\\033\\016\\251\\307\\260\\344\\344G\\303|\\315\\326\\272gs\\240\\002\\232\\007D\\011\\356\\275\\267\\335Yf\\357\\277\\021S	stage_dialog
\\013\\211\\021\\215/\\345\\303\\037\\023\\331Qv\\333\\247\\354\\334~\\271\\353\\352\\257\\215(\\342\\213\\024\\246\\2173|\\222v	d1874571-9b11-4ecf-a65d-454de53683b7
\\013\\251\\266\\223\\332k-\\273\\203\\316\\347D\\351S\\254\\\\\\265\\363\\322\\313\\223\\244\\240U\\013`z\\177\\334\\312\\002\\302	.{{= name }} {\n}
\\014\\207Gt!\\325p\\336\\347\\362f;\\230\\301\\366\\023:`\\247\\360\\302)\\301)\\205T\\034\\034\\236\\225:z	var w = $("#"+id);\n\nw.click(function() {\n    w.trigger('bundle_selected', { bundle_name: bundle.get('name') });\n});
\\016E!l\\032\\216~\\373\\323\\031\\210~\\3523\\315d\\006\\342\\310\\031\\025Cy0z\\241\\300Jq/\\240\\251	<div id="{{= id }}" class="{{= name }}">\n    <div class='loading'>Loading...</div>\n    <div class='loaded hide'>\n        <input type="text" class="autocomplete" placeholder='Text search'/>\n        <button class="cancel">Cancel</button>\n        <div class='results'></div>\n    </div>\n</div>
\\020 \\324\\024\\025\\251\\177\\236\\021\\277e1S\\332\\340\\036<9\\247<8\\254*_-<0i6\\240\\242\\232	<div id="{{= id }}" class="{{= name }}">\n    <button class='new_row'>new row</button>\n    <button class='stage'>stage</button>\n    <button class='commit_log'>history</button>\n    <button class='push_pull'>&#8644;push/pull</button>\n    <button class='bundle_config'>&#9881;config</button>\n    <button class='untracked'>&#9881;untracked</button>\n    <button class='export'>&#9881;export</button>\n    <button class='ignored'>&#9881;ignored</button>\n\n    <div class='filters'>\n        <span class='tab all'>all</span>\n        <span class='tab changed'>changed</span>\n        <span class='tab head'>head</span>\n    </div>\n    <div class='bundle_contents'>\n    </div>\n</div>
\\020F\\324\\337,S\\322\\353I\\0078H\\233\\263\\306EF\\315\\010\\035\\354,:\\252\\351\\0240\\241\\306$\\341\\015	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    \n    border-top: 1px solid #333;\n}\n\n.{{= name }}.expanded {\n    background-color: #333;\n    color: #aaa;\n}\n\n.{{= name }}:not(.expanded):hover {\n    background-color: #666;\n}\n\n.{{= name }}:not(.expanded):active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }} > .arrow {\n    display: inline-block;\n    margin: 0 0.5rem;\n    font-size: x-large;\n    vertical-align: sub;\n    \n    transform: rotate(270deg);\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    -moz-transform: rotate(270deg);\n    \n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }}.expanded > .arrow {\n    transform: rotate(90deg);\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    -moz-transform: rotate(90deg);\n}\n\n.{{= name }} > .empty {\n    display: block;\n    text-align: center;\n}\n\n.{{= name }} > .empty.hide {\n    display: none;\n}\n\n.{{= name }}:not(.expanded) > .list {\n    display: none;\n}\n
\\021s@'\\252\\354\\305\\300\\031\\000\\356\\210H\\326F!\\214\\305\\376\\224\\\\G\\263\\276\\250Z\\324\\322\\006\\266/\\031	stage_dialog_staged_field
\\022[}He\\303\\360\\360\\217I\\316A\\276\\367\\302\\377\\206m\\356\\335\\331\\231\\005$q\\361\\270\\356C\\222\\324@	<div id="{{= id }}" class="{{= name }}">\n    <h2 class="url"></h2>\n\n    <div class="actions">\n        Actions:\n        <button class="compare">compare</button> <button class="push">push</button> <button class="pull">pull</button>\n    </div>\n\n    <h3>Comparison</h3>\n    <p>This bundle's commits locally, compared with the commits in the remote bundle.</p>\n    \n    <table class="comparison" border=1>\n        <tr>\n            <th>local commit id</th>\n            <th>remote commit it</th>\n        </tr>\n    </table>\n</div>
\\024\\026\\223\\242\\315\\262\\234\\203\\234\\270\\274\\027\\223\\313d\\177\\011&\\244\\\\\\177\\355\\246\\207\\231\\031\\302\\256\\366\\206\\211\\223	b4ac3add-5bdc-4faa-be77-96399ad5e7c9
\\024\\276KE\\361\\216\\015\\214g\\264\\367\\031\\265\\024N\\356\\210I~A7\\011\\321\\035\\205\\260\\226\\330\\3424c\\020	0.1
\\024\\317\\213@\\021\\253\\010\\327\\213\\233\\375\\022\\245\\375\\301\\227\\237\\217\\030]\\250\\001\\206\\312\\305n\\350\\000\\213\\276z$	a88f985c-48c3-4f25-bb95-05901e4fff54
\\025jmb\\355\\236\\345\\256LU\\324\\264\\026\\367h#6\\247FA\\353y\\033\\0176\\353\\335j\\246\\215\\372(	ignore_modal
\\026\\230\\0154F\\301x\\313\\032Bz\\276\\212(\\3772\\2474N\\336\\004\\253\\314Y\\303F\\201:e\\256\\257\\310	12fa26f1-b310-44c1-bd4e-f788d1ba3357
\\027\\344\\037\\215\\217\\206\\224^\\241\\030\\315|\\014\\322@A <\\000\\366\\236\\361*\\255\\236\\202\\203\\337t\\264n\\374	sem_fkey_many_to_many_li
\\030\\236\\332\\311\\235\\366\\022\\251\\327\\301px\\2234\\223\\000\\251(y\\031\\371.\\327\\313\\275\\326\\277_\\315\\034\\031\\314	3ec63054-336c-4144-94ba-01edd5138cd4
\\033OF\\265>\\221F\\341\\311\\205\\221-\\305g\\320L\\012<\\220\\334R+\\334A\\226#Ta!\\0122\\235	bundle_remote_new
\\033\\222`8\\267T\\330\\206\\201\\230n\\03422 \\031\\034\\264g\\013\\272\\017\\355\\242\\034\\242$\\373\\361\\306\\331\\217	var w = $("#"+id);\n\n/*\n\tWe should really be using list_item_identifier_widget for this label\n    TODO: replace label_function with semantics lookup\n*/\n\n\n// Less destructive way to delete fkey reference\nw.find('.delete').click(function() {\n    row.set(to_column, null);\n    row.update()\n    .done(function(updated_row) {\n        console.log('Fkey updated', updated_row);\n        w.trigger('fkey_updated');\n        w.trigger('reload');\n    });\n});\n\n/*\n//\n// If we want to delete the foreign row\n// But I think it is preferrable that we set foreign key to null instead\n//  \nw.find('.delete').click(function() {\n    row.delete()\n    .done(function() {\n        console.log('Fkey deleted');\n        w.trigger('fkey_deleted');\n        w.remove();\n    });\n});\n*/
\\034\\270\\240\\332\\214\\000\\250\\346\\035\\366<\\222\\020ew\\375\\235\\031\\022\\326\\\\\\367\\030MgW\\244!\\364\\010\\342\\211	var w = $("#"+id);\n\nconsole.log('selected rows: ', rows);
\\034\\314O\\000\\225\\246t\\361+v6,\\251\\230\\230\\252\\275|p\\037\\247\\231\\260\\355\\035\\313\\224\\004?\\021\\375\\332	8f0690e2-7883-48d2-898f-e4ce3406b0cc
\\034\\347\\035L/\\016"\\204\\322\\272Jv\\257\\220|\\335\\274U\\251\\332\\351\\332Q\\263\\326\\373v|\\347\\001\\177\\207	var w = $("#"+id);\n\n/**********************************\nSOME HANDY DATE FUNCTIONS\n**********************************/\n\n// https://stackoverflow.com/questions/15396637/comparing-javascript-date-time-and-timestamp-from-postgresql\nDate.fromISO= function(s){\n    var day, tz,\n    rx=/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT ][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):(\\d\\d))?$/,\n    p= rx.exec(s) || [];\n    if(p[1]){\n        day= p[1].split(/\\D/);\n        for(var i= 0, L= day.length;i<L;i++){\n            day[i]= parseInt(day[i], 10) || 0;\n        };\n        day[1]-= 1;\n        day= new Date(Date.UTC.apply(Date, day));\n        if(!day.getDate()) return NaN;\n            //adjust for time zone offset:\n        if(p[5]){\n            tz= (parseInt(p[5], 10)*60);\n            if(p[6]) tz+= parseInt(p[6], 10);\n            if(p[4]== '+') tz*= -1;\n            if(tz) day.setUTCMinutes(day.getUTCMinutes()+ tz);\n        }\n        return day;\n    }\n    return NaN;\n}\n\n// https://gist.github.com/hurjas/2660489\n/**\n * Return a timestamp with the format "m/d/yy h:MM:ss TT"\n * @type {Date}\n */\n\nfunction timeStamp(now) {\n// Create an array with the current month, day and time\n  var date = [ now.getMonth() + 1, now.getDate(), now.getFullYear() ];\n\n// Create an array with the current hour, minute and second\n  var time = [ now.getHours(), now.getMinutes(), now.getSeconds() ];\n\n// Determine AM or PM suffix based on the hour\n  var suffix = ( time[0] < 12 ) ? "AM" : "PM";\n\n// Convert hour from military time\n  time[0] = ( time[0] < 12 ) ? time[0] : time[0] - 12;\n\n// If hour is 0, set it to 12\n  time[0] = time[0] || 12;\n\n// If seconds and minutes are less than 10, add a zero\n  for ( var i = 1; i < 3; i++ ) {\n    if ( time[i] < 10 ) {\n      time[i] = "0" + time[i];\n    }\n  }\n\n// Return the formatted string\n  return date.join("/") + " " + time.join(":") + " " + suffix;\n}\n\n\n\n\n\n\nvar date = Date.fromISO(commit.get('time'));\n\n\nw.find('td.date').html(timeStamp(date));\n\nw.find('button.checkout').click(function() {\n    if (confirm('Checking out this commit will OVERWRITE any uncommitted changes and restore the database to the state at this commit.  This could be DESTRUCTIVE.  Are you sure?')) {\n        endpoint.schema('bundle').function('checkout', [ commit.get('id') ]).then(function() {\n            alert ('done');\n        }).catch(function(e) {\n            alert ('failed: '+e.message);\n        });\n    }\n});\n\nif (bundle.get('head_commit_id') == commit.get('id')) {\n    w.find('.head_commit').show();\n}\n\n\n
\\035\\003T\\015\\273\\320I\\037\\331\\376\\032\\324\\245\\246\\241" \\316\\235\\012\\3345:\\005V\\254s\\246w\\236=Q	form_field_javascript
\\035c\\036\\262\\0333!\\022\\345b\\236[\\234\\345\\277\\265<\\230\\026\\001\\003\\275'-\\357\\345\\004<<\\246\\2206	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('ide:code_editor', { field: field, language: 'css' }) }}\n</div>
\\036W\\277\\216]\\311\\307\\242p\\376\\020\\333\\324\\305\\213\\360\\276\\324\\014\\362\\230\\306\\007co\\236\\033\\204\\375\\247\\031Y	var w = $("#"+id);\n\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\nwidget.sync(untracked_rows, w, function(schema) {\n    return widget('bundle_untracked_row_by_schema', { schema: schema });\n});\n\n
\\036a\\333\\023\\230\\007\\026\\332\\306\\252\\304H\\274e,\\240x\\270\\343\\252:\\306\\201\\275\\372\\251\\214@\\263\\267\\005s	82fa4009-7abb-4f6a-aa42-0d3216516956
\\036n\\326]w\\3266N\\352\\355Zt[\\245\\304\\230Z\\342\\267\\000\\335\\205\\327\\317\\177\\002{\\337)J3\\374	bundle
\\036wc\\351\\013\\000'\\236\\216z\\337\\313\\\\\\253$\\243uu\\326\\374\\350\\030\\256EC\\005\\203\\227\\037\\321\\336\\371	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    margin: 0;\n    font-size: 1.5rem;\n}\n\n.{{= name }} > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} > .buttons {\n    float: right;\n    height: 1.75rem;\n    padding-right: 1rem;\n}\n\n.{{= name }} > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\0375{\\212j5^\\256\\022ay\\256\\343&\\311y\\031\\341\\005\\333\\323\\373Kv\\205\\216\\374\\216\\240\\260\\026\\341	row_list_row
\\037\\347x\\250\\317\\363V<\\256qZ\\266\\305\\037\\215\\325\\0054\\031\\301_\\247{\\200\\270q\\237\\376Jl\\231/	var w = $("#"+id);\n\nconsole.log('change:',change);\n\nvar editor = CodeMirror(w.find('td.old_val')[0], {\n    value: old_val,\n    mode:  'text/javascript',\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\nfunction change_handler(doc) {\n    //field.set(doc.getValue());\n    //w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor.on('change', change_handler);\n\n\n\n\nvar editor2 = CodeMirror(w.find('td.new_val')[0], {\n    value: new_val,\n    mode:  'text/javascript',\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\nfunction change_handler(doc) {\n    //field.set(doc.getValue());\n    //w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor2.on('change', change_handler);\n
\\037\\361\\323\\302\\316a\\356\\012oj\\305\\\\\\263}x\\312\\356\\265P\\302\\337\\271\\217\\244U\\011\\363\\006\\036\\310\\271k	var w = $("#"+id);\n\n\n//endpoint.schema('widget').table('widget').row('name', 'dev_workspace').then(rewrite);\nfunction rewrite(r) {\n    \n    function get_data(str) {\n        // If this does not have 'g' flag there will be an infinite loop\n        var re = /\\/\\*editable_object-(.*)\\*\\/([\\s\\S]*?)\\/\\*end\\*\\//g,\n            arr,\n            obj = {};\n\n        // Safety measure\n        var MAX = 5,\n            counter = 0;\n\n        while ((arr = re.exec(str)) !== null) {\n            if (counter++ > MAX) {\n                break;\n            }\n            /* arr[0] is whole match; arr[1] is object identifier; arr[2] is object data only */\n            obj[arr[1]] = eval(arr[2]);\n        }\n        return obj;\n    }\n \n    function replace(str, ident, new_data) {\n        var re = new RegExp('(\\/\\\\*editable_object-' + ident + '\\\\*\\/)([\\\\s\\\\S]*)(\\/\\\\*end\\\\*\\/)');\n        return str.replace(re, '$1' + JSON.stringify(new_data, null, '\\t') + '$3');\n    }\n    \n    var js = r.get('post_js');\n    var data = get_data(js);\n    var new_js = replace(js, 'tables', data.tables.filter(function(e) {\n        return !(e.schema_name == 'widget' && e.relation_name == 'widget');\n    }));\n\n    // r.set('post_js', new_js).update().then(function(a) { console.log(a); });\n}\n\nvar colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\nvar available_tables = \n    /*editable_object-available*/\n    [\n    {\n        schema_name: 'widget',\n        relation_name: 'widget',\n        order_by: {\n            column: 'name'\n        },\n        include: ['id', 'name']\n    }, {\n        schema_name: 'widget',\n        relation_name: 'bundled_widget',\n    }, {\n        schema_name: 'meta',\n        relation_name: 'table'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'view'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'function'\n    }, {\n        schema_name: 'widget',\n        relation_name: 'dependency_js',\n        order_by: { column: 'name' },\n        include: ['id', 'name', 'version']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'resource',\n        order_by: { column: 'path' },\n        include: ['id', 'path']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'user',\n        order_by: { column: 'name' }\n    }]\n/*end*/\n;\n\nvar tables = \n    /*editable_object-tables*/\n    [\n    {\n        schema_name: 'widget',\n        relation_name: 'widget',\n        order_by: {\n            column: 'name'\n        },\n        include: ['id', 'name']\n    }, {\n        schema_name: 'widget',\n        relation_name: 'bundled_widget',\n    }, {\n        schema_name: 'meta',\n        relation_name: 'table'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'view'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'function'\n    }, {\n        schema_name: 'widget',\n        relation_name: 'dependency_js',\n        order_by: { column: 'name' },\n        include: ['id', 'name', 'version']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'resource',\n        order_by: { column: 'path' },\n        include: ['id', 'path']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'user',\n        order_by: { column: 'name' }\n    }]\n/*end*/\n;\n\n\nvar tabs = {};\nvar tab_colors = {};\ntables.forEach(function(t, i) {\n    var schema_name = t.schema_name;\n    var name = t.relation_name;\n    var relation = endpoint.schema(schema_name).table(name);\n    \n    var obj = {};\n    var keys = Object.keys(t);\n    keys.forEach(function(o) {\n        if (o != 'relation_name' && o != 'schema_name') {\n            obj[o] = t[o];\n        }\n    });\n    \n    tabs[name] = function() {\n        if (!Object.keys(obj).length) {\n            return widget('semantics/list_view', relation);\n        }\n        return widget('semantics/list_view', relation.rows(obj));\n    };\n    \n    tab_colors[name] = colors[i % colors.length];\n});\n\nw.append(\n    widget('tabbed_layout', {\n        base_url: base_url,\n        selected: url_parts[0],\n        tabs: tabs,\n        tab_colors: tab_colors\n    })\n);\n
\\177\\330\\334\\342\\022=\\236Jo\\272\\215TFp\\303V\\271\\370\\3709\\227f\\035\\221\\231b\\373\\240\\007b\\235z	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'name'],\n            order_by: {\n                column: 'name'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('ide:option', {\n                label: row.get('name'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\2007\\006Z\\022_)\\320\\261`8\\333|\\230TLGN\\035\\037z\\330\\370\\223)\\346;\\032m\\001,\\216	form_field_composite
\\200\\345\\211\\357`\\231l\\3163XE\\231I\\223\\020\\036\\2067\\230\\216\\014U\\224}\\024\\244\\306\\011\\235\\005\\231\\235	<div id="{{= id }}" class="{{= name }}">\n    <div class='title'>{{= properties.bundle_alias }}:{{= widget_name }}{{? properties.count > 1 }}(&times;{{=properties.count}}){{?}}</div>\n    <div class='children'>\n    </div>\n</div>
\\202%\\320\\034g\\201\\005+DE\\272^\\255\\250V)\\014$,\\021\\232?\\015e\\330\\013\\241f\\355\\271\\232\\314	0.3.2
\\202U\\2429\\206u\\3747\\254\\277H\\240\\206,\\216n\\342wOGi\\032\\215\\204\\330k`\\3248A\\025\\231	.{{= name }} {\n}\n\n.{{= name }}:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n\n\n.{{= name }} ul {\n    display: none;\n}\n\n.{{= name }} ul.open {\n    display: block;\n}\n
\\202\\200\\376s\\302\\033\\317+B\\251\\207\\311@\\344@\\276\\014i\\277\\337\\364\\012\\376\\011\\210#.4h\\210\\235\\272	400e206e-77ed-4b12-9c09-168ee2fc812b
\\202\\216\\215\\2156\\221\\342\\001: \\372\\246/!X\\214gplJ\\235z\\022\\036\\346\\2022[\\253\\3601\\371	.{{= name }} {\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n}\n\n.{{= name }} header .logo a {\n    font-size: 200%;\n    color: blue;\n    letter-spacing: 1ex;\n    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\n    text-decoration: none;\n    font-weight: bold;\n\n}\n\n.{{= name }} header a:hover {\n    text-decoration: underline;\n    color: blue;\n}\n\n\n.{{= name }} > .content {\n    display: flex;\n    flex: 2;\n    overflow: auto; /* was 'hidden' -elh */\n}\n\n.{{= name }} .row_list_section {\n    background-color: #222;\n    order: 0;\n    flex: 1 1 auto;\n    align-self: auto;\n    width: 20em;\n    overflow: auto;\n    padding: 4px;\n}\n\n.{{= name }} .workspace_section {\n    order: 0;\n    flex: 5 1 80%;\n    align-self: auto;\n}\n\n.{{= name }} .bundle_icon:hover {\n    cursor: pointer;\n}\n\n\n.{{= name }} .auth {\n    position: absolute;\n    top: 0;\n    right: 0;\n}\n        \n
\\202\\272\\232\\251\\225\\317\\241\\204>\\343\\037.\\203\\305\\204\\220M\\002\\020\\205\\360\\250oCS<\\347\\244\\252&`\\030	ffc4d8c8-9a36-42a6-91af-41ae7a771bf0
\\202w\\274\\346\\3553\\333o\\347\\026\\350\\272\\266\\253\\344I\\233\\265\\217\\215\\005i]\\224X\\275 \\020\\322\\315J\\233	var w = $("#"+id);\n\nvar commits = bundle.related_rows("id", "bundle.commit", "bundle_id", {\n    order_by: [{\n        column: 'time',\n        direction: 'desc'\n    }]\n});\n\nwidget.sync(commits, w.find(".commits"), function(commit) {\n    return widget("ide:commit_history_commit", {bundle: bundle, commit: commit});\n});
\\202x\\2136\\332\\332\\017p\\242\\201K\\342\\222J\\265\\300\\320\\011\\243\\237\\320!Y\\013,9\\020\\273q\\2752\\237	// CodeMirror is the only global var we claim\nwindow.CodeMirror = (function() {\n  "use strict";\n\n  // BROWSER SNIFFING\n\n  // Crude, but necessary to handle a number of hard-to-feature-detect\n  // bugs and behavior differences.\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  // IE11 currently doesn't count as 'ie', since it has almost none of\n  // the same bugs as earlier versions. Use ie_gt10 to handle\n  // incompatibilities in that version.\n  var old_ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = old_ie && (document.documentMode == null || document.documentMode < 8);\n  var ie_lt9 = old_ie && (document.documentMode == null || document.documentMode < 9);\n  var ie_gt10 = /Trident\\/([7-9]|\\d{2,})\\./.test(navigator.userAgent);\n  var ie = old_ie || ie_gt10;\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /win/i.test(navigator.platform);\n\n  var opera_version = opera && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (opera_version) opera_version = Number(opera_version[1]);\n  if (opera_version && opera_version >= 15) { opera = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));\n  var captureMiddleClick = gecko || (old_ie && !ie_lt9);\n\n  // Optimize some code when these features are not used\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // CONSTRUCTOR\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options || {};\n    // Determine effective options based on given values and defaults.\n    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))\n      options[opt] = defaults[opt];\n    setGuttersForLineNumbers(options);\n\n    var docStart = typeof options.value == "string" ? 0 : options.value.first;\n    var display = this.display = makeDisplay(place, docStart);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.state = {keyMaps: [],\n                  overlays: [],\n                  modeGen: 0,\n                  overwrite: false, focused: false,\n                  suppressEdits: false,\n                  pasteIncoming: false, cutIncoming: false,\n                  draggingText: false,\n                  highlight: new Delayed()};\n\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += " CodeMirror-wrap";\n\n    var doc = options.value;\n    if (typeof doc == "string") doc = new Doc(options.value, options.mode);\n    operation(this, attachDoc)(this, doc);\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (old_ie) setTimeout(bind(resetInput, this, true), 20);\n\n    registerEventHandlers(this);\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }\n    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);\n    else onBlur(this);\n\n    operation(this, function() {\n      for (var opt in optionHandlers)\n        if (optionHandlers.propertyIsEnumerable(opt))\n          optionHandlers[opt](this, options[opt], Init);\n      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    })();\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  function makeDisplay(place, docStart) {\n    var d = {};\n\n    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");\n    if (webkit) input.style.width = "1000px";\n    else input.setAttribute("wrap", "off");\n    // if border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) input.style.border = "1px solid black";\n    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");\n\n    // Wraps and hides input textarea\n    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");\n    // The actual fake scrollbars.\n    d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");\n    d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");\n    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");\n    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");\n    // DIVs containing the selection and the actual code\n    d.lineDiv = elt("div", null, "CodeMirror-code");\n    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");\n    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n    d.cursor = elt("div", "\\u00a0", "CodeMirror-cursor");\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    d.otherCursor = elt("div", "\\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");\n    // Used to measure text size\n    d.measure = elt("div", null, "CodeMirror-measure");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],\n                         null, "position: relative; outline: none");\n    // Moved around its parent to cover visible view\n    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");\n    // Set to the height of the text, causes scrolling\n    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");\n    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");\n    // Will contain the gutters, if any\n    d.gutters = elt("div", null, "CodeMirror-gutters");\n    d.lineGutter = null;\n    // Provides scrolling\n    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");\n    d.scroller.setAttribute("tabIndex", "-1");\n    // The element in which the editor lives.\n    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");\n    // Work around IE7 z-index bug\n    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = "0px";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";\n\n    // Current visible range (may be bigger than the view window).\n    d.viewOffset = d.lastSizeC = 0;\n    d.showingFrom = d.showingTo = docStart;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = "";\n    // Set to true when a non-horizontal-scrolling widget is added. As\n    // an optimization, widget aligning is skipped when d is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we currently expect input to appear\n    // (after some event like 'keypress' or 'input') and are polling\n    // intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n\n    d.cachedCharWidth = d.cachedTextHeight = null;\n    d.measureLineCache = [];\n    d.measureLineCachePos = 0;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string instead of the (large) selection.\n    d.inaccurateSelection = false;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    return d;\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      cm.display.wrapper.className += " CodeMirror-wrap";\n      cm.display.sizer.style.minWidth = "";\n    } else {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");\n      computeMaxLength(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line))\n        return 0;\n      else if (wrapping)\n        return (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var map = keyMap[cm.options.keyMap], style = map.style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, "") +\n      (style ? " cm-keymap-" + style : "");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));\n      if (gutterClass == "CodeMirror-linenumbers") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";\n      }\n    }\n    gutters.style.display = i ? "" : "none";\n  }\n\n  function lineLength(doc, line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find();\n      cur = getLine(doc, found.from.line);\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find();\n      len -= cur.text.length - found.from.ch;\n      cur = getLine(doc, found.to.line);\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  function computeMaxLength(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(doc, d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(doc, line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // "CodeMirror-linenumbers" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, "CodeMirror-linenumbers");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content. Optionally force a scrollTop.\n  function updateScrollbars(cm) {\n    var d = cm.display, docHeight = cm.doc.height;\n    var totalHeight = docHeight + paddingVert(d);\n    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";\n    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";\n    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);\n    var needsV = scrollHeight > (d.scroller.clientHeight + 1);\n    if (needsV) {\n      d.scrollbarV.style.display = "block";\n      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";\n      d.scrollbarV.firstChild.style.height =\n        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + "px";\n    } else {\n      d.scrollbarV.style.display = "";\n      d.scrollbarV.firstChild.style.height = "0";\n    }\n    if (needsH) {\n      d.scrollbarH.style.display = "block";\n      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";\n      d.scrollbarH.firstChild.style.width =\n        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + "px";\n    } else {\n      d.scrollbarH.style.display = "";\n      d.scrollbarH.firstChild.style.width = "0";\n    }\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = "block";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";\n    } else d.scrollbarFiller.style.display = "";\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = "block";\n      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";\n      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";\n    } else d.gutterFiller.style.display = "";\n\n    if (mac_geLion && scrollbarWidth(d.measure) === 0) {\n      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";\n      d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = "none";\n    }\n  }\n\n  function visibleLines(display, doc, viewPort) {\n    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;\n    if (typeof viewPort == "number") top = viewPort;\n    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}\n    top = Math.floor(top - paddingTop(display));\n    var bottom = Math.ceil(top + height);\n    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};\n  }\n\n  // LINE NUMBERS\n\n  function alignHorizontally(cm) {\n    var display = cm.display;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, l = comp + "px";\n    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {\n      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + "px";\n  }\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt("div", [elt("div", last)],\n                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = "";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + "px";\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n  function compensateForHScroll(display) {\n    return getRect(display.scroller).left - getRect(display.sizer).left;\n  }\n\n  // DISPLAY DRAWING\n\n  function updateDisplay(cm, changes, viewPort, forced) {\n    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;\n    var visible = visibleLines(cm.display, cm.doc, viewPort);\n    for (var first = true;; first = false) {\n      var oldWidth = cm.display.scroller.clientWidth;\n      if (!updateDisplayInner(cm, changes, visible, forced)) break;\n      updated = true;\n      changes = [];\n      updateSelection(cm);\n      updateScrollbars(cm);\n      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {\n        forced = true;\n        continue;\n      }\n      forced = false;\n\n      // Clip forced viewport to actual scrollable area\n      if (viewPort)\n        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,\n                            typeof viewPort == "number" ? viewPort : viewPort.top);\n      visible = visibleLines(cm.display, cm.doc, viewPort);\n      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)\n        break;\n    }\n\n    if (updated) {\n      signalLater(cm, "update", cm);\n      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)\n        signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);\n    }\n    return updated;\n  }\n\n  // Uses a set of changes plus the current scroll position to\n  // determine which DOM updates have to be made, and makes the\n  // updates.\n  function updateDisplayInner(cm, changes, visible, forced) {\n    var display = cm.display, doc = cm.doc;\n    if (!display.wrapper.offsetWidth) {\n      display.showingFrom = display.showingTo = doc.first;\n      display.viewOffset = 0;\n      return;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!forced && changes.length == 0 &&\n        visible.from > display.showingFrom && visible.to < display.showingTo)\n      return;\n\n    if (maybeUpdateLineNumberWidth(cm))\n      changes = [{from: doc.first, to: doc.first + doc.size}];\n    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";\n    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";\n\n    // Used to determine which lines need their line numbers updated\n    var positionsChangedFrom = Infinity;\n    if (cm.options.lineNumbers)\n      for (var i = 0; i < changes.length; ++i)\n        if (changes[i].diff && changes[i].from < positionsChangedFrom) { positionsChangedFrom = changes[i].from; }\n\n    var end = doc.first + doc.size;\n    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, visible.to + cm.options.viewportMargin);\n    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);\n    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);\n    if (sawCollapsedSpans) {\n      from = lineNo(visualLine(doc, getLine(doc, from)));\n      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;\n    }\n\n    // Create a range of theoretically intact lines, and punch holes\n    // in that using the change info.\n    var intact = [{from: Math.max(display.showingFrom, doc.first),\n                   to: Math.min(display.showingTo, end)}];\n    if (intact[0].from >= intact[0].to) intact = [];\n    else intact = computeIntact(intact, changes);\n    // When merged lines are present, we might have to reduce the\n    // intact ranges because changes in continued fragments of the\n    // intact lines do require the lines to be redrawn.\n    if (sawCollapsedSpans)\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i], merged;\n        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {\n          var newTo = merged.find().from.line;\n          if (newTo > range.from) range.to = newTo;\n          else { intact.splice(i--, 1); break; }\n        }\n      }\n\n    // Clip off the parts that won't be visible\n    var intactLines = 0;\n    for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i];\n      if (range.from < from) range.from = from;\n      if (range.to > to) range.to = to;\n      if (range.from >= range.to) intact.splice(i--, 1);\n      else intactLines += range.to - range.from;\n    }\n    if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {\n      updateViewOffset(cm);\n      return;\n    }\n    intact.sort(function(a, b) {return a.from - b.from;});\n\n    // Avoid crashing on IE's "unspecified error" when in iframes\n    try {\n      var focused = document.activeElement;\n    } catch(e) {}\n    if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";\n    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n    display.lineDiv.style.display = "";\n    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();\n\n    var different = from != display.showingFrom || to != display.showingTo ||\n      display.lastSizeC != display.wrapper.clientHeight;\n    // This is just a bogus formula that detects when the editor is\n    // resized or the font size changes.\n    if (different) {\n      display.lastSizeC = display.wrapper.clientHeight;\n      startWorker(cm, 400);\n    }\n    display.showingFrom = from; display.showingTo = to;\n\n    display.gutters.style.height = "";\n    updateHeightsInViewport(cm);\n    updateViewOffset(cm);\n\n    return true;\n  }\n\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {\n      if (ie_lt8) {\n        var bot = node.offsetTop + node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = getRect(node);\n        height = box.bottom - box.top;\n      }\n      var diff = node.lineObj.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(node.lineObj, height);\n        var widgets = node.lineObj.widgets;\n        if (widgets) for (var i = 0; i < widgets.length; ++i)\n          widgets[i].height = widgets[i].node.offsetHeight;\n      }\n    }\n  }\n\n  function updateViewOffset(cm) {\n    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));\n    // Position the mover div to align with the current virtual scroll position\n    cm.display.mover.style.top = off + "px";\n  }\n\n  function computeIntact(intact, changes) {\n    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n      var change = changes[i], intact2 = [], diff = change.diff || 0;\n      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n        var range = intact[j];\n        if (change.to <= range.from && change.diff) {\n          intact2.push({from: range.from + diff, to: range.to + diff});\n        } else if (change.to <= range.from || change.from >= range.to) {\n          intact2.push(range);\n        } else {\n          if (change.from > range.from)\n            intact2.push({from: range.from, to: change.from});\n          if (change.to < range.to)\n            intact2.push({from: change.to + diff, to: range.to + diff});\n        }\n      }\n      intact = intact2;\n    }\n    return intact;\n  }\n\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft;\n      width[cm.options.gutters[i]] = n.offsetWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n    var dims = getDimensions(cm);\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))\n      removeChildren(display.lineDiv);\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = "none";\n        node.lineObj = null;\n      } else {\n        node.parentNode.removeChild(node);\n      }\n      return next;\n    }\n\n    var nextIntact = intact.shift(), lineN = from;\n    cm.doc.iter(from, to, function(line) {\n      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();\n      if (lineIsHidden(cm.doc, line)) {\n        if (line.height != 0) updateLineHeight(line, 0);\n        if (line.widgets && cur && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {\n          var w = line.widgets[i];\n          if (w.showIfHidden) {\n            var prev = cur.previousSibling;\n            if (/pre/i.test(prev.nodeName)) {\n              var wrap = elt("div", null, null, "position: relative");\n              prev.parentNode.replaceChild(wrap, prev);\n              wrap.appendChild(prev);\n              prev = wrap;\n            }\n            var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));\n            if (!w.handleMouseEvents) wnode.ignoreEvents = true;\n            positionLineWidget(w, wnode, prev, dims);\n          }\n        }\n      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {\n        // This line is intact. Skip to the actual node. Update its\n        // line number if needed.\n        while (cur.lineObj != line) cur = rm(cur);\n        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)\n          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));\n        cur = cur.nextSibling;\n      } else {\n        // For lines with widgets, make an attempt to find and reuse\n        // the existing element, so that widgets aren't needlessly\n        // removed and re-inserted into the dom\n        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)\n          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }\n        // This line needs to be generated.\n        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);\n        if (lineNode != reuse) {\n          container.insertBefore(lineNode, cur);\n        } else {\n          while (cur != reuse) cur = rm(cur);\n          cur = cur.nextSibling;\n        }\n\n        lineNode.lineObj = line;\n      }\n      ++lineN;\n    });\n    while (cur) cur = rm(cur);\n  }\n\n  function buildLineElement(cm, line, lineNo, dims, reuse) {\n    var built = buildLineContent(cm, line), lineElement = built.pre;\n    var markers = line.gutterMarkers, display = cm.display, wrap;\n\n    var bgClass = built.bgClass ? built.bgClass + " " + (line.bgClass || "") : line.bgClass;\n    if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets)\n      return lineElement;\n\n    // Lines with gutter elements, widgets or a background class need\n    // to be wrapped again, and have the extra elements added to the\n    // wrapper div\n\n    if (reuse) {\n      reuse.alignable = null;\n      var isOk = true, widgetsSeen = 0, insertBefore = null;\n      for (var n = reuse.firstChild, next; n; n = next) {\n        next = n.nextSibling;\n        if (!/\\bCodeMirror-linewidget\\b/.test(n.className)) {\n          reuse.removeChild(n);\n        } else {\n          for (var i = 0; i < line.widgets.length; ++i) {\n            var widget = line.widgets[i];\n            if (widget.node == n.firstChild) {\n              if (!widget.above && !insertBefore) insertBefore = n;\n              positionLineWidget(widget, n, reuse, dims);\n              ++widgetsSeen;\n              break;\n            }\n          }\n          if (i == line.widgets.length) { isOk = false; break; }\n        }\n      }\n      reuse.insertBefore(lineElement, insertBefore);\n      if (isOk && widgetsSeen == line.widgets.length) {\n        wrap = reuse;\n        reuse.className = line.wrapClass || "";\n      }\n    }\n    if (!wrap) {\n      wrap = elt("div", null, line.wrapClass, "position: relative");\n      wrap.appendChild(lineElement);\n    }\n    // Kludge to make sure the styled element lies behind the selection (by z-index)\n    if (bgClass)\n      wrap.insertBefore(elt("div", null, bgClass + " CodeMirror-linebackground"), wrap.firstChild);\n    if (cm.options.lineNumbers || markers) {\n      var gutterWrap = wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),\n                                         lineElement);\n      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);\n      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))\n        wrap.lineNumber = gutterWrap.appendChild(\n          elt("div", lineNumberFor(cm.options, lineNo),\n              "CodeMirror-linenumber CodeMirror-gutter-elt",\n              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "\n              + display.lineNumInnerWidth + "px"));\n      if (markers)\n        for (var k = 0; k < cm.options.gutters.length; ++k) {\n          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n          if (found)\n            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +\n                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));\n        }\n    }\n    if (ie_lt8) wrap.style.zIndex = 2;\n    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n      positionLineWidget(widget, node, wrap, dims);\n      if (widget.above)\n        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, "redraw");\n    }\n    return wrap;\n  }\n\n  function positionLineWidget(widget, node, wrap, dims) {\n    if (widget.noHScroll) {\n      (wrap.alignable || (wrap.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + "px";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + "px";\n      }\n      node.style.width = width + "px";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = "relative";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";\n    }\n  }\n\n  // SELECTION / CURSOR\n\n  function updateSelection(cm) {\n    var display = cm.display;\n    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      updateSelectionCursor(cm);\n    else\n      display.cursor.style.display = display.otherCursor.style.display = "none";\n    if (!collapsed)\n      updateSelectionRange(cm);\n    else\n      display.selectionDiv.style.display = "none";\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, cm.doc.sel.head, "div");\n      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);\n      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                                        headPos.top + lineOff.top - wrapOff.top)) + "px";\n      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                                         headPos.left + lineOff.left - wrapOff.left)) + "px";\n    }\n  }\n\n  // No selection, plain cursor\n  function updateSelectionCursor(cm) {\n    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, "div");\n    display.cursor.style.left = pos.left + "px";\n    display.cursor.style.top = pos.top + "px";\n    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";\n    display.cursor.style.display = "";\n\n    if (pos.other) {\n      display.otherCursor.style.display = "";\n      display.otherCursor.style.left = pos.other.left + "px";\n      display.otherCursor.style.top = pos.other.top + "px";\n      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";\n    } else { display.otherCursor.style.display = "none"; }\n  }\n\n  // Highlight selection\n  function updateSelectionRange(cm) {\n    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;\n    var fragment = document.createDocumentFragment();\n    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +\n                               "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) +\n                               "px; height: " + (bottom - top) + "px"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, "left"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, "right");\n          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = pl;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = pl;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = clientWidth;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < pl + 1) left = pl;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    if (sel.from.line == sel.to.line) {\n      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n    } else {\n      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);\n      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);\n      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;\n      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(pl, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(pl, leftEnd.bottom, null, rightStart.top);\n    }\n\n    removeChildrenAndAdd(display.selectionDiv, fragment);\n    display.selectionDiv.style.display = "";\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursor.style.visibility = display.otherCursor.style.visibility = "";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";\n      }, cm.options.cursorBlinkRate);\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.showingTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changed = [], prevChange;\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {\n      if (doc.frontier >= cm.display.showingFrom) { // Visible\n        var oldStyles = line.styles;\n        line.styles = highlightLine(cm, line, state, true);\n        var ischange = !oldStyles || oldStyles.length != line.styles.length;\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) {\n          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;\n          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});\n        }\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changed.length)\n      operation(cm, function() {\n        for (var i = 0; i < changed.length; ++i)\n          regChange(this, changed[i].start, changed[i].end);\n      })();\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingLeft(display) {\n    var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));\n    return e.offsetLeft;\n  }\n\n  function measureChar(cm, line, ch, data, bias) {\n    var dir = -1;\n    data = data || measureLine(cm, line);\n    if (data.crude) {\n      var left = data.left + ch * data.width;\n      return {left: left, right: left + data.width, top: data.top, bottom: data.bottom};\n    }\n\n    for (var pos = ch;; pos += dir) {\n      var r = data[pos];\n      if (r) break;\n      if (dir < 0 && pos == 0) dir = 1;\n    }\n    bias = pos > ch ? "left" : pos < ch ? "right" : bias;\n    if (bias == "left" && r.leftSide) r = r.leftSide;\n    else if (bias == "right" && r.rightSide) r = r.rightSide;\n    return {left: pos < ch ? r.right : r.left,\n            right: pos > ch ? r.left : r.right,\n            top: r.top,\n            bottom: r.bottom};\n  }\n\n  function findCachedMeasurement(cm, line) {\n    var cache = cm.display.measureLineCache;\n    for (var i = 0; i < cache.length; ++i) {\n      var memo = cache[i];\n      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&\n          cm.display.scroller.clientWidth == memo.width &&\n          memo.classes == line.textClass + "|" + line.wrapClass)\n        return memo;\n    }\n  }\n\n  function clearCachedMeasurement(cm, line) {\n    var exists = findCachedMeasurement(cm, line);\n    if (exists) exists.text = exists.measure = exists.markedSpans = null;\n  }\n\n  function measureLine(cm, line) {\n    // First look in the cache\n    var cached = findCachedMeasurement(cm, line);\n    if (cached) return cached.measure;\n\n    // Failing that, recompute and store result in cache\n    var measure = measureLineInner(cm, line);\n    var cache = cm.display.measureLineCache;\n    var memo = {text: line.text, width: cm.display.scroller.clientWidth,\n                markedSpans: line.markedSpans, measure: measure,\n                classes: line.textClass + "|" + line.wrapClass};\n    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;\n    else cache.push(memo);\n    return measure;\n  }\n\n  function measureLineInner(cm, line) {\n    if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom)\n      return crudelyMeasureLine(cm, line);\n\n    var display = cm.display, measure = emptyArray(line.text.length);\n    var pre = buildLineContent(cm, line, measure, true).pre;\n\n    // IE does not cache element positions of inline elements between\n    // calls to getBoundingClientRect. This makes the loop below,\n    // which gathers the positions of all the characters on the line,\n    // do an amount of layout work quadratic to the number of\n    // characters. When line wrapping is off, we try to improve things\n    // by first subdividing the line into a bunch of inline blocks, so\n    // that IE can reuse most of the layout information from caches\n    // for those blocks. This does interfere with line wrapping, so it\n    // doesn't work when wrapping is on, but in that case the\n    // situation is slightly better, since IE does cache line-wrapping\n    // information and only recomputes per-line.\n    if (old_ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n      var fragment = document.createDocumentFragment();\n      var chunk = 10, n = pre.childNodes.length;\n      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n        var wrap = elt("div", null, null, "display: inline-block");\n        for (var j = 0; j < chunk && n; ++j) {\n          wrap.appendChild(pre.firstChild);\n          --n;\n        }\n        fragment.appendChild(wrap);\n      }\n      pre.appendChild(fragment);\n    }\n\n    removeChildrenAndAdd(display.measure, pre);\n\n    var outer = getRect(display.lineDiv);\n    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;\n    // Work around an IE7/8 bug where it will sometimes have randomly\n    // replaced our pre with a clone at this point.\n    if (ie_lt9 && display.measure.first != pre)\n      removeChildrenAndAdd(display.measure, pre);\n\n    function measureRect(rect) {\n      var top = rect.top - outer.top, bot = rect.bottom - outer.top;\n      if (bot > maxBot) bot = maxBot;\n      if (top < 0) top = 0;\n      for (var i = vranges.length - 2; i >= 0; i -= 2) {\n        var rtop = vranges[i], rbot = vranges[i+1];\n        if (rtop > bot || rbot < top) continue;\n        if (rtop <= top && rbot >= bot ||\n            top <= rtop && bot >= rbot ||\n            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {\n          vranges[i] = Math.min(top, rtop);\n          vranges[i+1] = Math.max(bot, rbot);\n          break;\n        }\n      }\n      if (i < 0) { i = vranges.length; vranges.push(top, bot); }\n      return {left: rect.left - outer.left,\n              right: rect.right - outer.left,\n              top: i, bottom: null};\n    }\n    function finishRect(rect) {\n      rect.bottom = vranges[rect.top+1];\n      rect.top = vranges[rect.top];\n    }\n\n    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {\n      var node = cur, rect = null;\n      // A widget might wrap, needs special care\n      if (/\\bCodeMirror-widget\\b/.test(cur.className) && cur.getClientRects) {\n        if (cur.firstChild.nodeType == 1) node = cur.firstChild;\n        var rects = node.getClientRects();\n        if (rects.length > 1) {\n          rect = data[i] = measureRect(rects[0]);\n          rect.rightSide = measureRect(rects[rects.length - 1]);\n        }\n      }\n      if (!rect) rect = data[i] = measureRect(getRect(node));\n      if (cur.measureRight) rect.right = getRect(cur.measureRight).left - outer.left;\n      if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));\n    }\n    removeChildren(cm.display.measure);\n    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {\n      finishRect(cur);\n      if (cur.leftSide) finishRect(cur.leftSide);\n      if (cur.rightSide) finishRect(cur.rightSide);\n    }\n    return data;\n  }\n\n  function crudelyMeasureLine(cm, line) {\n    var copy = new Line(line.text.slice(0, 100), null);\n    if (line.textClass) copy.textClass = line.textClass;\n    var measure = measureLineInner(cm, copy);\n    var left = measureChar(cm, copy, 0, measure, "left");\n    var right = measureChar(cm, copy, 99, measure, "right");\n    return {crude: true, top: left.top, left: left.left, bottom: left.bottom, width: (right.right - left.left) / 100};\n  }\n\n  function measureLineWidth(cm, line) {\n    var hasBadSpan = false;\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {\n      var sp = line.markedSpans[i];\n      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;\n    }\n    var cached = !hasBadSpan && findCachedMeasurement(cm, line);\n    if (cached || line.text.length >= cm.options.crudeMeasuringFrom)\n      return measureChar(cm, line, line.text.length, cached && cached.measure, "right").right;\n\n    var pre = buildLineContent(cm, line, null, true).pre;\n    var end = pre.appendChild(zeroWidthElement(cm.display.measure));\n    removeChildrenAndAdd(cm.display.measure, pre);\n    return getRect(end).right - getRect(cm.display.lineDiv).left;\n  }\n\n  function clearCaches(cm) {\n    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == "line") return rect;\n    if (!context) context = "local";\n    var yOff = heightAtLine(cm, lineObj);\n    if (context == "local") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == "page" || context == "window") {\n      var lOff = getRect(cm.display.lineSpace);\n      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Context may be "window", "page", "div", or "local"/null\n  // Result is in "div" coords\n  function fromCoordSystem(cm, coords, context) {\n    if (context == "div") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into "page" coordinate system\n    if (context == "page") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == "local" || !context) {\n      var localBox = getRect(cm.display.sizer);\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = getRect(cm.display.lineSpace);\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);\n  }\n\n  function cursorCoords(cm, pos, context, lineObj, measurement) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!measurement) measurement = measureLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = new Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Coords must be lineSpace-local\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineNo > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find();\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineNo = mergedPos.to.line;\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(cm, lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var measurement = measureLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), "line",\n                            lineObj, measurement);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < 0 ? -1 : xDiff ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt("pre");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode("x"));\n        measureText.appendChild(elt("br"));\n      }\n      measureText.appendChild(document.createTextNode("x"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt("span", "x");\n    var pre = elt("pre", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var width = anchor.offsetWidth;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap changes in such a way that each\n  // change won't have to update the cursor and display (which would\n  // be awkward, slow, and error-prone), but instead updates are\n  // batched and then all combined and executed at once.\n\n  var nextOpId = 0;\n  function startOperation(cm) {\n    cm.curOp = {\n      // An array of ranges of lines that have to be updated. See\n      // updateDisplay.\n      changes: [],\n      forceUpdate: false,\n      updateInput: null,\n      userSelChange: null,\n      textChanged: null,\n      selectionChanged: false,\n      cursorActivity: false,\n      updateMaxLine: false,\n      updateScrollPos: false,\n      id: ++nextOpId\n    };\n    if (!delayedCallbackDepth++) delayedCallbacks = [];\n  }\n\n  function endOperation(cm) {\n    var op = cm.curOp, doc = cm.doc, display = cm.display;\n    cm.curOp = null;\n\n    if (op.updateMaxLine) computeMaxLength(cm);\n    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {\n      var width = measureLineWidth(cm, display.maxLine);\n      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";\n      display.maxLineChanged = false;\n      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);\n      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)\n        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);\n    }\n    var newScrollPos, updated;\n    if (op.updateScrollPos) {\n      newScrollPos = op.updateScrollPos;\n    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible\n      var coords = cursorCoords(cm, doc.sel.head);\n      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n    }\n    if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {\n      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);\n      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;\n    }\n    if (!updated && op.selectionChanged) updateSelection(cm);\n    if (op.updateScrollPos) {\n      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, newScrollPos.scrollTop));\n      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, newScrollPos.scrollLeft));\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\n      alignHorizontally(cm);\n      if (op.scrollToPos)\n        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),\n                          clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);\n    } else if (newScrollPos) {\n      scrollCursorIntoView(cm);\n    }\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      resetInput(cm, op.userSelChange);\n\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], "hide");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");\n\n    var delayed;\n    if (!--delayedCallbackDepth) {\n      delayed = delayedCallbacks;\n      delayedCallbacks = null;\n    }\n    if (op.textChanged)\n      signal(cm, "change", cm, op.textChanged);\n    if (op.cursorActivity) signal(cm, "cursorActivity", cm);\n    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm1, f) {\n    return function() {\n      var cm = cm1 || this, withOp = !cm.curOp;\n      if (withOp) startOperation(cm);\n      try { var result = f.apply(cm, arguments); }\n      finally { if (withOp) endOperation(cm); }\n      return result;\n    };\n  }\n  function docOperation(f) {\n    return function() {\n      var withOp = this.cm && !this.cm.curOp, result;\n      if (withOp) startOperation(this.cm);\n      try { result = f.apply(this, arguments); }\n      finally { if (withOp) endOperation(this.cm); }\n      return result;\n    };\n  }\n  function runInOp(cm, f) {\n    var withOp = !cm.curOp, result;\n    if (withOp) startOperation(cm);\n    try { result = f(); }\n    finally { if (withOp) endOperation(cm); }\n    return result;\n  }\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    cm.curOp.changes.push({from: from, to: to, diff: lendiff});\n  }\n\n  // INPUT HANDLING\n\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // prevInput is a hack to work with IME. If we reset the textarea\n  // on every change, that breaks IME. So we look for changes\n  // compared to the previous content instead. (Modern browsers have\n  // events that indicate IME taking place, but these are not widely\n  // supported or compatible enough yet to rely on.)\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;\n    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.options.disableInput) return false;\n    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\n      input.value = input.value.substring(0, input.value.length - 1);\n      cm.state.fakedLastChar = false;\n    }\n    var text = input.value;\n    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {\n      resetInput(cm, true);\n      return false;\n    }\n\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    sel.shift = false;\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n    var from = sel.from, to = sel.to;\n    var inserted = text.slice(same);\n    if (same < prevInput.length)\n      from = Pos(from.line, from.ch - (prevInput.length - same));\n    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)\n      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + inserted.length));\n\n    var updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: splitLines(inserted),\n                       origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};\n    makeChange(cm.doc, changeEvent, "end");\n    cm.curOp.updateInput = updateInput;\n    signalLater(cm, "inputRead", cm, changeEvent);\n    if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\n        cm.options.smartIndent && sel.head.ch < 100) {\n      var electric = cm.getModeAt(sel.head).electricChars;\n      if (electric) for (var i = 0; i < electric.length; i++)\n        if (inserted.indexOf(electric.charAt(i)) > -1) {\n          indentLine(cm, sel.head.line, "smart");\n          break;\n        }\n    }\n\n    if (text.length > 1000 || text.indexOf("\\n") > -1) input.value = cm.display.prevInput = "";\n    else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n    return true;\n  }\n\n  function resetInput(cm, user) {\n    var minimal, selected, doc = cm.doc;\n    if (!posEq(doc.sel.from, doc.sel.to)) {\n      cm.display.prevInput = "";\n      minimal = hasCopyEvent &&\n        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n      var content = minimal ? "-" : selected || cm.getSelection();\n      cm.display.input.value = content;\n      if (cm.state.focused) selectInput(cm.display.input);\n      if (ie && !ie_lt9) cm.display.inputHasSelection = content;\n    } else if (user) {\n      cm.display.prevInput = cm.display.input.value = "";\n      if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    }\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, "mousedown", operation(cm, onMouseDown));\n    if (old_ie)\n      on(d.scroller, "dblclick", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);\n        extendSelection(cm.doc, word.from, word.to);\n      }));\n    else\n      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    on(d.lineSpace, "selectstart", function(e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!captureMiddleClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});\n\n    on(d.scroller, "scroll", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, "scroll", cm);\n      }\n    });\n    on(d.scrollbarV, "scroll", function() {\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, "scroll", function() {\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});\n\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, "mousedown", reFocus);\n    on(d.scrollbarV, "mousedown", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    var resizeTimer;\n    function onResize() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        // Might be a text scaling operation, clear size caches.\n        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;\n        clearCaches(cm);\n        runInOp(cm, bind(regChange, cm));\n      }, 100);\n    }\n    on(window, "resize", onResize);\n    // Above handler holds on to the editor and its data structures.\n    // Here we poll to unregister it when the editor is no longer in\n    // the document, so that it can be garbage-collected.\n    function unregister() {\n      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n      if (p) setTimeout(unregister, 5000);\n      else off(window, "resize", onResize);\n    }\n    setTimeout(unregister, 5000);\n\n    on(d.input, "keyup", operation(cm, function(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n      if (e.keyCode == 16) cm.doc.sel.shift = false;\n    }));\n    on(d.input, "input", function() {\n      if (ie && !ie_lt9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\n      fastPoll(cm);\n    });\n    on(d.input, "keydown", operation(cm, onKeyDown));\n    on(d.input, "keypress", operation(cm, onKeyPress));\n    on(d.input, "focus", bind(onFocus, cm));\n    on(d.input, "blur", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n      e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});\n      on(d.scroller, "dragenter", drag_);\n      on(d.scroller, "dragover", drag_);\n      on(d.scroller, "drop", operation(cm, onDrop));\n    }\n    on(d.scroller, "paste", function(e) {\n      if (eventInWidget(d, e)) return;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n    on(d.input, "paste", function() {\n      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\n      // Add a char to the end of textarea before paste occur so that\n      // selection doesn't span to the end of textarea.\n      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\n        var start = d.input.selectionStart, end = d.input.selectionEnd;\n        d.input.value += "$";\n        d.input.selectionStart = start;\n        d.input.selectionEnd = end;\n        cm.state.fakedLastChar = true;\n      }\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopy(e) {\n      if (d.inaccurateSelection) {\n        d.prevInput = "";\n        d.inaccurateSelection = false;\n        d.input.value = cm.getSelection();\n        selectInput(d.input);\n      }\n      if (e.type == "cut") cm.state.cutIncoming = true;\n    }\n    on(d.input, "cut", prepareCopy);\n    on(d.input, "copy", prepareCopy);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, "mouseup", function() {\n      if (document.activeElement == d.input) d.input.blur();\n      focusInput(cm);\n    });\n  }\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  function posFromMouse(cm, e, liberal) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||\n          target == display.scrollbarV || target == display.scrollbarV.firstChild ||\n          target == display.scrollbarFiller || target == display.gutterFiller) return null;\n    }\n    var x, y, space = getRect(display.lineSpace);\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n    return coordsChar(cm, x - space.left, y - space.top);\n  }\n\n  var lastClick, lastDoubleClick;\n  function onMouseDown(e) {\n    if (signalDOMEvent(this, e)) return;\n    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;\n    sel.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n\n    switch (e_button(e)) {\n    case 3:\n      if (captureMiddleClick) onContextMenu.call(cm, cm, e);\n      return;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      return;\n    }\n    // For button 1, if it was clicked inside the editor\n    // (posFromMouse returning non-null), we have to adjust the\n    // selection.\n    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}\n\n    if (!cm.state.focused) onFocus(cm);\n\n    var now = +new Date, type = "single";\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n      type = "triple";\n      e_preventDefault(e);\n      setTimeout(bind(focusInput, cm), 20);\n      selectLine(cm, start.line);\n    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n      type = "double";\n      lastDoubleClick = {time: now, pos: start};\n      e_preventDefault(e);\n      var word = findWordAt(getLine(doc, start.line).text, start);\n      extendSelection(cm.doc, word.from, word.to);\n    } else { lastClick = {time: now, pos: start}; }\n\n    var last = start;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&\n        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {\n      var dragEnd = operation(cm, function(e2) {\n        if (webkit) display.scroller.draggable = false;\n        cm.state.draggingText = false;\n        off(document, "mouseup", dragEnd);\n        off(display.scroller, "drop", dragEnd);\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          extendSelection(cm.doc, start);\n          focusInput(cm);\n          // Work around unexplainable focus problem in IE9 (#2127)\n          if (old_ie && !ie_lt9)\n            setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\n        }\n      });\n      // Let the drag handler handle this.\n      if (webkit) display.scroller.draggable = true;\n      cm.state.draggingText = dragEnd;\n      // IE's approach to draggable\n      if (display.scroller.dragDrop) display.scroller.dragDrop();\n      on(document, "mouseup", dragEnd);\n      on(display.scroller, "drop", dragEnd);\n      return;\n    }\n    e_preventDefault(e);\n    if (type == "single") extendSelection(cm.doc, clipPos(doc, start));\n\n    var startstart = sel.from, startend = sel.to, lastPos = start;\n\n    function doSelect(cur) {\n      if (posEq(lastPos, cur)) return;\n      lastPos = cur;\n\n      if (type == "single") {\n        extendSelection(cm.doc, clipPos(doc, start), cur);\n        return;\n      }\n\n      startstart = clipPos(doc, startstart);\n      startend = clipPos(doc, startend);\n      if (type == "double") {\n        var word = findWordAt(getLine(doc, cur.line).text, cur);\n        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);\n        else extendSelection(cm.doc, startstart, word.to);\n      } else if (type == "triple") {\n        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));\n        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));\n      }\n    }\n\n    var editorSize = getRect(display.wrapper);\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true);\n      if (!cur) return;\n      if (!posEq(cur, last)) {\n        if (!cm.state.focused) onFocus(cm);\n        last = cur;\n        doSelect(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, "mousemove", move);\n      off(document, "mouseup", up);\n    }\n\n    var move = operation(cm, function(e) {\n      if (!old_ie && !e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, "mousemove", move);\n    on(document, "mouseup", up);\n  }\n\n  function gutterEvent(cm, e, type, prevent, signalfn) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(getRect(cm.display.gutters).right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = getRect(display.lineDiv);\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && getRect(g).right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalfn(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, "gutterContextMenu")) return false;\n    return gutterEvent(cm, e, "gutterContextMenu", false, signal);\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, "gutterClick", true, signalLater);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join("\\n")), origin: "paste"}, "around");\n          }\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else {\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData("Text");\n        if (text) {\n          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;\n          setSelection(cm.doc, pos, pos);\n          if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");\n          cm.replaceSelection(text, null, "paste");\n          focusInput(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    var txt = cm.getSelection();\n    e.dataTransfer.setData("Text", txt);\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");\n      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n      if (opera) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (opera) img.parentNode.removeChild(img);\n    }\n  }\n\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplay(cm, [], val);\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplay(cm, []);\n    startWorker(cm, 100);\n  }\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (old_ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n        if (cur.lineObj) {\n          cm.display.currentWheelTarget = cur;\n          break;\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplay(cm, [], {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == "string") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var doc = cm.doc, prevShift = doc.sel.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) doc.sel.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      doc.sel.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n    maps.push(cm.options.keyMap);\n    return maps;\n  }\n\n  var maybeTransition;\n  function handleKeyBinding(cm, e) {\n    // Handle auto keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap) {\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n        keyMapChanged(cm);\n      }\n    }, 50);\n\n    var name = keyName(e, true), handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n             || lookupKey(name, keymaps, function(b) {\n                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)\n                    return doHandleBinding(cm, b);\n                });\n    } else {\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n    }\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n      signalLater(cm, "keyHandled", cm, name, e);\n    }\n    return handled;\n  }\n\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);\n    }\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (!cm.state.focused) onFocus(cm);\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    if (old_ie && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    // IE does strange things with escape.\n    cm.doc.sel.shift = code == 16 || e.shiftKey;\n    // First give onKeyEvent option a chance to handle this.\n    var handled = handleKeyBinding(cm, e);\n    if (opera) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection("");\n    }\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    fastPoll(cm);\n  }\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == "nocursor") return;\n    if (!cm.state.focused) {\n      signal(cm, "focus", cm);\n      cm.state.focused = true;\n      if (cm.display.wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n        cm.display.wrapper.className += " CodeMirror-focused";\n      if (!cm.curOp) {\n        resetInput(cm, true);\n        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\n      }\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, "blur", cm);\n      cm.state.focused = false;\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);\n  }\n\n  var detectingSelectAll;\n  function onContextMenu(cm, e) {\n    if (signalDOMEvent(cm, e, "contextmenu")) return;\n    var display = cm.display, sel = cm.doc.sel;\n    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\n\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || opera) return; // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)))\n      operation(cm, setSelection)(cm.doc, pos, pos);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = "absolute";\n    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +\n      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: transparent; outline: none;" +\n      "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";\n    focusInput(cm);\n    resetInput(cm, true);\n    // Adds "Select all" to context menu in FF\n    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";\n\n    function prepareSelectAllHack() {\n      if (display.input.selectionStart != null) {\n        var extval = display.input.value = "\\u200b" + (posEq(sel.from, sel.to) ? "" : display.input.value);\n        display.prevInput = "\\u200b";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n      }\n    }\n    function rehide() {\n      display.inputDiv.style.position = "relative";\n      display.input.style.cssText = oldCSS;\n      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all\n      if (display.input.selectionStart != null) {\n        if (!old_ie || ie_lt9) prepareSelectAllHack();\n        clearTimeout(detectingSelectAll);\n        var i = 0, poll = function(){\n          if (display.prevInput == "\\u200b" && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        };\n        detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (old_ie && !ie_lt9) prepareSelectAllHack();\n    if (captureMiddleClick) {\n      e_stop(e);\n      var mouseup = function() {\n        off(window, "mouseup", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, "mouseup", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  // UPDATING\n\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Make sure a position will be valid after the given change.\n  function clipPostChange(doc, change, pos) {\n    if (!posLess(change.from, pos)) return clipPos(doc, pos);\n    var diff = (change.text.length - 1) - (change.to.line - change.from.line);\n    if (pos.line > change.to.line + diff) {\n      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;\n      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);\n      return clipToLen(pos, getLine(doc, preLine).text.length);\n    }\n    if (pos.line == change.to.line + diff)\n      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +\n                       getLine(doc, change.to.line).text.length - change.to.ch);\n    var inside = pos.line - change.from.line;\n    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));\n  }\n\n  // Hint can be null|"end"|"start"|"around"|{anchor,head}\n  function computeSelAfterChange(doc, change, hint) {\n    if (hint && typeof hint == "object") // Assumed to be {anchor, head} object\n      return {anchor: clipPostChange(doc, change, hint.anchor),\n              head: clipPostChange(doc, change, hint.head)};\n\n    if (hint == "start") return {anchor: change.from, head: change.from};\n\n    var end = changeEnd(change);\n    if (hint == "around") return {anchor: change.from, head: end};\n    if (hint == "end") return {anchor: end, head: end};\n\n    // hint is null, leave the selection alone as much as possible\n    var adjustPos = function(pos) {\n      if (posLess(pos, change.from)) return pos;\n      if (!posLess(change.to, pos)) return end;\n\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n      if (pos.line == change.to.line) ch += end.ch - change.to.ch;\n      return Pos(line, ch);\n    };\n    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};\n  }\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, "beforeChange", doc, obj);\n    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Replace the range from from to to by the strings in replacement.\n  // change is a {from, to, text [, origin]} object\n  function makeChange(doc, change, selUpdate, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [""]});\n      if (split.length)\n        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);\n    } else {\n      makeChangeNoReadonly(doc, change, selUpdate);\n    }\n  }\n\n  function makeChangeNoReadonly(doc, change, selUpdate) {\n    if (change.text.length == 1 && change.text[0] == "" && posEq(change.from, change.to)) return;\n    var selAfter = computeSelAfterChange(doc, change, selUpdate);\n    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  function makeChangeFromHistory(doc, type) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history;\n    var event = (type == "undo" ? hist.done : hist.undone).pop();\n    if (!event) return;\n\n    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,\n                anchorAfter: event.anchorBefore, headAfter: event.headBefore,\n                generation: hist.generation};\n    (type == "undo" ? hist.undone : hist.done).push(anti);\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        (type == "undo" ? hist.done : hist.undone).length = 0;\n        return;\n      }\n\n      anti.changes.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change, null)\n                    : {anchor: event.anchorBefore, head: event.headBefore};\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      var rebased = [];\n\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  function shiftDoc(doc, distance) {\n    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}\n    doc.first += distance;\n    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);\n    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);\n    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);\n  }\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);\n    else updateDoc(doc, change, spans, selAfter);\n  }\n\n  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))\n      cm.curOp.cursorActivity = true;\n\n    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(doc, line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    regChange(cm, from.line, to.line + 1, lendiff);\n\n    if (hasHandler(cm, "change")) {\n      var changeObj = {from: from, to: to,\n                       text: change.text,\n                       removed: change.removed,\n                       origin: change.origin};\n      if (cm.curOp.textChanged) {\n        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else cm.curOp.textChanged = changeObj;\n    }\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == "string") code = splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);\n  }\n\n  // POSITION OBJECT\n\n  function Pos(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  }\n  CodeMirror.Pos = Pos;\n\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function cmp(a, b) {return a.line - b.line || a.ch - b.ch;}\n  function copyPos(x) {return Pos(x.line, x.ch);}\n\n  // SELECTION\n\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\n  // If shift is held, this will move the selection anchor. Otherwise,\n  // it'll set the whole selection.\n  function extendSelection(doc, pos, other, bias) {\n    if (doc.sel.shift || doc.sel.extend) {\n      var anchor = doc.sel.anchor;\n      if (other) {\n        var posBefore = posLess(pos, anchor);\n        if (posBefore != posLess(other, anchor)) {\n          anchor = pos;\n          pos = other;\n        } else if (posBefore != posLess(pos, other)) {\n          pos = other;\n        }\n      }\n      setSelection(doc, anchor, pos, bias);\n    } else {\n      setSelection(doc, pos, other || pos, bias);\n    }\n    if (doc.cm) doc.cm.curOp.userSelChange = true;\n  }\n\n  function filterSelectionChange(doc, anchor, head) {\n    var obj = {anchor: anchor, head: head};\n    signal(doc, "beforeSelectionChange", doc, obj);\n    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);\n    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);\n    return obj;\n  }\n\n  // Update the selection. Last two args are only used by\n  // updateDoc, since they have to be expressed in the line\n  // numbers before the update.\n  function setSelection(doc, anchor, head, bias, checkAtomic) {\n    if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {\n      var filtered = filterSelectionChange(doc, anchor, head);\n      head = filtered.head;\n      anchor = filtered.anchor;\n    }\n\n    var sel = doc.sel;\n    sel.goalColumn = null;\n    if (bias == null) bias = posLess(head, sel.head) ? -1 : 1;\n    // Skip over atomic spans.\n    if (checkAtomic || !posEq(anchor, sel.anchor))\n      anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");\n    if (checkAtomic || !posEq(head, sel.head))\n      head = skipAtomic(doc, head, bias, checkAtomic != "push");\n\n    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n\n    sel.anchor = anchor; sel.head = head;\n    var inv = posLess(head, anchor);\n    sel.from = inv ? head : anchor;\n    sel.to = inv ? anchor : head;\n\n    if (doc.cm)\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =\n        doc.cm.curOp.cursorActivity = true;\n\n    signalLater(doc, "cursorActivity", doc);\n  }\n\n  function reCheckSelection(cm) {\n    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");\n  }\n\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, "beforeCursorEnter");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find()[dir < 0 ? "from" : "to"];\n            if (posEq(newPos, curPos)) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SCROLLING\n\n  function scrollCursorIntoView(cm) {\n    var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);\n    if (!cm.state.focused) return;\n    var display = cm.display, box = getRect(display.sizer), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt("div", "\\u200b", null, "position: absolute; top: " +\n                           (coords.top - display.viewOffset) + "px; height: " +\n                           (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +\n                           coords.left + "px; width: 2px;");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (;;) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;\n    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;\n    var gutterw = display.gutters.offsetWidth;\n    var atLeft = x1 < gutterw + 10;\n    if (x1 < screenleft + gutterw || atLeft) {\n      if (atLeft) x1 = 0;\n      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n    } else if (x2 > screenw + screenleft - 3) {\n      result.scrollLeft = x2 + 10 - screenw;\n    }\n    return result;\n  }\n\n  function updateScrollPos(cm, left, top) {\n    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,\n                                scrollTop: top == null ? cm.doc.scrollTop : top};\n  }\n\n  function addToScrollPos(cm, left, top) {\n    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});\n    var scroll = cm.display.scroller;\n    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));\n    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));\n  }\n\n  // API UTILITIES\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc;\n    if (how == null) how = "add";\n    if (how == "smart") {\n      if (!cm.doc.mode.indent) how = "prev";\n      else var state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = "not";\n    } else if (how == "smart") {\n      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass) {\n        if (!aggressive) return;\n        how = "prev";\n      }\n    }\n    if (how == "prev") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == "add") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == "subtract") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == "number") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = "", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\\t";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString)\n      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");\n    else if (doc.sel.head.line == n && doc.sel.head.ch < curSpaceString.length)\n      setSelection(doc, Pos(n, curSpaceString.length), Pos(n, curSpaceString.length), 1);\n    line.stateAfter = null;\n  }\n\n  function changeLine(cm, handle, op) {\n    var no = handle, line = handle, doc = cm.doc;\n    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no)) regChange(cm, no, no + 1);\n    else return null;\n    return line;\n  }\n\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == "char") moveOnce();\n    else if (unit == "column") moveOnce(true);\n    else if (unit == "word" || unit == "group") {\n      var sawType = null, group = unit == "group";\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || "\\n";\n        var type = isWordChar(cur) ? "w"\n          : !group ? null\n          : /\\s/.test(cur) ? null\n          : "p";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == "page") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == "line") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  function findWordAt(line, pos) {\n    var start = pos.ch, end = pos.ch;\n    if (line) {\n      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n      var startChar = line.charAt(start);\n      var check = isWordChar(startChar) ? isWordChar\n        : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n        : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n      while (start > 0 && check(line.charAt(start - 1))) --start;\n      while (end < line.length && check(line.charAt(end))) ++end;\n    }\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};\n  }\n\n  function selectLine(cm, line) {\n    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));\n  }\n\n  // PROTOTYPE\n\n  // The publicly visible API. Note that operation(null, f) means\n  // 'wrap f in an operation, performed on its `this` parameter'\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != "mode") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? "push" : "unshift"](map);\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: operation(null, function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error("Overlays may not be stateful.");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: operation(null, function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == "string" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: operation(null, function(n, dir, aggressive) {\n      if (typeof dir != "string" && typeof dir != "number") {\n        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";\n        else dir = dir ? "add" : "subtract";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: operation(null, function(how) {\n      var sel = this.doc.sel;\n      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how, true);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      var doc = this.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null, // Deprecated, use 'type' instead\n              type: style || null,\n              state: state};\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      if (ch == 0) return styles[2];\n      for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else return styles[mid * 2 + 2];\n      }\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return helpers;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == "string") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, sel = this.doc.sel;\n      if (start == null) pos = sel.head;\n      else if (typeof start == "object") pos = clipPos(this.doc, start);\n      else pos = start ? sel.from : sel.to;\n      return cursorCoords(this, pos, mode || "page");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || "page");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || "page");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, last = this.doc.first + this.doc.size - 1;\n      if (line < this.doc.first) line = this.doc.first;\n      else if (line > last) { line = last; end = true; }\n      var lineObj = getLine(this.doc, line);\n      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || "page").top +\n        (end ? lineObj.height : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: operation(null, function(line, gutterID, value) {\n      return changeLine(this, line, function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: operation(null, function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regChange(cm, i, i + 1);\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp("(?:^|\\\\s)" + cls + "(?:$|\\\\s)").test(line[prop])) return false;\n        else line[prop] += " " + cls;\n        return true;\n      });\n    }),\n\n    removeLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(new RegExp("(?:^|\\\\s+)" + cls + "(?:$|\\\\s+)"));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: operation(null, function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    lineInfo: function(line) {\n      if (typeof line == "number") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = "absolute";\n      display.sizer.appendChild(node);\n      if (vert == "over") {\n        top = pos.top;\n      } else if (vert == "above" || vert == "near") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + "px";\n      node.style.left = node.style.right = "";\n      if (horiz == "right") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = "0px";\n      } else {\n        if (horiz == "left") left = 0;\n        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + "px";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: operation(null, onKeyDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd](this);\n    },\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, pos;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to))\n        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);\n      else\n        pos = dir < 0 ? sel.from : sel.to;\n      extendSelection(this.doc, pos, pos, dir);\n    }),\n\n    deleteH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel;\n      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");\n      else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");\n      this.curOp.userSelChange = true;\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, "div");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, target, goal;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to)) {\n        var pos = cursorCoords(this, sel.head, "div");\n        if (sel.goalColumn != null) pos.left = sel.goalColumn;\n        target = findPosV(this, pos, dir, unit);\n        if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);\n        goal = pos.left;\n      } else {\n        target = dir < 0 ? sel.from : sel.to;\n      }\n      extendSelection(this.doc, target, target, dir);\n      if (goal != null) sel.goalColumn = goal;\n    }),\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        this.display.cursor.className += " CodeMirror-overwrite";\n      else\n        this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");\n    },\n    hasFocus: function() { return this.state.focused; },\n\n    scrollTo: operation(null, function(x, y) {\n      updateScrollPos(this, x, y);\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: operation(null, function(range, margin) {\n      if (range == null) range = {from: this.doc.sel.head, to: null};\n      else if (typeof range == "number") range = {from: Pos(range, 0), to: null};\n      else if (range.from == null) range = {from: range, to: null};\n      if (!range.to) range.to = range.from;\n      if (!margin) margin = 0;\n\n      var coords = range;\n      if (range.from.line != null) {\n        this.curOp.scrollToPos = {from: range.from, to: range.to, margin: margin};\n        coords = {from: cursorCoords(this, range.from),\n                  to: cursorCoords(this, range.to)};\n      }\n      var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left),\n                                    Math.min(coords.from.top, coords.to.top) - margin,\n                                    Math.max(coords.from.right, coords.to.right),\n                                    Math.max(coords.from.bottom, coords.to.bottom) + margin);\n      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);\n    }),\n\n    setSize: operation(null, function(width, height) {\n      function interpret(val) {\n        return typeof val == "number" || /^\\d+$/.test(String(val)) ? val + "px" : val;\n      }\n      if (width != null) this.display.wrapper.style.width = interpret(width);\n      if (height != null) this.display.wrapper.style.height = interpret(height);\n      if (this.options.lineWrapping)\n        this.display.measureLineCache.length = this.display.measureLineCachePos = 0;\n      this.curOp.forceUpdate = true;\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: operation(null, function() {\n      var badHeight = this.display.cachedTextHeight == null;\n      clearCaches(this);\n      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);\n      regChange(this);\n      if (badHeight) estimateLineHeights(this);\n    }),\n\n    swapDoc: operation(null, function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      resetInput(this, true);\n      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);\n      signalLater(this, "swapDoc", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option("value", "", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option("mode", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option("indentUnit", 2, loadMode, true);\n  option("indentWithTabs", false);\n  option("smartIndent", true);\n  option("tabSize", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option("specialChars", /[\\t\\u0000-\\u0019\\u00ad\\u200b\\u2028\\u2029\\ufeff]/g, function(cm, val) {\n    cm.options.specialChars = new RegExp(val.source + (val.test("\\t") ? "" : "|\\t"), "g");\n    cm.refresh();\n  }, true);\n  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option("electricChars", true);\n  option("rtlMoveVisually", !windows);\n  option("wholeLineUpdateBefore", true);\n\n  option("theme", "default", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option("keyMap", "default", keyMapChanged);\n  option("extraKeys", null);\n\n  option("onKeyEvent", null);\n  option("onDragEvent", null);\n\n  option("lineWrapping", false, wrappingChanged, true);\n  option("gutters", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option("fixedGutter", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";\n    cm.refresh();\n  }, true);\n  option("coverGutterNextToScrollbar", false, updateScrollbars, true);\n  option("lineNumbers", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option("firstLineNumber", 1, guttersChanged, true);\n  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);\n  option("showCursorWhenSelecting", false, updateSelection, true);\n\n  option("resetSelectionOnContextMenu", true);\n\n  option("readOnly", false, function(cm, val) {\n    if (val == "nocursor") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n      if (!val) resetInput(cm, true);\n    }\n  });\n  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm, true);}, true);\n  option("dragDrop", true);\n\n  option("cursorBlinkRate", 530);\n  option("cursorScrollMargin", 0);\n  option("cursorHeight", 1);\n  option("workTime", 100);\n  option("workDelay", 100);\n  option("flattenSpans", true, resetModeState, true);\n  option("addModeClass", false, resetModeState, true);\n  option("pollInterval", 100);\n  option("undoDepth", 40, function(cm, val){cm.doc.history.undoDepth = val;});\n  option("historyEventDelay", 500);\n  option("viewportMargin", 10, function(cm){cm.refresh();}, true);\n  option("maxHighlightLength", 10000, resetModeState, true);\n  option("crudeMeasuringFrom", 10000);\n  option("moveInputWithCursor", true, function(cm, val) {\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n  });\n\n  option("tabindex", null, function(cm, val) {\n    cm.display.input.tabIndex = val || "";\n  });\n  option("autofocus", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode("application/xml");\n    }\n    if (typeof spec == "string") return {name: spec};\n    else return spec || {name: "null"};\n  };\n\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, "text/plain");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  CodeMirror.defineMode("null", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME("text/plain", "null");\n\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // UTILITIES\n\n  CodeMirror.isWordChar = isWordChar;\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch)\n        cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");\n      else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");\n    },\n    deleteLine: function(cm) {\n      var l = cm.getCursor().line;\n      cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");\n    },\n    delLineLeft: function(cm) {\n      var cur = cm.getCursor();\n      cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n    },\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor(), start = lineStart(cm, cur.line);\n      var line = cm.getLineHandle(start.line);\n      var order = getOrder(line);\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));\n      } else cm.extendSelection(start);\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n    },\n    goLineRight: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), "div").top + 5;\n      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div"));\n    },\n    goLineLeft: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), "div").top + 5;\n      cm.extendSelection(cm.coordsChar({left: 0, top: top}, "div"));\n    },\n    goLineUp: function(cm) {cm.moveV(-1, "line");},\n    goLineDown: function(cm) {cm.moveV(1, "line");},\n    goPageUp: function(cm) {cm.moveV(-1, "page");},\n    goPageDown: function(cm) {cm.moveV(1, "page");},\n    goCharLeft: function(cm) {cm.moveH(-1, "char");},\n    goCharRight: function(cm) {cm.moveH(1, "char");},\n    goColumnLeft: function(cm) {cm.moveH(-1, "column");},\n    goColumnRight: function(cm) {cm.moveH(1, "column");},\n    goWordLeft: function(cm) {cm.moveH(-1, "word");},\n    goGroupRight: function(cm) {cm.moveH(1, "group");},\n    goGroupLeft: function(cm) {cm.moveH(-1, "group");},\n    goWordRight: function(cm) {cm.moveH(1, "word");},\n    delCharBefore: function(cm) {cm.deleteH(-1, "char");},\n    delCharAfter: function(cm) {cm.deleteH(1, "char");},\n    delWordBefore: function(cm) {cm.deleteH(-1, "word");},\n    delWordAfter: function(cm) {cm.deleteH(1, "word");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},\n    delGroupAfter: function(cm) {cm.deleteH(1, "group");},\n    indentAuto: function(cm) {cm.indentSelection("smart");},\n    indentMore: function(cm) {cm.indentSelection("add");},\n    indentLess: function(cm) {cm.indentSelection("subtract");},\n    insertTab: function(cm) {\n      cm.replaceSelection("\\t", "end", "+input");\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection("add");\n      else cm.replaceSelection("\\t", "end", "+input");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n    },\n    newlineAndIndent: function(cm) {\n      operation(cm, function() {\n        cm.replaceSelection("\\n", "end", "+input");\n        cm.indentLine(cm.getCursor().line, null, true);\n      })();\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",\n    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",\n    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",\n    "Tab": "defaultTab", "Shift-Tab": "indentAuto",\n    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",\n    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",\n    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",\n    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",\n    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",\n    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",\n    fallthrough: "basic"\n  };\n  keyMap.macDefault = {\n    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",\n    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",\n    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",\n    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",\n    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",\n    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",\n    fallthrough: ["basic", "emacsy"]\n  };\n  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",\n    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",\n    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",\n    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"\n  };\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == "string") return keyMap[val];\n    else return val;\n  }\n\n  function lookupKey(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return "stop";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return "stop";\n\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != "[object Array]")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done != "stop";\n    }\n  }\n  function isModifierKey(event) {\n    var name = keyNames[event.keyCode];\n    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";\n  }\n  function keyName(event, noShift) {\n    if (opera && event.keyCode == 34 && event["char"]) return false;\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = "Alt-" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;\n    if (!noShift && event.shiftKey) name = "Shift-" + name;\n    return name;\n  }\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.keyName = keyName;\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = document.body;\n      // doc.activeElement occasionally throws on IE\n      try { hasFocus = document.activeElement; } catch(e) {}\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute("autofocus") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, "submit", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    textarea.style.display = "none";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = "";\n      if (textarea.form) {\n        off(textarea.form, "submit", save);\n        if (typeof textarea.form.submit == "function")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  }\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == "string") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == "string") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n  CodeMirror.StringStream = StringStream;\n\n  // TEXTMARKERS\n\n  function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  }\n  CodeMirror.TextMarker = TextMarker;\n  eventMixin(TextMarker);\n\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, "clear")) {\n      var found = this.find();\n      if (found) signalLater(this, "clear", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.to != null) max = lineNo(line);\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from != null)\n        min = lineNo(line);\n      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm);\n    }\n    if (withOp) endOperation(cm);\n  };\n\n  TextMarker.prototype.find = function(bothSides) {\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null || span.to != null) {\n        var found = lineNo(line);\n        if (span.from != null) from = Pos(found, span.from);\n        if (span.to != null) to = Pos(found, span.to);\n      }\n    }\n    if (this.type == "bookmark" && !bothSides) return from;\n    return from && {from: from, to: to};\n  };\n\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(), cm = this.doc.cm;\n    if (!pos || !cm) return;\n    if (this.type != "bookmark") pos = pos.from;\n    var line = getLine(this.doc, pos.line);\n    clearCachedMeasurement(cm, line);\n    if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {\n      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {\n        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);\n        break;\n      }\n      runInOp(cm, function() {\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;\n      });\n    }\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  var nextMarkerId = 0;\n\n  function markText(doc, from, to, options, type) {\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type);\n    if (options) copyObj(options, marker);\n    if (posLess(to, from) || posEq(from, to) && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      marker.collapsed = true;\n      marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");\n      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error("Inserting collapsed marker partially overlapping an existing one");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addToHistory(doc, {from: from, to: to, origin: "markText"},\n                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)\n        updateMaxLine = true;\n      var span = {from: null, to: null, marker: marker};\n      if (curLine == from.line) span.from = from.ch;\n      if (curLine == to.line) span.to = to.ch;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, span);\n      ++curLine;\n    });\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      if (marker.atomic) reCheckSelection(cm);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0, me = this; i < markers.length; ++i) {\n      markers[i].parent = this;\n      on(markers[i], "clear", function(){me.clear();});\n    }\n  }\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, "clear");\n  };\n  SharedTextMarker.prototype.find = function() {\n    return this.primary.find();\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.replacedWith;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.replacedWith = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  // TEXTMARKER SPANS\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({from: span.from,\n                                to: endsAfter ? null : span.to,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n                                to: span.to == null ? null : span.to - endCh,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find();\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;\n        var newParts = [j, 1];\n        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))\n          newParts.push({from: p.from, to: m.from});\n        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(true);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||\n          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)\n        return true;\n    }\n  }\n\n  function visualLine(doc, line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(doc, merged.find().from.line);\n    return line;\n  }\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.replacedWith) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find().to, endLine = getLine(doc, end.line);\n      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // LINE WIDGETS\n\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.cm = cm;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n  function widgetOperation(f) {\n    return function() {\n      var withOp = !this.cm.curOp;\n      if (withOp) startOperation(this.cm);\n      try {var result = f.apply(this, arguments);}\n      finally {if (withOp) endOperation(this.cm);}\n      return result;\n    };\n  }\n  LineWidget.prototype.clear = widgetOperation(function() {\n    var ws = this.line.widgets, no = lineNo(this.line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) this.line.widgets = null;\n    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;\n    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));\n    if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);\n    regChange(this.cm, no, no + 1);\n  });\n  LineWidget.prototype.changed = widgetOperation(function() {\n    var oldH = this.height;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(this.line, this.line.height + diff);\n    var no = lineNo(this.line);\n    regChange(this.cm, no, no + 1);\n  });\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)\n      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm, handle, function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {\n        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, 0, widget.height);\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Run the given mode's parser over a line, update the styles\n  // array, which contains alternating fragments of text and CSS\n  // classes.\n  function runMode(cm, text, mode, state, f, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    if (text == "" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = mode.token(stream, state);\n      }\n      if (cm.options.addModeClass) {\n        var mName = CodeMirror.innerMode(mode, state).mode.name;\n        if (mName) style = "m-" + (style ? mName + " " + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        if (curStart < stream.start) f(stream.start, curStyle);\n        curStart = stream.start; curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen];\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = cur ? cur + " " + style : style;\n          }\n        }\n      });\n    }\n\n    return st;\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen)\n      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == "" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n      mode.token(stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, builder) {\n    if (!style) return null;\n    for (;;) {\n      var lineClass = style.match(/(?:^|\\s)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? "bgClass" : "textClass";\n      if (builder[prop] == null)\n        builder[prop] = lineClass[2];\n      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(builder[prop]))\n        builder[prop] += " " + lineClass[2];\n    }\n    var cache = builder.cm.options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = "cm-" + style.replace(/ +/g, " cm-"));\n  }\n\n  function buildLineContent(cm, realLine, measure, copyWidgets) {\n    var merged, line = realLine, empty = true;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(cm.doc, merged.find().from.line);\n\n    var builder = {pre: elt("pre"), col: 0, pos: 0,\n                   measure: null, measuredSomething: false, cm: cm,\n                   copyWidgets: copyWidgets};\n\n    do {\n      if (line.text) empty = false;\n      builder.measure = line == realLine && measure;\n      builder.pos = 0;\n      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n      if ((old_ie || webkit) && cm.getOption("lineWrapping"))\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      var next = insertLineContent(line, builder, getLineStyles(cm, line));\n      if (measure && line == realLine && !builder.measuredSomething) {\n        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n        builder.measuredSomething = true;\n      }\n      if (next) line = getLine(cm.doc, next.to.line);\n    } while (next);\n\n    if (measure && !builder.measuredSomething && !measure[0])\n      measure[0] = builder.pre.appendChild(empty ? elt("span", "\\u00a0") : zeroWidthElement(cm.display.measure));\n    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))\n      builder.pre.appendChild(document.createTextNode("\\u00a0"));\n\n    var order;\n    // Work around problem with the reported dimensions of single-char\n    // direction spans on IE (issue #1129). See also the comment in\n    // cursorCoords.\n    if (measure && ie && (order = getOrder(line))) {\n      var l = order.length - 1;\n      if (order[l].from == order[l].to) --l;\n      var last = order[l], prev = order[l - 1];\n      if (last.from + 1 == last.to && prev && last.level < prev.level) {\n        var span = measure[builder.pos - 1];\n        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),\n                                               span.nextSibling);\n      }\n    }\n\n    var textClass = builder.textClass ? builder.textClass + " " + (realLine.textClass || "") : realLine.textClass;\n    if (textClass) builder.pre.className = textClass;\n\n    signal(cm, "renderLine", cm, realLine, builder.pre);\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt("span", "\\u2022", "cm-invalidchar");\n    token.title = "\\\\u" + ch.charCodeAt(0).toString(16);\n    return token;\n  }\n\n  function buildToken(builder, text, style, startStyle, endStyle, title) {\n    if (!text) return;\n    var special = builder.cm.options.specialChars;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n          builder.col += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == "\\t") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));\n          builder.col += tabWidth;\n        } else {\n          var token = builder.cm.options.specialCharPlaceholder(m[0]);\n          content.appendChild(token);\n          builder.col += 1;\n        }\n      }\n    }\n    if (style || startStyle || endStyle || builder.measure) {\n      var fullStyle = style || "";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt("span", [content], fullStyle);\n      if (title) token.title = title;\n      return builder.pre.appendChild(token);\n    }\n    builder.pre.appendChild(content);\n  }\n\n  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n    var wrapping = builder.cm.options.lineWrapping;\n    for (var i = 0; i < text.length; ++i) {\n      var start = i == 0, to = i + 1;\n      while (to < text.length && isExtendingChar(text.charAt(to))) ++to;\n      var ch = text.slice(i, to);\n      i = to - 1;\n      if (i && wrapping && spanAffectsWrapping(text, i))\n        builder.pre.appendChild(elt("wbr"));\n      var old = builder.measure[builder.pos];\n      var span = builder.measure[builder.pos] =\n        buildToken(builder, ch, style,\n                   start && startStyle, i == text.length - 1 && endStyle);\n      if (old) span.leftSide = old.leftSide || old;\n      // In IE single-space nodes wrap differently than spaces\n      // embedded in larger text nodes, except when set to\n      // white-space: normal (issue #1268).\n      if (old_ie && wrapping && ch == " " && i && !/\\s/.test(text.charAt(i - 1)) &&\n          i < text.length - 1 && !/\\s/.test(text.charAt(i + 1)))\n        span.style.whiteSpace = "normal";\n      builder.pos += ch.length;\n    }\n    if (text.length) builder.measuredSomething = true;\n  }\n\n  function buildTokenSplitSpaces(inner) {\n    function split(old) {\n      var out = " ";\n      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\\u00a0";\n      out += " ";\n      return out;\n    }\n    return function(builder, text, style, startStyle, endStyle, title) {\n      return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.replacedWith;\n    if (widget) {\n      if (builder.copyWidgets) widget = widget.cloneNode(true);\n      builder.pre.appendChild(widget);\n      if (builder.measure) {\n        if (size) {\n          builder.measure[builder.pos] = widget;\n        } else {\n          var elt = zeroWidthElement(builder.cm.display.measure);\n          if (marker.type == "bookmark" && !marker.insertLeft)\n            builder.measure[builder.pos] = builder.pre.appendChild(elt);\n          else if (builder.measure[builder.pos])\n            return;\n          else\n            builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);\n        }\n        builder.measuredSomething = true;\n      }\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = "", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = "";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }\n            if (m.className) spanStyle += " " + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == "bookmark" && sp.from == pos && m.replacedWith) foundBookmarks.push(m);\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return collapsed.marker.find();\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = "";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, "change", line, change);\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // First adjust the line structure\n    if (from.ch == 0 && to.ch == 0 && lastText == "" &&\n        (!doc.cm || doc.cm.options.wholeLineUpdateBefore)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)\n          added.push(new Line(text[i], spansFor(i), estimateHeight));\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, "change", doc, change);\n    setSelection(doc, selAfter.anchor, selAfter.head, null, true);\n  }\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, "delete");\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.history = makeHistory();\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n\n    if (typeof text == "string") text = splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || "\\n");\n    },\n    setValue: function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: splitLines(code), origin: "setValue"},\n                 {head: top, anchor: top}, true);\n    },\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || "\\n");\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n    setLine: function(line, text) {\n      if (isLine(this, line))\n        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));\n    },\n    removeLine: function(line) {\n      if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));\n      else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));\n    },\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == "number") line = getLine(this, line);\n      return visualLine(this, line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var sel = this.sel, pos;\n      if (start == null || start == "head") pos = sel.head;\n      else if (start == "anchor") pos = sel.anchor;\n      else if (start == "end" || start === false) pos = sel.to;\n      else pos = sel.from;\n      return copyPos(pos);\n    },\n    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},\n\n    setCursor: docOperation(function(line, ch, extend) {\n      var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);\n      if (extend) extendSelection(this, pos);\n      else setSelection(this, pos, pos);\n    }),\n    setSelection: docOperation(function(anchor, head, bias) {\n      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);\n    }),\n    extendSelection: docOperation(function(from, to, bias) {\n      extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);\n    }),\n\n    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},\n    replaceSelection: function(code, collapse, origin) {\n      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || "around");\n    },\n    undo: docOperation(function() {makeChangeFromHistory(this, "undo");}),\n    redo: docOperation(function() {makeChangeFromHistory(this, "redo");}),\n\n    setExtending: function(val) {this.sel.extend = val;},\n\n    historySize: function() {\n      var hist = this.history;\n      return {undo: hist.done.length, redo: hist.undone.length};\n    },\n    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = makeHistory(this.history.maxGeneration);\n      hist.done = histData.done.slice(0);\n      hist.undone = histData.undone.slice(0);\n    },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, "bookmark");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,\n                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = makeHistory();\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;}\n  });\n\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // The Doc methods that should be available on CodeMirror instances\n  var dontDelegate = "iter insert remove copy getEditor".split(" ");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error("This document is already in use.");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) computeMaxLength(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  function getLine(chunk, n) {\n    n -= chunk.first;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n  function heightAtLine(cm, lineObj) {\n    lineObj = visualLine(cm.doc, lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function makeHistory(startGen) {\n    return {\n      // Arrays of history events. Doing something adds an event to\n      // done and clears undo. Undoing moves events from done to\n      // undone, redoing moves them in the other direction.\n      done: [], undone: [], undoDepth: Infinity,\n      // Used to track when changes can be merged into a single undo\n      // event\n      lastTime: 0, lastOp: null, lastOrigin: null,\n      // Used by the isClean() method\n      generation: startGen || 1, maxGeneration: startGen || 1\n    };\n  }\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change["spans_" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  function historyChangeFromChange(doc, change) {\n    var from = { line: change.from.line, ch: change.from.ch };\n    var histChange = {from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  function addToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur = lst(hist.done);\n\n    if (cur &&\n        (hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == "*"))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;\n    } else {\n      // Can not be merged, start a new event.\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation,\n             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,\n             anchorAfter: selAfter.anchor, headAfter: selAfter.head};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth)\n        hist.done.shift();\n    }\n    hist.generation = ++hist.maxGeneration;\n    hist.lastTime = time;\n    hist.lastOp = opId;\n    hist.lastOrigin = change.origin;\n  }\n\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  function getOldSpans(doc, change) {\n    var found = change["spans_" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i], changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,\n                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSel(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }\n        if (to < cur.from.line) {\n          cur.from.line += diff;\n          cur.to.line += diff;\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!sub.copied) {\n        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);\n        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);\n        sub.copied = true;\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      } else {\n        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);\n        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT OPERATORS\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  function on(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent("on" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent("on" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  }\n\n  var delayedCallbacks, delayedCallbackDepth = 0;\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    if (!delayedCallbacks) {\n      ++delayedCallbackDepth;\n      delayedCallbacks = [];\n      setTimeout(fireDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      delayedCallbacks.push(bnd(arr[i]));\n  }\n\n  function signalDOMEvent(cm, e, override) {\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function fireDelayed() {\n    --delayedCallbackDepth;\n    var delayed = delayedCallbacks;\n    delayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;\n\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {\n      if (string.charAt(i) == "\\t") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n  CodeMirror.countColumn = countColumn;\n\n  var spaceStrs = [""];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + " ");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else {\n      // Suppress mysterious IE10 errors\n      try { node.select(); }\n      catch(_e) {}\n    }\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  function createObj(base, props) {\n    function Obj() {}\n    Obj.prototype = base;\n    var inst = new Obj();\n    if (props) copyObj(props, inst);\n    return inst;\n  }\n\n  function copyObj(obj, target) {\n    if (!target) target = {};\n    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n    return target;\n  }\n\n  function emptyArray(size) {\n    for (var a = [], i = 0; i < size; ++i) a.push(undefined);\n    return a;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch > "\\x80" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == "string") setTextContent(e, content);\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = "";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  function getRect(node) {\n    return node.getBoundingClientRect();\n  }\n  CodeMirror.replaceGetRect = function(f) { getRect = f; };\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return "draggable" in div || "dragDrop" in div;\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of tests matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  function spanAffectsWrapping() { return false; }\n  if (gecko) // Only for "$'"\n    spanAffectsWrapping = function(str, i) {\n      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;\n    };\n  else if (safari && !/Version\\/([6-9]|\\d\\d)\\b/.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      return /\\-[^ \\-?]|\\?[^ !\\'\\"\\),.\\-\\/:;\\?\\]\\}]/.test(str.slice(i - 1, i + 1));\n    };\n  else if (webkit && /Chrome\\/(?:29|[3-9]\\d|\\d\\d\\d)\\./.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      var code = str.charCodeAt(i - 1);\n      return code >= 8208 && code <= 8212;\n    };\n  else if (webkit)\n    spanAffectsWrapping = function(str, i) {\n      if (i > 1 && str.charCodeAt(i - 1) == 45) {\n        if (/\\w/.test(str.charAt(i - 2)) && /[^\\-?\\.]/.test(str.charAt(i))) return true;\n        if (i > 2 && /[\\d\\.,]/.test(str.charAt(i - 2)) && /[\\d\\.,]/.test(str.charAt(i))) return false;\n      }\n      return /[~!#%&*)=+}\\]\\\\|\\"\\.>,:;][({[<]|-[^\\-?\\.\\u2010-\\u201f\\u2026]|\\?[\\w~`@#$%\\^&*(_=+{[|><]|\\u2026[\\w~`@#$%\\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));\n    };\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt("span", "\\u200b");\n      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n    }\n    if (zwspSupported) return elt("span", "\\u200b");\n    else return elt("span", "\\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");\n  }\n\n  // See if "".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf("\\n", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);\n      var rt = line.indexOf("\\r");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints("StartToEnd", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt("div");\n    if ("oncopy" in e) return true;\n    e.setAttribute("oncopy", "return;");\n    return typeof e.oncopy == 'function';\n  })();\n\n  // KEY NAMING\n\n  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",\n                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",\n                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",\n                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",\n                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\\\",\n                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",\n                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, "ltr");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, "ltr");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(cm.doc, line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line;\n    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))\n      lineN = merged.find().to.line;\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN, ch);\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is somewhat involved. It is needed in order to move\n  // 'visually' through bi-directional text -- i.e., pressing left\n  // should make the cursor go left, even when in RTL text. The\n  // tricky part is the 'jumps', where RTL and LTR text touch each\n  // other. This often requires the cursor offset to move more than\n  // one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";\n    function charType(code) {\n      if (code <= 0xff) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return "R";\n      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);\n      else if (0x700 <= code && code <= 0x8ac) return "r";\n      else return "L";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = "L";\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == "m") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == "1" && cur == "r") types[i] = "n";\n        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";\n        else if (type == "," && prev == types[i+1] &&\n                 (prev == "1" || prev == "n")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == ",") types[i] = "N";\n        else if (type == "%") {\n          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}\n          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == "L" && type == "1") types[i] = "L";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == "L";\n          var after = (end < len ? types[end] : outerType) == "L";\n          var replace = before || after ? "L" : "R";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push({from: start, to: i, level: 0});\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != "L"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, {from: nstart, to: j, level: 2});\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift({from: 0, to: m[0].length, level: 0});\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push({from: len - m[0].length, to: len, level: 0});\n      }\n      if (order[0].level != lst(order).level)\n        order.push({from: len, to: len, level: order[0].level});\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = "3.21.0";\n\n  return CodeMirror;\n})();\n\n\n\n\n\n\n\n\nCodeMirror.defineMode("sql", function(config, parserConfig) {\n  "use strict";\n\n  var client         = parserConfig.client || {},\n      atoms          = parserConfig.atoms || {"false": true, "true": true, "null": true},\n      builtin        = parserConfig.builtin || {},\n      keywords       = parserConfig.keywords || {},\n      operatorChars  = parserConfig.operatorChars || /^[*+\\-%<>!=&|~^]/,\n      support        = parserConfig.support || {},\n      hooks          = parserConfig.hooks || {},\n      dateSQL        = parserConfig.dateSQL || {"date" : true, "time" : true, "timestamp" : true};\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n\n    // call hooks from the mime type\n    if (hooks[ch]) {\n      var result = hooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n\n    if (support.hexNumber == true &&\n      ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/))\n      || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {\n      // hex\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html\n      return "number";\n    } else if (support.binaryNumber == true &&\n      (((ch == "b" || ch == "B") && stream.match(/^'[01]+'/))\n      || (ch == "0" && stream.match(/^b[01]+/)))) {\n      // bitstring\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html\n      return "number";\n    } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {\n      // numbers\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html\n          stream.match(/^[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/);\n      support.decimallessFloat == true && stream.eat('.');\n      return "number";\n    } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {\n      // placeholders\n      return "variable-3";\n    } else if (ch == "'" || (ch == '"' && support.doubleQuote)) {\n      // strings\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html\n      state.tokenize = tokenLiteral(ch);\n      return state.tokenize(stream, state);\n    } else if ((((support.nCharCast == true && (ch == "n" || ch == "N"))\n        || (support.charsetCast == true && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)))\n        && (stream.peek() == "'" || stream.peek() == '"'))) {\n      // charset casting: _utf8'str', N'str', n'str'\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html\n      return "keyword";\n    } else if (/^[\\(\\),\\;\\[\\]]/.test(ch)) {\n      // no highlightning\n      return null;\n    } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {\n      // 1-line comment\n      stream.skipToEnd();\n      return "comment";\n    } else if ((support.commentHash && ch == "#")\n        || (ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" ")))) {\n      // 1-line comments\n      // ref: https://kb.askmonty.org/en/comment-syntax/\n      stream.skipToEnd();\n      return "comment";\n    } else if (ch == "/" && stream.eat("*")) {\n      // multi-line comments\n      // ref: https://kb.askmonty.org/en/comment-syntax/\n      state.tokenize = tokenComment;\n      return state.tokenize(stream, state);\n    } else if (ch == ".") {\n      // .1 for 0.1\n      if (support.zerolessFloat == true && stream.match(/^(?:\\d+(?:e[+-]?\\d+)?)/i)) {\n        return "number";\n      }\n      // .table_name (ODBC)\n      // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html\n      if (support.ODBCdotTable == true && stream.match(/^[a-zA-Z_]+/)) {\n        return "variable-2";\n      }\n    } else if (operatorChars.test(ch)) {\n      // operators\n      stream.eatWhile(operatorChars);\n      return null;\n    } else if (ch == '{' &&\n        (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {\n      // dates (weird ODBC syntax)\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html\n      return "number";\n    } else {\n      stream.eatWhile(/^[_\\w\\d]/);\n      var word = stream.current().toLowerCase();\n      // dates (standard SQL syntax)\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html\n      if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))\n        return "number";\n      if (atoms.hasOwnProperty(word)) return "atom";\n      if (builtin.hasOwnProperty(word)) return "builtin";\n      if (keywords.hasOwnProperty(word)) return "keyword";\n      if (client.hasOwnProperty(word)) return "string-2";\n      return null;\n    }\n  }\n\n  // 'string', with char specified in quote escaped by '\\'\n  function tokenLiteral(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      return "string";\n    };\n  }\n  function tokenComment(stream, state) {\n    while (true) {\n      if (stream.skipTo("*")) {\n        stream.next();\n        if (stream.eat("/")) {\n          state.tokenize = tokenBase;\n          break;\n        }\n      } else {\n        stream.skipToEnd();\n        break;\n      }\n    }\n    return "comment";\n  }\n\n  function pushContext(stream, state, type) {\n    state.context = {\n      prev: state.context,\n      indent: stream.indentation(),\n      col: stream.column(),\n      type: type\n    };\n  }\n\n  function popContext(state) {\n    state.indent = state.context.indent;\n    state.context = state.context.prev;\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: tokenBase, context: null};\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (state.context && state.context.align == null)\n          state.context.align = false;\n      }\n      if (stream.eatSpace()) return null;\n\n      var style = state.tokenize(stream, state);\n      if (style == "comment") return style;\n\n      if (state.context && state.context.align == null)\n        state.context.align = true;\n\n      var tok = stream.current();\n      if (tok == "(")\n        pushContext(stream, state, ")");\n      else if (tok == "[")\n        pushContext(stream, state, "]");\n      else if (state.context && state.context.type == tok)\n        popContext(state);\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context;\n      if (!cx) return 0;\n      var closing = textAfter.charAt(0) == cx.type;\n      if (cx.align) return cx.col + (closing ? 0 : 1);\n      else return cx.indent + (closing ? 0 : config.indentUnit);\n    },\n\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : null\n  };\n});\n\n(function() {\n  "use strict";\n\n  // `identifier`\n  function hookIdentifier(stream) {\n    // MySQL/MariaDB identifiers\n    // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html\n    var ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == "`" && !stream.eat("`")) return "variable-2";\n    }\n    return null;\n  }\n\n  // variable token\n  function hookVar(stream) {\n    // variables\n    // @@prefix.varName @varName\n    // varName can be quoted with ` or ' or "\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html\n    if (stream.eat("@")) {\n      stream.match(/^session\\./);\n      stream.match(/^local\\./);\n      stream.match(/^global\\./);\n    }\n\n    if (stream.eat("'")) {\n      stream.match(/^.*'/);\n      return "variable-2";\n    } else if (stream.eat('"')) {\n      stream.match(/^.*"/);\n      return "variable-2";\n    } else if (stream.eat("`")) {\n      stream.match(/^.*`/);\n      return "variable-2";\n    } else if (stream.match(/^[0-9a-zA-Z$\\.\\_]+/)) {\n      return "variable-2";\n    }\n    return null;\n  };\n\n  // short client keyword token\n  function hookClient(stream) {\n    // \\N means NULL\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html\n    if (stream.eat("N")) {\n        return "atom";\n    }\n    // \\g, etc\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html\n    return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;\n  }\n\n  // these keywords are used by all SQL dialects (however, a mode can still overwrite it)\n  var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from having in insert into is join like not on or order select set table union update values where ";\n\n  // turn a space-separated list into an array\n  function set(str) {\n    var obj = {}, words = str.split(" ");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  // A generic SQL Mode. It's not a standard, it just try to support what is generally supported\n  CodeMirror.defineMIME("text/x-sql", {\n    name: "sql",\n    keywords: set(sqlKeywords + "begin"),\n    builtin: set("bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")\n  });\n\n  CodeMirror.defineMIME("text/x-mssql", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered"),\n    builtin: set("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=]/,\n    dateSQL: set("date datetimeoffset datetime2 smalldatetime datetime time"),\n    hooks: {\n      "@":   hookVar\n    }\n  });\n\n  CodeMirror.defineMIME("text/x-mysql", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group groupby_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),\n    builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=&|^]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),\n    hooks: {\n      "@":   hookVar,\n      "`":   hookIdentifier,\n      "\\\\":  hookClient\n    }\n  });\n\n  CodeMirror.defineMIME("text/x-mariadb", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),\n    builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=&|^]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),\n    hooks: {\n      "@":   hookVar,\n      "`":   hookIdentifier,\n      "\\\\":  hookClient\n    }\n  });\n\n  // the query language used by Apache Cassandra is called CQL, but this mime type\n  // is called Cassandra to avoid confusion with Contextual Query Language\n  CodeMirror.defineMIME("text/x-cassandra", {\n    name: "sql",\n    client: { },\n    keywords: set("use select from using consistency where limit first reversed first and in insert into values using consistency ttl update set delete truncate begin batch apply create keyspace with columnfamily primary key index on drop alter type add any one quorum all local_quorum each_quorum"),\n    builtin: set("ascii bigint blob boolean counter decimal double float int text timestamp uuid varchar varint"),\n    atoms: set("false true"),\n    operatorChars: /^[<>=]/,\n    dateSQL: { },\n    support: set("commentSlashSlash decimallessFloat"),\n    hooks: { }\n  });\n\n  // this is based on Peter Raganitsch's 'plsql' mode\n  CodeMirror.defineMIME("text/x-plsql", {\n    name:       "sql",\n    client:     set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),\n    keywords:   set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),\n    builtin:    set("abs acos add_months ascii asin atan atan2 average bfile bfilename bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least lenght lenghtb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid upper user userenv varchar varchar2 variance varying vsize xml"),\n    operatorChars: /^[*+\\-%<>!=~]/,\n    dateSQL:    set("date time timestamp"),\n    support:    set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")\n  });\n}());\n\n/*\n  How Properties of Mime Types are used by SQL Mode\n  =================================================\n\n  keywords:\n    A list of keywords you want to be highlighted.\n  functions:\n    A list of function names you want to be highlighted.\n  builtin:\n    A list of builtin types you want to be highlighted (if you want types to be of class "builtin" instead of "keyword").\n  operatorChars:\n    All characters that must be handled as operators.\n  client:\n    Commands parsed and executed by the client (not the server).\n  support:\n    A list of supported syntaxes which are not common, but are supported by more than 1 DBMS.\n    * ODBCdotTable: .tableName\n    * zerolessFloat: .1\n    * doubleQuote\n    * nCharCast: N'string'\n    * charsetCast: _utf8'string'\n    * commentHash: use # char for comments\n    * commentSlashSlash: use // for comments\n    * commentSpaceRequired: require a space after -- for comments\n  atoms:\n    Keywords that must be highlighted as atoms,. Some DBMS's support more atoms than others:\n    UNKNOWN, INFINITY, UNDERFLOW, NaN...\n  dateSQL:\n    Used for date/time SQL standard syntax, because not all DBMS's support same temporal types.\n*/\n\n\n\n\n\n\n\n\n// TODO actually recognize syntax of TypeScript constructs\n\nCodeMirror.defineMode("javascript", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonMode = parserConfig.json;\n  var isTS = parserConfig.typescript;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: "keyword"};}\n    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");\n    var operator = kw("operator"), atom = {type: "atom", style: "atom"};\n\n    var jsKeywords = {\n      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,\n      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,\n      "var": kw("var"), "const": kw("var"), "let": kw("var"),\n      "function": kw("function"), "catch": kw("catch"),\n      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),\n      "in": operator, "typeof": operator, "instanceof": operator,\n      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,\n      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),\n      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: "variable", style: "variable-3"};\n      var tsKeywords = {\n        // object-like things\n        "interface": kw("interface"),\n        "extends": kw("extends"),\n        "constructor": kw("constructor"),\n\n        // scope modifiers\n        "public": kw("public"),\n        "private": kw("private"),\n        "protected": kw("protected"),\n        "static": kw("static"),\n\n        // types\n        "string": type, "number": type, "bool": type, "any": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == "/" && !inSet) return;\n        if (next == "[") inSet = true;\n        else if (inSet && next == "]") inSet = false;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '"' || ch == "'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "." && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret("number", "number");\n    } else if (ch == "." && stream.match("..")) {\n      return ret("spread", "meta");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == "=" && stream.eat(">")) {\n      return ret("=>", "operator");\n    } else if (ch == "0" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret("number", "number");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret("number", "number");\n    } else if (ch == "/") {\n      if (stream.eat("*")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat("/")) {\n        stream.skipToEnd();\n        return ret("comment", "comment");\n      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||\n               state.lastType == "sof" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla\n        return ret("regexp", "string-2");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret("operator", "operator", stream.current());\n      }\n    } else if (ch == "`") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == "#") {\n      stream.skipToEnd();\n      return ret("error", "error");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret("operator", "operator", stream.current());\n    } else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :\n                     ret("variable", "variable", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == "\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == "/" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ret("comment", "comment");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n    return ret("quasi", "string-2", stream.current());\n  }\n\n  var brackets = "([{}])";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf("=>", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (/[$\\w]/.test(ch)) {\n        sawSomething = true;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty("align"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == "variable" && inScope(state, content)) return "variable-2";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = "def";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: "this", next: {name: "arguments"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == "stat") indent = state.lexical.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == ")")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function(type) {\n      if (type == wanted) return cont();\n      else if (wanted == ";") return pass();\n      else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type, value) {\n    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);\n    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);\n    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);\n    if (type == "{") return cont(pushlex("}"), block, poplex);\n    if (type == ";") return cont();\n    if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);\n    if (type == "function") return cont(functiondef);\n    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);\n    if (type == "variable") return cont(pushlex("stat"), maybelabel);\n    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),\n                                      block, poplex, poplex);\n    if (type == "case") return cont(expression, expect(":"));\n    if (type == "default") return cont(expect(":"));\n    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),\n                                     statement, poplex, popcontext);\n    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);\n    if (type == "class") return cont(pushlex("form"), className, objlit, poplex);\n    if (type == "export") return cont(pushlex("form"), afterExport, poplex);\n    if (type == "import") return cont(pushlex("form"), afterImport, poplex);\n    return pass(pushlex("stat"), expression, expect(";"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);\n      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == "function") return cont(functiondef);\n    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);\n    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);\n    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);\n    if (type == "{") return contCommasep(objprop, "}", null, maybeop);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == ",") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == "operator") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == "?") return cont(expression, expect(":"), expr);\n      return cont(expr);\n    }\n    if (type == "quasi") { cx.cc.push(me); return quasi(value); }\n    if (type == ";") return;\n    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);\n    if (type == ".") return cont(property, me);\n    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);\n  }\n  function quasi(value) {\n    if (value.slice(value.length - 2) != "${") return cont();\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == "}") {\n      cx.marked = "string-2";\n      cx.state.tokenize = tokenQuasi;\n      return cont();\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == "{") return pass(statement);\n    return pass(expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == "{") return pass(statement);\n    return pass(expressionNoComma);\n  }\n  function maybelabel(type) {\n    if (type == ":") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(";"), poplex);\n  }\n  function property(type) {\n    if (type == "variable") {cx.marked = "property"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == "variable") {\n      cx.marked = "property";\n      if (value == "get" || value == "set") return cont(getterSetter);\n    } else if (type == "number" || type == "string") {\n      cx.marked = type + " property";\n    } else if (type == "[") {\n      return cont(expression, expect("]"), afterprop);\n    }\n    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);\n  }\n  function getterSetter(type) {\n    if (type != "variable") return pass(afterprop);\n    cx.marked = "property";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == ":") return cont(expressionNoComma);\n    if (type == "(") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == ",") {\n        var lex = cx.state.lexical;\n        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == "}") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == ":") return cont(typedef);\n  }\n  function typedef(type) {\n    if (type == "variable"){cx.marked = "variable-3"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == "variable") { register(value); return cont(); }\n    if (type == "[") return contCommasep(pattern, "]");\n    if (type == "{") return contCommasep(proppattern, "}");\n  }\n  function proppattern(type, value) {\n    if (type == "variable" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == "variable") cx.marked = "property";\n    return cont(expect(":"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == "=") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == ",") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);\n  }\n  function forspec1(type) {\n    if (type == "var") return cont(vardef, expect(";"), forspec2);\n    if (type == ";") return cont(forspec2);\n    if (type == "variable") return cont(formaybeinof);\n    return pass(expression, expect(";"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == ";") return cont(forspec3);\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }\n    return pass(expression, expect(";"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != ")") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}\n    if (type == "variable") {register(value); return cont(functiondef);}\n    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == "spread") return cont(funarg);\n    return pass(pattern, maybetype);\n  }\n  function className(type, value) {\n    if (type == "variable") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(_type, value) {\n    if (value == "extends") return cont(expression);\n  }\n  function objlit(type) {\n    if (type == "{") return contCommasep(objprop, "}");\n  }\n  function afterModule(type, value) {\n    if (type == "string") return cont(statement);\n    if (type == "variable") { register(value); return cont(maybeFrom); }\n  }\n  function afterExport(_type, value) {\n    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }\n    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == "string") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == "{") return contCommasep(importSpec, "}");\n    if (type == "variable") register(value);\n    return cont();\n  }\n  function maybeFrom(_type, value) {\n    if (value == "from") { cx.marked = "keyword"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == "]") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == "for") return pass(comprehension, expect("]"));\n    if (type == ",") return cont(commasep(expressionNoComma, "]"));\n    return pass(commasep(expressionNoComma, "]"));\n  }\n  function comprehension(type) {\n    if (type == "for") return cont(forspec, comprehension);\n    if (type == "if") return cont(expression, comprehension);\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: "sof",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty("align"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == "comment") return style;\n      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;\n      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);\n      else if (type == "form" && firstChar == "{") return lexical.indented;\n      else if (type == "form") return lexical.indented + indentUnit;\n      else if (type == "stat")\n        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);\n      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: ":{}",\n    blockCommentStart: jsonMode ? null : "/*",\n    blockCommentEnd: jsonMode ? null : "*/",\n    lineComment: jsonMode ? null : "//",\n    fold: "brace",\n\n    helperType: jsonMode ? "json" : "javascript",\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.defineMIME("text/javascript", "javascript");\nCodeMirror.defineMIME("text/ecmascript", "javascript");\nCodeMirror.defineMIME("application/javascript", "javascript");\nCodeMirror.defineMIME("application/ecmascript", "javascript");\nCodeMirror.defineMIME("application/json", {name: "javascript", json: true});\nCodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});\nCodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });\nCodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });\n\n\n\n\n\n\n        \n        \n        \nCodeMirror.defineMode("xml", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;\n  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag || true;\n\n  var Kludges = parserConfig.htmlMode ? {\n    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                      'track': true, 'wbr': true},\n    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                       'th': true, 'tr': true},\n    contextGrabbers: {\n      'dd': {'dd': true, 'dt': true},\n      'dt': {'dd': true, 'dt': true},\n      'li': {'li': true},\n      'option': {'option': true, 'optgroup': true},\n      'optgroup': {'optgroup': true},\n      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n      'rp': {'rp': true, 'rt': true},\n      'rt': {'rp': true, 'rt': true},\n      'tbody': {'tbody': true, 'tfoot': true},\n      'td': {'td': true, 'th': true},\n      'tfoot': {'tbody': true},\n      'th': {'td': true, 'th': true},\n      'thead': {'tbody': true, 'tfoot': true},\n      'tr': {'tr': true}\n    },\n    doNotIndent: {"pre": true},\n    allowUnquoted: true,\n    allowMissing: true\n  } : {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false\n  };\n  var alignCDATA = parserConfig.alignCDATA;\n\n  // Return variables for tokenizers\n  var tagName, type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == "<") {\n      if (stream.eat("!")) {\n        if (stream.eat("[")) {\n          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));\n          else return null;\n        } else if (stream.match("--")) {\n          return chain(inBlock("comment", "-->"));\n        } else if (stream.match("DOCTYPE", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat("?")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock("meta", "?>");\n        return "meta";\n      } else {\n        var isClose = stream.eat("/");\n        tagName = "";\n        var c;\n        while ((c = stream.eat(/[^\\s\\u00a0=<>\\"\\'\\/?]/))) tagName += c;\n        if (!tagName) return "tag error";\n        type = isClose ? "closeTag" : "openTag";\n        state.tokenize = inTag;\n        return "tag";\n      }\n    } else if (ch == "&") {\n      var ok;\n      if (stream.eat("#")) {\n        if (stream.eat("x")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(";");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(";");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(";");\n      }\n      return ok ? "atom" : "error";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == ">" || (ch == "/" && stream.eat(">"))) {\n      state.tokenize = inText;\n      type = ch == ">" ? "endTag" : "selfcloseTag";\n      return "tag";\n    } else if (ch == "=") {\n      type = "equals";\n      return null;\n    } else if (ch == "<") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + " error" : "error";\n    } else if (/[\\'\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.eatWhile(/[^\\s\\u00a0=<>\\"\\']/);\n      return "word";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return "string";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == "<") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == ">") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return "meta";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName.toLowerCase();\n      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == "openTag") {\n      state.tagName = tagName;\n      state.tagStart = stream.column();\n      return attrState;\n    } else if (type == "closeTag") {\n      var err = false;\n      if (state.context) {\n        if (state.context.tagName != tagName) {\n          if (Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName.toLowerCase()))\n            popContext(state);\n          err = !state.context || state.context.tagName != tagName;\n        }\n      } else {\n        err = true;\n      }\n      if (err) setStyle = "error";\n      return err ? closeStateErr : closeState;\n    } else {\n      return baseState;\n    }\n  }\n  function closeState(type, _stream, state) {\n    if (type != "endTag") {\n      setStyle = "error";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = "error";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == "word") {\n      setStyle = "attribute";\n      return attrEqState;\n    } else if (type == "endTag" || type == "selfcloseTag") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == "selfcloseTag" ||\n          Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) {\n        maybePopContext(state, tagName.toLowerCase());\n      } else {\n        maybePopContext(state, tagName.toLowerCase());\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = "error";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == "equals") return attrValueState;\n    if (!Kludges.allowMissing) setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return attrState;}\n    setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: inText,\n              state: baseState,\n              indented: 0,\n              tagName: null, tagStart: null,\n              context: null};\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      tagName = type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != "comment") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == "error" ? style + " error" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        return state.stringStartCol + 1;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (multilineTagIndentPastTag)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * multilineTagIndentFactor;\n      }\n      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      if (context && /^<\\//.test(textAfter))\n        context = context.prev;\n      while (context && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return 0;\n    },\n\n    electricChars: "/",\n    blockCommentStart: "<!--",\n    blockCommentEnd: "-->",\n\n    configuration: parserConfig.htmlMode ? "html" : "xml",\n    helperType: parserConfig.htmlMode ? "html" : "xml"\n  };\n});\n\nCodeMirror.defineMIME("text/xml", "xml");\nCodeMirror.defineMIME("application/xml", "xml");\nif (!CodeMirror.mimeModes.hasOwnProperty("text/html"))\n  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});        \n        \n        \n        \n        \n        \n        \n\n\n\n// HTMLMIXED\n\nCodeMirror.defineMode("htmlmixed", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});\n  var cssMode = CodeMirror.getMode(config, "css");\n\n  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;\n  scriptTypes.push({matches: /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i,\n                    mode: CodeMirror.getMode(config, "javascript")});\n  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {\n    var conf = scriptTypesConf[i];\n    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});\n  }\n  scriptTypes.push({matches: /./,\n                    mode: CodeMirror.getMode(config, "text/plain")});\n\n  function html(stream, state) {\n    var tagName = state.htmlState.tagName;\n    var style = htmlMode.token(stream, state.htmlState);\n    if (tagName == "script" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      // Script block: mode to change to depends on type attribute\n      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\\btype\\s*=\\s*("[^"]+"|'[^']+'|\\S+)[^<]*$/i);\n      scriptType = scriptType ? scriptType[1] : "";\n      if (scriptType && /[\\"\\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);\n      for (var i = 0; i < scriptTypes.length; ++i) {\n        var tp = scriptTypes[i];\n        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {\n          if (tp.mode) {\n            state.token = script;\n            state.localMode = tp.mode;\n            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));\n          }\n          break;\n        }\n      }\n    } else if (tagName == "style" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      state.token = css;\n      state.localMode = cssMode;\n      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur[0]);\n    }\n    return style;\n  }\n  function script(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       state.localMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localMode: null, localState: null, htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.localMode, state.localState);\n      return {token: state.token, localMode: state.localMode, localState: local,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.localMode || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.localMode.indent)\n        return state.localMode.indent(state.localState, textAfter);\n      else\n        return CodeMirror.Pass;\n    },\n\n    electricChars: "/{}:",\n\n    innerMode: function(state) {\n      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n    }\n  };\n}, "xml", "javascript", "css");\n\nCodeMirror.defineMIME("text/html", "htmlmixed");\n\n\n\n\n\n\n/* 3.21 version, which hash a bug\nCodeMirror.defineMode("htmlmixed", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});\n  var cssMode = CodeMirror.getMode(config, "css");\n\n  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;\n  scriptTypes.push({matches: /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i,\n                    mode: CodeMirror.getMode(config, "javascript")});\n  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {\n    var conf = scriptTypesConf[i];\n    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});\n  }\n  scriptTypes.push({matches: /./,\n                    mode: CodeMirror.getMode(config, "text/plain")});\n\n  function html(stream, state) {\n    var tagName = state.htmlState.tagName;\n    var style = htmlMode.token(stream, state.htmlState);\n    if (tagName == "script" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      // Script block: mode to change to depends on type attribute\n      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\\btype\\s*=\\s*("[^"]+"|'[^']+'|\\S+)[^<]*$/i);\n      scriptType = scriptType ? scriptType[1] : "";\n      if (scriptType && /[\\"\\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);\n      for (var i = 0; i < scriptTypes.length; ++i) {\n        var tp = scriptTypes[i];\n        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {\n          if (tp.mode) {\n            state.token = script;\n            state.localMode = tp.mode;\n            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));\n          }\n          break;\n        }\n      }\n    } else if (tagName == "style" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      state.token = css;\n      state.localMode = cssMode;\n      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n  function script(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       state.localMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localMode: null, localState: null, htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.localMode, state.localState);\n      return {token: state.token, localMode: state.localMode, localState: local,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.localMode || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.localMode.indent)\n        return state.localMode.indent(state.localState, textAfter);\n      else\n        return CodeMirror.Pass;\n    },\n\n    innerMode: function(state) {\n      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n    }\n  };\n}, "xml", "javascript", "css");\n\nCodeMirror.defineMIME("text/html", "htmlmixed");\n\n*/\n\n\n\n\n\nCodeMirror.defineMode("css", function(config, parserConfig) {\n  "use strict";\n\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      allowNested = parserConfig.allowNested;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == "@") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("def", stream.current());\n    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {\n      return ret(null, "compare");\n    } else if (ch == "\\"" || ch == "'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "#") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("atom", "hash");\n    } else if (ch == "!") {\n      stream.match(/^\\s*\\w*/);\n      return ret("keyword", "important");\n    } else if (/\\d/.test(ch) || ch == "." && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret("number", "unit");\n    } else if (ch === "-") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret("number", "unit");\n      } else if (stream.match(/^[^-]+-/)) {\n        return ret("meta", "meta");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, "select-op");\n    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret("qualifier", "qualifier");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (ch == "u" && stream.match("rl(")) {\n      stream.backUp(1);\n      state.tokenize = tokenParenthesized;\n      return ret("property", "word");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("property", "word");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == ")") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      if (ch == quote || !escaped && quote != ")") state.tokenize = null;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\"\\']/, false))\n      state.tokenize = tokenString(")");\n    else\n      state.tokenize = null;\n    return ret(null, "(");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type) {\n    state.context = new Context(type, stream.indentation() + indentUnit, state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = "atom";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = "keyword";\n    else\n      override = "variable";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == "{") {\n      return pushContext(state, stream, "block");\n    } else if (type == "}" && state.context.prev) {\n      return popContext(state);\n    } else if (type == "@media") {\n      return pushContext(state, stream, "media");\n    } else if (type == "@font-face") {\n      return "font_face_before";\n    } else if (type && type.charAt(0) == "@") {\n      return pushContext(state, stream, "at");\n    } else if (type == "hash") {\n      override = "builtin";\n    } else if (type == "word") {\n      override = "tag";\n    } else if (type == "variable-definition") {\n      return "maybeprop";\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    } else if (type == ":") {\n      return "pseudo";\n    } else if (allowNested && type == "(") {\n      return pushContext(state, stream, "params");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == "word") {\n      if (propertyKeywords.hasOwnProperty(stream.current().toLowerCase())) {\n        override = "property";\n        return "maybeprop";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:/, false) ? "property" : "tag";\n        return "block";\n      } else {\n        override += " error";\n        return "maybeprop";\n      }\n    } else if (type == "meta") {\n      return "block";\n    } else if (!allowNested && (type == "hash" || type == "qualifier")) {\n      override = "error";\n      return "block";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == ":") return pushContext(state, stream, "prop");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");\n    if (type == "}" || type == "{") return popAndPass(type, stream, state);\n    if (type == "(") return pushContext(state, stream, "parens");\n\n    if (type == "hash" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {\n      override += " error";\n    } else if (type == "word") {\n      wordAsValue(stream);\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    }\n    return "prop";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") { override = "property"; return "maybeprop"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == ")") return popContext(state);\n    return "parens";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == "word") {\n      override = "variable-3";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.media = function(type, stream, state) {\n    if (type == "(") return pushContext(state, stream, "media_parens");\n    if (type == "}") return popAndPass(type, stream, state);\n    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");\n\n    if (type == "word") {\n      var word = stream.current().toLowerCase();\n      if (word == "only" || word == "not" || word == "and")\n        override = "keyword";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = "attribute";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = "property";\n      else\n        override = "error";\n    }\n    return state.context.type;\n  };\n\n  states.media_parens = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);\n    return states.media(type, stream, state);\n  };\n\n  states.font_face_before = function(type, stream, state) {\n    if (type == "{")\n      return pushContext(state, stream, "font_face");\n    return pass(type, stream, state);\n  };\n\n  states.font_face = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") {\n      if (!fontProperties.hasOwnProperty(stream.current().toLowerCase()))\n        override = "error";\n      else\n        override = "property";\n      return "maybeprop";\n    }\n    return "font_face";\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") override = "tag";\n    else if (type == "hash") override = "builtin";\n    return "at";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "{" || type == ";") return popAndPass(type, stream, state);\n    if (type != "variable") override = "error";\n    return "interpolation";\n  };\n\n  states.params = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") wordAsValue(stream);\n    return "params";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: "top",\n              context: new Context("top", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == "object") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.prev &&\n          (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "font_face") ||\n           ch == ")" && (cx.type == "parens" || cx.type == "params" || cx.type == "media_parens") ||\n           ch == "{" && (cx.type == "at" || cx.type == "media"))) {\n        indent = cx.indent - indentUnit;\n        cx = cx.prev;\n      }\n      return indent;\n    },\n\n    electricChars: "}",\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    fold: "brace"\n  };\n});\n\n(function() {\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i]] = true;\n    }\n    return keys;\n  }\n\n  var mediaTypes_ = [\n    "all", "aural", "braille", "handheld", "print", "projection", "screen",\n    "tty", "tv", "embossed"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    "width", "min-width", "max-width", "height", "min-height", "max-height",\n    "device-width", "min-device-width", "max-device-width", "device-height",\n    "min-device-height", "max-device-height", "aspect-ratio",\n    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",\n    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",\n    "max-color", "color-index", "min-color-index", "max-color-index",\n    "monochrome", "min-monochrome", "max-monochrome", "resolution",\n    "min-resolution", "max-resolution", "scan", "grid"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var propertyKeywords_ = [\n    "align-content", "align-items", "align-self", "alignment-adjust",\n    "alignment-baseline", "anchor-point", "animation", "animation-delay",\n    "animation-direction", "animation-duration", "animation-iteration-count",\n    "animation-name", "animation-play-state", "animation-timing-function",\n    "appearance", "azimuth", "backface-visibility", "background",\n    "background-attachment", "background-clip", "background-color",\n    "background-image", "background-origin", "background-position",\n    "background-repeat", "background-size", "baseline-shift", "binding",\n    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",\n    "bookmark-target", "border", "border-bottom", "border-bottom-color",\n    "border-bottom-left-radius", "border-bottom-right-radius",\n    "border-bottom-style", "border-bottom-width", "border-collapse",\n    "border-color", "border-image", "border-image-outset",\n    "border-image-repeat", "border-image-slice", "border-image-source",\n    "border-image-width", "border-left", "border-left-color",\n    "border-left-style", "border-left-width", "border-radius", "border-right",\n    "border-right-color", "border-right-style", "border-right-width",\n    "border-spacing", "border-style", "border-top", "border-top-color",\n    "border-top-left-radius", "border-top-right-radius", "border-top-style",\n    "border-top-width", "border-width", "bottom", "box-decoration-break",\n    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",\n    "caption-side", "clear", "clip", "color", "color-profile", "column-count",\n    "column-fill", "column-gap", "column-rule", "column-rule-color",\n    "column-rule-style", "column-rule-width", "column-span", "column-width",\n    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",\n    "cue-after", "cue-before", "cursor", "direction", "display",\n    "dominant-baseline", "drop-initial-after-adjust",\n    "drop-initial-after-align", "drop-initial-before-adjust",\n    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",\n    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",\n    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",\n    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",\n    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",\n    "font-stretch", "font-style", "font-synthesis", "font-variant",\n    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",\n    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",\n    "font-weight", "grid-cell", "grid-column", "grid-column-align",\n    "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",\n    "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",\n    "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",\n    "icon", "image-orientation", "image-rendering", "image-resolution",\n    "inline-box-align", "justify-content", "left", "letter-spacing",\n    "line-break", "line-height", "line-stacking", "line-stacking-ruby",\n    "line-stacking-shift", "line-stacking-strategy", "list-style",\n    "list-style-image", "list-style-position", "list-style-type", "margin",\n    "margin-bottom", "margin-left", "margin-right", "margin-top",\n    "marker-offset", "marks", "marquee-direction", "marquee-loop",\n    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",\n    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",\n    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",\n    "outline-color", "outline-offset", "outline-style", "outline-width",\n    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",\n    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",\n    "page", "page-break-after", "page-break-before", "page-break-inside",\n    "page-policy", "pause", "pause-after", "pause-before", "perspective",\n    "perspective-origin", "pitch", "pitch-range", "play-during", "position",\n    "presentation-level", "punctuation-trim", "quotes", "region-break-after",\n    "region-break-before", "region-break-inside", "region-fragment",\n    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",\n    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",\n    "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size",\n    "speak", "speak-as", "speak-header",\n    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",\n    "tab-size", "table-layout", "target", "target-name", "target-new",\n    "target-position", "text-align", "text-align-last", "text-decoration",\n    "text-decoration-color", "text-decoration-line", "text-decoration-skip",\n    "text-decoration-style", "text-emphasis", "text-emphasis-color",\n    "text-emphasis-position", "text-emphasis-style", "text-height",\n    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",\n    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",\n    "text-wrap", "top", "transform", "transform-origin", "transform-style",\n    "transition", "transition-delay", "transition-duration",\n    "transition-property", "transition-timing-function", "unicode-bidi",\n    "vertical-align", "visibility", "voice-balance", "voice-duration",\n    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",\n    "voice-volume", "volume", "white-space", "widows", "width", "word-break",\n    "word-spacing", "word-wrap", "z-index", "zoom",\n    // SVG-specific\n    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",\n    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",\n    "color-interpolation", "color-interpolation-filters", "color-profile",\n    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",\n    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",\n    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",\n    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",\n    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",\n    "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var colorKeywords_ = [\n    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",\n    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",\n    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",\n    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",\n    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",\n    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",\n    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",\n    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",\n    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",\n    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",\n    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",\n    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",\n    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",\n    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",\n    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",\n    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",\n    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",\n    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",\n    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",\n    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",\n    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",\n    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",\n    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",\n    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",\n    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",\n    "whitesmoke", "yellow", "yellowgreen"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    "above", "absolute", "activeborder", "activecaption", "afar",\n    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",\n    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",\n    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page",\n    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",\n    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",\n    "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel",\n    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",\n    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",\n    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",\n    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",\n    "col-resize", "collapse", "column", "compact", "condensed", "contain", "content",\n    "content-box", "context-menu", "continuous", "copy", "cover", "crop",\n    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",\n    "decimal-leading-zero", "default", "default-button", "destination-atop",\n    "destination-in", "destination-out", "destination-over", "devanagari",\n    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",\n    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",\n    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",\n    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",\n    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",\n    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",\n    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",\n    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",\n    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",\n    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",\n    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",\n    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",\n    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",\n    "help", "hidden", "hide", "higher", "highlight", "highlighttext",\n    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",\n    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",\n    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",\n    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",\n    "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer",\n    "landscape", "lao", "large", "larger", "left", "level", "lighter",\n    "line-through", "linear", "lines", "list-item", "listbox", "listitem",\n    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",\n    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",\n    "lower-roman", "lowercase", "ltr", "malayalam", "match",\n    "media-controls-background", "media-current-time-display",\n    "media-fullscreen-button", "media-mute-button", "media-play-button",\n    "media-return-to-realtime-button", "media-rewind-button",\n    "media-seek-back-button", "media-seek-forward-button", "media-slider",\n    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",\n    "media-volume-slider-container", "media-volume-sliderthumb", "medium",\n    "menu", "menulist", "menulist-button", "menulist-text",\n    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",\n    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",\n    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",\n    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",\n    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",\n    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",\n    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",\n    "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer",\n    "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",\n    "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region",\n    "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",\n    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",\n    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",\n    "searchfield-cancel-button", "searchfield-decoration",\n    "searchfield-results-button", "searchfield-results-decoration",\n    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",\n    "single", "skip-white-space", "slide", "slider-horizontal",\n    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",\n    "small", "small-caps", "small-caption", "smaller", "solid", "somali",\n    "source-atop", "source-in", "source-out", "source-over", "space", "square",\n    "square-button", "start", "static", "status-bar", "stretch", "stroke",\n    "sub", "subpixel-antialiased", "super", "sw-resize", "table",\n    "table-caption", "table-cell", "table-column", "table-column-group",\n    "table-footer-group", "table-header-group", "table-row", "table-row-group",\n    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",\n    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",\n    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",\n    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",\n    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",\n    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",\n    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",\n    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",\n    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",\n    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",\n    "xx-large", "xx-small"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var fontProperties_ = [\n    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",\n    "font-stretch", "font-weight", "font-style"\n  ], fontProperties = keySet(fontProperties_);\n\n  var allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);\n  CodeMirror.registerHelper("hintWords", "css", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == "/") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ["comment", "comment"];\n  }\n\n  function tokenSGMLComment(stream, state) {\n    if (stream.skipTo("-->")) {\n      stream.match("-->");\n      state.tokenize = null;\n    } else {\n      stream.skipToEnd();\n    }\n    return ["comment", "comment"];\n  }\n\n  CodeMirror.defineMIME("text/css", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    tokenHooks: {\n      "<": function(stream, state) {\n        if (!stream.match("!--")) return false;\n        state.tokenize = tokenSGMLComment;\n        return tokenSGMLComment(stream, state);\n      },\n      "/": function(stream, state) {\n        if (!stream.eat("*")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: "css"\n  });\n\n  CodeMirror.defineMIME("text/x-scss", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      ":": function(stream) {\n        if (stream.match(/\\s*{/))\n          return [null, "{"];\n        return false;\n      },\n      "$": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "#": function(stream) {\n        if (!stream.eat("{")) return false;\n        return [null, "interpolation"];\n      }\n    },\n    name: "css",\n    helperType: "scss"\n  });\n\n  CodeMirror.defineMIME("text/x-less", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      "@": function(stream) {\n        if (stream.match(/^(charset|document|font-face|import|keyframes|media|namespace|page|supports)\\b/, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "&": function() {\n        return ["atom", "atom"];\n      }\n    },\n    name: "css",\n    helperType: "less"\n  });\n})();\n\n\n\n\n\n\n\nCodeMirror.defineMode("sass", function(config) {\n  var tokenRegexp = function(words){\n    return new RegExp("^" + words.join("|"));\n  };\n\n  var keywords = ["true", "false", "null", "auto"];\n  var keywordsRegexp = new RegExp("^" + keywords.join("|"));\n\n  var operators = ["\\\\(", "\\\\)", "=", ">", "<", "==", ">=", "<=", "\\\\+", "-", "\\\\!=", "/", "\\\\*", "%", "and", "or", "not"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[\\w\\-]+/;\n\n  var urlTokens = function(stream, state){\n    var ch = stream.peek();\n\n    if (ch === ")"){\n      stream.next();\n      state.tokenizer = tokenBase;\n      return "operator";\n    }else if (ch === "("){\n      stream.next();\n      stream.eatSpace();\n\n      return "operator";\n    }else if (ch === "'" || ch === '"'){\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return "string";\n    }else{\n      state.tokenizer = buildStringTokenizer(")", false);\n      return "string";\n    }\n  };\n  var multilineComment = function(stream, state) {\n    if (stream.skipTo("*/")){\n      stream.next();\n      stream.next();\n      state.tokenizer = tokenBase;\n    }else {\n      stream.next();\n    }\n\n    return "comment";\n  };\n\n  var buildStringTokenizer = function(quote, greedy){\n    if(greedy == null){ greedy = true; }\n\n    function stringTokenizer(stream, state){\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== "\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== "\\\\"));\n\n      /*\n      console.log("previousChar: " + previousChar);\n      console.log("nextChar: " + nextChar);\n      console.log("peekChar: " + peekChar);\n      console.log("ending: " + endingString);\n      */\n\n      if (endingString){\n        if (nextChar !== quote && greedy) { stream.next(); }\n        state.tokenizer = tokenBase;\n        return "string";\n      }else if (nextChar === "#" && peekChar === "{"){\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return "operator";\n      }else {\n        return "string";\n      }\n    }\n\n    return stringTokenizer;\n  };\n\n  var buildInterpolationTokenizer = function(currentTokenizer){\n    return function(stream, state){\n      if (stream.peek() === "}"){\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return "operator";\n      }else{\n        return tokenBase(stream, state);\n      }\n    };\n  };\n\n  var indent = function(state){\n    if (state.indentCount == 0){\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  };\n\n  var dedent = function(state){\n    if (state.scopes.length == 1) { return; }\n\n    state.scopes.shift();\n  };\n\n  var tokenBase = function(stream, state) {\n    var ch = stream.peek();\n\n    // Single line Comment\n    if (stream.match('//')) {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Multiline Comment\n    if (stream.match('/*')){\n      state.tokenizer = multilineComment;\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match('#{')){\n    state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return "operator";\n    }\n\n    if (ch === "."){\n      stream.next();\n\n      // Match class selectors\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "atom";\n      }else if (stream.peek() === "#"){\n        indent(state);\n        return "atom";\n      }else{\n        return "operator";\n      }\n    }\n\n    if (ch === "#"){\n      stream.next();\n\n      // Hex numbers\n      if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n        return "number";\n      }\n\n      // ID selectors\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "atom";\n      }\n\n      if (stream.peek() === "#"){\n        indent(state);\n        return "atom";\n      }\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/)){\n      return "number";\n    }\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/)){\n      return "unit";\n    }\n\n    if (stream.match(keywordsRegexp)){\n      return "keyword";\n    }\n\n    if (stream.match(/^url/) && stream.peek() === "("){\n      state.tokenizer = urlTokens;\n      return "atom";\n    }\n\n    // Variables\n    if (ch === "$"){\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n\n      if (stream.peek() === ":"){\n        stream.next();\n        return "variable-2";\n      }else{\n        return "variable-3";\n      }\n    }\n\n    if (ch === "!"){\n      stream.next();\n\n      if (stream.match(/^[\\w]+/)){\n        return "keyword";\n      }\n\n      return "operator";\n    }\n\n    if (ch === "="){\n      stream.next();\n\n      // Match shortcut mixin definition\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "meta";\n      }else {\n        return "operator";\n      }\n    }\n\n    if (ch === "+"){\n      stream.next();\n\n      // Match shortcut mixin definition\n      if (stream.match(/^[\\w-]+/)){\n        return "variable-3";\n      }else {\n        return "operator";\n      }\n    }\n\n    // Indent Directives\n    if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)){\n      indent(state);\n      return "meta";\n    }\n\n    // Other Directives\n    if (ch === "@"){\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      return "meta";\n    }\n\n    // Strings\n    if (ch === '"' || ch === "'"){\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return "string";\n    }\n\n    // Pseudo element selectors\n    if (ch == ':' && stream.match(pseudoElementsRegexp)){\n      return "keyword";\n    }\n\n    // atoms\n    if (stream.eatWhile(/[\\w-&]/)){\n      // matches a property definition\n      if (stream.peek() === ":" && !stream.match(pseudoElementsRegexp, false))\n        return "property";\n      else\n        return "atom";\n    }\n\n    if (stream.match(opRegexp)){\n      return "operator";\n    }\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  };\n\n  var tokenLexer = function(stream, state) {\n    if (stream.sol()){\n      state.indentCount = 0;\n    }\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === "@return"){\n      dedent(state);\n    }\n\n    if (style === "atom"){\n      indent(state);\n    }\n\n    if (style !== null){\n      var startOfToken = stream.pos - current.length;\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++){\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent){\n          newScopes.push(scope);\n        }\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  };\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: 'sass'}],\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    }\n  };\n});\n\nCodeMirror.defineMIME("text/x-sass", "sass");\n\n\n\n\n\n\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\nCodeMirror.defineMode("coffeescript", function(conf) {\n  var ERRORCLASS = "error";\n\n  function wordRegexp(words) {\n    return new RegExp("^((" + words.join(")|(") + "))\\\\b");\n  }\n\n  var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?)/;\n  var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n  var properties = /^(@|this\\.)[_A-Za-z$][_A-Za-z$0-9]*/;\n\n  var wordOperators = wordRegexp(["and", "or", "not",\n                                  "is", "isnt", "in",\n                                  "instanceof", "typeof"]);\n  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",\n                        "switch", "try", "catch", "finally", "class"];\n  var commonKeywords = ["break", "by", "continue", "debugger", "delete",\n                        "do", "in", "of", "new", "return", "then",\n                        "this", "throw", "when", "until"];\n\n  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n  indentKeywords = wordRegexp(indentKeywords);\n\n\n  var stringPrefixes = /^('{3}|\\"{3}|['\\"])/;\n  var regexPrefixes = /^(\\/{3}|\\/)/;\n  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];\n  var constants = wordRegexp(commonConstants);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    // Handle scope changes\n    if (stream.sol()) {\n      if (state.scope.align === null) state.scope.align = false;\n      var scopeOffset = state.scope.offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset && state.scope.type == "coffee") {\n          return "indent";\n        } else if (lineOffset < scopeOffset) {\n          return "dedent";\n        }\n        return null;\n      } else {\n        if (scopeOffset > 0) {\n          dedent(stream, state);\n        }\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle docco title comment (single line)\n    if (stream.match("####")) {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Handle multi line comments\n    if (stream.match("###")) {\n      state.tokenize = longComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Single line comment\n    if (ch === "#") {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Handle number literals\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\d+\\.\\d*/)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\.\\d+/)) {\n        floatLiteral = true;\n      }\n\n      if (floatLiteral) {\n        // prevent from getting extra . on 1..\n        if (stream.peek() == "."){\n          stream.backUp(1);\n        }\n        return "number";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^-?0x[0-9a-f]+/i)) {\n        intLiteral = true;\n      }\n      // Decimal\n      if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^-?0(?![\\dx])/i)) {\n        intLiteral = true;\n      }\n      if (intLiteral) {\n        return "number";\n      }\n    }\n\n    // Handle strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenFactory(stream.current(), false, "string");\n      return state.tokenize(stream, state);\n    }\n    // Handle regex literals\n    if (stream.match(regexPrefixes)) {\n      if (stream.current() != "/" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n        state.tokenize = tokenFactory(stream.current(), true, "string-2");\n        return state.tokenize(stream, state);\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n    // Handle operators and delimiters\n    if (stream.match(operators) || stream.match(wordOperators)) {\n      return "operator";\n    }\n    if (stream.match(delimiters)) {\n      return "punctuation";\n    }\n\n    if (stream.match(constants)) {\n      return "atom";\n    }\n\n    if (stream.match(keywords)) {\n      return "keyword";\n    }\n\n    if (stream.match(identifiers)) {\n      return "variable";\n    }\n\n    if (stream.match(properties)) {\n      return "property";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function tokenFactory(delimiter, singleline, outclass) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'"\\/\\\\]/);\n        if (stream.eat("\\\\")) {\n          stream.next();\n          if (singleline && stream.eol()) {\n            return outclass;\n          }\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          return outclass;\n        } else {\n          stream.eat(/['"\\/]/);\n        }\n      }\n      if (singleline) {\n        if (conf.mode.singleLineStringErrors) {\n          outclass = ERRORCLASS;\n        } else {\n          state.tokenize = tokenBase;\n        }\n      }\n      return outclass;\n    };\n  }\n\n  function longComment(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^#]/);\n      if (stream.match("###")) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.eatWhile("#");\n    }\n    return "comment";\n  }\n\n  function indent(stream, state, type) {\n    type = type || "coffee";\n    var offset = 0, align = false, alignOffset = null;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (scope.type === "coffee") {\n        offset = scope.offset + conf.indentUnit;\n        break;\n      }\n    }\n    if (type !== "coffee") {\n      align = null;\n      alignOffset = stream.column() + stream.current().length;\n    } else if (state.scope.align) {\n      state.scope.align = false;\n    }\n    state.scope = {\n      offset: offset,\n      type: type,\n      prev: state.scope,\n      align: align,\n      alignOffset: alignOffset\n    };\n  }\n\n  function dedent(stream, state) {\n    if (!state.scope.prev) return;\n    if (state.scope.type === "coffee") {\n      var _indent = stream.indentation();\n      var matched = false;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (_indent === scope.offset) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return true;\n      }\n      while (state.scope.prev && state.scope.offset !== _indent) {\n        state.scope = state.scope.prev;\n      }\n      return false;\n    } else {\n      state.scope = state.scope.prev;\n      return false;\n    }\n  }\n\n  function tokenLexer(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle "." connected identifiers\n    if (current === ".") {\n      style = state.tokenize(stream, state);\n      current = stream.current();\n      if (/^\\.[\\w$]+$/.test(current)) {\n        return "variable";\n      } else {\n        return ERRORCLASS;\n      }\n    }\n\n    // Handle scope changes.\n    if (current === "return") {\n      state.dedent += 1;\n    }\n    if (((current === "->" || current === "=>") &&\n         !state.lambda &&\n         !stream.peek())\n        || style === "indent") {\n      indent(stream, state);\n    }\n    var delimiter_index = "[({".indexOf(current);\n    if (delimiter_index !== -1) {\n      indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));\n    }\n    if (indentKeywords.exec(current)){\n      indent(stream, state);\n    }\n    if (current == "then"){\n      dedent(stream, state);\n    }\n\n\n    if (style === "dedent") {\n      if (dedent(stream, state)) {\n        return ERRORCLASS;\n      }\n    }\n    delimiter_index = "])}".indexOf(current);\n    if (delimiter_index !== -1) {\n      while (state.scope.type == "coffee" && state.scope.prev)\n        state.scope = state.scope.prev;\n      if (state.scope.type == current)\n        state.scope = state.scope.prev;\n    }\n    if (state.dedent > 0 && stream.eol() && state.scope.type == "coffee") {\n      if (state.scope.prev) state.scope = state.scope.prev;\n      state.dedent -= 1;\n    }\n\n    return style;\n  }\n\n  var external = {\n    startState: function(basecolumn) {\n      return {\n        tokenize: tokenBase,\n        scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},\n        lastToken: null,\n        lambda: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var fillAlign = state.scope.align === null && state.scope;\n      if (fillAlign && stream.sol()) fillAlign.align = false;\n\n      var style = tokenLexer(stream, state);\n      if (fillAlign && style && style != "comment") fillAlign.align = true;\n\n      state.lastToken = {style:style, content: stream.current()};\n\n      if (stream.eol() && stream.lambda) {\n        state.lambda = false;\n      }\n\n      return style;\n    },\n\n    indent: function(state, text) {\n      if (state.tokenize != tokenBase) return 0;\n      var scope = state.scope;\n      var closer = text && "])}".indexOf(text.charAt(0)) > -1;\n      if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;\n      var closes = closer && scope.type === text.charAt(0);\n      if (scope.align)\n        return scope.alignOffset - (closes ? 1 : 0);\n      else\n        return (closes ? scope.prev : scope).offset;\n    },\n\n    lineComment: "#",\n    fold: "indent"\n  };\n  return external;\n});\n\nCodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
\\203\\223\\232eR~\\222\\376(S\\004\\352I\\352\\354\\202mE\\300\\244\\370\\253t\\366\\023\\273\\247J\\014\\230\\016\\307	var w = $("#"+id);\n/*\nTEST FKEY AUTOCOMPLETE\n\n\n\nvar from_column = 'new_row_widget_id';\n\nw.append('<p>Using column: ' + from_column + '</p>');\n\n\nendpoint.schema('semantics').table('relation').row().where({\n    row_detail_widget_id: '40cca2f6-7c35-4118-83db-031e04e4397a'\n}).result(function(row) {\n\n    w.append(widget('sem_fkey_autocomplete', { \n        from_row: row,\n        from_column: from_column,\n        to_relation: endpoint.schema('widget').table('widget'),\n        to_column: 'id',\n        label_function: function(to_row) {\n            return to_row.get('name')\n        },\n        order_by_function: function(rows) {\n            return rows.order_by({ column: 'name' });\n        },\n        new_enabled: true\n    }));\n\n});\n*/\n\nendpoint.schema('mickey').table('post').row().where({\n    name: 'words mickey says'\n}).result(function(row) {    \n    \n    w.append(widget('sem_fkey_one_to_many', { \n        from_row: row,\n        from_column: 'id',\n        to_relation: endpoint.schema('mickey').table('blah'),\n        to_column: 'post_id',\n        label_function: function(to_row) {\n            return to_row.get('name')\n        },\n        order_by_function: function(rows) {\n            return rows.order_by({ column: 'name' });\n        },\n        new_enabled: true\n    }));\n    \n});\n
\\205\\241\\237\\206\\253\\377\\252B!\\227!\\302.\\304Z\\015\\021\\333K\\313\\255\\365X\\240:,\\317F\\034e\\013B	<div id="{{= id }}" class="{{= name }}">\n    <p>url_pattern: <span class='url_pattern'></span></p>\n    <p>args: <span class='args'></span></p>\n    <button class='delete'>delete</button>\n    <button class='save'>save</button>\n</div>
\\205p\\232|\\237\\274f^\\2143cr\\202\\302(z\\007\\007\\323Q@\\244gh\\021u\\267\\3367Y\\351$	.{{= name }} {\n    margin: 0 auto;\n    padding: 1em;\n    text-align: left;\n    height: 100%;\n}\n\n.{{= name }} .hide {\n    display: none;\n}\n\n.{{= name }} > .loaded > .autocomplete {\n}\n\n.{{= name }} > .loaded > .results {\n\n    top: 0;\n    bottom:0;\n    left:0;\n    right:0;\n    \n    margin-top: 2.5em;\n    margin-bottom: 0.5em;\n    margin-right: 1em;\n    margin-left: 1em;\n\n    width: auto;\n    height: auto;\n    overflow-y: auto;\n    position: absolute;\n}\n\n.{{= name }} .autocomplete-suggestions {\n    width: 100% !important;\n}\n\n.{{= name }} .autocomplete-suggestion {\n    color: white;\n    font-size: 12px;\n    \n    margin: 0 auto;\n    padding: 3px;\n    \n    display: block;\n    width: 100%;\n}\n\n.{{= name }} .autocomplete-suggestion.autocomplete-selected {\n    background-color: #555;\n}
\\205r\\012\\013H\\025\\011\\203,\\224w5\\310SV\\034\\034\\321\\210nP\\256\\255\\301\\246\\320\\274\\342j\\245\\351\\021	<div id="{{= id }}" class="{{= name }}">\n    <h3>endpoint.resource_binary upload</h3>\n    \n    file: <input class='fileUpload' type='file'><br>\n    path: <input class='path' type='text'><br>\n    <button class='upload'>upload</button>\n</div>
\\206\\361\\224\\023\\272\\021\\370\\304\\246X\\355R\\011\\217\\272x\\354\\014d\\006\\033\\261yM\\376/\\202\\031z"{\\000	.{{= name }} {\n    font-size: 80%;\n    position: fixed;\n    top: 4ex;\n    bottom: 2ex;\n    right: 0;\n    width: 20em;\n    border: 4px dashed blue;\n    margin-top: 3ex;\n\tbackground-color:rgba(0,0,0,0.95);\n    padding: .5ex .5em .5ex .5em;\n    z-index: 100;\n}
\\210\\2433f\\355\\330\\263\\311p\\230\\333>L\\034\\360v\\205\\356\\230\\262)\\235\\311sg\\001PK\\241\\242\\3648	layout_tabbed
\\211 \\371\\246\\343\\210>\\342.\\341\\177\\013\\362\\011\\300\\303\\006y\\347\\266\\226\\375\\371\\357U\\361^\\314\\337J\\235g	bundle_untracked_row_li
\\211~g\\323x;\\310\\304\\374n\\227\\361\\366\\343\\034\\344,\\273<\\351\\266@\\371\\273\\372V\\263\\017\\265z\\367'	row_detail_meta_table
\\212\\037)\\347\\311D\\337+\\203M\\362\\203\\006\\201\\300\\360\\236\\303N$i\\235\\250\\006,\\263M\\322\\210{\\323E	var w = $('#'+id);\n\nfunction display() {\n    var val = JSON.stringify(field.value);\n    \n    if (val == null) {\n        val = 'NULL';\n    }\n    \n    else if (val == '') {\n        val = '____';\n    }\n    \n    w.find('.display').html(val);\n    w.find('input').val(val);\n    \n    w.removeClass('saving')\n    .removeClass('editing')\n    .addClass('displaying');\n    \n    //w.find('.edit input').prop('disabled', false);\n}\ndisplay();\n\nfunction edit() {\n    w.removeClass('displaying')\n    .removeClass('saving')\n    .addClass('editing');\n    w.find('input').focus();\n}\n\n\nfunction save(saving_as_null) {\n    \n    w.removeClass('displaying')\n    .removeClass('editing')\n    .addClass('saving');\n    \n    //w.find('.edit input').prop('disabled', true);\n\n    var old_value = field.value;\n\n    // save\n    if (saving_as_null) {\n        field.set(null);\n    }\n    else {\n        field.set(w.find('input').val());\n    }\n    \n    field.update().then(function() {\n        w.trigger('status', ['Saved', 'success']);\n        w.trigger('form_field_save');\n        display();\n        \n    }).catch(function(error) {\n        field.set(old_value);\n        w.trigger('status', ['Failed save', 'fail']);\n        display();\n    });\n}\n\n\n// EVENT BINDINGS\nw.find('.save').on('click', save.bind(this, false));\nw.find('.save_as_null').on('click', save.bind(this, true));\nw.find('.display').on('click', edit);\nw.find('.cancel').on('click', display);\nw.find('input').on('keyup', function(e) {\n    if (e.keyCode == 27) {\n        display();\n    }\n    if (e.keyCode == 13) {\n        save(false);\n    }\n});\n
\\212\\334\\3007|'n\\252g\\377\\032\\366M\\330\\366\\314\\367r\\372f\\217\\011!\\247p\\005\\224\\234X\\007<\\226	2bc72050-e4fc-472a-ae7e-bee1f8869c85
\\212^\\332\\262\\202c$C!\\236\\005\\036J\\336-\\035[\\274g\\034x\\020Q\\277\\0247\\211|\\275\\376\\240\\361	/
\\212w\\227\\030\\256\\254\\264W\\316\\216\\273\\330\\252\\347\\024\\304P3\\311\\007\\256m8\\177\\237_\\354#\\305M\\205\\023	.{{= name }} {\n    border: 2px dotted gray;\n    padding: 10px;\n}\n\n.{{= name }} .comparison {\n    display: none;\n}
\\213\\214l\\220G\\302\\323\\010?B\\350=\\201U\\371\\001\\322\\005^\\353^w\\325\\345\\234\\320\\347p=P\\026\\\\	7dfc33c6-9cd9-459d-b98c-e0288f9cd186
\\2146\\231\\007\\037\\244)H\\207H\\210c_MD\\\\G\\256\\305e\\226X\\317\\345\\035\\010\\277Tb\\350\\363,	.{{= name }} {\n    white-space: nowrap;\n    display: none;\n}\n\n.{{= name }} .label {\n    font-size: 90%;\n}\n\n.{{= name }} .label:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n
\\214@\\016z\\205:f+\\203_\\327\\357\\377\\322,t\\261\\0274\\310\\227\\240Qi\\347\\261'\\006\\033|\\000x	bundle_push_pull
\\215/\\224D\\311\\363\\015B\\002"$;\\262\\357\\226\\357)\\276\\213(\\275\\344\\030\\260oF/(\\363I*\\361	bf6e6451-88c6-4642-b034-2c72a83ee6ec
\\2154\\302\\267\\344\\013\\273+\\277Y1\\224M\\3332\\262l\\305\\216\\364\\361\\347\\337c\\254\\207\\246Hc\\227"\\226	6046e06d-28c5-4d25-ad3a-4470c2195323
\\215\\347\\230G\\242\\264\\231H\\313\\210GCB\\002\\272\\204\\217\\254a\\324\\3624\\230+\\314\\321.\\224uw]{	var w = $("#"+id);\n\n// inputs:\n// relation {AQ.Relation}\n\n// this widget will insert uploaded file into the given 'relation'\n// the file data will be base64 encoded and set as the 'data' column (column type must be bytea)\n// the name of the file will be saved in the 'name' column\n\nw.find('.fileUpload').on('change', function () {\n    const reader = new FileReader()\n    const file = $(this).get(0).files[0]\n    reader.onload = event => {\n        const { name, size, type } = file\n        const dataURL = event.target.result\n        const data = dataURL.replace(/^data:.+;base64,/, '')\n        relation.insert({ name, data })\n        .then(result => {\n            console.log('file saved')\n        })\n        .catch(error => {\n            alert('file upload no worky\\n' + error)\n        })\n    }\n    reader.readAsDataURL(file)\n})
\\216Tx\\232\\375\\266\\214E\\373\\224\\212\\342\\341\\262G\\011)\\030o\\217\\303\\362\\231\\327\\373\\366\\015\\013yA\\014V	573d40f7-be20-468a-8140-7d8c318b2e08
\\221DL\\343\\252?\\001\\223\\251\\213\\263\\3368\\300\\324\\376\\031\\335)\\307\\311\\223\\242\\312\\314\\317_:\\332\\3063Q	c9da1004-c2e8-4fb2-9e9e-cc34ec077c77
\\221HJ\\024.%\\0332\\330\\030\\346<\\325\\037\\245\\337\\030\\357\\177\\265\\301\\036\\031\\203\\263\\177z\\373\\023\\262v\\262	4ed34807-309b-47f0-a796-34850d9937e5
\\222&\\221\\330\\025\\037\\366\\200\\201\\311\\311D#\\212\\302o\\266$\\350\\224\\265\\273Qn\\236\\0304\\376\\236\\327P\\226	5d9aa6c9-4e3d-4295-9ddc-f0506fef2e67
\\223\\207\\244\\341hZ9\\234\\366\\2446B\\215\\262\\342D3J\\214a7\\321)\\332t\\233h\\332\\253\\375\\242c	var w = $("#"+id);\n\n\nw.find('> .tabs').html(widget('layout_tabbed', {\n    tabs: {\n        'widgets': function () {\n            return widget('debugger3_widgets', { });\n        },\n        'data': function() {\n            return widget('debugger3_data', { });\n        },\n        'users': function() {\n            return widget('debugger3_users', { });\n        },\n    },\n    tab_colors: {\n        'widgets': 'blue',\n        'data': 'blue',\n        'machines-js': 'blue'\n    } \n}));\n
\\223\\213\\231\\3433\\010\\002\\251)\\013dE+\\0330:~\\372\\224\\335\\217_\\310kl\\224\\034\\360dL\\342 	/dev
\\223\\332\\316\\223\\206)\\223\\373"\\321\\316\\210\\203\\326\\210\\343\\214\\007\\334\\301\\272\\312\\217\\277X\\005}\\270\\226\\344\\257\\275	<li id="{{= id }}" class="{{= name }}">\n    <span class='arrow'>&#10094;</span>\n    <span class='title'>{{= row.get('name') || row.get('id') }}</span>\n    <span class='empty hide'>Empty</span>\n    <div class='list'></div>\n</li>
\\223\\345v\\004\\005_=\\364\\223f\\362\\237YD\\037\\373P\\031\\364\\006e\\024\\300\\373\\301%\\021\\346_\\003\\331\\343	<tr id="{{= id }}" class="{{= name }}">\n    <td><nobr><span class='head_commit'>HEAD&#10148;</span></nobr></td>\n    <td>{{= commit.get("role_id") }}</td>\n    <td class='date'></td>\n    <td>{{= commit.get("message") }}</td>\n    <td><button class='checkout'>Check Out</button></td>\n</tr>
\\225\\235Z\\312\\234\\254\\266C\\304)\\221\\376\\011]\\245\\246\\027\\336\\267\\355\\2240\\177\\214\\202KV\\232\\356\\003\\263\\017	<select id="{{= id }}" class="{{= name }}">\n    <option>Select one.</option>\n</select>
\\226-\\234<\\\\\\203\\037\\206\\326t\\232\\310\\317\\334&\\012\\300\\375\\361\\324\\323\\265\\303|C\\003\\205S\\243k\\211T	32344c09-b6ca-4ecc-b0da-b82c54d6c7b7
\\226\\010Cr\\323!\\356\\323L\\203\\3409H\\211\\225\\010\\320\\375\\326FOA\\204\\204\\236\\336d\\325\\225\\354`l	debugger3_widgets_tree
\\227>\\374\\264\\0246\\036\\252\\276\\344v9A\\011RF\\217|\\031r\\210(\\276\\024\\253\\344[\\217\\345G\\364\\221	events:\nbinds to close_modal:  closes.\n\n\n\n
\\230"!\\2669\\241C\\310\\374\\247Cu[\\223,\\2278\\3738?\\\\K?\\271V\\3666"\\342,\\2257	sem_fkey_one_to_many
\\231\\257\\021g.f@\\031\\277vC\\272\\337S\\335\\211F.\\020\\215\\032\\013\\227\\274\\321c\\177<\\204\\224D#	f94cba1e-dbf5-499b-9cf2-fe43ce8ab581
\\232^\\246\\314\\324\\334\\023\\2026\\027\\231\\033\\015\\332N0p\\241\\317\\326\\267\\327s\\352\\210\\011\\027\\\\\\036\\341\\030\\263	/upload
\\233\\0154\\237\\301\\273\\314Ap\\212\\211`\\2545^,|\\212\\313+(\\252\\246[@\\277\\276fc|;\\372	<div id="{{= id }}" class="{{= name }}">\n    <div class="buttons">\n        <button class="save">Save</button>\n        <button class="copy">Copy</button>\n        <button class="delete">Delete</button>\n    </div>\n    <p class='title'>widget: <span class='name'></span></p>\n    <div class="tabs"></div>\n    <div class="content"></div>\n</div>
\\233\\275z\\006\\207X\\312\\237\\025Q\\350\\307~\\037!f\\270\\370\\263\\221\\352\\273\\224\\012\\004"\\004N\\037x}\\241	e7087f6f-d536-4fdc-b5a4-aa61de67aa8c
\\234S\\370\\033\\333\\277nh\\341\\371\\313\\032\\3361!\\014:i\\224\\255o\\016\\211\\014\\245~\\302Z\\020\\261\\327`	bundle_config_dialog
\\234{\\011\\033~g\\274@\\324Ka\\333\\203\\353\\315\\375\\200\\277'x\\254\\321\\270\\023b\\277\\004\\305\\024\\216\\004\\002	<div id="{{= id }}" class="{{= name }}">\n    {{= bundle.get('name') }}\n</div>
\\235\\316\\201\\376b\\205d*>\\261x\\323\\252\\263\\216\\257x\\227e\\037(L\\003\\213\\000e\\210\\307\\273\\207v\\314	.{{= name }} button.stage_all {\n    float: right;\n}
\\236C\\314j\\202{\\023}*-|\\232+N\\222f\\266\\210\\241E]\\235\\241du\\034\\032\\011\\317ZB\\262	c2e6b45c-d4eb-4134-b246-84c542718717
\\237%\\371\\374\\3678}\\346F{\\3217\\230P.\\2351\\323\\325?UI\\322Y\\270\\027u5\\374\\363b<	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'purpose'],\n            order_by: {\n                column: 'purpose'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('ide:option', {\n                label: row.get('purpose'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\240X\\210\\266\\327\\215`Aw\\336\\235\\365U\\2407\\007\\353\\340\\002\\302\\362Wg\\271^o\\3614\\334\\236oj	<div id="{{= id }}" class="{{= name }}">\n    <input class='fileUpload' type='file'>\n</div>
\\240\\356\\347DO\\351\\031<\\017\\3763\\277\\357\\203:GT\\037y\\361\\232\\374\\200\\352\\206\\255t\\213)m\\375O	<div id="{{= id }}" class="{{= name }}">\n    {{= message }}\n</div>
\\241K$\\313G\\342\\023\\300\\275\\247\\210:\\372\\272\\0352\\202Q#\\232\\220\\340j\\360\\360\\011\\000E^\\011\\335\\221	9ba8e45a-4173-4c55-9bc2-97395897498f
\\241P\\323\\323\\277\\305`M\\345\\266"\\306\\336\\2226.q\\0242*\\345$M\\215\\316!\\304\\313c\\271\\247\\365	f522acae-3fc3-4b9b-83a0-f4990a384210
\\241\\032u\\340\\376\\356\\314\\032\\236\\377h+\\006\\357\\013\\024a\\355N\\347\\244\\326\\332J\\3433\\275\\301\\004\\035\\235Q	option
\\241\\310z\\347J`\\372\\324\\306`4\\213<n\\315dkHn\\327Mgn\\242\\370\\025\\035\\234uq\\021\\025	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <title>Aquameta</title>\n        \n        <link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n            \n            div.auth {\n                float: right;\n            }\n        </style>\n    </head>\n    <body>\n        <div class='auth'></div>\n        <h1>Aquameta</h1>\n        <p>Here are some starting places:</p>\n        <ul>\n            <li><a href='/dev'>/dev</a> - Developer IDE</li>\n            <li><a href='/docs'>/docs</a> - Documentation (coming soon)</li>\n            <li><a href='/snake'>/snake</a> - Snake - a sample game</li>\n        </ul>\n            \n    </body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.2', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.ui.auth', 'auth', db);\n            \n            $('body > div.auth').append(widget('auth:auth_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\241\\335\\012\\027\\377I\\256\\344\\202V-\\207\\2720\\035k\\245?\\375\\365\\017\\277\\230\\031Lbe<\\251\\334\\224\\025	9e0dfe9c-16eb-48dc-afe5-c064582fe6e4
\\241\\\\\\004\\000O\\027\\012i\\267\\265\\327\\265]|0\\342\\261a\\236\\001\\010\\275\\324\\226*\\377\\211>\\334\\237\\006\\315	sem_fkey_many_to_many
\\243S\\307c\\237\\273j\\203S\\242H\\246\\334\\204;\\011\\361\\031c\\026\\003\\324\\037\\240923a\\364\\253\\332h	fc2bee4e-a43c-431c-95fe-0cdc61d5c437
\\244\\240\\320\\363[|r\\011\\307_\\227\\334\\\\O\\235\\337i\\316\\356\\211\\3361\\356\\351\\231!\\036\\332)\\004.9	\n/*\n * jwerty - Awesome handling of keyboard events\n *\n * jwerty is a JS lib which allows you to bind, fire and assert key combination\n * strings against elements and events. It normalises the poor std api into\n * something easy to use and clear.\n *\n * This code is licensed under the MIT\n * For the full license see: http://keithamus.mit-license.org/\n * For more information see: http://keithamus.github.com/jwerty\n *\n * @author Keith Cirkel ('keithamus') <jwerty@keithcirkel.co.uk>\n * @license http://keithamus.mit-license.org/\n * @copyright Copyright © 2011, Keith Cirkel\n *\n */\n(function (global, exports) {\n\n    // Try require external librairies in Node.js context\n    function tryRequire(mod) {\n        if (typeof require == 'function' && typeof module !== 'undefined' && module.exports) {\n            try {\n                return require(mod.toLowerCase());\n            } catch (err) {}\n        } else {\n            return global[mod];\n        }\n    }\n\n    // Helper methods & vars:\n    var $d = global.document,\n        $ = (tryRequire('jQuery') || tryRequire('Zepto') || tryRequire('ender') || $d),\n        $$, // Element selector function\n        $b, // Event binding function\n        $u, // Event unbinding function\n        $f, // Event firing function\n        ke = 'keydown';\n\n    function realTypeOf(v, s) {\n        return (v === null) ? s === 'null'\n        : (v === undefined) ? s === 'undefined'\n        : (v.is && v instanceof $) ? s === 'element'\n        : Object.prototype.toString.call(v).toLowerCase().indexOf(s) > 7;\n    }\n\n    if ($ === $d) {\n        $$ = function (selector, context) {\n            return selector ? $.querySelector(selector, context || $) : $;\n        };\n        $b = function (e, fn) { e.addEventListener(ke, fn, false); };\n        $u = function (e, fn) { e.removeEventListener(ke, fn, false); };\n        $f = function (e, jwertyEv) {\n            var ret = $d.createEvent('Event'),\n            i;\n\n            ret.initEvent(ke, true, true);\n\n            for (i in jwertyEv) ret[i] = jwertyEv[i];\n\n            return (e || $).dispatchEvent(ret);\n        };\n    } else {\n        $$ = function (selector, context) { return $(selector || $d, context); };\n        $b = function (e, fn) { $(e).bind(ke + '.jwerty', fn); };\n        $u = function (e, fn) { $(e).unbind(ke + '.jwerty', fn) };\n        $f = function (e, ob) { $(e || $d).trigger($.Event(ke, ob)); };\n    }\n\n    // Private\n    var _modProps = { 16: 'shiftKey', 17: 'ctrlKey', 18: 'altKey', 91: 'metaKey' };\n\n    // Generate key mappings for common keys that are not printable.\n    var _keys = {\n\n        // MOD aka toggleable keys\n        mods: {\n            // Shift key, ⇧\n            '⇧': 16,\n            shift: 16,\n            // CTRL key, on Mac: ⌃\n            '⌃': 17,\n            ctrl: 17,\n            // ALT key, on Mac: ⌥ (Alt)\n            '⌥': 18,\n            alt: 18,\n            option: 18,\n            // META, on Mac: ⌘ (CMD), on Windows (Win), on Linux (Super)\n            '⌘': 91,\n            meta: 91,\n            cmd: 91,\n            'super': 91,\n            win: 91\n        },\n\n        // Normal keys\n        keys: {\n            // Backspace key, on Mac: ⌫ (Backspace)\n            '⌫': 8,\n            backspace: 8,\n            // Tab Key, on Mac: ⇥ (Tab), on Windows ⇥⇥\n            '⇥': 9,\n            '⇆': 9,\n            tab: 9,\n            // Return key, ↩\n            '↩': 13,\n            'return': 13,\n            enter: 13,\n            '⌅': 13,\n            // Pause/Break key\n            'pause': 19,\n            'pause-break': 19,\n            // Caps Lock key, ⇪\n            '⇪': 20,\n            caps: 20,\n            'caps-lock': 20,\n            // Escape key, on Mac: ⎋, on Windows: Esc\n            '⎋': 27,\n            escape: 27,\n            esc: 27,\n            // Space key\n            space: 32,\n            // Page-Up key, or pgup, on Mac: ↖\n            '↖': 33,\n            pgup: 33,\n            'page-up': 33,\n            // Page-Down key, or pgdown, on Mac: ↘\n            '↘': 34,\n            pgdown: 34,\n            'page-down': 34,\n            // END key, on Mac: ⇟\n            '⇟': 35,\n            end: 35,\n            // HOME key, on Mac: ⇞\n            '⇞': 36,\n            home: 36,\n            // Insert key, or ins\n            ins: 45,\n            insert: 45,\n            // Delete key, on Mac: ⌫ (Delete)\n            del: 46,\n            'delete': 46,\n\n            // Left Arrow Key, or ←\n            '←': 37,\n            left: 37,\n            'arrow-left': 37,\n            // Up Arrow Key, or ↑\n            '↑': 38,\n            up: 38,\n            'arrow-up': 38,\n            // Right Arrow Key, or →\n            '→': 39,\n            right: 39,\n            'arrow-right': 39,\n            // Up Arrow Key, or ↓\n            '↓': 40,\n            down: 40,\n            'arrow-down': 40,\n\n            // odities, printing characters that come out wrong:\n            // Num-Multiply, or *\n            '*': 106,\n            star: 106,\n            asterisk: 106,\n            multiply: 106,\n            // Num-Plus or +\n            '+': 107,\n            'plus': 107,\n            // Num-Subtract, or -\n            '-': 109,\n            subtract: 109,\n            'num-.': 110,\n            'num-period': 110,\n            'num-dot': 110,\n            'num-full-stop': 110,\n            'num-delete': 110,\n            // Semicolon\n            ';': 186,\n            semicolon: 186,\n            // = or equals\n            '=': 187,\n            'equals': 187,\n            // Comma, or ,\n            ',': 188,\n            comma: 188,\n            //'-': 189, //???\n            // Period, or ., or full-stop\n            '.': 190,\n            period: 190,\n            'full-stop': 190,\n            // Slash, or /, or forward-slash\n            '/': 191,\n            slash: 191,\n            'forward-slash': 191,\n            // Tick, or `, or back-quote\n            '`': 192,\n            tick: 192,\n            'back-quote': 192,\n            // Open bracket, or [\n            '[': 219,\n            'open-bracket': 219,\n            // Back slash, or \\\n            '\\\\': 220,\n            'back-slash': 220,\n            // Close backet, or ]\n            ']': 221,\n            'close-bracket': 221,\n            // Apostraphe, or Quote, or '\n            '\\'': 222,\n            quote: 222,\n            apostraphe: 222\n        }\n\n    };\n\n    // To minimise code bloat, add all of the 0-9 and NUMPAD 0-9 keys in a loop\n    var i = 47,\n        n = 0;\n    while (++i < 106) {\n        _keys.keys[n] = i;\n        _keys.keys['num-' + n] = i + 48;\n        ++n;\n    }\n\n    // To minimise code bloat, add all of the F1-F25 keys in a loop\n    i = 111,\n    n = 1;\n    while (++i < 136) {\n        _keys.keys['f' + n] = i;\n        ++n;\n    }\n\n    // To minimise code bloat, add all of the letters of the alphabet in a loop\n    i = 64;\n    while (++i < 91) {\n        _keys.keys[String.fromCharCode(i).toLowerCase()] = i;\n    }\n\n    function JwertyCode(jwertyCode) {\n        var i,\n            c,\n            n,\n            z,\n            keyCombo,\n            optionals,\n            jwertyCodeFragment,\n            rangeMatches,\n            rangeI;\n\n        // In-case we get called with an instance of ourselves, just return that.\n        if (jwertyCode instanceof JwertyCode) return jwertyCode;\n\n        // If jwertyCode isn't an array, cast it as a string and split into array.\n        if (!realTypeOf(jwertyCode, 'array')) {\n            jwertyCode = (String(jwertyCode)).replace(/\\s/g, '').toLowerCase()\n                .match(/(?:\\+,|[^,])+/g);\n        }\n\n        // Loop through each key sequence in jwertyCode\n        for (i = 0, c = jwertyCode.length; i < c; ++i) {\n\n            // If the key combo at this part of the sequence isn't an array,\n            // cast as a string and split into an array.\n            if (!realTypeOf(jwertyCode[i], 'array')) {\n                jwertyCode[i] = String(jwertyCode[i])\n                    .match(/(?:\\+\\/|[^\\/])+/g);\n            }\n\n            // Parse the key optionals in this sequence\n            optionals = [],\n            n = jwertyCode[i].length;\n            while (n--) {\n\n                // Begin creating the object for this key combo\n                jwertyCodeFragment = jwertyCode[i][n];\n\n                keyCombo = {\n                    jwertyCombo: String(jwertyCodeFragment),\n                    shiftKey: false,\n                    ctrlKey: false,\n                    altKey: false,\n                    metaKey: false\n                };\n\n                // If jwertyCodeFragment isn't an array then cast as a string\n                // and split it into one.\n                if (!realTypeOf(jwertyCodeFragment, 'array')) {\n                    jwertyCodeFragment = String(jwertyCodeFragment).toLowerCase()\n                        .match(/(?:(?:[^\\+])+|\\+\\+|^\\+$)/g);\n                }\n\n                z = jwertyCodeFragment.length;\n                while (z--) {\n\n                    // Normalise matching errors\n                    if (jwertyCodeFragment[z] === '++') jwertyCodeFragment[z] = '+';\n\n                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo\n                    if (jwertyCodeFragment[z] in _keys.mods) {\n                        keyCombo[_modProps[_keys.mods[jwertyCodeFragment[z]]]] = true;\n                    } else if (jwertyCodeFragment[z] in _keys.keys) {\n                        keyCombo.keyCode = _keys.keys[jwertyCodeFragment[z]];\n                    } else {\n                        rangeMatches = jwertyCodeFragment[z].match(/^\\[([^-]+\\-?[^-]*)-([^-]+\\-?[^-]*)\\]$/);\n                    }\n                }\n                if (realTypeOf(keyCombo.keyCode, 'undefined')) {\n                    // If we picked up a range match earlier...\n                    if (rangeMatches && (rangeMatches[1] in _keys.keys) && (rangeMatches[2] in _keys.keys)) {\n                        rangeMatches[2] = _keys.keys[rangeMatches[2]];\n                        rangeMatches[1] = _keys.keys[rangeMatches[1]];\n\n                        // Go from match 1 and capture all key-comobs up to match 2\n                        for (rangeI = rangeMatches[1]; rangeI < rangeMatches[2]; ++rangeI) {\n                            optionals.push({\n                                altKey: keyCombo.altKey,\n                                shiftKey: keyCombo.shiftKey,\n                                metaKey: keyCombo.metaKey,\n                                ctrlKey: keyCombo.ctrlKey,\n                                keyCode: rangeI,\n                                jwertyCombo: String(jwertyCodeFragment)\n                            });\n\n                        }\n                        keyCombo.keyCode = rangeI;\n                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo\n                    } else {\n                        keyCombo.keyCode = 0;\n                    }\n                }\n                optionals.push(keyCombo);\n\n            }\n            this[i] = optionals;\n        }\n        this.length = i;\n        return this;\n    }\n\n    var jwerty = exports.jwerty = {\n        /**\n         * jwerty.event\n         *\n         * `jwerty.event` will return a function, which expects the first\n         *  argument to be a key event. When the key event matches `jwertyCode`,\n         *  `callbackFunction` is fired. `jwerty.event` is used by `jwerty.key`\n         *  to bind the function it returns. `jwerty.event` is useful for\n         *  attaching to your own event listeners. It can be used as a decorator\n         *  method to encapsulate functionality that you only want to fire after\n         *  a specific key combo. If `callbackContext` is specified then it will\n         *  be supplied as `callbackFunction`'s context - in other words, the\n         *  keyword `this` will be set to `callbackContext` inside the\n         *  `callbackFunction` function.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Function} callbackFucntion is a function (or boolean) which\n         *      is fired when jwertyCode is matched. Return false to\n         *      preventDefault()\n         *   @param {Object} callbackContext (Optional) The context to call\n         *      `callback` with (i.e this)\n         *\n         */\n        event: function (jwertyCode, callbackFunction, callbackContext /*? this */) {\n\n            // Construct a function out of callbackFunction, if it is a boolean.\n            if (realTypeOf(callbackFunction, 'boolean')) {\n                var bool = callbackFunction;\n                callbackFunction = function () { return bool; };\n            }\n\n            jwertyCode = new JwertyCode(jwertyCode);\n\n            // Initialise in-scope vars.\n            var i = 0,\n                c = jwertyCode.length - 1,\n                returnValue,\n                jwertyCodeIs;\n\n            // This is the event listener function that gets returned...\n            return function (event) {\n\n                // if jwertyCodeIs returns truthy (string)...\n                if ((jwertyCodeIs = jwerty.is(jwertyCode, event, i))) {\n                    // ... and this isn't the last key in the sequence,\n                    // incriment the key in sequence to check.\n                    if (i < c) {\n                        ++i;\n                        return;\n                    // ... and this is the last in the sequence (or the only\n                    // one in sequence), then fire the callback\n                    } else {\n                        returnValue = callbackFunction.call(\n                            callbackContext || this, event, jwertyCodeIs);\n\n                        // If the callback returned false, then we should run\n                        // preventDefault();\n                        if (returnValue === false) event.preventDefault();\n\n                        // Reset i for the next sequence to fire.\n                        i = 0;\n                        return;\n                    }\n                }\n\n                // If the event didn't hit this time, we should reset i to 0,\n                // that is, unless this combo was the first in the sequence,\n                // in which case we should reset i to 1.\n                i = jwerty.is(jwertyCode, event) ? 1 : 0;\n            };\n        },\n\n        /**\n         * jwerty.is\n         *\n         * `jwerty.is` will return a boolean value, based on if `event` matches\n         *  `jwertyCode`. `jwerty.is` is called by `jwerty.event` to check\n         *  whether or not to fire the callback. `event` can be a DOM event, or\n         *  a jQuery/Zepto/Ender manufactured event. The properties of\n         *  `jwertyCode` (speficially ctrlKey, altKey, metaKey, shiftKey and\n         *  keyCode) should match `jwertyCode`'s properties - if they do, then\n         *  `jwerty.is` will return `true`. If they don't, `jwerty.is` will\n         *  return `false`.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {KeyboardEvent} event is the KeyboardEvent to assert against\n         *   @param {Integer} i (Optional) checks the `i` key in jwertyCode\n         *      sequence\n         *\n         */\n        is: function (jwertyCode, event, i /*? 0*/) {\n            jwertyCode = new JwertyCode(jwertyCode);\n            // Default `i` to 0\n            i = i || 0;\n            // We are only interested in `i` of jwertyCode;\n            jwertyCode = jwertyCode[i];\n            // jQuery stores the *real* event in `originalEvent`, which we use\n            // because it does annoything stuff to `metaKey`\n            event = event.originalEvent || event;\n\n            // We'll look at each optional in this jwertyCode sequence...\n            var n = jwertyCode.length,\n                returnValue = false;\n\n            // Loop through each fragment of jwertyCode\n            while (n--) {\n                returnValue = jwertyCode[n].jwertyCombo;\n                // For each property in the jwertyCode object, compare to `event`\n                for (var p in jwertyCode[n]) {\n                    // ...except for jwertyCode.jwertyCombo...\n                    if (p !== 'jwertyCombo' && event[p] != jwertyCode[n][p]) returnValue = false;\n                }\n                // If this jwertyCode optional wasn't falsey, then we can return early.\n                if (returnValue !== false) return returnValue;\n            }\n            return returnValue;\n        },\n\n        /**\n         * jwerty.key\n         *\n         *  `jwerty.key` will attach an event listener and fire\n         *   `callbackFunction` when `jwertyCode` matches. The event listener is\n         *   attached to `document`, meaning it will listen for any key events\n         *   on the page (a global shortcut listener). If `callbackContext` is\n         *   specified then it will be supplied as `callbackFunction`'s context\n         *   - in other words, the keyword `this` will be set to\n         *   `callbackContext` inside the `callbackFunction` function.\n         *   returns a subscription handle `h`, by which you may undo the binding\n         *   by calling `h.unbind()`\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Function} callbackFunction is a function (or boolean) which\n         *      is fired when jwertyCode is matched. Return false to\n         *      preventDefault()\n         *   @param {Object} callbackContext (Optional) The context to call\n         *      `callback` with (i.e this)\n         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,\n         *      or an HTML*Element on which to bind the eventListener\n         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender\n         *      object, or an HTML*Element on which to scope the selector\n         *\n         */\n        key: function (jwertyCode, callbackFunction, callbackContext /*? this */, selector /*? document */, selectorContext /*? body */) {\n            // Because callbackContext is optional, we should check if the\n            // `callbackContext` is a string or element, and if it is, then the\n            // function was called without a context, and `callbackContext` is\n            // actually `selector`\n            var realSelector = realTypeOf(callbackContext, 'element') || realTypeOf(callbackContext, 'string') ? callbackContext : selector,\n            // If `callbackContext` is undefined, or if we skipped it (and\n            // therefore it is `realSelector`), set context to `global`.\n                realcallbackContext = realSelector === callbackContext ? global : callbackContext,\n            // Finally if we did skip `callbackContext`, then shift\n            // `selectorContext` to the left (take it from `selector`)\n                realSelectorContext = realSelector === callbackContext ? selector : selectorContext;\n\n            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,\n            // then just use it neat, otherwise find it in DOM using $$()\n            var element = realTypeOf(realSelector, 'element') ? realSelector : $$(realSelector, realSelectorContext);\n            var callback = jwerty.event(jwertyCode, callbackFunction, realcallbackContext);\n            $b( element, callback );\n            \n            return {unbind:function(){ $u( element, callback ) }};\n        },\n        \n        /**\n         * jwerty.fire\n         *\n         * `jwerty.fire` will construct a keyup event to fire, based on\n         *  `jwertyCode`. The event will be fired against `selector`.\n         *  `selectorContext` is used to search for `selector` within\n         *  `selectorContext`, similar to jQuery's\n         *  `$('selector', 'context')`.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,\n         *      or an HTML*Element on which to bind the eventListener\n         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender\n         *      object, or an HTML*Element on which to scope the selector\n         *\n         */\n        fire: function (jwertyCode, selector /*? document */, selectorContext /*? body */, i) {\n            jwertyCode = new JwertyCode(jwertyCode);\n            var realI = realTypeOf(selectorContext, 'number') ? selectorContext : i;\n\n            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,\n            // then just use it neat, otherwise find it in DOM using $$()\n            $f(\n                realTypeOf(selector, 'element') ? selector : $$(selector, selectorContext),\n                jwertyCode[realI || 0][0]\n            );\n        },\n\n        KEYS: _keys\n    };\n\n}(typeof global !== 'undefined' && global.window || this, (typeof module !== 'undefined' && module.exports ? module.exports : this)));\n
\\244\\342\\010/q\\366-k\\341zN\\375\\022\\215\\226\\353\\356\\2270m`\\324\\232\\345\\320\\364\\271\\204\\032\\245L\\207	var w = $("#"+id);\n\nendpoint.schema('endpoint').table('template_route').rows({\n    where: {\n        name: 'template_id',\n        op: '=',\n        value: template.get('id')\n    }\n}).then(function(routes) {\n    widget.sync(routes, w.find('.routes'), function(route) {\n        return widget('ide:template_route', { route: route });\n    });\n\n});\n\n\nw.find('button.new').click(function() {\n    if (url_pattern = prompt('Enter the URL pattern of the route to add to this template')) {\n        endpoint.schema('endpoint').table('template_route').insert({\n            url_pattern: url_pattern,\n            template_id: template.get('id')\n        }).then(function(route) {\n            w.find('.routes').append(widget('ide:template_route', { route: route }));\n        });\n    }\n});
\\244\\350\\300Z\\267\\024\\270\\024f\\324\\235\\304\\032\\272\\025\\023\\225\\236B\\344\\015\\201\\211\\252\\030+4\\322\\367-\\231x	var w = $('#'+id);\n\nw.find('.content').append(content);\n\nfunction dismiss(e) {\n    e.stopPropagation();\n    w.fadeOut('fast').remove(); \n    return false;\n}\n\nw.on('click done dismiss close_modal', dismiss);\nw.find('.content').on('click', function(e) {\n    e.stopPropagation();\n});\njwerty.key('esc', dismiss);\n
\\245=\\203\\023\\004P\\030dP\\257\\206\\350\\351\\210\\333\\17721\\215nT\\334r^"\\205HG\\230"\\017\\337	28f80b64-3f7e-4c74-b906-cf266b12da9e
\\245\\204\\365#\\032\\363r\\313\\330\\375\\202hy\\236\\301`A\\333h\\224\\323$\\012YZ\\204\\3721\\207\\270\\035\\243	<div id="{{= id }}" class="{{= name }}">\n    <div class="overlay"></div>\n    <div class="content"></div>\n</div>
\\245\\364\\027\\200\\312\\011A\\207\\005\\347\\002\\342Z\\203|?\\341,np2\\366\\232\\365\\017\\342p;\\353a\\254\\231	d6e22ebd-0168-4efa-80c9-5f9c097734d2
\\250\\202\\261\\331\\233\\351\\303\\244\\221\\201.>\\007\\310\\350\\3307P\\310#\\316r/6P\\352\\325\\273\\300\\344\\222_	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});\n\nw.find('.edit').on('click', function(e) {\n    e.stopPropagation();\n    w.append(widget('ide:modal', {\n        content: widget('semantics/row_detail', row)\n    }));\n});\n\nw.on('form_field_save', function() {\n    e.stopPropagation();\n    w.replaceWith('semantics/list_item', row)\n});\n
\\250\\256Z\\251\\012\\224\\331\\010\\374z\\263[\\030p*0\\036\\223x\\3703\\206\\364\\235K\\035\\306<\\005\\002\\243O	<div id="{{= id }}" class="{{= name }}">\n</div>
\\251B\\311\\323\\217\\014\\257\\2377\\200\\331\\3447\\323\\345\\257Z\\355\\030k\\210Tx\\212\\227*\\221O}\\031\\342\\374	.{{= name }} {\n}\n\n.{{= name }}:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n\n.{{= name }} ul {\n    display: none;\n}\n\n.{{= name }} ul.open {\n    display: block;\n}\n
\\252)\\350\\230(\\321\\373\\202\\355=\\257\\030w\\310.\\254u\\207'[7\\021\\226\\004<\\325\\244\\020\\360(\\013\\013	29b4e0ef-4a15-43a7-930c-21e5f1653e76
\\252\\010?\\304\\307\\271)\\274\\\\\\273\\\\\\2756\\324\\271bk\\036\\023D\\340\\263\\357t\\235$\\340\\231\\371X\\345R	.{{= name }} div.unstaged {\n    display: none;\n    background-color: pink;\n}\n\n.{{= name }} div.staged {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} div.unstaged_fields {\n    display: none;\n    background-color: pink;\n}\n.{{= name }} div.staged_fields {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.modified_link {\n    font-size: 72%;\n}\n.{{= name }} span.modified_link:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n\n.{{= name }} .text_id span:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n\n.{{= name }} button.untrack {\n    display: none;\n}
\\252\\325\\207\\250\\035\\3139v\\371?rZ\\216\\213^\\361Z\\2778\\011\\261(\\010+y|n\\232\\243>.Z	.{{= name }} {\n}\n
\\253\\0308U\\344c\\343)~\\035\\365\\344e\\331\\302\\007\\016<\\301\\015\\372\\221Y\\024]\\011\\2760\\300\\310\\006\\304	<section id="{{= id }}" class="{{= name }}">\n    <header>\n        <div class='auth'></div>\n        <div class='logo'><a href="/dev">aquameta</a></div>\n        <div class='title'></div>\n    </header>\n\n    <div class="content">\n        <div class='row_list_section'/>\n        <div class='workspace_section'/>\n    </div>\n    \n    <footer>\n        Aquameta\n    </footer>\n</section>
\\256\\272\\361C\\225\\001\\264(d\\317\\350\\027\\303t\\351]]\\314dY\\235y<\\031\\206z\\322\\361\\\\} 0	<div id="{{= id }}" class="{{= name }}">\n    <nav><!--\n        {{ Object.keys(tabs).forEach(function(tab_name) { }}\n\t\t--><a {{ if(typeof base_url != 'undefined') { }}\n      \t\t\thref='{{= base_url + "/" + tab_name }}' }}\n    \t  {{ } }} data-tab="{{= tab_name }}">{{= tab_name }}</a><!--\n        {{ }); }}\n    --></nav>\n    <div class="content"></div>\n</div>
\\256\\353\\012\\004\\240mqG\\036\\353V\\005\\016m\\341\\205\\026\\313nSm['\\265D\\205f\\265x\\335i\\226	var w = $("#"+id);\n\nw.css('padding-left', depth+'em');\n\nfunction get_ids() {\n    var ids = '';\n    if (properties.ids.length > 0)\n        ids = '#'+properties.ids.join(',#');\n    return ids;\n}\n\nw.bind('mouseover', function(e) {\n    $(get_ids()).addClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\nw.bind('mouseout', function(e) {\n    $(get_ids()).removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n// recurse for each child\nfor (var child_name in properties.children) {\n    var child = properties.children[child_name];\n\n    w.after(widget('debugger3_widgets_tree', { \n        widget_name: child_name,\n        properties: child,\n        depth: depth+1\n    }));\n}\n\nw.click(function(e) {\n    e.stopPropagation();\n    console.log(properties);\n    endpoint.schema('widget').table('widget').row('id', properties.widget_row_id).then(function(widget_row) {\n        $('body').append(\n            widget('modal', { \n                content: widget('row_detail_widget', { row: widget_row })\n            })\n        );\n    });\n});\n\n\n
\\256lg\\007\\311C\\277\\324\\325D\\351\\236\\326\\362R\\326xx#A\\271Q2\\342\\206\\323\\377\\232\\246\\356\\240\\227	ce5a0276-859b-4095-a681-3465453cf648
\\257\\257y'\\201\\376\\001,\\241v\\352\\357(\\276\\246~\\000\\002J\\376\\373\\207\\352\\211\\367\\021,\\334\\031\\205\\336\\331	var w = $("#"+id);\n\nfunction toggle_show() {\n    if (w.find('.debugger_container').is(':visible')) {\n        w.find('.debugger_container').hide();\n        w.find('input:checkbox').prop('checked', false);\n        ///w.find('.debugger3').data('disable')();\n    }\n    else {\n        w.find('.debugger_container').show();\n        w.find('.debugger_container').html(widget('debugger3'));\n        w.find('input:checkbox').prop('checked', true);\n    }\n}\n\njwerty.key('ctrl+alt+x', toggle_show);\nw.find('input').change(toggle_show)\n\nif ( typeof show != 'undefined' && show == true) {\n    toggle_show();\n}
\\260\\205\\321\\357\\210\\230\\321\\024"?\\214\\206-\\032\\214\\304\\263p\\030h}\\274\\312%j!\\002\\253\\301\\300\\251A	var w = $("#"+id);\n/*\nsetTimeout(function() {\n\tw.trigger('done');\n}, 4000);\n*/\n\nwidget.sync(endpoint.schema('endpoint').table('mimetype').rows(), w.find('.mimetype'), function(mime) {\n    return widget('ide:option', {\n        label: mime.get('mimetype'),\n        value: mime.get('id')\n    });\n});\n\nw.find('.save').on('click', function() {\n    if (w.find('.path').val() == '' || w.find('.mimetype').val() == null) {\n        alert('Path and mimetype needed');\n        return;\n    }\n    endpoint.schema('endpoint').table('resource').insert({\n        path: w.find('.path').val(),\n        mimetype_id: w.find('.mimetype').val(),\n        content: '<!doctype html><html><head></head><body></body></html>'\n    })\n    .then(function(new_row) {\n        w.trigger('insert', { row: new_row });\n        w.trigger('status', ['Resource created', 'success']);\n        w.trigger('done');\n        w.remove();\n    });\n});\n\nw.find('.exit').on('click', function() {\n    w.trigger('done');\n});\n
\\262\\241\\363\\365\\221w\\344\\030\\265B\\334\\273\\372\\206\\343+K\\341E\\213\\203\\223\\243C\\2427\\033\\212\\031\\2066\\222	.{{= name }} {\n    cursor: pointer;\n}\n\n.{{= name }} > .open:hover {\n    text-decoration: underline;\n}
\\2631\\265:\\370\\316~M\\226\\005\\365\\205\\276`]I\\015A\\027\\0052\\257a\\206\\203\\375\\201\\322\\236\\200\\321\\005	4c9473d4-dba2-4f08-939c-6fe1654fdb6d
\\263\\312XvE\\325\\345>\\243\\243\\013\\247N1\\300n3<3\\233_\\273\\037\\031\\177l\\303\\250\\210j\\324>	var w = $("#"+id);\n\nw.change(function() {\n    if(!!to_js) {\n        field.value = to_js($(this).val());\n    }\n    else {\n        field.value = $(this).val();\n    }\n    \n    w.trigger("saved");\n});\n\nwidget.sync(\n    rows,\n    w,\n    function(row) {\n        return widget('editable_field_fkey_select_option', {\n            row: row,\n            key_maker: key_maker,\n            current_value: field.value,\n            labeler: labeler\n        });\n    }\n);
\\263\\360\\236\\305\\376q\\037\\022\\017\\306U\\201\\345@9\\031\\235N!\\3103)\\017\\0148 \\274\\300\\021Rc\\011	.{{= name }} .head_commit {\n    display: none;\n    color: yellow;\n    font-size: 200%;\n}\n\n.{{= name }} td.date {\n    white-space:nowrap;  \n}
\\264\\036^I\\031\\376\\247\\2445\\200:\\231\\233\\246h\\272\\207\\373\\364m*5\\253{\\022\\375\\223\\264\\342z\\266\\253	<span id="{{= id }}" class="{{= name }} highlighted">\n    <nobr>\n        <span class="label">{{= label }}</span>\n    \t<span class="close">&#10006;</span\n    ></nobr\n></span>
\\264\\322\\013\\323Sj\\241\\201\\031\\312a(\\314+\\332\\266s\\376m\\361U\\204\\010\\361"\\322\\262Lv2\\300e	var w = $("#"+id);\n\nfor (var i=0;i<stage_field_changes.length;i++) {\n    w.append(widget('stage_field_changed_diff', {\n        staged: true,\n        change: stage_field_changes[i],\n        old_val: stage_field_changes_old_vals[i],\n        new_val: stage_field_changes_new_vals[i]\n    }));\n}\nfor (var i=0;i<offstage_field_changes.length;i++) {\n    w.append(widget('stage_field_changed_diff', {\n        staged: false,\n        change: offstage_field_changes[i],\n        old_val: offstage_field_changes_old_vals[i],\n        new_val: offstage_field_changes_new_vals[i]\n    }));\n}
\\265\\000]\\207\\360\\0336\\232\\200\\371\\211X\\004\\000.\\305Nj\\033\\337ZU\\340\\321]h,_\\366\\010\\334\\230	bundle_selector
\\265\\322\\205\\200o8\\010\\000\\206QyU\\267\\375\\033^\\017\\361\\253\\370d\\217\\267|\\367\\260}36\\000\\221\\243	461cd150-e88f-4215-8a32-03476084baf4
\\267Yr\\035p#:\\207\\207\\345]\\371\\217\\2748w\\213p\\331a\\0111\\304\\006\\375\\030\\373[\\373\\026\\035\\015	666d5961-1263-4290-b672-e7d58d8b078e
\\267v\\257\\276Q\\032Q\\320hX!\\021\\235\\313\\353\\244\\375\\272\\201\\346\\036\\221\\207\\231:J7\\272\\202\\036\\012n	commit_history_dialog
\\270(Ns*. \\267J\\202.\\337\\204\\022\\005\\305PJ\\350\\177\\246\\327\\032\\301\\014\\356\\311\\364X\\\\\\006n	var w = $("#"+id);\n\n\n/* SETUP */\nvar rel_name;\nvar relation = datum;\nif (!(datum instanceof AQ.Rowset)) {\n    datum = datum.rows()\n    .then(function(rows) {\n        rel_name = rows.relation.schema.name + '.' + rows.relation.name;\n        w.find('.title').text(rel_name);\n    });\n}\nelse {\n    rel_name = datum.relation.schema.name + '.' + datum.relation.name;\n    relation = datum.relation;\n    w.find('.title').text(rel_name);\n}\n\nwidget.sync(datum, w.find('> .list > ul'), function(row) {\n    return widget('semantics/list_item', row);\n});\n\n\n\n/* TRIGGERS */\nw.on('list_item_click', function(e, row, list_item) {\n    list_item.toggleClass('selected');\n    w.find('.header .continue').toggle(!!w.find('.header ~ * > .selected').length);\n});\n\nw.find('.divider').on('click', function() {\n    w.find('.list').toggleClass('collapsed');\n});\n\nw.find('.toggle_options').on('click', function() {\n    w.find('.arrow').toggleClass('up');\n    if (w.find('.arrow').hasClass('up')) {\n        w.find('.search').focus();\n    }\n});\n\nw.find('.new').on('click', function() {\n    w.append(\n        widget('ide:modal', {\n            content: widget('semantics/new_row', relation)\n        })\n    );\n});\n\nw.find('.continue').on('click', function() {\n    var selected_items = w.find('.header ~ * > .selected').map(function() {\n        return $(this).data('row');\n    }).toArray();\n    w.trigger('list_view_select', [selected_items]);\n});\n\n\n\n/* SEARCH */\nfunction search(e) {\n    var list_items = w.find('li');\n    var val = $(this).val().trim();\n    if (val != '') {\n        \n        var matching_elements = $.grep(\n            list_items, \n            function(e, i) {\n                var re = new RegExp(val, 'i');\n\n                if (re.test($(e).html())) {\n                    return true;\n                }\n                return false;\n            });\n        \n        list_items.hide();\n        $(matching_elements).show();\n    }\n    else {\n        list_items.show();\n    }\n}\n/*\nvar debounced_search = debounce(search, 200, false);\nw.find('.search').on('keyup', debounced_search);\n*/\nw.find('.search').on('keyup', search);\n
\\270\\026\\341Awey\\3245\\256n\\271z/K\\374\\031\\344\\270\\\\O\\261R\\370\\321\\224\\250\\325l\\037\\333\\367	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\nfunction load_options() {\n    var content = "<option value='none' selected>[ None ]</option>";\n    \n    if (typeof new_enabled != 'undefined' && new_enabled == true) {\n        content += "<option class='new' value='new'>[ Create New ]</option>";\n    }\n    \n    w.find('select').empty().html(content);\n    \n    var to_rows = order_by_function(to_relation.rows());\n    widget.sync(to_rows, w.find('select'), function(to_row) {\n        return widget('option', {\n            label: label_function(to_row),\n            value: to_row.get(to_column),\n            selected: from_row.get(from_column) == to_row.get(to_column)\n        });\n    });\n}\nload_options();\n\n\n// find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    schema_name: to_relation.schema.name,\n    name: to_relation.name\n}).result(function(to_relation_obj) {\n\n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n\n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n\n\n    w.find('select').change(function() {\n\n        var val = w.find('select').val();\n\n        if(val == 'new') {\n            \n            w.append(\n                widget('modal_overlay', {\n                    content: widget(new_row_widget, { \n                        relation: to_relation_obj,\n                        context_data: context_data\n                    })\n                })\n            );\n            \n        }\n        else if (val == 'none') {\n\n            \n            from_row.set(from_column, null);\n\n            from_row.update()\n            .done(function() {\n\n                console.log('Fkey updated');\n                w.trigger('fkey_updated');\n\n            });\n            \n        }\n        else {\n            \n            from_row.set(from_column, val);\n\n            from_row.update()\n            .done(function() {\n\n                console.log('Fkey updated');\n                w.trigger('fkey_updated');\n\n            });\n        }\n    });\n\n});\n\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n});\n\nw.on('new_row', function(e, payload) {\n    \n    from_row.set(from_column, payload.new_row.get(to_column));\n    from_row.update()\n    .done(function() {\n        \n        console.log('Fkey updated');\n        w.trigger('fkey_updated');\n        load_options();\n        \n    });\n});
\\271\\235@\\217\\321M\\027\\257\\311\\2564*\\321V8\\252\\030\\234\\211^\\006U\\021\\356\\010\\000\\000\\277\\364\\024v\\025	<div id="{{= id }}" class="{{= name }}">\n    <div class='header'>\n        <button class='select_bundles'>Change bundles</button>\n        <span class='bundle_manager_container'></span>\n        {{= widget('ide:auth') }}\n    </div>\n    <div class='content bundle_list'></div>\n    <div class='content bundle_workspace'></div>\n    <div class='status_container'></div>\n    {{= widget('ide:debugger') }}\n</div>
\\272@IN\\213\\375>H\\263\\007\\206w\\227\\266\\375\\023'\\322?\\257\\214!\\224\\203\\024hV\\344\\371p\\350U	<div id="{{= id }}" class="{{= name }}">\n    <nav>\n        {{ Object.keys(tabs).forEach(function(tab_name) { }}<a data-tab="{{= tab_name }}">{{= tab_name }}</a>{{ }); }}\n    </nav>\n    \n    <div class="content">\n    </div>\n</div>
\\272f7\\031\\031\\271\\314\\364\\2339\\244\\363\\223\\277\\000fd\\356m|\\000\\321\\304\\334\\253\\276RbK#\\007$	62282f67-1366-4313-9585-ea52d8b8fea8
\\273\\016r\\306\\0339=\\370\\221]\\022\\214\\011\\253\\215\\212\\211\\355\\222It\\231\\353 \\273\\215\\200\\246\\030\\014'F	<div id="{{= id }}" class="{{= name }}">\n    <h2>Commit History</h2>\n    \n    <table class="commits" border=1>\n        <tr>\n            <th></th>\n            <th>author</th>\n            <th>commit time</th>\n            <th>message</th>\n            <th></th>\n        </tr>\n    </table>\n</div>
\\274\\200~\\256S\\210\\326\\342C\\330\\344\\251b3s\\005%\\025\\273\\330^DQZc\\206]a\\275\\236\\031\\303	<div id="{{= id }}" class="{{= name }}">\n    <span class='field_name'></span><button class='stage'>stage</button>\n</div>
\\274\\201}\\201@\\236\\265/\\307\\020=\\205?a\\365\\370c\\030\\231\\257\\311\\330\\322\\032\\270 8}\\3047\\006\\320	var w = $("#"+id);\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'schema': 9881,\n    'data': 9883,\n    'semantics': 7784\n};\n\n\nvar widget_fn = {\n    'schema': function() {\n        \n        // TODO: endpoint.suffix_clause should support complex types in where clause\n        \n        return widget('semantics/grid_view', endpoint.schema('meta').table('column').rows({\n            where: [{\n                name: 'relation_name',\n                op: '=',\n                value: datum.get('name')\n            }, {\n                name: 'schema_name',\n                op: '=',\n                value: datum.get('schema_name')\n            }],\n            order_by: {\n                column: 'name'\n            },\n            exclude: ['id', 'relation_id', 'schema_name', 'relation_name']\n        }), {\n            context: {\n                relation_id: datum.get('id')\n            }\n        });\n    },\n    'data': function() {\n        return widget('semantics/grid_view', endpoint.schema(datum.get('schema_name')).table(datum.get('name')).rows({\n//            limit: 10\n        }));\n    },\n    'semantics': function() {\n\n        return widget('semantics/grid_view', endpoint.schema('semantics').table('relation').rows({\n            where: {\n                name: 'relation_id',\n                op: '=',\n                value: datum.get('id')\n            }\n        }), {\n            context: {\n                relation_id: datum.get('id')\n            }\n        });\n    }\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\nw.find('.section').on('click', function() {\n    w.find('.section').removeClass('selected');\n    $(this).addClass('selected');\n    w.find('.content').empty().append(\n        widget_fn[$(this).attr('data-section')]()\n    );\n});\n\nw.find('.content').append(\n    widget_fn[w.find('.section.selected').attr('data-section')]()\n);\n
\\2757\\321OM\\246\\343n\\205y\\206\\255\\213.YZ\\217\\261H8B/\\242\\354M.~\\336\\364\\303\\243\\301	6159ecb9-3821-4a57-8463-fab618da324b
\\275\\345G\\335\\357,sj\\341'\\345\\244y\\015U\\007b\\305\\212\\247\\216\\013\\022\\345'\\256\\262\\230\\330\\3173\\031	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('semantics_manager') }}\n    <!--<p>Testing beehive.practice row from semantics.relation</p>-->\n    <p>Testing sem_fkey_one_to_many with<br>mickey.post row 'words mickey says' referenced by fkeys in mickey.blah</p>\n</div>
\\275\\364\\234<8\\202\\020/\\300\\027\\377\\266a\\020\\214c\\2506\\320e\\210\\212@\\223\\231C\\230\\314U\\302\\352/	auth
\\275n\\014&\\360L\\300urg\\237\\236q\\012\\356T\\203\\253\\3443\\325'\\244\\325.\\264\\240\\317\\226\\340,/	<div id="{{= id }}" class="{{= name }}">\n    <div class="toggle">\n        <label><input type="checkbox" />debugger</label>\n    </div>\n    \n    <div class="debugger_container"></div>\n</div>
\\275wf\\264\\203\\232\\251\\327#\\242R\\317F\\336c\\002Gh\\347\\265;GiA\\013\\371\\243\\313eq\\247\\032	<div id="{{= id }}" class="{{= name }}">\n    <h3>ignored by this bundle</h3>\n    coming soon....\n</div>
\\276\\006\\252\\250\\217M\\030K\\231\\312Z6\\004\\211\\223\\253\\204lK\\302\\227T\\022F\\200\\374c\\235\\273Z\\274\\022	05642077-3e03-40e9-b1e0-c679b283f6a4
\\276\\303;\\263\\341N\\206\\344\\000N\\303\\246\\266X/\\234\\002\\371\\311xp\\223t\\357A\\355LK\\006\\3052\\020	<div id="{{= id }}" class="{{= name }}">\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <p class='title'>\n            <span class='path'></span>\n            <a class='path_link' target='_blank'><button>Go to <span class='path_button'>page</span></button></a>\n        </p>\n        <div class='section_content'></div>\n    </div>\n</div>
\\277\\033\\274\\240\\306\\265\\246\\364l\\3649W$\\224\\217w\\011\\370\\307\\262\\311\\322\\245"\\257\\260\\273L\\313\\035\\324\\350	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.unstage').click(function() {\n    endpoint.schema('bundle').function('unstage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function() {\n        w.trigger('reload_stage_dialog');\n    })\n    .catch(function() {\n        alert('unstage failed');\n        console.error('unstage failed');\n    });\n    \n});\n
\\300\\231k\\343-N\\356.1\\276a\\346\\305\\207\\371\\370|\\007\\366\\233\\377O\\326K\\316~{'l\\233~\\241	17ad7fc1-e56f-4fd0-9c0a-342174a44e79
\\3019\\3550&\\355\\231[\\255\\344S/\\362 Ge\\011b\\312\\024\\0351\\274YRQ7\\304X\\367\\212=	form_field_css
\\301]\\2224\\221\\340[\\315\\362\\003HA\\350\\216\\373\\333\\263\\313\\036U\\\\H\\233\\365m\\211o\\311D\\216\\006&	bundle_untracked_row_by_schema
\\302L\\205\\337\\333d\\331?\\033i\\017\\331\\350\\3321;U\\347\\034\\015\\2618\\317}\\220\\307x2\\367M\\215\\214	var w = $("#"+id);\n\nw.find('.name').append(widget('semantics/form_field', row.field('name')));\nw.find('.routes').html(widget('ide:template_routes', { template: row }));\nw.find('.content').append(widget('semantics/form_field', row.field('content')));\nw.find('.content_save').click(function() {\n    row.update().then(function() {\n        alert ('saved.');\n    });\n});\n\nw.find('button.delete_template').click(function() {\n    if (confirm('Delete this template?')) {\n        row.delete().then(function() {\n            alert('success');\n            w.remove();\n        }).catch(function(e,o ) {\n            alert('delete failed.');\n            console.log('delete template failed: ',e,o);\n        });\n    }\n});
\\303\\265\\031\\001\\314\\265\\272\\001<\\231#\\304\\355z\\247\\321/\\243\\310\\213\\245o\\214\\024T\\272\\301\\213r'\\263=	b2ec28ca-3747-4afb-9096-be88eb2a67f0
\\304NXN3F\\013l\\352\\240*\\331\\232\\217\\257A\\277\\207,\\202|\\231#'\\323v\\223\\211\\205\\337\\017|	<div id="{{= id }}" class="{{= name }}">\n    <h2>Bundle Config</h2>\n    \n    <h3>Rename</h3>\n    \n    <p>Change the name of this bundle.</p>\n    \n    <button class='rename'>Rename</button>\n    \n        \n        \n    \n    <h3 style='color: red'>DESTRUCTION</h3>\n    \n    <p>Delete this bundle and remove it from the database permanently.</p>\n    \n    <button class='delete_bundle_oh_no'>DELETE</button>\n</div>
\\305\\200:nM\\252j\\364\\000\\350\\257\\012\\344\\027\\377m|U\\250m\\021\\272J\\014\\366\\324C\\301\\\\\\346\\372\\305	modal
\\305\\242\\010tw\\345O\\251\\331#V\\335P\\020X\\227\\271\\323E\\362[(\\222\\274\\371\\247\\027\\305\\237\\276\\027\\335	var w = $("#"+id);\nvar tab_links = w.find('> nav > a');\nvar content = w.find('.content');\n\n\n// tab colors\ntab_links.each(function() {\n    var tab_name = $(this).attr('data-tab');\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n\t    $(this).css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\n\ntab_links.click(function() {\n    tab_links.removeClass('selected');\n    var tab_name = $(this).attr('data-tab');\n    w.data('selected_tab', $(this));\n\n    content.html(tabs[$(this).addClass('selected').attr('data-tab')]());\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n        w.css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\ntab_links.filter(':first').click();\n\n\n\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n    content.html(tabs[w.data('selected_tab').attr('data-tab')]());\n});
\\305\\247*\\206<)\\260'a\\271\\264X\\360\\023\\007\\331#8of\\370\\202\\222\\306\\314C\\023\\327\\366\\316\\225\\030	<div id="{{= id }}" class="{{= name }}">\n    <h3>ignore rows</h3>\n</div>
\\306\\003ped\\316\\023\\025\\214;\\222\\254N\\2549\\376\\213T\\200\\311\\364\\350\\214\\230|\\200TN\\036\\350\\022M	list_item_with_version
\\306\\222\\234\\005x\\346\\350\\245h\\367\\364e\\353s\\006\\301\\025'\\025r\\2237H\\022\\030y\\377\\352a\\260\\224Q	bundle_selection
\\306\\244\\226\\345x\\003\\227\\015\\011\\011\\0160Ih\\355SXR/\\037\\027\\243\\260\\004\\200\\3130\\346L\\354?\\371	bundle_remote
\\306_0L\\237\\342\\310\\332)\\311QH\\352yY\\243\\362\\312\\026l\\344\\006ZiA/\\211{\\332\\002\\2330	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\nw.append(content);
\\307B\\000\\237\\316\\2207\\274\\012p\\246\\367\\003\\315JY\\235\\343\\247%\\005@J\\010-\\025|\\004@U\\007\\236	<li id="{{= id }}" class="{{= name }}">\n    {{= relation.get('relation_name') }}\n    <ul></ul>\n</li>
\\307\\021\\211low\\307\\276\\017]\\342\\025\\351\\320\\306\\035\\315U\\301\\260eM\\374E\\210!\\244\\357\\2351\\340\\243	modal_overlay
\\307\\332\\350\\320r\\275BE(\\316\\006[\\024\\274w,G\\213K\\227\\350\\337Hq`^j\\257\\224\\333\\355\\234	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar where_obj = {};\nwhere_obj[to_column] = from_row.get(from_column);\n\nto_relation.row().where(where_obj).result(function(row) {\n    \n    /*\n    console.log(row);\n    \n    if (row != 'undefined') {\n    }\n    */\n    \n    w.find('.open').html(label_function(row));\n    \n});\n\nw.on('fkey_updated', function(e, payload) {\n    \n    w.find('.open').html(label_function(payload));\n    \n});\n\nw.on('fkey_deleted', function(e, payload) {\n    \n    w.find('.open').html('Click to select');\n    \n});\n\nw.find('.open').click(function() {\n    w.append(widget('modal_dialog', {\n        content: widget('sem_fkey_autocomplete_form', {\n            from_row: from_row,\n            from_column: from_column,\n            to_relation: to_relation,\n            to_column: to_column,\n            label_function: label_function,\n            order_by_function: order_by_function,\n            new_enabled: new_enabled\n        })\n    }));\n});\n
\\310\\201 \\022\\314W\\371\\000\\015{\\376*\\271H\\204\\276\\266\\2247\\037\\374\\352\\003 f\\256f\\004\\345\\275\\227\\253	var w = $("#"+id);\n\n\n\n// widget\n\nw.find('#widget').click(function() {\n    var name = prompt('New widget name');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('widget').insert({ name: name })\n    .then(function(widget) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'widget',\n            'id',\n            widget.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: widget, row_id: widget.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n\n// resource\n\nw.find('#resource').click(function() {\n    var path = prompt('Enter the path for this resource');\n    if (!path) { return; }\n\n    endpoint.schema('endpoint').table('resource').insert({ path: path, content: '', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(resource) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'resource',\n            'id',\n            resource.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: resource, row_id: resource.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n\n// resource_binary\n\nw.find('#resource_binary').click(function() {\n    w.trigger('open_tab', {\n        tab_id: 'resource_binary_upload'\n    });\n});\n\n\n\n\n// template\n\nw.find('#template').click(function() {\n    endpoint.schema('endpoint').table('template').insert({ content: '<html></html>', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(template) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'template',\n            'id',\n            template.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: template, row_id: template.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n// dependency_js\n\nw.find('#dependency_js').click(function() {\n    var name = prompt('Enter the name for this dependency');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('dependency_js').insert({\n        name: name,\n        content: '// add your js library here',\n        version: ''\n    }).then(function(dep) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'dependency_js',\n            'id',\n            dep.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: dep, row_id: dep.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// table\n\nw.find('#table').click(function() {\n    var name = prompt('New table name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('table').insert({\n        schema_name: schema,\n        name: name\n    }).then(function(table) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'table',\n            'id',\n            table.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: table, row_id: table.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// view\n\nw.find('#view').click(function() {\n    var name = prompt('New view name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('view').insert({\n        schema_name: schema,\n        name: name,\n        query: 'select 1'\n    }).then(function(view) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'view',\n            'id',\n            view.id\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: view, row_id: view.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n// function\nw.find('#function').click(function() {\n    var name = prompt('New function name');\n    if (!name) { return; }\n\n    var schema = prompt('What schema should it go in?');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('function').insert({\n        name: name,\n        schema_name: schema,\n        parameters: ['integer'],\n        return_type: 'void',\n        definition: '',\n        language: 'sql'\n    })\n    .then(function(f) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'function',\n            'id',\n            f.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: f, row_id: f.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n
\\311\\371\\213\\302\\341yz\\221\\244#D\\300\\311\\255\\203\\022ruR\\232\\246\\274r\\312\\302\\215\\363\\333\\256\\344\\213A	ee286dbd-aebe-46a7-b4c6-57c14e75eff8
\\311r,\\355y{|f\\265\\024&\\016\\010\\231\\211<\\367GA'\\271\\260\\030'S\\357\\262{\\016\\255\\270\\333	<div id="{{= id }}" class="{{= name }}">\n    <label><span class='label'></span>&nbsp;<select><option value='null'>null</option></select></label>&nbsp;\n    <div class='error'><small>Invalid input</small></div>\n</div>
\\312x\\035\\240\\352:[)\\033\\273\\004\\305L|\\341\\233\\252A\\205:i`\\237\\245\\005%\\237#\\364\\010Y\\271	6622e339-25e4-458e-a147-54b67a50fc8a
\\313\\230u\\353i\\355\\003m\\304\\027X(\\374\\244\\341.\\343c\\374\\324D\\023o\\355\\346\\244\\304.\\362<\\0148	0c47b0ff-a846-450b-bee9-6cfe3777ae11
\\313r\\022>\\033iL\\303+\\310}\\326\\254\\374\\345\\332X= t\\007\\246F\\247P\\037A\\207kv~\\262	fba92725-3bb8-4f3c-bec0-9367df38060c
\\314\\337K\\361\\353\\2348F\\216\\3151\\013\\361\\211VL\\356\\3526\\030]\\317\\370\\027\\236AV\\341&\\203\\330H	stage_dialog_staged_fields
\\315\\210b\\367\\035d\\352\\013\\305\\315i3\\350k\\236"$T)\\334\\336\\016i2\\276\\262\\212Q\\346\\332\\374P	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.1', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:file_input'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n
\\3160\\177\\204\\217^LM\\001\\263\\215\\262\\306zxg^\\030\\365\\217\\351vV\\314\\216\\364\\2361\\343\\004L_	new_field_fkey_name
\\316r3~x\\021\\013\\315\\302\\027V\\003\\3327u\\3379\\216\\037\\344"\\254\\247\\201\\025\\335s]g\\2415b	var w = $("#"+id);\n\nw.find('button.export').click(function() {\n    var dir = w.find('input.directory').val();\n\n\n    if (confirm('export this bundle to '+dir+'?')) {\n        endpoint.schema('bundle').function('bundle_export_csv', [ bundle.get('name'), dir ])\n        .then(function() {\n            alert ('success');\n            w.trigger('close_modal');\n        })\n        .catch(function(e) {\n            alert('failed:'+e);\n        });\n    }\n});
\\317Qwa\\007\\307\\002\\030\\356\\234"\\333\\226l}\\266\\320,sz\\006^V\\037\\377w\\305z\\021\\361\\310\\340	var w = $("#"+id);\n\nw.click(function(event) {\n    event.stopPropagation();\n    \n    w.find('> ul').toggleClass('open');\n    if (!w.find('> ul').hasClass('open')) {\n        w.find('> ul').empty();\n    } else {\n        var rows = relation.related_rows('relation_id','bundle.untracked_row','relation_id');\n        widget.sync(rows, w.find('ul'), function(row) {\n            return widget('bundle_untracked_row', { row: row })\n        });\n    }\n});
\\320\\024\\306^Au\\277b\\274|\\321\\307\\2512Hh\\315\\205I\\205A\\217)\\263z\\205\\327\\260\\326\\267\\242|	84335014-52fd-45d8-9a38-3d789aeb1939
\\320r\\344\\374\\223\\305\\302\\232\\013\\360h\\342q\\372\\354\\334\\232@\\360\\201\\375\\350\\244"j\\266ZF\\200\\315\\003\\007	.{{= name }} {\n    white-space: nowrap;\n    display: none;\n}\n\n.{{= name }} .label {\n    font-size: 90%;\n}\n\n.{{= name }}:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} span.icon {\n    display: none;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n.{{= name }} span.added {\n    color: green;\n}\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.tracked {\n    color: lightblue;\n}\n\n.{{= name }} .expand {\n    cursor: pointer;\n    display: none;\n}\n\n.{{= name }} .expand:hover {\n    background-color: red;\n}
\\3217Q\\354\\005\\330\\025\\267S\\320\\321jd\\325\\215]c\\307\\256\\015\\027j/\\024$k \\360\\250R\\311\\222	.{{= name }} {\n\theight: 100%;\n    width: 100%;\n}\n\n.{{= name }} > nav {\n    height: 1.5rem;\n    border-bottom: 0.15rem solid #333;\n}\n\n.{{= name }} > nav a {\n    color: #666;\n    cursor: pointer;\n    padding: 0 .5em 1px 0.5em;\n    display: inline-block;\n    transition: background 200ms ease-in;\n    text-decoration: none;\n}\n\n.{{= name }} > nav a.selected {\n    background: #333;\n    color: white;\n}\n\n.{{= name }} > .content {\n    height: calc(100% - 1.5rem);\n}\n
\\323\\270_\\353x<\\220=\\323M7\\035\\371\\307\\000\\317\\213(\\363,\\333\\301v\\217d\\345\\037\\235\\321\\034\\017\\375	var w = $("#"+id);\n\n// new row button handler\nw.find('button.new_row').click(       function() { w.trigger('open_tab', { tab_id: 'new_row' }); });\nw.find('button.stage').click(         function() { w.trigger('open_tab', { tab_id: 'stage' }); });\nw.find('button.commit_log').click(    function() { w.trigger('open_tab', { tab_id: 'commit_log' }); });\nw.find('button.bundle_config').click( function() { w.trigger('open_tab', { tab_id: 'bundle_config' }); });\nw.find('button.push_pull').click(     function() { w.trigger('open_tab', { tab_id: 'push_pull' }); });\nw.find('button.untracked').click(     function() { w.trigger('open_tab', { tab_id: 'untracked' }); });\nw.find('button.export').click(        function() { w.trigger('open_tab', { tab_id: 'export' }); });\nw.find('button.ignored').click(        function() { w.trigger('open_tab', { tab_id: 'ignored' }); });\n\n// filter handlers\nw.find('.filters .all').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        },\n        exclude: [\n            'offstage_field_changes_old_vals',\n            'offstage_field_changes_new_vals',\n            'stage_field_changes_old_vals',\n            'stage_field_changes_new_vals'\n        ]\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\n// filter handlers\nw.find('.filters .changed').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        },\n        exclude: [\n            'offstage_field_changes_old_vals',\n            'offstage_field_changes_new_vals',\n            'stage_field_changes_old_vals',\n            'stage_field_changes_new_vals'\n        ]\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nvar commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    order_by: {\n        column: 'row_id'\n    },\n    exclude: [\n        'offstage_field_changes_old_vals',\n        'offstage_field_changes_new_vals',\n        'stage_field_changes_old_vals',\n        'stage_field_changes_new_vals'\n    ]\n});\n\n// filter handlers\nw.find('.filters .head').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_commit_row','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nw.find('.filters .all').click();\n\n// listen for triggers from semantic widgets which indicate crud changes to handle\nw.closest('.ide').bind('insert', function(e, o) {\n    alert('insert detected');\n    \n    var row_id = o.row.id;\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_value = row_id.pk_value;\n\n    endpoint.schema('bundle').function('tracked_row_add', [ \n        bundle.get('name'), \n        schema_name, \n        relation_name, \n        pk_column_name, \n        pk_value\n    ]).then(function() {\n        w.trigger('bundle_row_open', { row: o.row, row_id: row_id });\n    }).catch(function (e) {\n        alert('error calling tracked_row_add');\n    });\n});\n
\\323\\324I\\000\\242\\351o8g\\346U\\221y_9j\\331\\225\\26189\\204\\2703\\242U\\274#\\025K \\021	var w = $("#"+id);\n\nif (typeof row_id != 'undefined') {\n    $.when(endpoint.schema(row_id.pk_column_id.relation_id.schema_id.name).table(row_id.pk_column_id.relation_id.name).row().where({\n        id: row_id.pk_value\n    })).then(function(mimetype) {\n\t\tdoit(mimetype);\n    });\n} else {\n\tif (typeof row != 'undefined') {\n    \tdoit(row);\n    } else {\n        console.log("No row or row_id passed into semantics_mimetype_listitem_identifier.");\n    }\n}\n\nfunction doit(row) {\n    w.html('widget.widget: '+row.get('name'));\n}\n
\\324\\254\\023\\332\\361\\026\\302\\216\\272\\205 \\371\\000\\007-\\223\\340\\370\\353\\346\\212>\\230d]\\317;\\247\\261\\014B\\276	7d5ba057-2b25-4083-80e7-c37200e20786
\\324\\300\\010em\\037+6\\024\\037\\023\\271\\274\\357Z\\326c\\226\\330\\223\\352\\365X\\313P\\016\\347\\235G\\351{\\372	4e8942d3-1efa-45ec-8ed3-86b2c8a115c5
\\325'\\236\\362\\255\\304\\305+OH\\032\\024\\356^\\227\\267*\\205+\\245\\201\\023UXp\\255\\016@6\\370\\001k	46741261-c826-4f49-8c41-d51fec861ea0
\\325LDh6u\\014aS[]\\202\\230\\246\\325\\012\\203I\\261u\\037\\215\\017n\\356.7i\\330w\\002\\211	list_item_expandable
\\325\\0127\\006k\\023H\\252\\371b:\\2674\\030v\\364 \\026\\322\\313\\252l\\027\\302\\2251\\223P\\200\\313\\277e	widget-util
\\325\\275\\004_k\\313\\016\\230cd\\253n4\\312\\202p\\257Cse\\212l\\316{\\007w\\230\\203\\013\\203\\224!	form_field_html
\\3263\\313f\\326\\015J}z!\\352\\264\\354\\212\\346\\360\\231\\221\\302WP\\305J[Z\\334A\\270q\\252\\267\\261	("(""(endpoint)"",template)",content)
\\326Aw\\037\\331\\304L\\206%\\335u\\354\\360|1\\252E\\316nS\\351\\002\\316\\354\\246\\2534\\031\\015\\310\\203+	d8e8c142-1fb4-4298-b6a0-ac5d07b1749c
\\326\\035n\\323\\207xS\\200\\306K\\350\\22320\\203"\\007E"\\312\\326\\336\\207\\350X\\376{\\250\\333\\216\\254\\364	/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.bundle_name = "[non-widget]";\n        widget_node.bundle_alias = "[non-widget]";\n        widget_node.widget_id = "[non-widget]";\n        widget_node.widget_row_id = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n        widget_node.bundle_name = $(element).attr('data-bundle_name');\n        widget_node.bundle_alias = $(element).attr('data-bundle_alias');\n        widget_node.widget_id = $(element).attr('data-widget_id');\n        widget_node.widget_row_id = $(element).attr('data-widget_row_id');\n        widget_node.element = element;\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // bundle stuff\n            smalltree[name]['bundle_name'] = child.bundle_name;\n            smalltree[name]['bundle_alias'] = child.bundle_alias;\n            smalltree[name]['widget_row_id'] = child.widget_row_id;\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n\n
\\326\\332\\246\\236\\3132?]/\\251\\367:`\\232\\335W\\247\\025i{\\333#uR\\013\\302U\\013\\305\\235gu	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td>{{= change.get('change_type') }}</td>\n    <td>{{= change.get('row_exists') }}</td>\n    <td>\n        <button class='unstage'>unstage</button>\n    </td>\n</tr>
\\327\\341\\227z\\3339\\231\\006\\2048PSm\\266\\264&Y\\302\\366\\215\\377\\240\\305\\325"\\222\\220"&\\336\\205\\014	tabbed_layout
\\327lm\\306\\252l\\311\\216\\177\\243}E\\257\\267H\\330\\202\\374(\\312k@\\033\\003.\\361\\352\\345\\327\\262\\210\\206	workspace_tab
\\330\\210\\023\\016\\322\\204\\250d\\211\\035\\272]\\357\\333\\360\\303`\\312\\303W\\207\\207\\021I\\301%\\364\\263\\245c#\\344	.{{= name }} {\n} \n\n.{{= name }}:not(.invalid) .error {\n    display: none;\n}\n\n.{{= name }} .error {\n    color: red;\n}
\\330\\353\\215Q\\2513\\240_\\371\\332\\177\\352\\331\\237 b\\370{\\231\\245\\347\\305\\352\\212\\253M\\244\\030\\225;6\\320	bc92c925-2114-4e0e-ae01-f2ecbeda6017
\\332\\003\\220\\316\\007\\212h\\244\\321\\213\\034NZ\\216\\226\\344Ir\\253\\363\\227\\323\\303\\216\\261\\375\\034\\277Jd\\357!	commit_history_commit
\\332\\004\\002\\374>\\220\\021>\\013_t\\245\\373\\273\\343\\213\\027\\334\\251\\377[1\\344\\231\\300\\225z\\216j+Qr	<div id="{{= id }}" class="{{= name }}">\n    <p>{{= widget('semantics/form_field', row.field('name')) }}</p>\n    <div class="top">\n        <div class="sections">\n            <div class="section schema selected" data-section='schema'>schema</div>\n            <div class="section data" data-section='data'>data</div>\n            <div class="section semantics" data-section='semantics'>semantics</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="delete">Delete</button>\n            </div>\n            <div class="content"></div>\n        </div>\n    </div>\n</div>
\\332\\320)b\\351\\235\\341\\\\nG"=\\315\\244\\273k\\253\\226\\325\\324;.\\\\\\0317\\226x\\300y\\230\\0223	226aedab-05e0-4963-965e-914a55625753
\\333\\024,V\\246,\\250\\275`\\370\\364\\344\\240j\\035\\023\\364\\220Ag\\255\\364\\377m\\372\\264\\366\\264\\325'\\353\\215	row_detail_resource
\\335'A\\342sI\\026\\024:m\\277\\035\\0319\\313\\300C\\226\\361\\003V\\372\\365J\\272( f\\316\\304\\033_	944b5a05-be70-45a1-a549-1301d38799e4
\\335|\\243G\\352]\\375\\201\\015\\3563\\214\\011,\\277c\\367uWq\\217$\\200,\\306\\221\\325\\333\\234\\236\\030v	<li id="{{= id }}" class="{{= name }}">\n    {{= schema.get('schema_name') }}\n    <ul></ul>\n</li>
\\3363\\2318\\345\\354\\012\\025\\205\\250\\200\\032\\341\\272l\\214?Q_\\255\\212\\024\\376\\267\\210\\376\\016\\031\\0366,\\204	list_item_with_schema
\\336\\020R\\216o\\013\\345o$pv\\200\\320\\334u\\365\\022\\303\\033\\2320\\354\\212kJ:\\364\\012\\254\\023&\\311	.{{= name }} {\n\theight: 100%;\n    display: flex;\n    flex-flow: column;\n}\n\n.{{= name }} .tab_contents {\n    flex: 1;\n    overflow: hidden;\n}
\\3377\\\\\\373;\\324\\344\\301\\014\\311\\343b\\252\\330\\372Y\\316\\247\\254=\\216\\222\\230x\\332&\\242\\315\\303\\327\\276)	.{{= name }} {\n    margin: 3px;\n}\n\n.{{= name }} .filters {\n    padding: 1px 0px;\n}\n\n.{{= name }} .filters .tab {\n    border-color: #888;\n    border-style: solid;\n    border-width: 1px 1px 1px 1px;\n    padding: 0px 1em;\n}\n\n.{{= name }} .filters .tab:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} .filters .tab.highlighted {\n    background-color: #077;\n}
\\337;C\\246E\\003',\\272\\004\\351\\331\\003|J\\202{\\021\\231\\373M\\361\\005W\\345\\317g\\220M\\361g\\313	new_field_fkey_purpose
\\337\\324\\2166\\370\\263\\356\\376X\\027\\2335\\030\\027\\005\\366\\031\\005\\274\\255\\251\\023\\324n\\303j\\367\\204\\033\\004$v	<div id="{{= id }}" class="{{= name }}">\n    <div class='tab_headers'/>\n    <div class='tab_contents'/>\n</div>
\\337m\\275\\267_\\325#\\224\\313\\015\\202\\002)\\356\\366\\221\\272)?G\\234\\326\\244\\220i\\265C6\\236.\\206e	<div id="{{= id }}" class="{{= name }}">\n    <a href="/dev" target="_blank" style="color: white;">Developer Tools</a>\n    <div class="tabs"></div>\n</div>
\\341t\\322\\036\\316mH\\256g\\371F\\337\\213^\\372\\247\\324AEh\\324\\266\\317H\\374\\367\\200\\302$\\232<\\037	88fccadf-0885-4819-bacb-9359a27a7fc7
\\342\\312#\\033\\355\\366}cn0\\235`\\227\\215\\376\\254\\340\\253\\001\\341\\210\\371*\\235\\224\\036\\205\\314\\205\\346rv	<div id="{{= id }}" class="{{= name }}">\n    <select>\n    </select>\n</div>
\\343\\224\\000\\377\\342\\372\\251\\206\\351\\233\\021\\352~\\022\\257\\211\\006\\325\\206\\311\\370\\275Od*\\224z\\356\\361\\257\\021\\350	<div id="{{= id }}" class="{{= name }}">\n    <ul class='fkeys'></ul>\n    <button class='new'>New</button>\n</div>
\\343\\260\\304B\\230\\374\\034\\024\\232\\373\\364\\310\\231o\\271$'\\256A\\344d\\233\\223L\\244\\225\\231\\033xR\\270U	
\\343\\334\\316\\343\\377\\247~\\211w/d\\304\\021L\\317\\360Q\\000\\2058E\\035\\222:1\\373\\201\\006G\\307\\\\#	967ec665-f37e-470e-b5c9-a2eac0eb9c89
\\344W\\010\\220\\274\\307\\301c\\232~\\2347\\352g\\245\\310\\265h\\206\\376\\276\\017/\\3625g<\\002\\204&Z\\035	endpoint/template
\\344\\013\\206d\\250\\032>\\316\\270\\246\\011!\\317p\\326\\262\\222Ne\\207\\301\\307\\211\\226\\307\\211\\271#:\\032)\\215	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation;\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\344\\260\\206e\\262Q\\033\\310l\\247\\317\\021\\026\\364\\244\\3374\\354\\\\\\177\\012\\0312\\236\\026l\\330\\240\\016\\206#\\202	return {};
\\345P\\202\\261 \\243\\\\g(\\373o)\\025\\236\\320\\013\\037\\234\\307vn\\364*R3z\\303\\300\\233\\017\\340w	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    padding-left: 10rem;\n    \n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    padding: 1.5rem;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .sections {\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: 2rem 0.5rem;\n}\n\n.{{= name }} .section {\n    cursor: pointer;\n    cursor: hand;\n    padding: 20px;\n    text-align: center;\n    border: 1px solid gray;\n    color: gray;\n    width: 9em;\n    box-sizing: border-box;\n}\n\n.{{= name }} .icon {\n    font-size: 300%;\n}\n\n.{{= name }} .section:hover {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} .section.selected {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} .section_content > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\345\\021\\357\\0330\\365\\015\\275qM\\300\\366\\205\\025\\344\\014\\360F\\227H\\324]\\316\\242\\311\\204\\252^6<\\031\\274	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n    w.find('.text_id').click(function() {\n        w.trigger('bundle_row_open', { row_id: change.get('row_id'), row: real_row });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// tracked\nif (change.get('change_type') == 'tracked') {\n    w.find('button.untrack').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:stage_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:stage_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    // console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('button.untrack').click(function() {\n    endpoint.schema('bundle').function('untrack_row', [\n        bundle.get('name'),\n        schema_name,\n        relation_name,\n        pk_column_name,\n        pk_value\n    ]).then(function() {\n        w.remove();\n    }).catch(function(e) {\n        show_error(e);\n    });\n});\n\nw.find('.modified_link').click(function() {\n    w.append(widget('ide:modal', {\n        content: widget('ide:stage_row_changed_diffs', {\n            \n            stage_field_changes: change.get('stage_field_changes'),\n            stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n            stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n            \n            offstage_field_changes: change.get('offstage_field_changes'),\n            offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n            offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n            \n            bundle: bundle\n        })\n    }));\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_stage_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n
\\345\\310\\324\\001\\037\\245\\311\\205Z\\2038\\312!\\002\\265K\\233\\336t\\342\\336\\221\\021`\\343\\255(R\\340&/\\236	4a7f3178-5d7b-4fab-a1ec-aadb2d2d21fa
\\346A\\336\\333nn\\274\\024\\310\\250\\307(3(n\\365\\335\\316lJ\\2660\\302\\305\\355\\250j\\272V~Af	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('ide:code_editor', { field: field, language: 'javascript' }) }}\n</div>
\\346\\207\\242\\342n\\300\\200\\360\\274I\\336\\014\\022\\205F\\251'\\265_\\344\\342\\237\\365\\366n<2\\316\\335\\331)\\207	.{{= name }} {\n    cursor: pointer;\n}\n\n.{{= name }}:hover {\n    background-color: #336;\n}
\\347 \\241\\253\\261\\267\\206\\277\\010\\344<[\\276\\206\\031\\025gni\\333r\\240\\362\\034\\262\\321^\\004\\370\\272\\360s	.{{= name }} {\n} \n\n.{{= name }}:not(.displaying) > .display {\n    display: none;\n}\n\n.{{= name }} > .display:hover {\n    text-decoration: underline;\n    cursor: hand;\n    cursor: pointer;\n}\n\n.{{= name }}:not(.editing) > .edit {\n    display: none;\n}\n\n.{{= name }}:not(.saving) > .save {\n    display: none;\n}\n
\\347\\213pb\\331\\351\\032\\245\\300\\342\\344A\\316\\304\\015\\337\\225\\305\\240\\007\\213\\022+N\\202\\202\\353\\247\\213P?\\002	stage_dialog_staged_row
\\347\\272\\356n'zsm\\245$#\\016\\313\\3573\\322\\012M\\362\\353\\022\\366\\254\\015z\\305N1\\300E"\\252	.{{= name }} .bulk_action {\n    border-bottom: 1px solid blue;\n}
\\350G\\215\\272c^u\\323\\255\\244\\005\\002\\251B\\367-%)\\355@\\2074\\3360u\\240U\\315\\307I\\222V	<li id="{{= id }}" class="{{= name }}">\n    {{= label_function(row) }} <button class='delete'>[ X ]</button>\n</li>
\\352I\\\\\\340\\232\\324-\\316\\014\\201\\270\\220\\374\\234\\217AH\\217\\277\\002~-\\212\\247\\021\\247D\\205\\326\\326\\321\\022	e74a4129-6e37-49d2-9391-0f6d99d8fd79
\\352\\206f\\005\\206U&,\\034;\\220\\013{D\\326.\\367\\027\\270\\030\\330\\217\\017\\352\\335\\213q+\\367\\3253\\013	bundle_untracked_row
\\354/q\\305\\014\\321\\211Vem\\033w\\312\\036\\344[%{\\236\\265\\361\\240\\317\\020\\243|a\\037\\266\\250\\036L	bundle_untracked
\\355,)\\314Z\\3350\\337u\\344\\357od\\010i\\024\\006\\356\\322\\315\\374\\027Ej\\377u\\376\\315\\350\\310\\277\\261	<div id="{{= id }}" class="{{= name }}">\n    <!--\n    <div class='tabs'>\n        <div class='tab localhost'>bundles</div>\n        <div class='tab untracked'>untracked</div>\n    </div>\n\t-->\n    <div class='container'>\n        <div class='bundles'>\n            <button class='new'>new bundle</button>\n            <button class='import'>import</button>\n            <button class='hub'>hub</button>\n        </div>\n    </div>\n</div>
\\355\\010\\362k\\304\\306\\301\\227?\\300\\250\\306\\237q9\\325-\\352*\\255o\\316+\\266\\346\\002\\037R\\264\\331\\033\\347	129c7484-653d-4206-b81a-a703e87a491a
\\355\\206l\\304\\204\\034p\\353\\347Jl\\246\\270\\244\\302\\222\\020-\\334\\364m\\341\\222'\\254S\\200(7Rvc	<div id="{{= id }}" class="{{= name }}">\n    <!--<p>For the time being, use copy to create a new row in this table instead</p>\n\n    <small>Press ESC to return</small>\n    <button class='exit'>Exit</button>\n    <p>You really should have just copied this... but anyway</p>\n-->\n    <input class='path' type='text' placeholder='/my_new_resource'>\n    <select class='mimetype'></select>\n    <button class='save'>Save</button>\n</div>
\\356(<\\304L\\243\\214\\274\\350\\235\\373\\224\\246v\\313\\352\\356,\\273\\364\\274Y\\333A\\342S:\\232\\221\\321;\\025	18b4a552-9546-4194-89a3-059bd71838db
\\356\\311L\\3137\\200&\\321\\011\\333\\214)\\000\\202*\\243\\357MK`\\370\\205\\005\\320\\253I\\374\\253*\\237c]	<div id="{{= id }}" class="{{= name }}">\n    A template can be served up at a particular URL path, or multiple paths.\n    \n    <div class='routes'>\n    </div>\n    \n    <button class='new'>add route</button>\n</div>
\\356q\\274\\235}\\375\\317\\373\\373\\034\\030\\002\\261v\\322\\025\\376\\253V\\011#\\325\\300\\360\\031\\241\\253\\020E\\267x\\236	var w = $("#"+id);\n\n/*\nthis is pretty much crap.\nyeah.  this really is total crap.\ndo we really want to ahve to go thru bundle.tracked_row here?  how about just putting bundle_id back on ignored_*?  seems more righter, but means we hae to import/export those tables as well.  but... ignore rules really are a part of the bundle, so it seems to make sense.\n*/\nbundle.related_rows('id','bundle.tracked_row','bundle_id', {\n    where: [\n        {\n            name: 'bundle_id',\n            op: '=',\n            value: bundle.get('id')\n        }, {\n            name: '(row_id::meta.relation_id).name',\n            op: '=',\n            value: 'ignored_schema'\n        }\n    ]\n}).then(function(tracked_row) {\n    widget.sync(ignored_schema, w.find('.schema'), function() {\n        return widget('ide:bundle_ignored_schema', { row_id: tracked_row });\n    });\n});
\\357&\\016\\232\\243\\306s\\257$\\015\\027\\242f\\004\\2006\\032\\216\\010\\035\\037\\376\\312*^\\320\\343!\\237\\301\\205g	dev
\\357\\230\\013\\227\\307\\374\\304\\025?i\\207\\276\\340\\242\\356P\\322\\235\\002\\332i\\272\\007\\344\\203\\271\\306\\030D\\317\\336\\340	var w = $("#"+id);\n\nw.find('.delete_bundle_oh_no').click(function() {\n    if(confirm('Are you sure you really want to PERMANTENTLY DELETE this bundle?')) {\n        bundle.delete().then(function() {\n            alert ('gone.');\n        }).catch(function() {\n            alert('failed.');\n        });\n    }\n});\n\n\nw.find('.rename').click(function() {\n    alert('coming soon....');\n});\n\n\n
\\357\\267Yu\\271\\367\\274@\\020\\006\\342\\366\\221\\345\\376%\\336K\\023\\252\\367\\226\\026k\\035n\\00366\\277\\3118	5958da09-33b4-455c-a50f-05896aa1a7cc
\\357\\3350C\\373\\273\\342n\\325\\226\\311v\\204\\205\\330K[\\330\\212D\\000"\\321\\362\\025\\265\\020E'\\272\\304?	206646d9-7fe3-45c2-8db1-56fa22bc62c6
\\357c\\3562\\307\\300\\307+\\264\\222!\\355\\302\\277\\305\\230N)v\\356\\001\\274\\210=j8\\200\\365\\252\\255K\\254	<div id="{{= id }}" class="{{= name }}">\n    <h2>Push/Pull</h2>\n    \n    <h2>Remotes</h2>\n    \n    <p>A remote is another database that you wish to share your bundles with.  You can push and pull changes with another remote.</p>\n    \n    <div class="remotes"></div>\n    \n    <button class='new_remote'>New Remote</button>\n\n</div>
\\360V\\373\\301B\\271l:<\\023x\\201$\\255\\250\\275[@x\\361\\0172\\036\\307D\\376\\320\\215\\202\\273\\337\\022	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}\n\n.{{= name }} > .edit {\n    display: none;\n    padding: 0.25rem;\n    float: right;\n}\n\n.{{= name }}:hover > .edit {\n    display: initial;\n}\n
\\360\\326\\275\\335M\\337\\303\\315\\353\\243\\224Al\\303\\211\\273\\271\\217\\321\\262\\250\\3244O\\227\\302\\2770\\332#\\2115	.{{= name }} {\n    position: relative;\n    height: 100%;\n    text-align: left;\n}\n\n\n/* BASICS */\n.CodeMirror {\n    /* Set height, width, borders, and global font properties here */\n    height: 100% !important;\n    font-family: monospace;\n    height: auto;\n}\n\n.CodeMirror-scroll {\n    /* Set scrolling behaviour here */\n    overflow-y: hidden;\n    overflow-x: auto;\n}\n\n.CodeMirror-hscrollbar {\n    display: none;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n    padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre {\n    padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler {\n    background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n    border-right: 1px solid #ddd;\n    background-color: #f7f7f7;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n    padding: 0 3px 0 5px;\n    min-width: 20px;\n    text-align: right;\n    color: #999;\n}\n\n/* CURSOR */\n\n.CodeMirror div.CodeMirror-cursor {\n    border-left: 1px solid black;\n    z-index: 3;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n    border-left: 1px solid silver;\n}\n.CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor {\n    width: auto;\n    border: 0;\n    background: #7e7;\n    z-index: 1;\n}\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror div.CodeMirror-cursor.CodeMirror-overwrite {}\n\n.cm-tab { display: inline-block; }\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable {color: black;}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3 {color: #085;}\n.cm-s-default .cm-property {color: black;}\n.cm-s-default .cm-operator {color: black;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-error {color: #f00;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n\n.cm-invalidchar {color: #f00;}\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\nthe editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n    line-height: 1;\n    position: relative;\n    overflow: hidden;\n    background: white;\n    color: black;\n}\n\n.CodeMirror-scroll {\n    /* 30px is the magic margin used to hide the element's real scrollbars */\n    /* See overflow: hidden in .CodeMirror */\n    margin-bottom: -30px; margin-right: -30px;\n    padding-bottom: 30px; padding-right: 30px;\n    height: 100%;\n    outline: none; /* Prevent dragging from highlighting the element */\n    position: relative;\n}\n.CodeMirror-sizer {\n    position: relative;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\nbefore actuall scrolling happens, thus preventing shaking and\nflickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler {\n    position: absolute;\n    z-index: 6;\n    display: none;\n}\n.CodeMirror-vscrollbar {\n    right: 0; top: 0;\n    overflow-x: hidden;\n    overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n    bottom: 0; left: 0;\n    overflow-y: hidden;\n    overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n    right: 0; bottom: 0;\n    z-index: 6;\n}\n\n.CodeMirror-gutters {\n    position: absolute; left: 0; top: 0;\n    height: 100%;\n    padding-bottom: 30px;\n    z-index: 3;\n}\n.CodeMirror-gutter {\n    height: 100%;\n    padding-bottom: 30px;\n    margin-bottom: -32px;\n    display: inline-block;\n    /* Hack to make IE7 behave */\n    *zoom:1;\n    *display:inline;\n}\n.CodeMirror-gutter-elt {\n    position: absolute;\n    cursor: default;\n    z-index: 4;\n}\n\n.CodeMirror-lines {\n    cursor: text;\n}\n.CodeMirror pre {\n    /* Reset some styles that the rest of the page might have set */\n    -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n    border-width: 0;\n    background: transparent;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    white-space: pre;\n    word-wrap: normal;\n    line-height: inherit;\n    color: inherit;\n    z-index: 2;\n    position: relative;\n    overflow: visible;\n}\n.CodeMirror-wrap pre {\n    word-wrap: break-word;\n    white-space: pre-wrap;\n    word-break: normal;\n}\n.CodeMirror-linebackground {\n    position: absolute;\n    left: 0; right: 0; top: 0; bottom: 0;\n    z-index: 0;\n}\n\n.CodeMirror-linewidget {\n    position: relative;\n    z-index: 2;\n    overflow: auto;\n}\n\n.CodeMirror-widget {\n    display: inline-block;\n}\n\n.CodeMirror-wrap .CodeMirror-scroll {\n    overflow-x: hidden;\n}\n\n.CodeMirror-measure {\n    position: absolute;\n    width: 100%; height: 0px;\n    overflow: hidden;\n    visibility: hidden;\n}\n.CodeMirror-measure pre { position: static; }\n\n.CodeMirror div.CodeMirror-cursor {\n    position: absolute;\n    visibility: hidden;\n    border-right: none;\n    width: 0;\n}\n.CodeMirror-focused div.CodeMirror-cursor {\n    visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n\n.cm-searching {\n    background: #ffa;\n    background: rgba(255, 255, 0, .4);\n}\n\n/* IE7 hack to prevent it from returning funny offsetTops on the spans */\n.CodeMirror span { *vertical-align: text-bottom; }\n\n@media print {\n    /* Hide the cursor when printing */\n    .CodeMirror div.CodeMirror-cursor {\n        visibility: hidden;\n    }\n}\n\n\n\n/* Based on Sublime Text's Monokai theme */\n\n.cm-s-monokai.CodeMirror {background: #272822; color: #f8f8f2;}\n.cm-s-monokai div.CodeMirror-selected {background: #49483E !important;}\n.cm-s-monokai .CodeMirror-gutters {background: #272822; border-right: 0px;}\n.cm-s-monokai .CodeMirror-linenumber {color: #d0d0d0;}\n.cm-s-monokai .CodeMirror-cursor {border-left: 1px solid #f8f8f0 !important;}\n\n.cm-s-monokai span.cm-comment {color: #75715e;}\n.cm-s-monokai span.cm-atom {color: #ae81ff;}\n.cm-s-monokai span.cm-number {color: #ae81ff;}\n\n.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute {color: #a6e22e;}\n.cm-s-monokai span.cm-keyword {color: #f92672;}\n.cm-s-monokai span.cm-string {color: #e6db74;}\n\n.cm-s-monokai span.cm-variable {color: #a6e22e;}\n.cm-s-monokai span.cm-variable-2 {color: #9effff;}\n.cm-s-monokai span.cm-def {color: #fd971f;}\n.cm-s-monokai span.cm-error {background: #f92672; color: #f8f8f0;}\n.cm-s-monokai span.cm-bracket {color: #f8f8f2;}\n.cm-s-monokai span.cm-tag {color: #f92672;}\n.cm-s-monokai span.cm-link {color: #ae81ff;}\n\n.cm-s-monokai .CodeMirror-matchingbracket {\n    text-decoration: underline;\n    color: white !important;\n}\n\n\n.cm-s-blackboard.CodeMirror { background: #0C1021; color: #F8F8F8; }\n.cm-s-blackboard .CodeMirror-selected { background: #253B76 !important; }\n.cm-s-blackboard .CodeMirror-gutters { background: #0C1021; border-right: 0; }\n.cm-s-blackboard .CodeMirror-linenumber { color: #888; }\n.cm-s-blackboard .CodeMirror-cursor { border-left: 1px solid #A7A7A7 !important; }\n\n.cm-s-blackboard .cm-keyword { color: #FBDE2D; }\n.cm-s-blackboard .cm-atom { color: #D8FA3C; }\n.cm-s-blackboard .cm-number { color: #D8FA3C; }\n.cm-s-blackboard .cm-def { color: #8DA6CE; }\n.cm-s-blackboard .cm-variable { color: #FF6400; }\n.cm-s-blackboard .cm-operator { color: #FBDE2D;}\n.cm-s-blackboard .cm-comment { color: #AEAEAE; }\n.cm-s-blackboard .cm-string { color: #61CE3C; }\n.cm-s-blackboard .cm-string-2 { color: #61CE3C; }\n.cm-s-blackboard .cm-meta { color: #D8FA3C; }\n.cm-s-blackboard .cm-error { background: #9D1E15; color: #F8F8F8; }\n.cm-s-blackboard .cm-builtin { color: #8DA6CE; }\n.cm-s-blackboard .cm-tag { color: #8DA6CE; }\n.cm-s-blackboard .cm-attribute { color: #8DA6CE; }\n.cm-s-blackboard .cm-header { color: #FF6400; }\n.cm-s-blackboard .cm-hr { color: #AEAEAE; }\n.cm-s-blackboard .cm-link { color: #8DA6CE; }
\\361\\252\\242\\334\\024+B\\345\\244N\\334\\001\\311]~\\030{\\024I\\341u\\272\\243`\\304i\\304\\302\\323\\327\\316;	<div id="{{= id }}" class="{{= name }}">\n    <p class='title'>\n        <span class='name'></span>\n        <span class='version'>Version:</span>\n    </p>\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <div class='section_content'></div>\n    </div>\n</div>
\\361y`\\347\\027\\256\\221`\\324\\347.\\325\\304\\205\\325\\340\\326\\015\\220\\363pT\\034\\310|b\\246\\032\\256\\306\\277p	0d106cc7-33b0-4afe-9472-3aca86e66bbb
\\362U\\335?\\306(N:P\\201\\252\\333\\222u\\312\\002D\\361XW\\212D\\352\\034\\306\\322\\006\\230>L\\332\\243	<div id="{{= id }}" class="{{= name }}">\n    <h3>CHANGE!</h3>\n    <table width=100%>\n        <tr>\n            <th>old value</th>\n            <th>new value</th>\n        <tr>\n            <td class="old_val" valign=top width=50%></td>\n            <td class="new_val" valign=top width=50%></td>\n        </tr>\n    </table>\n</div>
\\362\\222\\000\\243\\265\\354p\\036\\240\\201\\270\\347::^V\\314\\241\\204\\322\\355f\\003\\274\\227\\031\\\\+\\267O\\246l	template_routes
\\363I\\205s\\270\\233\\374p\\256\\374\\001\\357\\271o\\272\\343L\\334\\011~\\006i\\311\\207w\\371\\000G\\210\\023bm	486d1939-8093-40b9-b790-a6d1675727c8
\\363\\242fW\\312\\207\\230\\370\\275\\011\\275\\320\\373\\213\\027\\177I\\241\\364\\031\\242\\262\\025\\377\\261\\357\\303\\214\\266S\\360\\327	var w = $("#"+id);\n\nconsole.log('remote:',remote);\n\nremote.related_row('endpoint_id','endpoint.remote_endpoint','id')\n.then(function(ep) {\n    console.log('ep:', ep);\n    w.find('h2.url').html(ep.get('url'));\n\n    w.find('button.compare').click(function() {\n        w.find('.comparison').show();\n        endpoint.schema('bundle').function('remote_compare_commits', [\n            remote.get('id')\n        ]).then(function(comparisons) {\n            console.log(comparisons);\n\n            $.each(comparisons.rows, function(i, c) {\n                console.log('####',i,c);\n                w.find('.comparison').append(widget('ide:bundle_remote_commit_comparison_row', {\n                    comparison: c\n                }));\n            });\n        });\n\n    });\n\n\n    w.find('button.push').click(function() {\n        var push_results = endpoint.schema('bundle').function('remote_push', [ remote.get('id') ]);\n        $.when(push_results).then(function(r) {\n            console.log(r);\n        });\n    });\n\n\n    w.find('button.pull').click(function() {\n\n    });\n\n});\n
\\363\\314\\273\\362\\370\\211\\011\\301\\313c\\277\\342\\340\\267\\347)\\035\\302\\201\\246(\\024\\267\\332|\\302S\\016\\262\\332\\207\\236	.{{= name }} .toggle {\n\tposition: fixed;\n    bottom: 0;\n    right: 1em;\n}\n\n.{{= name }} .debugger_container {\n    display: none;\n}
\\363\\344\\364B\\220\\333O(\\235\\370\\252O\\0344 HY\\0137\\313\\000\\015\\323\\020\\342\\314\\247\\354\\315\\350R\\300	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\363pL\\260\\300\\222\\270g\\242\\214M\\310\\034<\\233&\\244r\\210\\273\\027U\\257\\226\\230\\227\\017\\216\\211\\204(t	290a4947-989a-41fb-bfbb-94e4fe59ebc8
\\365[\\331\\321\\3016\\375\\365\\220#\\005%\\213C;&\\002\\267\\2763\\334w}\\365Pj\\335\\014\\321Q \\343	aad6b1d3-c105-4fba-9fbb-faafa4855ddd
\\366\\262\\254:6\\020\\033n\\341Q\\277L\\013\\001\\301\\3022i\\365\\036[\\256\\217\\272\\200\\226R^\\367\\201l\\231	d5ff5f93-b643-49f7-87b3-5909b35ad026
\\366\\262r\\235\\032\\230I\\344\\003K2SB\\276\\373h!\\002A&&/\\004\\220\\316\\262F\\207\\254&\\011_	75abad58-4f0a-48a4-825c-7ac9423cec0d
\\370\\351oz\\210\\216$~\\356\\021\\362u\\350\\204\\025\\371;\\365\\3421\\235\\345MbN\\012\\266U\\2021\\363\\314	.{{= name }} {\n    display: inline-block;\n    width: 50%;\n    padding: 5rem 3rem;\n    background-color: #333;\n    border: 0.25rem solid #222;\n}\n\n.{{= name }} > * {\n    display: block;\n    margin: 0.5rem;\n}\n\n.{{= name }} > input {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > input:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > input:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}
\\372\\211\\205\\311\\004\\221_`\\374]V\\367\\375\\353\\336\\344\\337X\\206\\335\\177\\356\\275\\217\\331\\017*\\360\\241\\011G\\205	<div id="{{= id }}" class="{{= name }}">\n    <nobr>\n        <span class='label'></span>\n        <span class='changes'>\n            <span title='This row has been modified' class='icon modified'>&Delta;</span>\n            <span title='This row has been deleted' class='icon deleted'>-</span>\n            <span title='This row has been added' class='icon added'>+</span>\n            <span title='This row has been added' class='icon tracked'>&#128065;</span>\n            <span title='This row does not exist in the live database' class='icon doesnt_exist'>&#x1f5d1;</span>\n        </span>\n    </nobr>\n</div>
\\372\\304\\237\\245\\204\\266\\266|\\232\\311Y_\\267\\264\\274\\240\\001M\\367\\2263\\267\\022\\236\\207\\275\\271\\355KU\\365\\357	var w = $("#"+id);\n\nw.find('.url_pattern').append(widget('semantics/form_field', route.field('url_pattern')));\nw.find('.args').append(widget('semantics/form_field', route.field('args')));\nw.find('button.delete').click(function() {\n    route.delete().then(function() {\n        w.remove();\n    });\n});\nw.find('button.save').click(function() {\n    console.log('args is ', route.get('args'));\n    console.log('path is ', route.get('path'));\n    \n    route.update()\n    .then(function() {\n        alert ('saved');\n    }).catch(function() {\n        alert ('failed.');\n    });\n});\n
\\372\\333}\\2254i\\200\\305\\015@6\\020\\007\\360\\303k\\266!5~\\343_\\233\\034yWk\\342\\230\\266\\304S	var w = $("#"+id);\nvar tab_links = w.find('> nav > a');\nvar content = w.find('.content');\n\n// tab colors\ntab_links.each(function() {\n    var tab_name = $(this).attr('data-tab');\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n\t    $(this).css('border-left', '10px solid ' + tab_colors[tab_name]);\n    }\n});\n\n\ntab_links.on('click', function() {\n    tab_links.removeClass('selected');\n    var tab_name = $(this).attr('data-tab');\n    w.data('selected_tab', $(this));\n\n    content.html(tabs[$(this).addClass('selected').attr('data-tab')]());\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n        w.css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\n\nif (typeof selected == 'undefined') {\n    tab_links.filter(':first').get(0).click();\n}\nelse {\n    tab_links.filter('[data-tab="' + selected + '"]').get(0).click();\n}\n
\\374\\206y\\363\\226C+\\367\\373\\373\\255\\254~R\\365\\206\\255\\035er|T=\\376\\276B\\253.\\005\\177\\275\\376	var w = $("#"+id);\n\n/* Flushes current styles \n    so initial opacity/background-color/visibility take effect\n      before adding "fade" class */\nw.css('opacity');\n\nw.addClass(type + ' fade');\n\nsetTimeout(function() {\n    w.remove();\n}, 2000);\n
\\374\\246\\316\\206^A:hd\\\\\\324}\\010\\267\\000\\362K\\270O@\\221\\022\\353\\353*Dv\\342\\330q\\372\\214	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <!-- link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'-->\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.2', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            AQ.Widget.import('org.aquameta.ui.auth', 'auth', db);\n            \n            $('body').append(widget('ide:ide'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\374\\307\\311\\315g"SlV\\257\\321\\321\\014\\205\\355$\\367s\\210\\223\\371p\\033{\\377\\035\\277R9\\276\\340\\357	semantics_widget_widget_listitem_identifier
\\375\\270\\035\\257T\\260\\177\\366R\\256\\376\\222(k\\010\\363\\213a\\254\\216\\244K4\\375\\225\\342T\\003\\344\\252i\\343	stage_dialog_unstaged_field
\\377P\\266\\010\\013r\\306m\\035\\371}\\\\\\005K\\036\\020\\362\\312\\320\\211\\205\\366(\\204\\3178\\227\\020.\\203\\366\\336	var w = $("#"+id);\n\nw.find('> .tabs').html(widget('ide:workspace_tabs', { bundle: bundle }));\n\n// config button\nw.find('.tools .config_button').click(function() {\n    w.trigger('open_tab', { tab_id: 'bundle_config' });\n});
\\377\\226\\216H\\366\\027\\242y\\266\\363_\\305\\225\\346\\314\\274d`\\200\\232\\262\\320\\274\\367bp\\\\\\252\\252>\\321\\026	var w = $("#"+id);\n\nvar rel_name = datum.schema.name + '.' + datum.name;\nw.find('.rel_name').text(rel_name);\n\nfunction save(save_as_null) {\n    var val = w.find('.name').val().trim();\n\n    if (save_as_null) {\n        val = null;\n    }\n\n    datum.insert({\n        name: val\n    })\n    .then(function() {\n        w.trigger('status', ['New row on ' + rel_name, 'success']);\n        w.trigger('done');\n    }).catch(function() {\n        w.trigger('status', ['Failed insert on ' + rel_name, 'fail']);\n    });\n}\n\n\n/* TRIGGERS */\nw.find('.save_as_null').on('click', save.bind(this, true));\n\nw.find('.name').on('keyup', function(e) {\n    e.stopPropagation();\n    if (e.key == 13) {\n        save(false);\n    }\n});\n\nw.find('.save').on('click', save.bind(this, false));\nw.on('keydown', jwerty.event('ctrl+s', save.bind(this, false)));\n
\\377\\276\\314\\006\\247\\314+\\\\!!6\\025\\233J\\336u/\\325h\\207\\243\\240\\3437w,\\337`\\330\\255\\352\\371	<span id="{{= id }}" class="{{= name }} displaying">\n    <span class='display'></span>\n    <span class='edit'>\n        <input type='text' value='{{= field.value }}'>\n        <button class='save'>Save</button>\n        <button class='cancel'>Cancel</button>\n        <button class='save_as_null'>Save as null</button>\n    </span>\n    <span class='save'>\n        saving...\n    </span>\n</span>\n
\\377\\303:\\357(\\035CvL\\221q\\306\\200\\202\\3104\\253D*`lHoM\\324\\317\\0317\\344lA\\013	a1a8b72b-59ed-45dc-ac50-dfa5dbb71f43
\\377\\321\\374\\033/\\364\\356\\246\\255I\\262G\\3676\\\\\\355\\344glccd\\353xd5\\225\\230\\253\\255\\3647	sem_fkey_one_to_many_li
\\377\\355\\242R\\337\\314\\254\\322F\\027\\256\\257\\305I}\\022w\\256\\020\\354\\010!vkG\\246\\325w\\013\\275\\372\\353	d38b4273-997a-49bd-bc23-438423620dc9
\\377t\\011\\0006[@\\220R\\271\\242x"q,5\\234\\2707\\272\\364\\326\\337\\346\\007l\\223\\317%\\327\\367-	row_detail_dependency_js
\\\\A\\312\\333\\372i\\224\\343\\000\\377\\020\\301\\347\\301\\233{\\314\\242\\336"\\024\\3455=\\344\\256\\211\\277\\313\\272\\2220	new_row_by_name
\\\\Sx(q5\\271vVXm{H\\372\\312\\343O\\0045\\027J+y\\376\\000\\351=2\\026\\023m\\323	stage_row_changed_diffs
\\\\\\246SV\\351MO\\033_W\\260G~\\345!\\3173\\025\\201X\\305\\007U\\013\\030\\345\\345s8\\004\\211\\377	f8d12582-51c7-43fc-b5f4-3eb9094e0e72
\\x00a6604f711b3951a9c9b92ad213f1ef9ed7907a4736df15c89b1748038e4b63	793960f9-5522-499b-a36e-144f80c8a741
\\x010404bcbbeba19f05574855f723605751727cac878c8a337a4eaa814acfaadc	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .top .title {\n    padding: 0;\n    margin: 0;\n    font-size: 1.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    float: right;\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\x01c41b9e11bde17c942c63b20bebbce0e413d7ce8236b163363dfea882cfabcb	bundle_untracked_row_by_relation
\\x01d77afe570be5cd922566a8e8e5ff47ac697884b293e8402172d79263875b9e	<span id="{{= id }}" class="{{= name }}">\n\tlist_item_identifier\t\n</span>\n
\\x023281e09957a139263dff804274c83f58bf233da6abb8fe32e2619c5ede37a3	.{{= name }} {\n    border: 1px solid white;\n    height: 100%;\n    overflow: auto;\n    padding: 10px;\n}
\\x030b00f2812102719bca2c47c155f5d5cca239014f66d05152d6e4c2c5faeebf	<div id="{{= id }}" class="{{= name }}">\n    A widget can be served up at a particular URL path, or multiple paths.\n    \n    <div class='routes'>\n    </div>\n    \n    <button class='new'>add route</button>\n</div>
\\x03126132feebd323b61bf18fe2017dc5ef13dd17fd386510fde8e7930df6c429	.{{= name }} {\n    display: inline-block;\n    height: 100%;\n}\n\n.{{= name }} > .dropdown {\n    display: none;\n    position: absolute;\n    z-index: 5;\n    top: 1.5rem;\n    right: 0;\n    background-color: black;\n    opacity: 0.9;\n    border-bottom: 0.25rem solid #333;\n    border-left: 0.25rem solid #333;\n}\n\n.{{= name }} > .dropdown > div {\n    width: 100%;\n    padding: 1rem;\n    text-align: left;\n    color: white;\n}\n\n.{{= name }}:hover > .dropdown {\n    display: block;\n}\n\n.{{= name }} > .dropdown > .logout {\n    cursor: pointer;\n}\n\n.{{= name }} > .dropdown > .logout:hover {\n    background-color: #333;\n}\n\n.{{= name }} > .dropdown > .logout:active {\n    background-color: #666;\n}\n
\\x0364b9327e9f6db8a4cc665b66a4785186c379322e2d69affbdf29bf392f6872	3.21
\\x03bf25c98d457711c1e8a7ee3788df5650f2a77532db338bcfdbe740465b6271	fae0b7d9-080e-4637-90dc-95a75a74af02
\\x03d450c88b7375af114af9193638260f8623b418738a0521ff2e6a626cd33c69	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('name') || row.get('id') }}<button class='edit'>Edit</button>\n</li>
\\x04032455b62fcdb2252b66d4e525ed36c5a7e2dc704f0a6c8db0268c3f5f72a1	<section id="{{= id }}" class="{{= name }}">\n    <header>\n        <nobr>\n            <a href="/dev">a q u a m e t a</a>\n        </nobr>\n        <h1><span class='title'></span></h1>\n    </header>\n\n    <div class="content">\n        <div class='row_list_section'/>\n        <div class='workspace_section'/>\n    </div>\n    \n    <footer>\n        Aquameta\n    </footer>\n</section>
\\x04c057e533d43652dc5881daafef06a9b9882df2bea9e3051864d8da513844d9	var w = $("#"+id);\n\n// new row button handler\nw.find('button.new_row').click(       function() { w.trigger('open_tab', { tab_id: 'new_row' }); });\nw.find('button.stage').click(         function() { w.trigger('open_tab', { tab_id: 'stage' }); });\nw.find('button.commit_log').click(    function() { w.trigger('open_tab', { tab_id: 'commit_log' }); });\nw.find('button.bundle_config').click( function() { w.trigger('open_tab', { tab_id: 'bundle_config' }); });\nw.find('button.push_pull').click(     function() { w.trigger('open_tab', { tab_id: 'push_pull' }); });\n\n// filter handlers\nw.find('.filters .all').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\n// filter handlers\nw.find('.filters .changed').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nvar commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    order_by: {\n        column: 'row_id'\n    }\n});\n\n// filter handlers\nw.find('.filters .head').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_commit_row','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nw.find('.filters .all').click();\n\n// listen for triggers from semantic widgets which indicate crud changes to handle\nw.closest('.ide').bind('insert', function(e, o) {\n    alert('insert detected');\n    \n    var row_id = o.row.id;\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_value = row_id.pk_value;\n\n    endpoint.schema('bundle').function('tracked_row_add', [ \n        bundle.get('name'), \n        schema_name, \n        relation_name, \n        pk_column_name, \n        pk_value\n    ]).then(function() {\n        w.trigger('bundle_row_open', { row: o.row, row_id: row_id });\n    }).catch(function (e) {\n        alert('error calling tracked_row_add');\n    });\n});\n
\\x05aa513b891bbe3734cb3032f038e4aeb1ad7b291350bac2edb16c96159ad711	sem_fkey_select
\\x05d53f52c425e2a2d9c91a9ab369e21cfd547a49609e614e16332d90d52fc29d	54461126-acc3-4f77-a3ab-e2b89045828c
\\x0730d16d3355e0797bef6aa38585aab32853a6957ffc4b4b88a54842f043368a	.{{= name }} {\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    \n   \tcursor: pointer;\n  \topacity: 0.95;\n    z-index: 10;\n    overflow: auto;\n    \n  \tbackground-color: black;\n    color: white;\n    font-size: initial;\n    text-align: center;\n}\n\n.{{= name }} > .content {\n    display: inline;\n    cursor: auto;\n}\n
\\x073c1634c496cdb649d1afe0a312bbb4b7e1741b271542e4a436c3b8824b1761	status
\\x07b1ceb8e580abaadff3cca891933f9707da199caf887752b5d761a13dd990b7	var w = $("#"+id);\nvar username = false;\n\n\nfunction get_session_cookie() {\n    return document.cookie.replace(/(?:(?:^|.*;\\s*)SESSION\\s*\\=\\s*([^;]*).*$)|^.*$/, "$1");\n}\n\nfunction logout_and_redirect(url) {\n    // remove session cookie\n    document.cookie='SESSION=';\n\n    // redirect after a timeout\n    setTimeout(function() {\n        w.trigger('auth');\n        //location.reload(true);\n        location.assign(url || '/');\n    }, 1000);\n}\n\n\nendpoint.schema('endpoint').table('current_user').row()\n.then(function(row) {\n\n    var role_name = row.get('current_user');\n    var role_id = { name: role_name };\n    console.log('role name', role_name);\n\n    if (role_name == 'anonymous') {\n        throw 'Not logged in';\n    }\n    if (role_name == 'postgres') {\n        alert('You\\'re logged in as postgres, that\\'s not right, call mickey');\n    }\n\n    return endpoint.schema('endpoint').table('user').row('role_id', role_id);\n\n}).then(function(row) {\n    username = row.get('name') || row.get('email');\n    w.find('.username').html(username);\n}).catch(function(e) {\n    console.log('not logged in:', e);\n    logout_and_redirect();\n});\n\n\n\nw.find('.logout').click(function() {\n\n    var cookie = get_session_cookie('SESSION');\n    if (cookie != null) {\n\n        // there exists a session cookie\n        // look for session in table\n        endpoint.schema('endpoint').table('session').row('id', cookie)\n        .then(function(session) {\n\n            if(!session) {\n                // not logged in\n                return logout_and_redirect();\n            }\n            session.delete().then(function() {\n                // logged out now\n                // redirect\n                logout_and_redirect();\n            });\n        });\n\n    }\n    else {\n        // there is no session cookie\n        logout_and_redirect();\n    }\n});
\\x07b81c31ef33ebbc74dbb4a308e0b5c350da8a14a409e0e0afbc657311f67047	89fb8792-4291-4712-b470-6ff89a016f4a
\\x080cc193da25c469a35fe9796dd9a11f381c97d69bb5a0d6cd94be5749d86ceb	6702454c-5f3c-4dd1-8b74-f854fad327ae
\\x083a2768f5179d96f11b892b4bb9159fc6e1fbd015acedc99830778a855ddc49	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}
\\x08bf1086796a1542a8158d92b46997100acd78d7b05ffd646ecb05f0a129bebd	var w = $("#"+id);\n\n// auth_manager\nw.find('.auth').html(widget('auth:auth_manager'));\n\n\n// redirect if necessary\nvar bundle_name = window.location.hash.split('#')[1];\n\nif (typeof bundle_name == 'undefined') {\n    w.find('.row_list_section').html(widget('ide:bundle_selector'));\n    w.on('bundle_selected', function(e, payload) {\n        \n        w.find('.bundle_selector').remove();\n        bundle_name = payload.bundle_name;\n        window.location.hash = bundle_name;\n        show_bundle();\n    });\n}\nelse {\n    show_bundle();\n}\n\nfunction show_bundle() {\n    endpoint.schema('bundle').table('bundle').row({\n        where: {\n            name: 'name',\n            op: '=',\n            value: bundle_name\n        }\n    }).then(function(bundle) {\n        // load the workspace\n        w.find('.workspace_section').html(widget('ide:workspace', { bundle: bundle }));\n        w.find('.row_list_section').html(widget('ide:row_list', { bundle: bundle }));\n        w.find('header .title').html(bundle.get('name'));\n    });\n\n}
\\x09787c47226922e272b3b97467749131b99227185fc322133d8d6ad5eec5b9fc	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .title {\n    padding: 1.5rem 0;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .title > span:nth-child(2) {\n    padding: 0 1rem;\n    font-size: 1rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\x09a77ebba97985e8052b481293163e6744018ead6a88238cfbb1c661d1fb0419	var w = $("#"+id);\n\nw.data('row_id', row.get('row_id'));\n\nvar schema_name = row.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = row.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = row.get('row_id').pk_column_id.name;\nvar pk_value = row.get('row_id').pk_value;\n\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n    \n    w.find('.label').html(widget('semantics/text_identifier', real_row ));\n    \n\t// click handler needs real_row, so put the handler in here after real_row is loaded\n    w.find('.label').click(function() {\n        w.trigger('bundle_row_open', { row_id: row.get('row_id'), row: real_row });\n    });\n    return real_row;\n\n}).catch(function(e) {\n    console.log(e);\n\tw.find('.label').html(schema_name+'.'+relation_name+'.'+pk_value);\n}).then(function() {\n    //w.show();\n    w.find('.label > *').ready(function() {\n        w.show();\n    });\n});\n\n\n
\\x09b94bd3b76ff8f60030c57ccf93148637af21c8c4e31975e335eff8e4c7bf74	commit_dialog_changed_row
\\x09ed692a5582d4632d6498170a84a4e79167d7a3aa2e5e53d0fc978cb367ff61	row_detail_template
\\x0a1b0ea9c7b0e4e447c37ccdd6ba6773a0029a074409eebdb7dd5966efbf1153	stage_dialog
\\x0abec9113e597b7c35202552e84b91ce0d41fda20690358cc5d93893a4b43e28	<div id="{{= id }}" class="{{= name }}">\n    <h1>template: <span class='name'></span></h1>\n    \n    <h3>Routes</h3>\n    <div class='routes'></div>\n    \n    <h3>Content</h3>\n    <div class='content'></div>\n</div>
\\x0b234982b8a26ebbe6ee960838610c1e88e0bb5617b746432c865f0da70c409f	var w = $("#"+id);\n\nw.css('padding-left', depth+'em');\n\nfunction get_ids() {\n    var ids = '';\n    if (properties.ids.length > 0)\n        ids = '#'+properties.ids.join(',#');\n    return ids;\n}\n\nw.bind('mouseover', function(e) {\n    $(get_ids()).addClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\nw.bind('mouseout', function(e) {\n    $(get_ids()).removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n// recurse for each child\nfor (var child_name in properties.children) {\n    var child = properties.children[child_name];\n\n    w.after(widget('debugger3_widgets_tree', { \n        widget_name: child_name,\n        properties: child,\n        depth: depth+1\n    }));\n}\n\n// launches the widget editor in a modal, editing the specified widget\nfunction edit_widget_by_name(widget_name) {\n    endpoint.schema('widget').table('widget').row('name', widget_name).then(function(widget_row) {\n        $('body').append(\n            widget('modal', { \n                content: widget('row_detail_widget', { row: widget_row })\n            })\n        );\n    });\n}\n\nw.click(function(e) {\n    e.stopPropagation();\n    edit_widget_by_name(widget_name);\n});\n\n\n
\\x0b611c683cb76b316ad8b11d86949ee9798c9757c73efa1fd7440d3989837a81	<div id="{{= id }}" class="{{= name }}">\n    <h3>Untracked Rows</h3>\n    \n    <input type='checkbox' class='checkall'>\n    <button class='ignore'>ignore</button>\n    <button class='track'>add to {{= bundle.get('name') }}</button>\n    <button class='delete'>delete</button>\n    \n    <div class='rows'>\n    </div>\n</div>
\\x0b89118d2fe5c31f13d95176dba7ecdc7eb9ebeaaf8d28e28b14a68f337c9276	d1874571-9b11-4ecf-a65d-454de53683b7
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0c87477421d570dee7f2663b98c1f6133a60a7f0c229c12985541c1c9e953a7a	var w = $("#"+id);\n\nw.click(function() {\n    w.trigger('bundle_selected', { bundle_name: bundle.get('name') });\n});
\\x0e00937fe9c342742e72e9d153d811e309f4f53c94e4d80f3c751bf9562bd9f4	var w = $("#"+id);\n\n\nfor (var i=0;i<stage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:commit_dialog_staged_field', {\n        field: stage_field_changes[i],\n        old_val: stage_field_changes_old_vals[i],\n        new_val: stage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}
\\x0e45216c1a8e7efbd319887eea33cd6406e2c819154379307aa1c04a712fa0a9	<div id="{{= id }}" class="{{= name }}">\n    <div class='loading'>Loading...</div>\n    <div class='loaded hide'>\n        <input type="text" class="autocomplete" placeholder='Text search'/>\n        <button class="cancel">Cancel</button>\n        <div class='results'></div>\n    </div>\n</div>
\\x1020d41415a97f9e11bf653153dae01e3c39a73c38ac2a5f2d3c306936a0a29a	<div id="{{= id }}" class="{{= name }}">\n    <button class='new_row'>new row</button>\n    <button class='stage'>stage</button>\n    <button class='commit_log'>history</button>\n    <button class='push_pull'>&#8644;push/pull</button>\n    <button class='bundle_config'>&#9881;config</button>\n    <button class='untracked'>&#9881;untracked</button>\n    <button class='export'>&#9881;export</button>\n    <button class='ignored'>&#9881;ignored</button>\n\n    <div class='filters'>\n        <span class='tab all'>all</span>\n        <span class='tab changed'>changed</span>\n        <span class='tab head'>head</span>\n    </div>\n    <div class='bundle_contents'>\n    </div>\n</div>
\\x1046d4df2c53d2eb490738489bb3c64546cd081dec2c3aaae91430a1c624e10d	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    \n    border-top: 1px solid #333;\n}\n\n.{{= name }}.expanded {\n    background-color: #333;\n    color: #aaa;\n}\n\n.{{= name }}:not(.expanded):hover {\n    background-color: #666;\n}\n\n.{{= name }}:not(.expanded):active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }} > .arrow {\n    display: inline-block;\n    margin: 0 0.5rem;\n    font-size: x-large;\n    vertical-align: sub;\n    \n    transform: rotate(270deg);\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    -moz-transform: rotate(270deg);\n    \n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }}.expanded > .arrow {\n    transform: rotate(90deg);\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    -moz-transform: rotate(90deg);\n}\n\n.{{= name }} > .empty {\n    display: block;\n    text-align: center;\n}\n\n.{{= name }} > .empty.hide {\n    display: none;\n}\n\n.{{= name }}:not(.expanded) > .list {\n    display: none;\n}\n
\\x11734027aaecc5c01900ee8848d646218cc5fe945c47b3bea85ad4d206b62f19	stage_dialog_staged_field
\\x125b7d4865c3f0f08f49ce41bef7c2ff866deeddd999052471f1b8ee4392d440	<div id="{{= id }}" class="{{= name }}">\n    <h2 class="url"></h2>\n\n    <div class="actions">\n        Actions:\n        <button class="compare">compare</button> <button class="push">push</button> <button class="pull">pull</button>\n    </div>\n\n    <h3>Comparison</h3>\n    <p>This bundle's commits locally, compared with the commits in the remote bundle.</p>\n    \n    <table class="comparison" border=1>\n        <tr>\n            <th>local commit id</th>\n            <th>remote commit it</th>\n        </tr>\n    </table>\n</div>
\\x141693a2cdb29c839cb8bc1793cb647f0926a45c7feda6879919c2aef6868993	b4ac3add-5bdc-4faa-be77-96399ad5e7c9
\\x14be4b45f18e0d8c67b4f719b5144eee88497e413709d11d85b096d8e2346310	0.1
\\x14cf8b4011ab08d78b9bfd12a5fdc1979f8f185da80186cac56ee8008bbe7a24	a88f985c-48c3-4f25-bb95-05901e4fff54
\\x156a6d62ed9ee5ae4c55d4b416f7682336a74641eb791b0f36ebdd6aa68dfa28	ignore_modal
\\x1654d6442f4c235d9a7a8b7febcca45d0ad960197cc66bd9764876b009e337bf	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.2', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            AQ.Widget.import('org.aquameta.ui.auth', 'auth', db);\n            \n            $('body').append(widget('ide:ide'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\x16980d3446c178cb1a427abe8a28ff32a7344ede04abcc59c346813a65aeafc8	12fa26f1-b310-44c1-bd4e-f788d1ba3357
\\x177bbf222c75409a7e804de9bc310e04ec38997a8e251a0212214f1bf18a50c6	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n    w.find('.text_id').click(function() {\n        w.trigger('bundle_row_open', { row_id: change.get('row_id'), row: real_row });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:commit_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:commit_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('.modified_link').click(function() {\n    alert ('coming soon...');\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_commit_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n\n\n\n\n
\\x17e41f8d8f86945ea118cd7c0cd24041203c00f69ef12aad9e8283df74b46efc	sem_fkey_many_to_many_li
\\x189edac99df612a9d7c1707893349300a9287919f92ed7cbbdd6bf5fcd1c19cc	3ec63054-336c-4144-94ba-01edd5138cd4
\\x19ee06d9ffad9ef96abeb93569804e8324776f75b4f542855b2e257d657005cb	var w = $("#"+id);\n\nendpoint.schema('endpoint').table('template_route').rows({\n    where: {\n        name: 'template_id',\n        op: '=',\n        value: template.get('id')\n    }\n}).then(function(routes) {\n    widget.sync(routes, w.find('.routes'), function(route) {\n        return widget('ide:template_route', { route: route });\n    });\n\n});\n\n\nw.find('button.new').click(function() {\n    if (path = prompt('Enter the URL path of the route to add to this template')) {\n        endpoint.schema('widget').table('template_route').insert({\n            path: path,\n            template_id: template.get('id')\n        }).then(function(route) {\n            w.find('.routes').append(widget('ide:template_route', { route: route }));\n        });\n    }\n});
\\x1b4f46b53e9146e1c985912dc567d04c0a3c90dc522bdc4196235461210a329d	bundle_remote_new
\\x1b926038b754d88681986e1c323220191cb4670bba0feda21ca224fbf1c6d98f	var w = $("#"+id);\n\n/*\n\tWe should really be using list_item_identifier_widget for this label\n    TODO: replace label_function with semantics lookup\n*/\n\n\n// Less destructive way to delete fkey reference\nw.find('.delete').click(function() {\n    row.set(to_column, null);\n    row.update()\n    .done(function(updated_row) {\n        console.log('Fkey updated', updated_row);\n        w.trigger('fkey_updated');\n        w.trigger('reload');\n    });\n});\n\n/*\n//\n// If we want to delete the foreign row\n// But I think it is preferrable that we set foreign key to null instead\n//  \nw.find('.delete').click(function() {\n    row.delete()\n    .done(function() {\n        console.log('Fkey deleted');\n        w.trigger('fkey_deleted');\n        w.remove();\n    });\n});\n*/
\\x1bd8be09f8ed2bbfed93f015b8d642d0bb2cfa87b09d25b026dc7ce32d53079a	var w = $("#"+id);\nvar username = false;\n\n\nfunction get_session_cookie() {\n    return document.cookie.replace(/(?:(?:^|.*;\\s*)SESSION\\s*\\=\\s*([^;]*).*$)|^.*$/, "$1");\n}\n\nfunction logout_and_redirect(url) {\n    // remove session cookie\n    document.cookie='SESSION=';\n\n    // redirect after a timeout\n    setTimeout(function() {\n        w.trigger('auth');\n        //location.reload(true);\n        location.assign(url || '/');\n    }, 1000);\n}\n\nendpoint.schema('endpoint').table('current_user').row()\n.then(function(row) {\n\n    var role_name = row.get('current_user');\n    var role_id = { name: role_name };\n    console.log('role name', role_name);\n\n    if (role_name == 'anonymous') {\n        throw 'Not logged in';\n    }\n    if (role_name == 'postgres') {\n        alert('You\\'re logged in as postgres, that\\'s not right, call mickey');\n    }\n\n    return endpoint.schema('endpoint').table('user').row('role_id', role_id);\n\n}).then(function(row) {\n    username = row.get('name') || row.get('email');\n    w.find('.username').html(username);\n}).catch(function(e) {\n    console.log('not logged in:', e);\n    logout_and_redirect();\n});\n\n\n\nw.find('.logout').click(function() {\n\n    var cookie = get_session_cookie('SESSION');\n    if (cookie != null) {\n\n        // there exists a session cookie\n        // look for session in table\n        endpoint.schema('endpoint').table('session').row('id', cookie)\n        .then(function(session) {\n\n            if(!session) {\n                // not logged in\n                return logout_and_redirect();\n            }\n            session.delete().then(function() {\n                // logged out now\n                // redirect\n                logout_and_redirect();\n            });\n        });\n\n    }\n    else {\n        // there is no session cookie\n        logout_and_redirect();\n    }\n});
\\x1cb8a0da8c00a8e61df63c92106577fd9d1912d65cf7184d6757a421f408e289	var w = $("#"+id);\n\nconsole.log('selected rows: ', rows);
\\x1ccc4f0095a674f12b76362ca99898aabd7c701fa799b0ed1dcb94043f11fdda	8f0690e2-7883-48d2-898f-e4ce3406b0cc
\\x1ce71d4c2f0e2284d2ba4a76af907cddbc55a9dae9da51b3d6fb767ce7017f87	var w = $("#"+id);\n\n/**********************************\nSOME HANDY DATE FUNCTIONS\n**********************************/\n\n// https://stackoverflow.com/questions/15396637/comparing-javascript-date-time-and-timestamp-from-postgresql\nDate.fromISO= function(s){\n    var day, tz,\n    rx=/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT ][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):(\\d\\d))?$/,\n    p= rx.exec(s) || [];\n    if(p[1]){\n        day= p[1].split(/\\D/);\n        for(var i= 0, L= day.length;i<L;i++){\n            day[i]= parseInt(day[i], 10) || 0;\n        };\n        day[1]-= 1;\n        day= new Date(Date.UTC.apply(Date, day));\n        if(!day.getDate()) return NaN;\n            //adjust for time zone offset:\n        if(p[5]){\n            tz= (parseInt(p[5], 10)*60);\n            if(p[6]) tz+= parseInt(p[6], 10);\n            if(p[4]== '+') tz*= -1;\n            if(tz) day.setUTCMinutes(day.getUTCMinutes()+ tz);\n        }\n        return day;\n    }\n    return NaN;\n}\n\n// https://gist.github.com/hurjas/2660489\n/**\n * Return a timestamp with the format "m/d/yy h:MM:ss TT"\n * @type {Date}\n */\n\nfunction timeStamp(now) {\n// Create an array with the current month, day and time\n  var date = [ now.getMonth() + 1, now.getDate(), now.getFullYear() ];\n\n// Create an array with the current hour, minute and second\n  var time = [ now.getHours(), now.getMinutes(), now.getSeconds() ];\n\n// Determine AM or PM suffix based on the hour\n  var suffix = ( time[0] < 12 ) ? "AM" : "PM";\n\n// Convert hour from military time\n  time[0] = ( time[0] < 12 ) ? time[0] : time[0] - 12;\n\n// If hour is 0, set it to 12\n  time[0] = time[0] || 12;\n\n// If seconds and minutes are less than 10, add a zero\n  for ( var i = 1; i < 3; i++ ) {\n    if ( time[i] < 10 ) {\n      time[i] = "0" + time[i];\n    }\n  }\n\n// Return the formatted string\n  return date.join("/") + " " + time.join(":") + " " + suffix;\n}\n\n\n\n\n\n\nvar date = Date.fromISO(commit.get('time'));\n\n\nw.find('td.date').html(timeStamp(date));\n\nw.find('button.checkout').click(function() {\n    if (confirm('Checking out this commit will OVERWRITE any uncommitted changes and restore the database to the state at this commit.  This could be DESTRUCTIVE.  Are you sure?')) {\n        endpoint.schema('bundle').function('checkout', [ commit.get('id') ]).then(function() {\n            alert ('done');\n        }).catch(function(e) {\n            alert ('failed: '+e.message);\n        });\n    }\n});\n\nif (bundle.get('head_commit_id') == commit.get('id')) {\n    w.find('.head_commit').show();\n}\n\n\n
\\x1d03540dbbd0491fd9fe1ad4a5a6a12220ce9d0adc353a0556ac73a6779e3d51	form_field_javascript
\\x1d631eb21b332112e5629e5b9ce5bfb53c98160103bd272defe5043c3ca69036	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('ide:code_editor', { field: field, language: 'css' }) }}\n</div>
\\x1e57bf8e5dc9c7a270fe10dbd4c58bf0bed40cf298c607636f9e1b84fda71959	var w = $("#"+id);\n\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\nwidget.sync(untracked_rows, w, function(schema) {\n    return widget('bundle_untracked_row_by_schema', { schema: schema });\n});\n\n
\\x1e61db13980716dac6aac448bc652ca078b8e3aa3ac681bdfaa98c40b3b70573	82fa4009-7abb-4f6a-aa42-0d3216516956
\\x1e6ed65d77d6364eeaed5a745ba5c4985ae2b700dd85d7cf7f027bdf294a33fc	bundle
\\x1e7763e90b00279e8e7adfcb5cab24a37575d6fce818ae45430583971fd1def9	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    margin: 0;\n    font-size: 1.5rem;\n}\n\n.{{= name }} > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} > .buttons {\n    float: right;\n    height: 1.75rem;\n    padding-right: 1rem;\n}\n\n.{{= name }} > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\x1ecaf60e2406ea2fbd2d021985bb64e8fc6598f3d904c18cb46931a5bfdec87d	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n    w.find('.text_id').click(function() {\n        w.trigger('bundle_row_open', { row_id: change.get('row_id'), row: real_row });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// tracked\nif (change.get('change_type') == 'tracked') {\n    w.find('button.untrack').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:stage_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:stage_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    // console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('button.untrack').click(function() {\n    if (confirm('Untrack this row and remove it from the project?')) {\n        endpoint.schema('bundle').function('untrack_row', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            w.remove();\n        }).catch(function(e) {\n            show_error(e);\n        });\n    }\n\n});\n\nw.find('.modified_link').click(function() {\n    w.append(widget('ide:modal', {\n        content: widget('ide:stage_row_changed_diffs', {\n            \n            stage_field_changes: change.get('stage_field_changes'),\n            stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n            stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n            \n            offstage_field_changes: change.get('offstage_field_changes'),\n            offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n            offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n            \n            bundle: bundle\n        })\n    }));\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_stage_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n
\\x1f357b8a6a355eae126179aee326c97919e105dbd3fb4b76858efc8ea0b016e1	row_list_row
\\x1fe778a8cff3563cae715ab6c51f8dd5053419c15fa77b80b8719ffe4a6c992f	var w = $("#"+id);\n\nconsole.log('change:',change);\n\nvar editor = CodeMirror(w.find('td.old_val')[0], {\n    value: old_val,\n    mode:  'text/javascript',\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\nfunction change_handler(doc) {\n    //field.set(doc.getValue());\n    //w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor.on('change', change_handler);\n\n\n\n\nvar editor2 = CodeMirror(w.find('td.new_val')[0], {\n    value: new_val,\n    mode:  'text/javascript',\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\nfunction change_handler(doc) {\n    //field.set(doc.getValue());\n    //w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor2.on('change', change_handler);\n
\\x1ff1d3c2ce61ee0a6f6ac55cb37d78caeeb550c2dfb98fa45509f3061ec8b96b	var w = $("#"+id);\n\n\n//endpoint.schema('widget').table('widget').row('name', 'dev_workspace').then(rewrite);\nfunction rewrite(r) {\n    \n    function get_data(str) {\n        // If this does not have 'g' flag there will be an infinite loop\n        var re = /\\/\\*editable_object-(.*)\\*\\/([\\s\\S]*?)\\/\\*end\\*\\//g,\n            arr,\n            obj = {};\n\n        // Safety measure\n        var MAX = 5,\n            counter = 0;\n\n        while ((arr = re.exec(str)) !== null) {\n            if (counter++ > MAX) {\n                break;\n            }\n            /* arr[0] is whole match; arr[1] is object identifier; arr[2] is object data only */\n            obj[arr[1]] = eval(arr[2]);\n        }\n        return obj;\n    }\n \n    function replace(str, ident, new_data) {\n        var re = new RegExp('(\\/\\\\*editable_object-' + ident + '\\\\*\\/)([\\\\s\\\\S]*)(\\/\\\\*end\\\\*\\/)');\n        return str.replace(re, '$1' + JSON.stringify(new_data, null, '\\t') + '$3');\n    }\n    \n    var js = r.get('post_js');\n    var data = get_data(js);\n    var new_js = replace(js, 'tables', data.tables.filter(function(e) {\n        return !(e.schema_name == 'widget' && e.relation_name == 'widget');\n    }));\n\n    // r.set('post_js', new_js).update().then(function(a) { console.log(a); });\n}\n\nvar colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\nvar available_tables = \n    /*editable_object-available*/\n    [\n    {\n        schema_name: 'widget',\n        relation_name: 'widget',\n        order_by: {\n            column: 'name'\n        },\n        include: ['id', 'name']\n    }, {\n        schema_name: 'widget',\n        relation_name: 'bundled_widget',\n    }, {\n        schema_name: 'meta',\n        relation_name: 'table'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'view'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'function'\n    }, {\n        schema_name: 'widget',\n        relation_name: 'dependency_js',\n        order_by: { column: 'name' },\n        include: ['id', 'name', 'version']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'resource',\n        order_by: { column: 'path' },\n        include: ['id', 'path']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'user',\n        order_by: { column: 'name' }\n    }]\n/*end*/\n;\n\nvar tables = \n    /*editable_object-tables*/\n    [\n    {\n        schema_name: 'widget',\n        relation_name: 'widget',\n        order_by: {\n            column: 'name'\n        },\n        include: ['id', 'name']\n    }, {\n        schema_name: 'widget',\n        relation_name: 'bundled_widget',\n    }, {\n        schema_name: 'meta',\n        relation_name: 'table'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'view'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'function'\n    }, {\n        schema_name: 'widget',\n        relation_name: 'dependency_js',\n        order_by: { column: 'name' },\n        include: ['id', 'name', 'version']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'resource',\n        order_by: { column: 'path' },\n        include: ['id', 'path']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'user',\n        order_by: { column: 'name' }\n    }]\n/*end*/\n;\n\n\nvar tabs = {};\nvar tab_colors = {};\ntables.forEach(function(t, i) {\n    var schema_name = t.schema_name;\n    var name = t.relation_name;\n    var relation = endpoint.schema(schema_name).table(name);\n    \n    var obj = {};\n    var keys = Object.keys(t);\n    keys.forEach(function(o) {\n        if (o != 'relation_name' && o != 'schema_name') {\n            obj[o] = t[o];\n        }\n    });\n    \n    tabs[name] = function() {\n        if (!Object.keys(obj).length) {\n            return widget('semantics/list_view', relation);\n        }\n        return widget('semantics/list_view', relation.rows(obj));\n    };\n    \n    tab_colors[name] = colors[i % colors.length];\n});\n\nw.append(\n    widget('tabbed_layout', {\n        base_url: base_url,\n        selected: url_parts[0],\n        tabs: tabs,\n        tab_colors: tab_colors\n    })\n);\n
\\x20948542f9ed46ea7b75a04a6b76db4c15324eed0ed52f2d00fdb5cb8bafc847	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\nendpoint.schema('widget').table('widget').row('id', row.get('id'))\n.then(function(row) {\n    \n    w.find('.widget_id').text(row.get('id'));\n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n    \n\t// html, css, post_js\n    ['html','css','post_js'].forEach(function(col_name, i) {\n        tabs[col_name] = function() {\n            return widget('semantics/form_field', row.field(col_name));\n        };\n        tab_colors[col_name] = colors[i % colors.length];\n    });\n    \n    // input\n    tabs['input'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('input').rows({\n        where: {\n            name: 'widget_id',\n            op: '=',\n            value: datum.get('id')\n        },\n            exclude: ['id', 'widget_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['input'] = colors[4 % colors.length];\n    \n    // dependency_js\n    tabs['dependencies'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('widget_dependency_js').rows({\n            where: {\n                name: 'widget_id',\n                op: '=',\n                value: datum.get('id')\n            },\n            include: ['dependency_js_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['dependencies'] = colors[5 % colors.length];\n\n\n    /* TABBED LAYOUT */\n    // var preview_row = row.clone();\n\n    w.find('> .top > .section_content > .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Widget deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            //set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n            w.trigger('row_detail_save');\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n            //setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.find('.delete').on('click', handle_delete_button);\n\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Widget copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('inserted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x20addba5225aebe4ebed6646ec29b72b940b0fddad2a7d7b7d8b552f9fb58b29	3200bd8c-3230-4df0-b035-78d53aae2aaf
\\x2127fcee590bf0397ca4a10a003788ff7eef62056cd3c082c2c2eb4a361ca712	var w = $("#"+id);\n\n\nvar rel_name = row.relation.schema.name + '.' + row.relation.name;\n\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    w.find('.section_content').append(widget('semantics/form_field', row.field('content')));\n    \n    w.find('.path').append(widget('semantics/form_field', row.field('path')));\n    w.find('.path_link').attr('href', row.get('path'));\n    w.find('.path_button').text(row.get('path'));\n\n    // SAVE\n    function save() {\n        row.update()\n        .then(function() {\n            w.trigger('status', ['Resource saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n        });\n    }\n\n\n    w.find('.save').on('click', save);\n    w.on('keydown', jwerty.event('ctrl+s', save));\n\n\n    // DELETE\n    w.find('.delete').on('click', function() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Resource deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    });\n    \n\n\n    // COPY\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_path = row.get('path') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('path', new_path);\n\n            row.relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Resource copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n\n});
\\x215096f44ab5f27a3442c5ba3849ade94122de549ab58d15cc2719591e6e92f9	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('name') + ' ' + row.get('version') }}\n</li>
\\x21867e0014e56249cf8b6272582e570529f7e517e1650baee71317c0eea9893b	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.1', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:ide'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\x21a3230e03772a58aff1b3709a9e232850916337e1fba95c434076b6668c6e08	workspace
\\x227ae55bd869eedf9afbc17dfc4aa0e4722725413ae5f3fd6ad8644f8e1de4f6	c7e98fc9-4324-4006-9738-ac3d869201ba
\\x239df2de3a3fe418de896855176bf769af52c84a3914f39556847da5dc87b528	<div id="{{= id }}" class="{{= name }}">\n    <ul class='join_rows'></ul>\n    <button class='new'>New</button>\n</div>
\\x23c695f775ff961d43009ca83db5360fa615e361f8bc8b5fce121b234076ffad	stage_field_changed_diff
\\x23e60aa5bd9141b3d7291496696e825c28cb6ec37307ed56be08eb98a122f0f3	d442d653-5e64-4cf7-bd6a-b38ee8a60c42
\\x23f6ae61c1f705b9e873fba8d1ea17552e9c6de2a2a5671286aa636c9d04ea64	var w = $("#"+id);\n\nconsole.log('comparison: ', comparison);
\\x242e0c998dcc8a1b89738fa267ff768fca29427688a9f7490a2b506dd486525a	<div id="{{= id }}" class="{{= name }}">\n    <h1>Stage</h1>\n    \n    <table border=1 class='changes'>\n        <tr><th>row</th><th>change</th><th>unstaged</th><th>staged</th><th>row exists</th></tr>\n    </table>\n\n    <button class='stage_all'>stage all unstaged</button>\n    <button class='untrack_all'>untrack all tracked</button>\n\n    <p><button class='do_commit'>commit staged changes</button></p>\n</div>
\\x248dd1be90addcb21e1ed81edc7a17efdb95c68f793a77310f89e7dae99b599b	var w = $("#"+id);\n\nvar schema_name = row.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = row.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = row.get('row_id').pk_column_id.name;\nvar pk_value = row.get('row_id').pk_value;\n\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n    \n    w.html(widget('semantics/text_identifier', real_row ));\n});\n    \n\n\nw.find('.button').click(function(event) {\n    event.stopPropagation();\n    alert('coming soon');\n\n/*    var row_id = row.get('row_id');\n\n    endpoint.schema('bundle').function('stage_row_add').args({\n        'bundle_name':    bundle.get('name'),\n        'schema_name':    row_id.pk_column_id.relation_id.schema_id.name,\n        'relation_name':  row_id.pk_column_id.relation_id.name,\n        'pk_column_name': row_id.pk_column_id.name,\n        'pk_value':       row_id.pk_value\n\n    }).done(function() {\n        alert('ok');\n    }).fail(function(message) {\n        alert('bad');\n    });\n*/        \n});\n\n
\\x249542a6858902bca05224cc1fe94e34a34e0e666287ec148e7ff53383963ccb	89a53440-2cd0-4dca-a500-24569c49f29c
\\x249e1d0a70b7445c18235f45b5f4a51f6dcc5517c997689e9799882b895d7e81	.{{= name }} {\n}\n\n.{{= name }} .tab {\n    display: inline-block;\n    border: 1px 1px 1px 0px solid green;\n}\n\n.{{= name }} .tab:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n
\\x2520f881643932bc15458ca2b1f1c7896cb2af76b4a59a541e74b898d5850057	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('ide:code_editor', { field: field, language: 'htmlmixed' }) }}\n</div>
\\x25272fbbb7fd0dab9d23c3c8f9fff111bc881ad7311509adda78b66e4aa9c2cd	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <title>Aquameta</title>\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <h1>Aquameta</h1>\n        <p>Here are some starting places:</p>\n        <ul>\n            <li><a href='/login'>/dev</a> - Login</li>\n            <li><a href='/dev'>/dev</a> - Developer IDE</li>\n            <li><a href='/docs'>/docs</a> - Documentation (coming soon)</li>\n            <li><a href='/snake'>/snake</a> - Snake - a sample game</li>\n        </ul>\n            \n    </body>\n</html>\n\n
\\x252b8ff88d3201ce1dbbf47370308c5e999e7a1bad7a769bf6e70ba8d1d8e50d	.{{= name }} {\n\theight: 100%;\n    width: 100%;\n    color: white;\n    /*\n    display: flex;\n    flex-flow: column nowrap;\n    position: relative;\n    */\n}\n\n.{{= name }} > nav {\n    border-bottom: 0.2rem solid #333;\n    flex: 1.5em 0 0;\n}\n\n.{{= name }} > nav a {\n    color: #555;\n    cursor: pointer;\n    padding: 0 .5em 1px 0.5em;\n    display: inline-block;\n    transition: background 0.15s ease-in;\n}\n\n.{{= name }} > nav a.selected {\n    background: #444;\n    color: white;\n}\n\n.{{= name }} > .content {\n    /* flex: 0px 1; */\n    height: 95%;\n}\n\n\n.{{= name }} > .content > div {\n    height: 100%;\n}\n\n\n.{{= name }} > .content > div.selected {\n    display: block;\n}\n
\\x253bc27ba36e1e80503d8e735efe9eb7f78c92043953f49f912fa8814470d184	var w = $("#"+id);\n\n\nfor (var i=0;i<offstage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:stage_dialog_unstaged_field', {\n        field: offstage_field_changes[i],\n        old_val: offstage_field_changes_old_vals[i],\n        new_val: offstage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}\n
\\x255fcfc2e56b5142d24bf72edd3450a79ad76666134589869a4dadd1f59bf026	var w = $("#"+id);\n\n\n// changes\nbundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    /* first staged, then unstaged modified, then unstaged deleted */\n    order_by: [{\n        column: 'staged'\n    }, {\n        column: 'change_type'\n    }]\n}).then(function(changes) {\n    widget.sync(changes, w.find('.changes'), function(change) {\n        return widget('ide:stage_dialog_changed_row', { bundle: bundle, change: change });\n    });\n});\n\n// commit button handler\nw.find('button.do_commit').click(function() {\n    var message;\n    if (message = prompt('enter a commit message')) {\n        endpoint.schema('bundle').function('commit', [bundle.get('name'), message])\n        .then(function() {\n            w.trigger('close_tab', { tab_id: 'stage' });\n        }).catch(function(e) {\n            alert ('fail! '+e);\n        });\n    }\n});\n\nw.find('button.stage_all').click(function() {\n    w.find('button.stage').click();\n});\n\nw.find('button.untrack_all').click(function() {\n    w.find('button.untrack').click();\n});\n\n// untracked rows\n/*\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\n\nwidget.sync(untracked_rows, w.find('.untracked_rows'), function(schema) {\n    return widget('ide:bundle_untracked_row_by_schema', { schema: schema, bundle: bundle });\n});\n*/\n\nw.bind('reload_stage_dialog', function() {\n    w.replaceWith(widget('ide:stage_dialog', { bundle: bundle }));\n});\n\n
\\x27564f2066a531bd639714e2489f68d5092b2800f8696f7348d2c8dcc1d97e31	df6d1b09-280a-436e-8b89-8d41feb95173
\\x283ba2dd18572f58e69e962579a3b1dc948bfb66c5cbc2301852cffbe5005402	e9bf57c1-8616-4407-96c4-29cd79208868
\\x2844bd1599eb979610ca0f9ad3e28ce8dfc7cbf5e417d62df7d2111358e309ee	<div id="{{= id }}" class="{{= name }}">\n    \n    <h3>Import a Bundle from the Filesystem</h3>\n    \n    bundle directory: <input type='text' size=100 class='directory' value='/opt/aquameta/bundles-available/NAME'><br>\n    <button class='import'>import</button>\n</div>
\\x28deec000112f80eba04dd52fb6d397b66fae30323808f1d47fa4ae6e507d6ad	debugger3
\\x295d7dc9653dc1608b6e4743e087350a69598d2b2e34c50b836fe13e59b22792	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'javascript' }) }}\n</div>
\\x2993b97ec7e80ee892e71bd4657d1a4f482250afe86af87e7eaccffa98e3b451	template_route
\\x29bd8f0a60658db033c8ee6d1c29a1506eaef8e44b2c7d1c53ae9fd5e355bd39	c307d345-15c6-4690-a152-10b272fd8589
\\x29c91e1ca29a771fb691ee518719d77ab2bb7d0a3f9144c68df66c8a99d93cee	var w = $("#"+id);\n\nw.find('button.create').click(function() {\n    endpoint.schema('endpoint').table('remote_endpoint').insert({\n        name: w.find('input.name').val(),\n        url: w.find('input.url').val()\n    }).then(function(remote_endpoint) {\n        \n\n        endpoint.schema('bundle').table('remote').insert({\n            endpoint_id: remote_endpoint.get('id'),\n            bundle_id: bundle.get('id')\n        }).then(function() {\n            alert ('ok');\n            w.trigger('close_modal');\n        }).catch(function(e, o) {\n            alert('fail: ' + e);\n            w.trigger('close_modal');\n        });        \n        \n    }).catch(function(e, o) {\n        alert('fail: ' + e);\n        w.trigger('close_modal');\n    });\n});\n\nw.find('button.cancel').click(function() {\n    w.trigger('close_modal');\n});
\\x2a2a9a6f44008f60948abb1f8becc059b5558417a72f9a5cbd9d662d4d97f5f7	<div id="{{= id }}" class="{{= name }}">\n    <h3>Untracked Rows</h3>\n\n    <button class='refresh'>&#8635;refresh</button>\n\n    <div class='bulk_action'>\n        <input type='checkbox' class='checkall'>\n        <span class='actions'>\n            <button class='ignore'>ignore</button>\n            <button class='track'>add to {{= bundle.get('name') }}</button>\n            <button class='delete'>delete</button>\n        </span>\n    </div>\n    <div class='rows'>\n    </div>\n</div>
\\x2a5225842f5a3cc192e147296831824b0a877b10d88039780f3c09defae32481	This is the top level widget for the Spacebase IDE.\n
\\x2ae25daa4b211fa1bf4cd99780a7a5e903da30710c05a8c4e97402201086b1ea	ee265dda-bb3b-4c27-9270-d91cdf8eda75
\\x2aedc0d9d5cb6f641879eaa445815cfcff8f293933c76b93b0057cc924f9c5ad	.{{= name }} {\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n}\n\n.{{= name }} header .logo a {\n    font-size: 200%;\n    color: blue;\n    letter-spacing: 1ex;\n    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\n    text-decoration: none;\n    font-weight: bold;\n\n}\n\n.{{= name }} header a:hover {\n    text-decoration: underline;\n    color: blue;\n}\n\n\n.{{= name }} > .content {\n    display: flex;\n    flex: 2;\n    overflow: auto; /* was 'hidden' -elh */\n}\n\n.{{= name }} .row_list_section {\n    background-color: #222;\n    order: 0;\n    flex: 1 1 auto;\n    align-self: auto;\n    width: 20em;\n    overflow: auto;\n    padding: 4px;\n}\n\n.{{= name }} .workspace_section {\n    order: 0;\n    flex: 5 1 80%;\n    align-self: auto;\n}\n\n.{{= name }} .bundle_icon:hover {\n    cursor: pointer;\n}\n\n
\\x2b5ab3b14b7e41f01524fab82b802185f2e982a27d00d3f52b0cd5f99d924ab1	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <title>Aquameta</title>\n        \n        <link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <h1>Aquameta</h1>\n        <p>Here are some starting places:</p>\n        <ul>\n            <li><a href='/login'>/dev</a> - Login</li>\n            <li><a href='/dev'>/dev</a> - Developer IDE</li>\n            <li><a href='/docs'>/docs</a> - Documentation (coming soon)</li>\n            <li><a href='/snake'>/snake</a> - Snake - a sample game</li>\n        </ul>\n            \n    </body>\n</html>\n\n
\\x2b6bb5452d5baa848fb25b1e0e32f142cdc059586f2b114fd1b5f54a3f12d6b4	var w = $('#'+id);\nw.find('.content').append(content);\n\nfunction dismiss(event) {\n    w.fadeOut('fast').remove(); \n    return false;\n}\n\n/*\nwtf is this:  screwing up form elements in modals.\nfunction stop_event(event) {\n    event.stopPropagation();\n    return false;\n}\nw.find('> .content > *').click(stop_event);\n*/\n\nw.on('dismiss', dismiss);\n\nw.find('> .overlay').click(dismiss);\nw.on('done', dismiss);\nw.bind('close_modal', dismiss); // redundant to above?\njwerty.key('esc', dismiss);
\\x2b84078e337bbdbe8438cc1baf4b55968c29e50a2d3085171f4fa6a628b23da5	ce5ce449-1c74-40ee-85f8-316d60eb8d9a
\\x2bdbd2b52cf43445d7b50ad9c836c47f5057370a99ff1f8eb1d36b085bdf839a	cfac112c-8b9a-4c30-a97d-05761c9be92c
\\x2c781f81da566b69615c12c6bb6b54b2b7f4379a48ac9c1c35770fc72c5a2785	f38dce36-f77b-43e9-9a2c-4da393c04e6b
\\x2cf0e333359e6c47c696df1efda7cbac77499a5f708fdfa7cb0b120bba3ae351	sem_fkey_autocomplete
\\x2d6ad446f839f7e06ebbd5bb4fd3e44e406a4e9197f33a0f0fb13f0e577cb252	3dfc84e2-9482-418a-b78a-0f78da1a62c0
\\x2d7a9f36e2077964ddf2990649abe80e102e6fdaecc5dad3865bbef0520b90af	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\nvar fkeys;\nvar where_obj = {};\nwhere_obj[to_column] = from_row.get(from_column);\nfunction load_fkeys() {\n    \n    w.find('.fkeys').empty();\n    \n    fkeys = order_by_function(to_relation.rows().where(where_obj));\n    \n    widget.sync(fkeys, w.find('.fkeys'), function(row) {\n        return widget('sem_fkey_one_to_many_li', { \n            row: row,\n            to_column: to_column,\n            label_function: label_function\n        });\n    });\n    \n}\nload_fkeys();\n\n\n// Find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    name: to_relation.name,\n    schema_name: to_relation.schema.name\n}).result(function(to_relation_obj) {\n    \n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n    \n    context_data[to_column] = from_row.get(from_column);\n    \n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n    \n    w.find('.new').click(function() {\n        w.append(widget('modal_overlay', {\n            content: widget(new_row_widget, {\n                relation: to_relation_obj,\n                context_data: context_data\n            })\n        }));\n    });\n\n});\n\nw.on('reload', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});\n\nw.on('fkey_updated', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});\n\nw.on('fkey_deleted', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});
\\x2dff8254d6b8f523f375279839c40b590315d425f2e52ea07980b60c16645d62	var w = $("#"+id);\n\nw.find('button.import').click(function() {\n    var dir = w.find('input.directory').val();\n\n    endpoint.schema('bundle').function('bundle_import_csv', [ dir ])\n    .then(function() {\n        alert ('success');\n    })\n    .catch(function(e) {\n        alert('failed:'+e);\n    });\n});
\\x2fe8e53b780becb1df0722b5a40cbb13dbb21b2e22229c531de6775c0be29557	.{{= name }} {\n}\n\n.{{= name }} .new_row_button {\n    display: inline-block;\n    text-align: center;\n    border-style: solid;\n    border-width: 1px;\n    padding: 10px;\n    margin: 5px;\n    min-height: 75px;\n    min-width: 100px;\n    vertical-align: top;\n    cursor: pointer;\n}\n\n.{{= name }} .new_row_button:hover {\n    background-color: gray;\n}\n\n.{{= name }} .new_row_button:active {\n    background-color: green;\n}\n\n.{{= name }} .new_row_icon {\n    min-height: 27px;\n}
\\x301a4427bfb14951997c4a44e3a1c3fc10f4ca779a93c99433712ceb78d2275c	commit_dialog
\\x303bdf18a0978a13fcc9836778ff1e83dd9880d461db6c907ad067fdb009ce8c	jwerty
\\x30f3b7dfb46cd14ffbfbf29832b350155149d0e73412787c0083cd49b99c0952	/*jshint smarttabs:true */\n\n/**\n * closestDescendant - 0.1.1 - 2013-04-09\n * https://github.com/tlindig/jquery-closest-descendant \n *\n * Copyright (c) 2013 Tobias Lindig\n * http://tlindig.de/ \n *\n * Licensed MIT\n */\n(function( $ ) {\n    \n    /**\n\t * Get the first element(s) that matches the selector by traversing down\n\t * through descendants in the DOM tree level by level. It use a breadth\n\t * first search (BFS), that mean it will stop search and not going deeper in\n\t * the current subtree if the first matching descendant was found.\n\t *\n\t * @param  {selectors} selector -required- a jQuery selector\n\t * @param  {boolean} findAll -optional- default is false, if true, every\n\t *                           subtree will be visited until first match\n\t * @return {jQuery} matched element(s)\n\t */\n    $.fn.closestDescendant = function(selector, findAll) {\n        \n        if (!selector || selector === '') {\n            return $();\n        }\n        \n        findAll = findAll ? true : false;\n        \n        var resultSet = $();\n        \n        this.each(function() {\n            \n            var $this = $(this);\n            \n            // breadth first search for every matched node,\n            // go deeper, until a child was found in the current subtree or the leave was reached.\n            var queue = [];\n            queue.push( $this );\n            while ( queue.length > 0 ) {\n                var node = queue.shift();\n                var children = node.children();\n                for ( var i = 0; i < children.length; ++i ) {\n                    var $child = $(children[i]);\n                    if ( $child.is( selector ) ) {\n                        resultSet.push( $child[0] ); //well, we found one\n                        if ( ! findAll ) {\n                            return false;//stop processing\n                        }\n                    } else {\n                        queue.push( $child ); //go deeper\n                    }\n                }\n            }\n        });\n        \n        return resultSet;\n    };\n})($);\n\n\n
\\x317831d3d38b5b78e6fa403de9d0e6c0bbf8e68d19cbab7fcb3eb717835e141c	<div id="{{= id }}" class="{{= name }}">\n    <span>Logged in</span>\n    <div class='dropdown'>\n        <div class='username'></div>\n        <div class='logout'>Logout</div>\n    </div>\n</div>
\\x323515a276c543825a403ef1dfaa2bd1a2063407d5c1ca4680c478ff5a8be32f	.{{= name }} {\n\n}\n\n.{{= name }} { position: relative; } \n
\\x329de19a5067c718221472b0f8b95e693d2236720fde39a5440f4c731872b4c4	bundle_remote_commit_comparison_row
\\x335c996971ae280046f30253e6381c1618a34e987ca4f4ea3aaa44214b829b25	.{{= name }} {\n  \tbackground: #000;\n    color: white;\n    \n   \tcursor: pointer;\n  \topacity: 0.9;\n\n    height: 100%;\n    width: 100%; \n    \n    position: fixed;\n    left: 0;\n    top: 0;\n    \n    z-index: 9;\n    \n    display: table;\n\n}\n\n.{{= name }} > .content {\n    position: absolute;\n    \n    width: 100%;\n    height: 100%;\n    \n    overflow-y: auto;\n        \n    left: 0;\n    top: 0;\n        \n    text-align: center;\n    display: table-cell;\n    vertical-align: middle;\n}\n\n
\\x346164397f7f0425c4b6ce95da2a77a260e58ad34213c57b062397ac754e18d9	var w = $('#'+id);\n
\\x347dd5042d86a602736aba80182866b9571b56e88c74567a5142624179f35de8	row_detail_tabbed
\\x34eb02a2ec6d73f0af6a5fa7f18da91f8bb542b9916aad5a7322f1d1c3db9282	sem_fkey_autocomplete_form
\\x360442d725f35393b0ec2ab68ad64c4dd6495a5a4496c4943539d2fa9aa3060b	bb20fbd6-05bc-45df-b6b4-669e58d0b47a
\\x363a0e488af6bc8882ef62395b9550a8a744107b5d06d0cc2127943a840b662e	a7ec4e00-8bc5-4901-aa20-fe3d31f44705
\\x363ce6b74e6242abd74fd7e49e8113f2b0fab6982afe5d45ebef42a209cf0f82	c5ca1ee1-932d-4802-93f1-ebb97de837ff
\\x3647007463dd88b3064c3320c3b8e1548e903365e1337527d6372d07f933cd46	stage_dialog_unstaged_fields\n
\\x36e7e48f31c5fd9ad4f7a56842d1253fc374f7fa0483f235b058106109416601	19719263-ddf4-448b-9851-deddd1a92e21
\\x375d750e37e2cebfd2909e93f5b6507fd24d2f174c659f2636708b2168b171b3	.{{= name }} {\n    position: relative;\n\tbottom: 0;\n    top: 0;\n    height: 100px;\n}\n\n.{{= name }} .new_widget {\n    padding-top: 10px;\n    color: red;\n}\n\n\n
\\x385d11f809c9983f8bfc371dc5b6ee4ebdb81f8faef950050d91801f87c9a410	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:commit_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:commit_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('.modified_link').click(function() {\n    alert ('coming soon...');\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_commit_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n\n\n\n\n
\\x38badf9d070eb3ad4c4aff45404a6b85a9442415b8ecebf5d8453c2ad0c1a807	bundle_remotes
\\x38e274caa98e1c81efac39e9396a20ffb836c061397fb6ebdf017cf74f4b375e	bf19b949-74d3-4938-ab5d-ad092884053d
\\x394a9593b5810f5d1eaffb4f54232a5969d61b61a5d13b735e49c96382459234	var w = $("#"+id);\n\n\nvar show_bundles = function() {\n\n    var retrieved = false;\n\n    return function() {\n        \n        w.removeClass('bundle_edit');\n\n        if (!retrieved) {\n            retrieved = true;\n            endpoint.schema('bundle').table('bundle').rows({ order_by: {\n                column: 'name',\n                direction: 'asc'\n            }}).then(function(bundles) {\n                w.find('.bundle_list').append(widget('ide:list_view_gateway', {\n                    datum: bundles\n                }));\n            });\n        }\n    };\n}();\n\n\n\n/* URL */\n// When continue button in list_view_gateway is pressed,\n//   get the bundles and place in url\nw.on('list_view_select', function(e, bundles) {\n    var bundle_names = bundles.map(function(e) {\n        return e.get('name');\n    }).sort().join(',');\n    window.location.href = '#/' + encodeURIComponent(bundle_names);\n});\n\nvar current_state = null;\n    \nfunction select_state() {\n    \n    var slugs = window.location.hash.split('/').slice(1);\n    var new_state = null;\n    if (slugs.length) {\n        new_state = decodeURIComponent(slugs[0]);\n    }\n\n    if (new_state == null) {\n        w.data('bundles', null);\n        return show_bundles();\n    }\n    \n    w.addClass('bundle_edit');\n    if (new_state != current_state) {\n        \n        var bundles = new_state.split(',');\n        w.data('bundles', bundles);\n        \n        w.find('> .bundle_workspace').empty().html(\n            widget('dev_workspace', { base_url: '#/' + slugs[0], url_parts: slugs.slice(1) })\n        );\n        w.find('.bundle_manager_container').empty().append(\n            widget('bundle', { bundles: bundles })\n        );\n        current_state = new_state;\n    }\n\n    $('html, body').animate({\n        scrollTop: 0\n    }, 'fast');\n    \n    // Do nothing if states are the same\n    // Let the widget handle back/forward within itself\n    \n}\n$(window).on('popstate', select_state);\nselect_state();\n\n\nw.find('.select_bundles').on('click', show_bundles);\n\n\n\n/* STATUS */\nw.on('status', add_status);\n\nfunction add_status(e, message, type) {\n    e.stopPropagation();\n    w.find('.status_container').append(widget('status', { message: message, type, type }));\n}\n\n
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x3abcbfe2e2ab75cacb52e302924e2bda0550be8f30becd95dfed6eabbd9ea6c5	<div id="{{= id }}" class="{{= name }}">\n    Bundle manager\n</div>
\\x3c6ee223373bfd2019b46acd5c74b35b369a64a70f2fe8755266fc667bc437ab	code_editor
\\x3c826b90397bd87d258c5a83e2071ae976dfdce8ba5b576bbd0042cb49b3f5fb	<div id="{{= id }}" class="{{= name }}">\n    <h3>diff!</h3>\n    \n</div>
\\x3cd6f0248e628061efe3bee3c0c950854d89be5dff754681a774cf2727a9b2aa	<div id="{{= id }}" class="{{= name }}">\n    <div class='tabs'>\n        <div class='tab localhost'>bundles</div>\n        <div class='tab untracked'>untracked</div>\n    </div>\n    <div class='container'>\n        <div class='bundles'>\n            <button class='select'>select bundle</button>\n            <button class='new'>new bundle</button>\n        </div>\n    </div>\n</div>
\\x3d05b227178ca5a294b67e387f6c05560a8326a10161fde87ca35f0d31200e78	debugger3_manager
\\x3d5ae5f0c166e8438956902ecf385ef8889abb84e1fd6246f6d346cf99c81f77	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td class='change_type'>\n        <span title='This row has been modified' class='icon modified'>&Delta;<span class='modified_link'>(diff)</span></span>\n        <span title='This row has been deleted' class='icon deleted'>-</span>\n        <span title='This row has been added' class='icon added'>+</span>\n        <span title='This row has been tracked' class='icon tracked'>&#128065;</span>\n    </td>\n    <td>\n        <div class='unstaged'>\n            <button class='stage'>stage →</button>\n        </div>\n        <div class='unstaged_fields'>\n        </div>\n    </td>    \n    <td>\n        <div class='staged'>\n            <button class='unstage'>← unstage</button>\n        </div>\n        <div class='staged_fields'>\n        </div>\n    </td>\n    <td>{{= change.get('row_exists') }}</td>\n    <td><button class='untrack'>untrack</button></td>\n</tr>
\\x3d9e6697f8071a64d89a5e65c2e800e384906e6d498d5c26add6f658fe715089	<div id="{{= id }}" class="{{= name }}">\n    <nobr>\n        <input type='checkbox' class='action'><span class='label'></span>\n    </nobr>\n</div>
\\x3e07d25cbd771ce74b01507e8234151fddf5de87a309baa5885fc48dcc29b1a3	<div id="{{= id }}" class="{{= name }}">\n    <div class="show_all">show all</div>\n    <div class="tree_container">\n        \n    </div>\n</div>
\\x3e0be0f7454e57c4110567e8a4c669513cab084a3fcf86b039c610afca335d1c	abd67d40-5fcc-499d-be81-8f23eed50855
\\x3e28439bbcf1736f7fe5593f4df731afd2e7bb6d5050b9e377dd8ca0935212d5	<div id="{{= id }}" class="{{= name }}">\n    <div class="content"></div>\n</div>
\\x3e32c790682dc359a9d122e57cb4408d89a5ea112a067bdcf61c47661e326538	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('schema_name') + '.' + row.get('name') }}\n</li>
\\x3e48a45305b2f6bed65c918160c5eb9baef2bbd2380f5e506b5e63182578eeb7	33a37d92-671d-4988-93c6-e18742636808
\\x3e49f390f5b85d2e80ed98b4b91ebd4afd7b5f2a2193c7208cc202dc8a848379	<div id="{{= id }}" class="{{= name }}">\n    <h2>New Row</h2>\n    <hr/>\n    \n    <h3>Development</h3>\n    <div class="new_row_buttons">\n        <div id="widget" class="new_row_button">\n            <div class="new_row_icon">⚙</div>\n            <div class="new_row_name">Widget</div>\n        </div>\n        <div id="resource" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Resource</div>\n        </div>\n        <div id="dependency_js" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Javascript Library</div>\n        </div>\n        <div id="table" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Table</div>\n        </div>\n        <div id="view" class="new_row_button">\n            <div class="new_row_icon">⌕</div>\n            <div class="new_row_name">View</div>\n        </div>\n        <div id="function" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Function</div>\n        </div>\n        <div id="binary" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Binary</div>\n        </div>\n        <div id="fdw" class="new_row_button">\n            <div class="new_row_icon">&#8599;</div>\n            <div class="new_row_name">Foreign Table</div>\n        </div>\n    </div>\n    \n    <h3>Bundle</h3>\n    \n    <h3>Everything</h3>\n</div>
\\x3ea991664e41a5312b9dd406faa7030cf88a38e9844e5fe117aaa3a62af0878e	var w = $("#"+id);\n\nw.find('.name').append(widget('semantics/form_field', row.field('name')));\nw.find('.routes').html(widget('ide:template_routes', { template: row }));\nw.find('.content').append(widget('semantics/form_field', row.field('content')));\n\n
\\x3eaf593f950a29b38bd9ed67aad93cad0c7bea497a8633922a58ff34fd701ab3	.{{= name }} {\n}\n\n.{{= name }} > .fkeys {\n    list-style: none;\n}
\\x3ebbe99bc662d869c3ccc1b07231d35e035799186c4211fb80f1f767a03872c6	var w = $("#"+id);\n\nvar remotes = bundle.related_rows('id','bundle.remote','bundle_id');\n\nwidget.sync(remotes, w.find('.remotes'), function(remote) {\n    return widget('ide:bundle_remote', { remote: remote });\n\n});\n\nw.find('.new_remote').click(function() {\n    w.append(widget('ide:modal', { content: widget('ide:bundle_remote_new', { bundle: bundle }) }));\n});
\\x3ecf3818e503f7979143846f9eae93f74799cd95df2925ce4764fbbd64ee12f7	var w = $("#"+id);\n\nw.find('.path').append(widget('semantics/form_field', route.field('path')));\nw.find('.args').append(widget('semantics/form_field', route.field('args')));\nw.find('button.delete').click(function() {\n    route.delete().then(function() {\n        w.remove();\n    });\n});\nw.find('button.save').click(function() {\n    console.log('args is ', route.get('args'));\n    console.log('path is ', route.get('path'));\n    \n    route.update()\n    .then(function() {\n        alert ('saved');\n    }).catch(function() {\n        alert ('failed.');\n    });\n});\n
\\x3ed59cae8358ff4b661c092d2b94f0d52a7f08d5a1ecd693c6f1f229d9d27159	8e0abc5c-3346-493c-895c-c3236d18ff33
\\x3f71edbb36d9a5c96bcaf667a8aed8ce594f6503ea97376c1a8b9523b29c192f	.{{= name }} {\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n}\n\n.{{= name }} > header {\n    margin: 0;\n}\n\n.{{= name }} > header img {\n    display: inline;\n    vertical-align: middle;\n}\n\n.{{= name }} > header .text {\n    display: inline;\n    vertical-align: middle;\n}\n\n\n.{{= name }} > .content {\n    display: flex;\n    flex: 2;\n    overflow: auto; /* was 'hidden' -elh */\n}\n\n.{{= name }} .row_list_section {\n    order: 0;\n    flex: 1 1 auto;\n    align-self: auto;\n    border: 1px solid gray;\n    width: 20em;\n    overflow: auto;\n    padding: 4px;\n}\n\n.{{= name }} .workspace_section {\n    order: 0;\n    flex: 5 1 80%;\n    align-self: auto;\n}\n\n.{{= name }} .bundle_icon:hover {\n    cursor: pointer;\n}\n\n.{{= name }} header {\n    padding-bottom: 0px;\n}\n.{{= name }} header a {\n    font-size: 200%;\n    color: blue;\n    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\n    text-decoration: none;\n    font-weight: bold;\n\n}\n\n.{{= name }} header a:hover {\n    text-decoration: underline;\n    color: blue;\n}\n
\\x3fba2f328b9a7cd5a7c22717d4a6a4f3e0fb79363f6281beda89699d12f289b5	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'css' }) }}\n</div>
\\x4086cf69c099bba946cbd45569e9bc47bc2a0f1f9956b8651df73f4aef03a015	var w = $("#"+id);\n\n\n// new row button handler\nw.find('button.new_row').click(function() {\n    console.log('new row trigger fired.');\n    w.trigger('open_tab', { tab_id: 'new_row' });\n});\n\n\n// new row button handler\nw.find('button.commit').click(function() {\n    w.trigger('open_tab', { tab_id: 'commit' });\n});\n\nw.find('button.commit_log').click(function() {\n    w.trigger('open_tab', { tab_id: 'commit_log' });\n});\n\n\n\nw.find('button.bundle_config').click(function() {\n    w.trigger('open_tab', { tab_id: 'bundle_config' });\n});\n\n\n\nw.find('button.push_pull').click(function() {\n    w.trigger('open_tab', { tab_id: 'push_pull' });\n});\n\n\n\n\n\n\n\n\n// filter handlers\nw.find('.filters .all').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\n// filter handlers\nw.find('.filters .changed').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nvar commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    order_by: {\n        column: 'row_id'\n    }\n});\n\n// filter handlers\nw.find('.filters .head').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_commit_row','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nw.find('.filters .all').click();\n\n// listen for triggers from semantic widgets which indicate crud changes to handle\nw.closest('.ide').bind('insert', function(e, o) {\n    alert('insert detected');\n    \n    var row_id = o.row.id;\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_value = row_id.pk_value;\n\n    endpoint.schema('bundle').function('tracked_row_add', [ \n        bundle.get('name'), \n        schema_name, \n        relation_name, \n        pk_column_name, \n        pk_value\n    ]).then(function() {\n        w.trigger('bundle_row_open', { row: o.row, row_id: row_id });\n    }).catch(function (e) {\n        alert('error calling tracked_row_add');\n    });\n});\n\n\nfunction refresh_active_window() {\n}\n\n\n
\\x40a7c53ff3e30f9fd798b5187194a9201993aefa6a5fc45927befa404fb9705c	<tr id="{{= id }}" class="{{= name }}">\n    <td class="local comp">\n        {{= comparison.row.local_commit_id }}\n    </td>\n    \n    <td class="remote comp">\n        {{= comparison.row.remote_commit_id }}\n    </td>\n</tr>
\\x41c18b9209140e16dc2f5aec74cf7f627dddba1e54b757a268373e54cb3ad347	fkey_test
\\x425c3c83339aad5de458f764ae5bfb8bd47e61ca2121074179889c0c5ff1c7aa	<div id="{{= id }}" class="{{= name }}">\n    <h2>New row</h2>\n    <input class='name' type='text' placeholder='New name'>\n    <button class='save'>Create</button>\n    <button class='save_as_null'>Save as null</button>\n</div>
\\x432b1a5aa2ce105118a633e322633a24add43777ad9691b285194ab0118b5ff8	var w = $("#"+id);\n\nvar change = commit_row.get('change_type');\n\nif (change != 'same') {\n    if (change == 'added')\n\t    w.find('.added').show();\n    else if (change == 'deleted')\n\t    w.find('.deleted').show();\n    else if (change == 'modified')\n\t    w.find('.modified').show();\n    else if (change == 'tracked')\n\t    w.find('.tracked').show();\n    else w.append('UNKNOWN CHANGE TYPE: '+change);\n}\n\nvar exists = commit_row.get('row_exists');\nif (exists == false) {\n    w.find('.doesnt_exist').show();\n}\n\nvar schema_name = commit_row.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = commit_row.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = commit_row.get('row_id').pk_column_id.name;\nvar pk_value = commit_row.get('row_id').pk_value;\n\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n    \n    w.find('.label').html(widget('semantics/text_identifier', real_row ));\n    \n\t// click handler needs real_row, so put the handler in here after real_row is loaded\n    w.click(function() {\n        w.trigger('bundle_row_open', { row_id: commit_row.get('row_id'), row: real_row });\n    });\n    return real_row;\n\n}).catch(function(e) {\n    console.log(e);\n\tw.find('.label').html(schema_name+'.'+relation_name+'.'+pk_value);\n}).then(function() {\n    //w.show();\n    w.find('.label > *').ready(function() {\n        w.show();\n    });\n});\n\n\n
\\x43a7a359077a6699d1fef86b2ca9203a636976b5d01c2f5d52fab18988ee2172	var w = $("#"+id);\n\nvar bundle_name = window.location.hash.split('#')[1];\n\n\nif (typeof bundle_name == 'undefined') {\n    w.find('header .title').html('Select a bundle');\n    w.find('.row_list_section').html(widget('ide:bundle_selector'));\n    w.on('bundle_selected', function(e, payload) {\n        \n        w.find('.bundle_selector').remove();\n        bundle_name = payload.bundle_name;\n        window.location.hash = bundle_name;\n        show_bundle();\n    });\n}\nelse {\n    show_bundle();\n}\n\nfunction show_bundle() {\n    endpoint.schema('bundle').table('bundle').row({\n        where: {\n            name: 'name',\n            op: '=',\n            value: bundle_name\n        }\n    }).then(function(bundle) {\n        // load the workspace\n        w.find('.workspace_section').html(widget('ide:workspace', { bundle: bundle }));\n        w.find('.row_list_section').html(widget('ide:row_list', { bundle: bundle }));\n        w.find('header .title').html(bundle.get('name'));\n    });\n\n}
\\x43bb3242654275b32bf8bb4ddc6e799f7ac7258151a237090e092043507f021e	var w = $("#"+id);\n\n\nfor (var i=0;i<stage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:stage_dialog_staged_field', {\n        field: stage_field_changes[i],\n        old_val: stage_field_changes_old_vals[i],\n        new_val: stage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}\n
\\x4559a1bf5a69e6adb2450a215b0867d0fa258b70d82a24926130af616ae13c7a	var w = $("#"+id);\n\nw.click(function(event) {\n    event.stopPropagation();\n\n    w.find('> ul').toggleClass('open');\n    if (!w.find('> ul').hasClass('open')) {\n        w.find('> ul').empty();\n    } else {\n        var relations = schema.related_rows('schema_id','bundle.untracked_row_by_relation','schema_id');\n        widget.sync(relations, w.find('ul'), function(relation) {\n            return widget('bundle_untracked_row_by_relation', { relation: relation })\n        });\n    }\n});
\\x461009a6b0b850477ad0b1d661d4437abc4838c9fd08bf6a731c67bcfb1ea53a	.{{= name }} button.stage {\n    float: right;\n}
\\x462b832f6b6e93d91abb3eaff6762ff26421e405d98b2401ffb7c39c6ead7f25	var w = $("#"+id);\n\n\n// changes\nbundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    /* first staged, then unstaged modified, then unstaged deleted */\n    order_by: [{\n        column: 'staged'\n    }, {\n        column: 'change_type'\n    }]\n}).then(function(changes) {\n    widget.sync(changes, w.find('.changes'), function(change) {\n        return widget('ide:stage_dialog_changed_row', { bundle: bundle, change: change });\n    });\n});\n\n// commit button handler\nw.find('button.do_commit').click(function() {\n    var message;\n    if (message = prompt('enter a commit message')) {\n        endpoint.schema('bundle').function('commit', [bundle.get('name'), message])\n        .then(function() {\n            w.trigger('close_tab', { tab_id: 'commit' });\n        }).catch(function(e) {\n            alert ('fail! '+e);\n        });\n    }\n});\n\nw.find('button.stage_all').click(function() {\n    w.find('button.stage').click();\n});\n\n// untracked rows\n/*\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\n\nwidget.sync(untracked_rows, w.find('.untracked_rows'), function(schema) {\n    return widget('ide:bundle_untracked_row_by_schema', { schema: schema, bundle: bundle });\n});\n*/\n\nw.bind('reload_stage_dialog', function() {\n    w.replaceWith(widget('ide:stage_dialog', { bundle: bundle }));\n});\n\n
\\x46720f6ea15d33e05713d3ac8dee758de8f01e74ca63dcedf569c5995d76cb07	row_list
\\x46975344ee6d8d7c570f1aebf2f9926683d219f3a5579f09bd1b6be5e02909dd	.{{= name }} {\n    height: 100%;\n}\n\n.{{= name }} .tabs {\n    height: 100%;\n}
\\x4812bb60aeec2400a63245f25cd9627e8ae11398592538307494b2380216326c	<div id="{{= id }}" class="{{= name }}">\n    <div class='fields'>\n    </div>\n</div>
\\x482a80f74412a47b7bcbf661efcb68b5108ece60d2a37ac00dd9458a0efa5437	var w = $("#"+id);\n\n\nfunction new_tab(tab_id, label, content) {\n    // console.log('opening new tab');\n    // create the header\n    w.find('.tab_headers').append(widget('ide:workspace_tab_header', {\n        label: label,\n        tab_id: tab_id\n    }));\n\n\n    // create the tab\n    w.find('> .tab_contents').append(widget('ide:workspace_tab', {\n        content: content,\n        tab_id: tab_id\n    }));\n\n    // focus\n    show_tab(tab_id);\n}\n\nfunction current_tab() {\n    return w.find('.workspace_tab_header.highlighted').first().data('tab_id');\n}\n\nfunction show_tab(tab_id) {\n    // console.log('show tab ', tab_id);\n    // show the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).show();\n        } else {\n            $(this).hide();\n        }\n    })\n\n    // highlight the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).addClass('highlighted');\n        } else {\n            $(this).removeClass('highlighted');\n        }\n    })\n}\n\nfunction close_tab(tab_id) {\n    /*\n    why doesn't this work?\n    w.find('.workspace_tab[data-tab_id="'+tab_id+'"]').remove();\n    w.find('.workspace_tab_header[data-tab_id="'+tab_id+'"]').remove();\n    */\n    \n    var current_tab_closed = false;\n    if (tab_id == current_tab()) {\n        current_tab_closed = true;\n    }\n    \n    // remove the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // remove the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // if the current tab is closed, replace it with another\n    if (current_tab_closed) {\n        var last_tab = w.find('.workspace_tab').last();\n        if (last_tab) {\n            show_tab(last_tab.data('tab_id'));\n        }\n    }\n}\n\nfunction tab_is_open(tab_id) {\n    // check to see if it's already open\n    var is_open = false;\n    var tabs = w.find('.workspace_tab');\n    for (var i=0;i<tabs.length;i++) {\n        var this_tab_id = $(tabs[i]).data('tab_id');\n\n        // console.log('comparing '+this_tab_id +' to ' + tab_id);\n        if (this_tab_id == tab_id) {\n            // console.log('already open');\n            return true;\n        }\n    };\n    return false;\n}\n\nw.closest('.ide').bind('close_tab', function(e,o) {\n    close_tab(o.tab_id);\n});\n\nw.closest('.ide').bind('show_tab', function(e,o) {\n    show_tab(o.tab_id);\n});\n\nconsole.log(endpoint);\n// handler for row clicked event\nw.closest('.ide').bind('bundle_row_open', function(e, o) {\n    // console.log('bundle_row_clicked', e, o);\n\n    var row_id = o.row_id;\n    var row = o.row;\n\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_val = row_id.pk_value;\n    var label = widget('semantics/text_identifier', row);\n    var tab_id = schema_name + '.' + relation_name + '.' + pk_val;\n\n    if (!tab_is_open(tab_id)) {\n        console.log(endpoint);\n        // open a new tab for this row\n        endpoint\n        .schema(schema_name)\n        .table(relation_name)\n        .row(pk_column_name, pk_val).then(function(real_row) {\n            new_tab(tab_id, label, widget('semantics/row_detail', real_row));\n        }).catch(function(e) {\n            console.log('error: ',e);\n        });\n    } else {\n        // send to front\n        show_tab(tab_id);\n    }\n\n\n});\n\n// new generic dialog handler\nw.closest('.ide').bind('open_tab', function(e,o) {\n    var tab_id = o.tab_id;\n\n    if (tab_is_open(tab_id)) {\n        show_tab(tab_id);\n    } else {\n        switch (tab_id) {\n            case 'new_row':\n                new_tab('new_row', 'New Row', widget('ide:new_row_dialog', { bundle: bundle }));\n                break;\n            case 'commit':\n                new_tab('commit', 'Commit', widget('ide:commit_dialog', { bundle: bundle }));\n                break;\n            case 'commit_log':\n                new_tab('commit_log', 'Commit History', widget('ide:commit_history_dialog', { bundle: bundle }));\n                break;\n            case 'bundle_config':\n                new_tab('bundle_config', 'Bundle Config', widget('ide:bundle_config_dialog', { bundle: bundle }));\n                break;\n            case 'push_pull':\n                new_tab('push_pull', 'Push Pull', widget('ide:bundle_push_pull', { bundle: bundle }));\n                break;\n            default:\n                alert ('internal error: no such dialog as '+tab_id);\n        }\n    }\n});\n\n// close generic dialog\nw.closest('.ide').bind('close_tab', function(e,o) {\n    var tab_id = o.tab_id;\n    close_tab(o.tab_id);\n});\n\n\n\n\n\n
\\x4938388f0c68650a2120ab03dfbf8e39b08edca0d086b3c3fd02e84e501a5fab	var w = $("#"+id);
\\x49ed84d05b59d4c96dc196182eb54212f36dc0ac0aad4eaac284212cf2ebe87c	if (typeof data_name != 'undefined' && typeof data != 'undefined') {\n    $('#'+id).data(data_name, data);\n}
\\x4a414fe95b277f1743ca3e635ed62af81d6dbc16c97d116b189ddb5aa5450daa	var w = $("#"+id);\n\nw.find('.path').append(widget('semantics/form_field', route.field('path')));\nw.find('button.delete').click(function() {\n    route.delete().then(function() {\n        w.remove();\n    });\n});\n
\\x4ad95b404c0a630f9f73dcf0b89eea53d47c890fde1c05dbc700be8f6a880df1	6c743b6f-ac9a-4c49-bf56-9903254d6643
\\x4b39116cce477ed9752f75cdee9c48b784e79208a8a61bcfc85161aa5dd1a44d	<div id="{{= id }}" class="{{= name }}">\n    <h1>yo dogg i'm a template editor</h1>\n</div>
\\x4c37e2ce9e5b1d3200064c3eca14a4027a1088b0bc406d35cf476b9ea2cb8fab	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\n// TODO this fails for views\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var columns = [];\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\n    if (row.columns == null) {\n        throw 'Please call this row with "meta_data" set to true. ' + rel_name;\n    }\n    row.columns.forEach(function(col, i) {\n        if (col.name != 'id' && col.name != 'name') {\n            tabs[col.name] = function() {\n                return widget('semantics/form_field', row.field(col.name));\n            };\n            tab_colors[col.name] = colors[i % colors.length];\n            columns.push(col.name);\n        }\n    });\n\n\n    /* TABBED LAYOUT */\n    var preview_row = row.clone();\n\n    w.find('> .top > .section_content > .tabs').append(\n        widget('core:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Row deleted from ' + rel_name, 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Widget delete failed', 'fail']);\n            setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('button.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.find('button.delete').on('click', handle_delete_button);\n\n    w.find('button.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Row copied from ' + rel_name, 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('isnerted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(xhr) {\n                w.trigger('status', ['Row copy failed on ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x4c7702bcc44b6c5b360449c1a15e643d4114f5f70b789c7cf0b8f9ced4b40e98	commit_dialog_unstaged_field
\\x4d2b4793a5f45e14036938937bb1cd40961d0d0ccefd56a0a7d50a5a5f6744d9	workspace_tab_header
\\x4da963918e5dd8bd90cf2a7000d880fbfa52d28828d837bdafaf9dbb19b1ad16	bundle_ignored_schema
\\x4e6876b6dded2b27ddc7f7e617501a1da4af0d6b3524a30403702305c0c612ca	stage_dialog_changed_row
\\x50235897630bafa5cada43a34fd3e8e8d20fb04f6d04d319bb73dbd8fed86d91	.{{= name }} {\n    white-space: nowrap;\n    display: none;\n}\n\n.{{= name }}:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.tracked {\n    color: lightblue;\n}\n\n.{{= name }} .expand {\n    cursor: pointer;\n    display: none;\n}\n.{{= name }} .expand:hover {\n    background-color: red;\n}
\\x507969d85ce0b82c4c3ad3ea57dbb41ae84f7b5ba4477d5b500a991aca06ac0e	.{{= name }} {\n    border: 2px dotted red;\n    padding: 5px;\n    margin: 5px;\n}
\\x51111600a316ca942f14150d605eabe2534f7d9984a3d6756cab4de7cf2e3729	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'htmlmixed' }) }}\n</div>
\\x52a04589e8e0d5c378e277f333866aec7a0563f3818442be7f4268eb8c2fdabd	a4d101f6-3d5f-464b-87d6-637525254ed8
\\x52bd16217e8b90894703f18f78be37ecb0bfff0e1873114f43f6ca1da71eb67d	var w = $("#"+id);\n\n\nvar rel_name = row.relation.schema.name + '.' + row.relation.name;\n\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    w.find('.section_content').append(widget('semantics/form_field', row.field('content')));\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    w.find('.version').append(widget('semantics/form_field', row.field('version')));\n\n    // SAVE\n    function save() {\n        row.update()\n        .then(function() {\n            w.trigger('status', ['Dependency saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n        });\n    }\n\n\n    w.find('.save').on('click', save);\n    w.on('keydown', jwerty.event('ctrl+s', save));\n\n\n    // DELETE\n    w.find('.delete').on('click', function() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Dependency deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    });\n    \n\n\n    // COPY\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n            row.relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Dependency copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n\n});
\\x535798d7baa8a70efd38183e997ca1d5d1ae214ed68bec0a985ab0ffd216796d	<div id="{{= id }}" class="{{= name }}">\n    <h2>New Row</h2>\n    <hr/>\n    \n    <h3>Development</h3>\n    <div class="new_row_buttons">\n        <div id="widget" class="new_row_button">\n            <div class="new_row_icon">⚙</div>\n            <div class="new_row_name">Widget</div>\n        </div>\n        <div id="resource" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Resource</div>\n        </div>\n        <div id="template" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Template</div>\n        </div>        \n        <div id="dependency_js" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Javascript Library</div>\n        </div>\n        <div id="table" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Table</div>\n        </div>\n        <div id="view" class="new_row_button">\n            <div class="new_row_icon">⌕</div>\n            <div class="new_row_name">View</div>\n        </div>\n        <div id="function" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Function</div>\n        </div>\n        <div id="resource_binary" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Binary</div>\n        </div>\n        <div id="fdw" class="new_row_button">\n            <div class="new_row_icon">&#8599;</div>\n            <div class="new_row_name">Foreign Table</div>\n        </div>\n    </div>\n    \n    <h3>Bundle</h3>\n    \n    <h3>Everything</h3>\n</div>
\\x5358ff53681056ae0356462ae3387d63d678d4d4b649586509fda2e5e1506fa8	fcda24f0-1c2a-4b7d-a488-da24c13fef6c
\\x53b83fc9c3dd01621d2c0683f4991bb625254f9033a7d6d8b46afa013cc0d87e	bundle_untracked_browser
\\x53e8601e9073fa3019b40cdc5d25740665535c929287b6e67d9c840001857fa0	file_input
\\x542c9d3d5b5f708f31f4c40197cf25af5140fe6fc34a941a6ea10d64d3df910c	<div id="{{= id }}" class="{{= name }}">\n    <h1>commit!</h1>\n    \n    <h3>Changes</h3>\n        \n    <table border=1 class='changes'>\n        <tr><th>row</th><th>change</th><th>unstaged</th><th>staged</th></tr>\n    </table>\n\n    <!--\n    <h3>Untracked Rows</h3>\n    <p>These are changes to rows that have not yet been added to this commit.</p>\n    \n    <div class='untracked_rows'>\n        ...\n    </div>\n-->\n    <button class='stage_all'>stage all</button>\n\n    <p><button class='do_commit'>commit staged changes</button></p>\n</div>
\\x55a2c50c268113c589166dacb53c4f9aa8dd3cbe551aac17732e3964bea2e7d5	8ab2e8c6-93be-4367-b5ee-1e2c14579929
\\x56e2e69b7ccf2c2537bad2279a914317852a266ef9f7974dd560bb9621db27c6	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\n/*\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n*/\n\nendpoint.schema('widget').table('widget').row('id', row.get('id'))\n.then(function(row) {\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n    \n\t// html, css, post_js, server_js\n    ['html','css','server_js','common_js','post_js'].forEach(function(col_name, i) {\n        tabs[col_name] = function() {\n            return widget('semantics/form_field', row.field(col_name));\n        };\n        tab_colors[col_name] = colors[i % colors.length];\n    });\n    \n    // input\n    tabs['input'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('input').rows({\n        where: {\n            name: 'widget_id',\n            op: '=',\n            value: datum.get('id')\n        },\n            exclude: ['id', 'widget_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['input'] = colors[5 % colors.length];\n    \n    // dependency_js\n    tabs['dependencies'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('widget_dependency_js').rows({\n            where: {\n                name: 'widget_id',\n                op: '=',\n                value: datum.get('id')\n            },\n            include: ['dependency_js_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['dependencies'] = colors[6 % colors.length];\n\n    \n    // widget_route\n    tabs['widget_route'] = function() {\n        return widget('ide:widget_routes', { widget_id: datum.get('id') });\n    };\n    tab_colors['widget_route'] = colors[7 % colors.length];\n    \n    \n    /* TABBED LAYOUT */\n    // var preview_row = row.clone();\n\n    w.find('> .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Widget deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            //set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n            w.trigger('row_detail_save');\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n            //setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.on('keydown', jwerty.event('ctrl+alt+s', handle_save_button));\n    w.find('.delete').on('click', handle_delete_button);\n\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Widget copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('inserted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x5703f774560776175843c001581d09995d668491531534a2cfdea7bc56b51e7a	<div id="{{= id }}" class="{{= name }}">\n    <div class='tools'>\n    </div>\n    <div class='tabs'></div>\n\n</div>
\\x57ae1612b9692014484953cfe0da9216432bd372ab84a1b8041cf3b991fc9a87	506990f8-99c0-4441-a3fd-04ec402d7e22
\\x57d02e31a15cc04634064013f94ed94694ab920c67305f4c72a3cf820581240a	f71fad4d-4284-47f5-9dbf-bffdded7973b
\\x57e92380116b7ffa8e0fcf62152acf66a3f5b27f6b5ba48e74f0e40ea99f7303	bundle_ignored
\\x585002546fa8b30771ec448dc759adaf5a8faf42c14d6f40316718ae3fc05243	debugger3_widgets
\\x598daa1531878274259b2ce9e9794060ef3a7fa18f5c6aa0659dff47f2a74605	<div id="{{= id }}" class="{{= name }}">\n    <h1>Stage</h1>\n    \n    <table border=1 class='changes'>\n        <tr><th>row</th><th>change</th><th>unstaged</th><th>staged</th><th>row exists</th></tr>\n    </table>\n\n    <button class='stage_all'>stage all</button>\n\n    <p><button class='do_commit'>commit staged changes</button></p>\n</div>
\\x59c6f94018afaecb43687ba36fdb933ccca4f9223ecd72356d9823252e0d59c7	.{{= name }} {\n    height: 100%;\n}
\\x5a9d09b15ba1b1ff3aa5076baba29b5b347e21345d0c69eed33c2792a7a742c0	var w = $("#"+id);\n\n\nfunction new_tab(tab_id, label, content) {\n    // console.log('opening new tab');\n    // create the header\n    w.find('.tab_headers').append(widget('ide:workspace_tab_header', {\n        label: label,\n        tab_id: tab_id\n    }));\n\n\n    // create the tab\n    w.find('> .tab_contents').append(widget('ide:workspace_tab', {\n        content: content,\n        tab_id: tab_id\n    }));\n\n    // focus\n    show_tab(tab_id);\n}\n\nfunction current_tab() {\n    return w.find('.workspace_tab_header.highlighted').first().data('tab_id');\n}\n\nfunction show_tab(tab_id) {\n    // console.log('show tab ', tab_id);\n    // show the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).show();\n        } else {\n            $(this).hide();\n        }\n    })\n\n    // highlight the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).addClass('highlighted');\n        } else {\n            $(this).removeClass('highlighted');\n        }\n    })\n}\n\nfunction close_tab(tab_id) {\n    /*\n    why doesn't this work?\n    w.find('.workspace_tab[data-tab_id="'+tab_id+'"]').remove();\n    w.find('.workspace_tab_header[data-tab_id="'+tab_id+'"]').remove();\n    */\n    \n    var current_tab_closed = false;\n    if (tab_id == current_tab()) {\n        current_tab_closed = true;\n    }\n    \n    // remove the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // remove the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // if the current tab is closed, replace it with another\n    if (current_tab_closed) {\n        var last_tab = w.find('.workspace_tab').last();\n        if (last_tab) {\n            show_tab(last_tab.data('tab_id'));\n        }\n    }\n}\n\nfunction tab_is_open(tab_id) {\n    // check to see if it's already open\n    var is_open = false;\n    var tabs = w.find('.workspace_tab');\n    for (var i=0;i<tabs.length;i++) {\n        var this_tab_id = $(tabs[i]).data('tab_id');\n\n        // console.log('comparing '+this_tab_id +' to ' + tab_id);\n        if (this_tab_id == tab_id) {\n            // console.log('already open');\n            return true;\n        }\n    };\n    return false;\n}\n\nw.closest('.ide').bind('close_tab', function(e,o) {\n    close_tab(o.tab_id);\n});\n\nw.closest('.ide').bind('show_tab', function(e,o) {\n    show_tab(o.tab_id);\n});\n\nconsole.log(endpoint);\n// handler for row clicked event\nw.closest('.ide').bind('bundle_row_open', function(e, o) {\n    // console.log('bundle_row_clicked', e, o);\n\n    var row_id = o.row_id;\n    var row = o.row;\n\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_val = row_id.pk_value;\n    var label = widget('semantics/text_identifier', row);\n    var tab_id = schema_name + '.' + relation_name + '.' + pk_val;\n\n    if (!tab_is_open(tab_id)) {\n        console.log(endpoint);\n        // open a new tab for this row\n        endpoint\n        .schema(schema_name)\n        .table(relation_name)\n        .row(pk_column_name, pk_val).then(function(real_row) {\n            new_tab(tab_id, label, widget('semantics/row_detail', real_row));\n        }).catch(function(e) {\n            console.log('error: ',e);\n        });\n    } else {\n        // send to front\n        show_tab(tab_id);\n    }\n\n\n});\n\n// new generic dialog handler\nw.closest('.ide').bind('open_tab', function(e,o) {\n    var tab_id = o.tab_id;\n\n    if (tab_is_open(tab_id)) {\n        show_tab(tab_id);\n    } else {\n        switch (tab_id) {\n            case 'new_row':\n                new_tab('new_row', 'New Row', widget('ide:new_row_dialog', { bundle: bundle }));\n                break;\n            case 'stage':\n                new_tab('stage', 'Stage', widget('ide:stage_dialog', { bundle: bundle }));\n                break;\n            case 'commit_log':\n                new_tab('commit_log', 'Commit History', widget('ide:commit_history_dialog', { bundle: bundle }));\n                break;\n            case 'bundle_config':\n                new_tab('bundle_config', 'Bundle Config', widget('ide:bundle_config_dialog', { bundle: bundle }));\n                break;\n            case 'push_pull':\n                new_tab('push_pull', 'Push Pull', widget('ide:bundle_push_pull', { bundle: bundle }));\n                break;\n            case 'untracked':\n                new_tab('untracked', 'Untracked Rows', widget('ide:bundle_untracked', { bundle: bundle }));\n                break;\n            default:\n                alert ('internal error: no such dialog as '+tab_id);\n        }\n    }\n});\n\n// close generic dialog\nw.closest('.ide').bind('close_tab', function(e,o) {\n    var tab_id = o.tab_id;\n    close_tab(o.tab_id);\n});\n\n\n\n\n\n
\\x5a9fd7f013c72c07f72be1650c88999c1b282299a34aef99a2ae021be514fa08	.{{= name }} {\n    border-top: 1px solid white;\n    height: 100%;\n    overflow: auto;\n    padding: 10px;\n}
\\x5ace3d25ce6590a5e97cd1b482c97a8c803308ef40a4c9a6351dac8ed514a8af	b6638ea9-df8f-409e-990b-34ffee6ab4f3
\\x5b34c6a510ab9d0afeea41479c44fe221ae08fe8ba4d34932d3128bbb3f19ed9	resource_binary_upload
\\x5b8ace7a1dec735183d9bfe62b1468faa8391e645895a03ed659e3ed5e34f74e	var w = $("#"+id);\n\n\nfunction new_tab(tab_id, label, content) {\n    // console.log('opening new tab');\n    // create the header\n    w.find('.tab_headers').append(widget('ide:workspace_tab_header', {\n        label: label,\n        tab_id: tab_id\n    }));\n\n\n    // create the tab\n    w.find('> .tab_contents').append(widget('ide:workspace_tab', {\n        content: content,\n        tab_id: tab_id\n    }));\n\n    // focus\n    show_tab(tab_id);\n}\n\nfunction current_tab() {\n    return w.find('.workspace_tab_header.highlighted').first().data('tab_id');\n}\n\nfunction show_tab(tab_id) {\n    // console.log('show tab ', tab_id);\n    // show the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).show();\n        } else {\n            $(this).hide();\n        }\n    })\n\n    // highlight the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).addClass('highlighted');\n        } else {\n            $(this).removeClass('highlighted');\n        }\n    })\n}\n\nfunction close_tab(tab_id) {\n    /*\n    why doesn't this work?\n    w.find('.workspace_tab[data-tab_id="'+tab_id+'"]').remove();\n    w.find('.workspace_tab_header[data-tab_id="'+tab_id+'"]').remove();\n    */\n    \n    var current_tab_closed = false;\n    if (tab_id == current_tab()) {\n        current_tab_closed = true;\n    }\n    \n    // remove the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // remove the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // if the current tab is closed, replace it with another\n    if (current_tab_closed) {\n        var last_tab = w.find('.workspace_tab').last();\n        if (last_tab) {\n            show_tab(last_tab.data('tab_id'));\n        }\n    }\n}\n\nfunction tab_is_open(tab_id) {\n    // check to see if it's already open\n    var is_open = false;\n    var tabs = w.find('.workspace_tab');\n    for (var i=0;i<tabs.length;i++) {\n        var this_tab_id = $(tabs[i]).data('tab_id');\n\n        // console.log('comparing '+this_tab_id +' to ' + tab_id);\n        if (this_tab_id == tab_id) {\n            // console.log('already open');\n            return true;\n        }\n    };\n    return false;\n}\n\nw.closest('.ide').bind('close_tab', function(e,o) {\n    close_tab(o.tab_id);\n});\n\nw.closest('.ide').bind('show_tab', function(e,o) {\n    show_tab(o.tab_id);\n});\n\nconsole.log(endpoint);\n// handler for row clicked event\nw.closest('.ide').bind('bundle_row_open', function(e, o) {\n    // console.log('bundle_row_clicked', e, o);\n\n    var row_id = o.row_id;\n    var row = o.row;\n\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_val = row_id.pk_value;\n    var label = widget('semantics/text_identifier', row);\n    var tab_id = schema_name + '.' + relation_name + '.' + pk_val;\n\n    if (!tab_is_open(tab_id)) {\n        console.log(endpoint);\n        // open a new tab for this row\n        endpoint\n        .schema(schema_name)\n        .table(relation_name)\n        .row(pk_column_name, pk_val).then(function(real_row) {\n            new_tab(tab_id, label, widget('semantics/row_detail', real_row));\n        }).catch(function(e) {\n            console.log('error: ',e);\n        });\n    } else {\n        // send to front\n        show_tab(tab_id);\n    }\n\n\n});\n\n// new generic dialog handler\nw.closest('.ide').bind('open_tab', function(e,o) {\n    var tab_id = o.tab_id;\n\n    if (tab_is_open(tab_id)) {\n        show_tab(tab_id);\n    } else {\n        switch (tab_id) {\n            case 'new_row':\n                new_tab('new_row', 'New Row', widget('ide:new_row_dialog', { bundle: bundle }));\n                break;\n            case 'stage':\n                new_tab('stage', 'Stage', widget('ide:stage_dialog', { bundle: bundle }));\n                break;\n            case 'commit_log':\n                new_tab('commit_log', 'Commit History', widget('ide:commit_history_dialog', { bundle: bundle }));\n                break;\n            case 'bundle_config':\n                new_tab('bundle_config', 'Bundle Config', widget('ide:bundle_config_dialog', { bundle: bundle }));\n                break;\n            case 'push_pull':\n                new_tab('push_pull', 'Push Pull', widget('ide:bundle_push_pull', { bundle: bundle }));\n                break;\n            case 'untracked':\n                new_tab('untracked', 'Untracked Rows', widget('ide:bundle_untracked', { bundle: bundle }));\n                break;\n            case 'export':\n                new_tab('export', 'Export', widget('ide:bundle_export', { bundle: bundle }));\n                break;\n            case 'resource_binary_upload':\n                new_tab('resource_binary_upload', 'Resource Binary Upload', widget('ide:resource_binary_upload', { bundle: bundle }));\n                break;\n            case 'ignored':\n                new_tab('ignored', 'Ignored', widget('ide:bundle_ignored', { bundle: bundle }));\n                break;\n            default:\n                alert ('internal error: no such dialog as '+tab_id);\n        }\n    }\n});\n\n// close generic dialog\nw.closest('.ide').bind('close_tab', function(e,o) {\n    var tab_id = o.tab_id;\n    close_tab(o.tab_id);\n});\n\n\n\n\n\n
\\x5ba997e85188d885358bbeb791b71b1ba8650bb217a3e1d4f661feae68f097b9	codemirror
\\x5bae293baf08571e4ff4e5779171c82f68d15e88475ab4a300180c84cfe0c315	.{{= name }} h3 {\n    text-decoration: underline;\n}
\\x5bd16e6bbb24b12243b365a45d53172a53be98a60751f4e142e7e1e7695bbde6	.{{= name }} {\n    padding: 1px;\n    margin-bottom: 1px;\n}\n\n\n.{{= name }}:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n\n\n.{{= name }} .button {\n    float: right;\n\tborder-radius: 50%;\n    width: 1.5ex;\n    height: 1.5ex;\n    background-color: white;\n    color: black;\n}
\\x5c41cadbfa6994e300ff10c1e7c19b7bcca2de2214e5353de4ae89bfcbba9230	new_row_by_name
\\x5c5378287135b97656586d7b48facae34f0435174a2b79fe00e93d3216136dd3	stage_row_changed_diffs
\\x5ca65356e94d4f1b5f57b0477ee521cf33158158c507550b18e5e573380489ff	f8d12582-51c7-43fc-b5f4-3eb9094e0e72
\\x5d09cb54360e74189ff5545545c5c13f36546cb51185f1dd0b3927a544c7ddf1	dev_workspace
\\x5d528502a7f157dae91beedda534ceb9995d86bc71e377fb9791b7608d1c655d	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'purpose'],\n            order_by: {\n                column: 'purpose'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('core:option', {\n                label: row.get('purpose'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\x5e39e6a15744841e70452c017b5668484d8dc032ab0653baf2364a5a0055ad83	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\n/*\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n*/\n\nendpoint.schema('widget').table('widget').row('id', row.get('id'))\n.then(function(row) {\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n    \n\t// html, css, post_js, server_js\n    ['html','css','server_js','common_js','post_js'].forEach(function(col_name, i) {\n        tabs[col_name] = function() {\n            return widget('semantics/form_field', row.field(col_name));\n        };\n        tab_colors[col_name] = colors[i % colors.length];\n    });\n    \n    // input\n    tabs['input'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('input').rows({\n        where: {\n            name: 'widget_id',\n            op: '=',\n            value: datum.get('id')\n        },\n            exclude: ['id', 'widget_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['input'] = colors[5 % colors.length];\n    \n    // dependency_js\n    tabs['dependencies'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('widget_dependency_js').rows({\n            where: {\n                name: 'widget_id',\n                op: '=',\n                value: datum.get('id')\n            },\n            include: ['dependency_js_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['dependencies'] = colors[6 % colors.length];\n\n\n    /* TABBED LAYOUT */\n    // var preview_row = row.clone();\n\n    w.find('> .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Widget deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            //set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n            w.trigger('row_detail_save');\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n            //setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.on('keydown', jwerty.event('ctrl+alt+s', handle_save_button));\n    w.find('.delete').on('click', handle_delete_button);\n\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Widget copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('inserted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x5e936e765eac067af5433268effc8698a8e22a85e17d4a4a6c2558d0590ce53d	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\n// TODO this fails for views\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var columns = [];\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\n    if (row.columns == null) {\n        throw 'Please call this row with "meta_data" set to true. ' + rel_name;\n    }\n    row.columns.forEach(function(col, i) {\n        if (col.name != 'id' && col.name != 'name') {\n            tabs[col.name] = function() {\n                return widget('semantics/form_field', row.field(col.name));\n            };\n            tab_colors[col.name] = colors[i % colors.length];\n            columns.push(col.name);\n        }\n    });\n\n\n    /* TABBED LAYOUT */\n    var preview_row = row.clone();\n\n    w.find('> .top > .section_content > .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Row deleted from ' + rel_name, 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Widget delete failed', 'fail']);\n            setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('button.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.find('button.delete').on('click', handle_delete_button);\n\n    w.find('button.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Row copied from ' + rel_name, 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('isnerted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(xhr) {\n                w.trigger('status', ['Row copy failed on ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x5eb69aaa28a8760f69907d4773a4ff4b55547c9b0f729fa8c718933a65f58c34	.{{= name }} {\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n}\n\n.{{= name }} > header {\n    margin: 0;\n}\n\n.{{= name }} > header img {\n    display: inline;\n    vertical-align: middle;\n}\n\n.{{= name }} > header .text {\n    display: inline;\n    vertical-align: middle;\n}\n\n\n.{{= name }} > .content {\n    display: flex;\n    flex: 2;\n    overflow: auto; /* was 'hidden' -elh */\n}\n\n.{{= name }} .row_list_section {\n    order: 0;\n    flex: 1 1 auto;\n    align-self: auto;\n    border: 1px solid white;\n    width: 20em;\n    overflow: auto;\n}\n\n.{{= name }} .workspace_section {\n    order: 0;\n    flex: 5 1 80%;\n    align-self: auto;\n}\n\n.{{= name }} .bundle_icon:hover {\n    cursor: pointer;\n}\n\n.{{= name }} header {\n    padding-bottom: 0px;\n}\n.{{= name }} header a {\n    font-size: 200%;\n    color: blue;\n    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\n    text-decoration: none;\n    font-weight: bold;\n\n}\n\n.{{= name }} header a:hover {\n    text-decoration: underline;\n    color: blue;\n}\n
\\x5fc8dd0f8a3f95275654a4408b63993028b68a10ae6c2912b883e0e7ed888805	<div id="{{= id }}" class="{{= name }}">\n    Enter the URL of the remote you would like to add:\n\n    <p>\n        URL: <input type='text' value='http://' class='url' /><br>\n        Name: <input type='text' class='name' /><br>\n        <button class='create'>Create</button>\n        <button class='cancel'>Cancel</button>\n    </p>\n</div>
\\x5fcdf47c196e2c42d435d1999b322cae7fa667521562ea00de1ca48af5b8e38e	efa37228-3471-4f88-b744-7965d2403dae
\\x5feceb66ffc86f38d952786c6d696c79c2dbc239dd4e91b46729d73a27fb57e9	0
\\x5ff4313fbc0e8b9b09f59026186b3a25a3d0d2f0dac00c0915807da807709a3a	<div id="{{= id }}" class="{{= name }}">\n    {{= row.get('row_id') }}\n</div>
\\x606f905a24a9c6fad3f403cd2589b74ea7ae03a19ff81eeefaf668864f08eab5	<div id="{{= id }}" class="{{= name }}">\n    <span class='open'>Click to select</span>\n</div>
\\x614896271504fde786be2226571345aec077456d9151454c17a2f931723c3938	var w = $("#"+id);\n\nvar remotes = bundle.related_rows('id','bundle.remote','bundle_id');\n\nw.find('.remotes').html(widget('semantics/list_view', remotes));
\\x61eb5a8c57aa76f14579a39b0c87ab47c1d71eb8a39b98b371d3eaafb6e62108	0768c4d8-09f6-41b1-9895-6c0c0877f812
\\x61f66d6d78fe5c0be8c9debcaf8c2d845c8ce07566ac7d530fd941416e9bdb0c	.{{= name }} {\n    height: 100%;\n}\n\n.{{= name }} > .header {\n    height: 1.5rem;\n    text-align: right;\n    background-color: #333;\n}\n\n.{{= name }} > .header > .select_bundles {\n    float: left;\n}\n\n.{{= name }} > .header > * {\n\theight: 100%;\n}\n\n.{{= name }}:not(.bundle_edit) > .header > button.select_bundles,\n.{{= name }}:not(.bundle_edit) > .header > span.bundle_manager_container,\n.{{= name }}:not(.bundle_edit) > div.bundle_workspace,\n.{{= name }}.bundle_edit > div.bundle_list {\n    display: none;\n}\n\n.{{= name }} > .content {\n    height: calc(100% - 1.5rem);\n}\n\n.{{= name }} > .status_container {\n    position: fixed;\n    bottom: 0;\n    right: 0;\n    width: 100%;\n    z-index: 100;\n}\n
\\x623838ad2a41659aa8f50c946de087db894b41fb77926a1a5c9cfb23b4a56ee6	var w = $("#"+id);\n\nw.find('.name').append(widget('semantics/form_field', row.field('name')));\nw.find('.routes').html(widget('ide:template_routes', { template: row }));\nw.find('.content').append(widget('semantics/form_field', row.field('content')));\nw.find('.content_save').click(function() {\n    row.update().then(function() {\n        alert ('saved.');\n    });\n});\n\n
\\x623feb70a8beccc3eee250d91dfea56cde9dbad3881a8177fbbec4196659fd5a	var w = $("#"+id);\n\nw.find('button.refresh').click(function() {\n    w.replaceWith(widget('ide:bundle_untracked', { bundle: bundle }));\n});\n\nendpoint.schema('bundle').table('untracked_row').rows({\n}).then(function(untracked) {\n    widget.sync(untracked, w.find('.rows'), function(row) {\n        return widget('bundle_untracked_row_li', {\n            row: row\n        });\n    });\n});\n\nw.find('input.checkall').change(function() {\n    console.log('checkall');\n    if(this.checked) {\n        w.find('input.action').prop('checked',true);\n        w.find('span.actions').show();\n    } else {\n        w.find('input.action').prop('checked', false);\n        w.find('span.actions').hide();\n    }\n\n});\n\nw.find('button.ignore').click(function() {\n    var selected = [];\n    w.find('input.action:checked').each(function() {\n        selected.push($(this).closest('.bundle_untracked_row_li').data('row_id'));\n    });\n\n    w.append(widget('ide:modal', {\n        content: widget('ide:ignore_modal', {\n            rows: selected\n        })\n    }));\n\n    /*\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema('bundle').function('ignored_row_add', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            li.remove();\n        }).catch(function(e,o) {\n            alert('error ignoring row!');\n            console.log('error ignoring row: ', row_id, e,o);\n        });\n\n    */\n});\n\n\nw.find('button.track').click(function() {\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            li.remove();\n        }).catch(function(e,o) {\n            alert('error tracking row!');\n            console.log('error ignoring row: ', row_id, e,o);\n        });\n    });\n});\n\n\n\n\nw.find('button.delete').click(function() {\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema(schema_name).table(relation_name).row(pk_column_name, pk_value)\n        .then(function(row) {\n            row.delete().then(function() {\n                li.remove();\n            }).catch(function(e,o) {\n                alert('error tracking row!');\n                console.log('error ignoring row: ', row_id, e,o);\n            });\n        })\n        .catch(function() {\n            alert('could not find row');\n        });\n    });\n});\n\n
\\x62698de7ebb236b44c3e0b61bd82139bec11aa423e76504b58a6a0fd421b1212	<div id="{{= id }}" class="{{= name }}">\n    <label><input type='radio' name='{{= name }}' value='{{= bundle.get("name") }}'> {{= bundle.get('name') }}</label>\n</div>
\\x629f3d2d42dd95f2b3b548f586b38499bb8f4b1f655cb8053229c9c195a1c4f5	list_item_path
\\x62e4283b1b269c99b2322fc0ffdd053d6ea1ed4d5302210fe831fc6f35ce6f61	3a598b60-305d-4b23-8e01-855219b33ac2
\\x62efef9f19c849df6889982f78626156ec0662e77ac59f21324c5ae22b3bf803	bundle_import_fs
\\x637fa38ff5990502881082c8879f84e4c0e1c917d790e475645472206e60a28b	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\n\nw.find('.close').click(function(e) {\n    w.trigger('close_tab', { tab_id: tab_id });\n    e.stopPropagation();\n});\n\nw.click(function() {\n    w.trigger('show_tab', { tab_id: tab_id });\n});
\\x650ae161af699a8d17ea55e5e842965c55a65ece1c268437b53a091ca319a564	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('path') || row.get('id') }}\n</li>
\\x659b19554accb3f2798a4c2bd9a8ae58b120af2884027fc871e8dbe12eafc9fb	<option id="{{= id }}" class="{{= name }}" value="{{= value }}" {{? typeof selected != 'undefined' && selected == true}}selected {{?}}>{{= label }}</option>\n\n
\\x65a4a992a2b9f883981446749eab41103b6fb1baabea7839ced30c8f992e271e	stage_dialog_unstaged_fields
\\x65bf4dc92e018509d2f36000be7dec2779fe7de3d22a0ccd56fcc8bed335091d	.{{= name }} {\n    cursor: pointer;\n    position: relative;\n}\n\n.{{= name }}:hover {\n    background-color: yellow;\n    color: black;\n}\n\n.debugger3_widget_highlight {\n    border: 4px solid yellow !important;\n}
\\x66d37ba7fe649b445f3defbdd887c092adf11f7c8948622c31089083fb075290	<div id="{{= id }}" class="{{= name }}">\n    <h3>Export to Filesystem</h3>\n    \n    bundle directory: <input type='text' size=100 class='directory' value='/opt/aquameta/bundles-available/{{= bundle.get('name') }}'><br>\n    <button class='export'>export</button>\n</div>
\\x6863377c1a83631e87615c4e3b15f0becc49cafaf9414bec2bd5e5f9bb7c6558	var w = $("#"+id);\n\nvar bundles = endpoint.schema('bundle').table('bundle').rows({\n    order_by: {\n        column: 'name'\n    }\n})\nwidget.sync(bundles, w.find('.bundles'), function(bundle) {\n    return widget('bundle_selection', { bundle: bundle });\n});\n\nw.find('.bundles .select').on('click', function() {\n    w.trigger('bundle_selected', { bundle_name: w.find(':checked').val() });\n});\n\n\nw.find('.bundles .new').on('click', function() {\n    var name;\n    if (name = prompt('Enter bundle name')) {\n        endpoint.schema('bundle').table('bundle').insert({\n            name: name\n        }).then(function() {\n            w.replaceWith(widget('ide:bundle_selector'));\n        }).catch(function(e,o) {\n            console.log('error creating bundle: ', e, o);\n        });\n    }\n});\n\n\nw.find('.bundles button.import').click(function() {\n    w.append(widget('ide:modal', { content: widget('ide:bundle_import_fs') }));\n});\n\n\n\n\nw.find('.tabs .untracked').click(function() {\n    var untracked = endpoint.schema('bundle').table('untracked_row').rows();\n    w.find('.bundles').html(widget('ide:bundle_untracked_browser', { untracked: untracked }));\n\n    \n});
\\x6877310210ad6eb417d226f6c596e780936bb123a2fe63f965466cd1f5915a64	.{{= name }} {\n    display: flex;\n    flex-direction: row;\n    height: 100%;\n}\n\n.{{= name }}.detail_view > section.list {\n    flex: 1;\n}\n\n.{{= name }}.detail_view > section.detail {\n    flex: 2;\n}\n\n\n\n/* LIST */\n.{{= name }} > .list {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.{{= name }} > .list > ul {\n    flex: 9;\n    list-style: none;\n    overflow-y: auto;\n    padding: 0;\n    margin: 0;\n}\n\n.{{= name }}.detail_view > .list {\n    margin: 0;\n    background-color: #888;\n}\n\n.{{= name }}:not(.detail_view) > .list {\n    width: 80%;\n    margin: 0 auto;\n    background-color: none;\n}\n\n.{{= name }} > .list.collapsed {\n    width: 0;\n    display: none;\n}\n\n\n.{{= name }} > .list > .header {\n    flex: 1;\n    text-align: center;\n    border-bottom: 0.5rem solid rgba(0, 0, 100, 0.2);\n}\n\n.{{= name }}.detail_view > .list > .header {\n    flex: 0;\n    display: block;\n    text-align: center;\n}\n\n.{{= name }}.detail_view > .list > .header > .title {\n    font-size: initial;\n}\n\n.{{= name }} > .list > .header > .title {\n    display: inline-block;\n    font-size: x-large;\n    margin-bottom: 1rem;\n}\n\n.{{= name }} > .list > .header > .arrow {\n    display: inline-block;\n    margin: 0 0.5rem;\n    font-size: x-large;\n    vertical-align: sub;\n    \n    transform: rotate(270deg);\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    -moz-transform: rotate(270deg);\n    \n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }} > .list > .header > .arrow.up {\n    transform: rotate(90deg);\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    -moz-transform: rotate(90deg);\n}\n\n.{{= name }}.detail_view > .list > .header > .arrow {\n    font-size: initial;\n    vertical-align: middle;\n}\n\n.{{= name }} > .list > .header > .continue.hide {\n    display: none;\n}\n\n.{{= name }} > .list > .header > .continue {\n    position: relative;\n    width: 25%;\n    padding: 0.75rem;\n    \n    font-size: medium;\n    border: 2px solid darkgreen;\n    border-radius: 0.1rem;\n    color: #ddd;\n    background-color: green;\n}\n\n.{{= name }} > .list > .header > .continue:hover {\n    background-color: darkgreen;\n}\n\n.{{= name }} > .list > .header > .continue:active {\n    top: 1px;\n    background-color: lightgreen;\n}\n\n.{{= name }}.detail_view > .list > .header > button {\n    margin: 1rem auto;\n}\n\n.{{= name }} > .list > .header > button:first-child {\n    margin-left: 2rem;\n}\n\n.{{= name }} > .list > .header > button {\n    margin: 1rem 0;\n}\n\n.{{= name }} > .list > .header > .options {\n    display: inline-block;\n    width: 60%;\n    text-align: left;\n    padding: 0 1rem 1rem;\n}\n\n.{{= name }}.detail_view > .list > .header > .options {\n    width: 100%;\n}\n\n.{{= name }} > .list > .header > .arrow:not(.up) ~ .options {\n    display: none;\n}\n\n.{{= name }} > .list > .header > .options > .search {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > .list > .header > .options > .search:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > .list > .header > .options > .search:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}\n\n\n\n/* DIVIDER */\n.{{= name }}:not(.detail_view) > .divider {\n    display: none;\n}\t\n\n.{{= name }}.detail_view > .divider {\n    padding: 0.25rem;\n    background-color: #333;\n\tcursor: w-resize;\n    pointer: w-resize;\n}\n\n.{{= name }}.detail_view > .divider > span {\n    display: inline-block;\n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }} > .list.collapsed + .divider {\n    cursor: e-resize;\n    pointer: e-resize;\n}\n\n.{{= name }} > .list.collapsed + .divider > span {\n    transform: rotate(180deg);\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    -moz-transform: rotate(180deg);\n}\n\n.{{= name }} > .divider:hover {\n    background-color: #666;\n}\n\n.{{= name }} > .divider:active {\n    background-color: #888;\n}\n\n\n\n/* DETAIL */\n.{{= name }}.detail_view > .detail {\n    padding: 0 1rem 1rem;\n    /* padding: 1rem; */\n}\n
\\x68ab7ed2eb06ac9f8b64f529ea52d50a441baac2e3b98242d8bde19b5b2e05b5	5b3d0629-48a8-4695-af58-52235349ae00
\\x68cd8c4c16a9155db64a91a376b40ee1aec6c0106de7c8c2590ebaa0ecdfd4f0	.{{= name }} {\n    border: 1px solid #999;\n    width: 100px;\n    background-color: #000;\n    padding-left: 5px;\n}\n\n.{{= name }} .close {\n    padding: 0px 5px;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n    cursor: pointer;\n}\n\n.{{= name }}.highlighted {\n    background-color: #0aa;\n}\n\n.{{= name }} span.close:hover {\n    background-color: red;\n    color: white;\n    cursor: pointer;\n}
\\x6a16a1c8a0871db9d880ec09aa08a951aff4aad8a4cdf401b27129a89b7617c8	33e64e6d-87ec-4598-882d-1c5a7560082a
\\x6a861794547f4aae2955aa5fa5ec3a739840e148985598f9952d9ee96a2cde7f	var w = $("#"+id);\n\nw.find('button.upload').click(function () {\n    const reader = new FileReader()\n    const file = w.find('.fileUpload').get(0).files[0];\n    \n    reader.onload = event => {\n        const { name, size, type } = file\n        const dataURL = event.target.result\n        const content = dataURL.replace(/^data:.+;base64,/, '');\n        \n        endpoint.schema('endpoint').table('mimetype_extension').row({\n            where: {\n                name: 'extension',\n                op: '=',\n                value: name.split('.').pop()\n            }\n        }).then(function(ext) {\n            const mimetype_id = ext.get('mimetype_id') || '';\n            endpoint.schema('endpoint').table('resource_binary').insert({\n                path: w.find('input.path').val(),\n                content: content,\n                mimetype_id: mimetype_id\n            }).then(result => {\n                alert('success.');\n                console.log('file saved')\n            }).catch(error => {\n                alert('file upload no worky\\n' + error)\n            })\n        });\n    }\n    reader.readAsDataURL(file)\n});\n\nw.find('.fileUpload').change(function() {\n    if (w.find('input.path').val() == '') {\n        var filename = w.find('input.fileUpload').val().split('\\\\').pop();\n        w.find('input.path').val('/'+bundle.get('name')+'/'+filename);\n    }\n});
\\x6afb5c2e817aceb67adf11cb7960fc9c5ef71aa6335d1b9bbecf1853b5b98bbd	<div id="{{= id }}" class="{{= name }}">\n    <h1>template: <span class='name'></span></h1>\n    \n    <div class='actions' style='float: right'>\n        <button class='delete_template'>delete template</button>\n    </div>\n    \n    <h3>Routes</h3>\n    <div class='routes'></div>\n    \n    <h3>Content</h3>\n    <button class='content_save'>save</button>\n    <div class='content'></div>\n</div>
\\x6b493f0906f9fed9907837053d8465844786e217633b7f64a4d4f477dea6e6bb	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n \n * join_table:\n * join_from_column:\n * join_to_column:\n \n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar join_rows;\nvar where_object = {};\nwhere_object[join_from_column] = from_row.get(from_column);\nfunction show_list() {\n    \n    w.find('.join_rows').empty();\n    \n    join_rows = endpoint.schema(join_table.schema.name).table(join_table.name).rows().where(where_object);\n    \n    widget.sync(join_rows, w.find('.join_rows'), function(row) {\n        return widget('sem_fkey_many_to_many_li', { \n            row: row,\n            label_function: label_function\n        });\n    });\n}\n
\\x6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b	1
\\x6c071d732c8713602aa93dfe40ae1da37ef6b96a21fde8f6f09ce9db3fbd0ab1	list_view_gateway
\\x6c82f41c7a1d89a354e8c39cd75f59ef3fbe445c2cfa496c5d4492a92a1351a0	757f5d27-b98c-4e03-9b9a-68457402456d
\\x6d007c11256a4b37081649f93d2bfaeb17d6ce2c88e71167eec6fbfacc12ef24	11f0af38-f0b0-4fbe-8618-3ba3d6688e75
\\x6d413d7d60591219deddbe3e3dbebfa6158249792bdaea53f73341979c491d7f	bundle_export
\\x6d75986e4b0effde19361ad9a2301a5e3f2bbf4ae0a578d33d860fd9c41258a5	.{{= name }} div.unstaged {\n    display: none;\n    background-color: pink;\n}\n\n.{{= name }} div.staged {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} div.unstaged_fields {\n    display: none;\n    background-color: pink;\n}\n.{{= name }} div.staged_fields {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.modified_link {\n    font-size: 72%;\n}\n.{{= name }} span.modified_link:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n\n.{{= name }} .text_id span:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n
\\x6e50b025cd05e665433b2efaf49d2ea5d961a72949154e9014fd99ff6777f348	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\n/*\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n*/\n\nendpoint.schema('widget').table('widget').row('id', row.get('id'))\n.then(function(row) {\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n    \n\t// html, css, post_js, server_js\n    ['html','css','post_js','server_js'].forEach(function(col_name, i) {\n        tabs[col_name] = function() {\n            return widget('semantics/form_field', row.field(col_name));\n        };\n        tab_colors[col_name] = colors[i % colors.length];\n    });\n    \n    // input\n    tabs['input'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('input').rows({\n        where: {\n            name: 'widget_id',\n            op: '=',\n            value: datum.get('id')\n        },\n            exclude: ['id', 'widget_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['input'] = colors[4 % colors.length];\n    \n    // dependency_js\n    tabs['dependencies'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('widget_dependency_js').rows({\n            where: {\n                name: 'widget_id',\n                op: '=',\n                value: datum.get('id')\n            },\n            include: ['dependency_js_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['dependencies'] = colors[5 % colors.length];\n\n\n    /* TABBED LAYOUT */\n    // var preview_row = row.clone();\n\n    w.find('> .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Widget deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            //set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n            w.trigger('row_detail_save');\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n            //setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.on('keydown', jwerty.event('ctrl+alt+s', handle_save_button));\n    w.find('.delete').on('click', handle_delete_button);\n\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Widget copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('inserted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x6e88768ee76162254332f894fc5ff4f638f8f760017cd52bd7720479857ea07d	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.2', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:ide'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\x6ef876c8791daec6f97cb3b47ed632bab5f56b74bee3fed0761e97e3acfa4bc2	<div id="{{= id }}" class="{{= name }}">\n    <p>{{= widget('semantics/form_field', row.field('name')) }}</p>\n    <div class="top">\n        <div class="sections">\n            <div class="section code selected">code</div>\n            <div class="section data">data</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="save">Save</button>\n                <button class="copy">Copy</button>\n                <button class="delete">Delete</button>\n            </div>\n            <div class="tabs"></div>\n        </div>\n    </div>\n</div>
\\x6f0563d19348597343ca2c5c6aa2bb7dd19c6243acde7934023df25f22d213e6	50d541d0-91d8-4d23-8a16-ef99261ae323
\\x6fd5396780d06df02a0335e226220c48ba21c4670a75ffffeff3799c207a0595	8ed1284f-340f-4d28-885c-2efea81c7b7e
\\x700754396d520b688905e32933931d1a34d55c871ef6fa63681cb521529bb298	<div id="{{= id }}" class="{{= name }}">\n    <span class='field_name'></span><button class='unstage'>unstage</button>\n</div>
\\x71cc2f18ac5d0a8f1782b88ed6bacb883306ea367e2c9aa6f55c98cfb69c2706	/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.bundle_name = "[non-widget]";\n        widget_node.bundle_alias = "[non-widget]";\n        widget_node.widget_id = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n        widget_node.bundle_name = $(element).attr('data-bundle_name');\n        widget_node.bundle_alias = $(element).attr('data-bundle_alias');\n        widget_node.widget_id = $(element).attr('data-widget_id');\n        widget_node.element = element;\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // bundle stuff\n            smalltree[name]['bundle_name'] = child.bundle_name;\n            smalltree[name]['bundle_alias'] = child.bundle_alias;\n            smalltree[name]['widget_id'] = child.widget_id;\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n\n
\\x71d5b0cec037bb29ab1930b61ef0a586bf2071c0b1f883921f8a20b2f8b44622	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\n/*\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n*/\n\nendpoint.schema('widget').table('widget').row('id', row.get('id'))\n.then(function(row) {\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n    \n\t// html, css, post_js\n    ['html','css','post_js'].forEach(function(col_name, i) {\n        tabs[col_name] = function() {\n            return widget('semantics/form_field', row.field(col_name));\n        };\n        tab_colors[col_name] = colors[i % colors.length];\n    });\n    \n    // input\n    tabs['input'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('input').rows({\n        where: {\n            name: 'widget_id',\n            op: '=',\n            value: datum.get('id')\n        },\n            exclude: ['id', 'widget_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['input'] = colors[4 % colors.length];\n    \n    // dependency_js\n    tabs['dependencies'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('widget_dependency_js').rows({\n            where: {\n                name: 'widget_id',\n                op: '=',\n                value: datum.get('id')\n            },\n            include: ['dependency_js_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['dependencies'] = colors[5 % colors.length];\n\n\n    /* TABBED LAYOUT */\n    // var preview_row = row.clone();\n\n    w.find('> .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Widget deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            //set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n            w.trigger('row_detail_save');\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n            //setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.on('keydown', jwerty.event('ctrl+alt+s', handle_save_button));\n    w.find('.delete').on('click', handle_delete_button);\n\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Widget copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('inserted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x729aaaa4651a7837c344487775a5b42198e73e98ca7bbdf9583ac2d5a356c3ea	row_detail_widget
\\x72f82ac3904a47573322714031736d032ea6ee806a27c0505d9507b35cdccafe	editable_field_fkey_select
\\x7350ba8d2f23a9badfaecbb353f2e59b22d10f9052aeefe5414d2c74d36b2822	<div id="{{= id }}" class="{{= name }}">\r\n</div>
\\x73a21564138e23828ddab93c8bd3bbd2ab17c096888b39d73cd9e01303bb5852	var w = $("#"+id);\n\nendpoint.schema('endpoint').table('template_route').rows({\n    where: {\n        name: 'template_id',\n        op: '=',\n        value: template_id\n    }\n}).then(function(routes) {\n    widget.sync(routes, w.find('.routes'), function(route) {\n        return widget('ide:template_route', { template: template });\n    });\n\n});\n\n\nw.find('button.new').click(function() {\n    if (path = prompt('Enter the URL path of the route to add to this template')) {\n        endpoint.schema('widget').table('template_route').insert({\n            path: path,\n            template_id: template_id\n        }).then(function(route) {\n            w.find('.routes').append(widget('ide:template_route', { route: route }));\n        });\n    }\n});
\\x73ccb3af163ca15969f8afed1fdb87f3c4ec1fd554de2a22ccdbabae1992e704	new_row_use_copy_instead
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x7484ca9efd2ac871da3e91d18e74385aecf331bf1a27b91d8bd2a39fee19dca9	var w = $("#"+id);\n\n////////////////////////////////////////////////////////////////////\n// clearable timeout - http://stackoverflow.com/questions/5226578/check-if-a-timeout-has-been-cleared\n////////////////////////////////////////////////////////////////////\n\nfunction Timeout(fn, interval, scope, args) {\n    scope = scope || window;\n    var self = this;\n    var wrap = function(){\n        self.clear();\n        fn.apply(scope, args || arguments);\n    }\n    this.id = setTimeout(wrap, interval);\n}\n\n\nTimeout.prototype.id = null\nTimeout.prototype.cleared = false;\nTimeout.prototype.clear = function () {\n    clearTimeout(this.id);\n    this.cleared = true;\n    this.id = null;\n};\n\n////////////////////////////////////////////////////////////////////\n// draw the tree\n////////////////////////////////////////////////////////////////////\n\nfunction draw_tree() {\n    if (timer && !timer.cleared) {\n        timer.clear();\n    }\n\n    \n    var widget_tree = get_widget_tree($('body')[0]);\n    var agg_tree = get_aggregate_widget_tree(widget_tree);\n\n    var c = w.find('.tree_container').empty();\n    for (var widget_name in agg_tree) {\n\n        c.append(widget('debugger3_widgets_tree', { \n            widget_name: widget_name,\n            properties: agg_tree[widget_name],\n            depth: 0\n        }));\n    }\n}\n\nfunction delayed_redraw(e, payload) {\n    var widg = payload.widget.get(0);\n    // don't redraw for any debugger widget loadings\n    if (widg.className.indexOf('debugger3_widgets_tree') != -1) return;\n    \n    if (!timer || timer.cleared) {\n        // console.log('setting up delayed redraw....'+widg.className);\n        timer = new Timeout(draw_tree, 100);\n    }\n    else { \n        // console.log('.....no go on '+widg.className); \n    }\n}\n\nvar timer = false;\ndraw_tree();\n$(document).bind('widget_loaded', delayed_redraw);\n\n\n\n/////////////////////////////////////////////////////////////////////\n// show all\n/////////////////////////////////////////////////////////////////////\n\nw.find('div.show_all').bind('mouseover', function(e) {\n    $("[data-widget]").addClass('debugger3_widget_highlight');\n    e.stopPropagation();    \n}).bind('mouseout', function(e) {\n    $("[data-widget]").removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n
\\x75cc81e8305512e5ee3f9f0f96a56312266547cb30d67e7f9a5528c975a772dd	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.stage').click(function() {\n    endpoint.schema('bundle').function('stage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function(e, o) {\n        console.log(e, o);\n        w.trigger('reload_stage_dialog');\n    })\n    .catch(function() {\n        alert('stage failed');\n        console.error('stage failed');\n    });\n    \n});\n
\\x7669ec761fa6b88a8e8cdb03a1ed8387a6abc1d57a1d4358ba4bdfb4932254d0	89a4a72e-cd33-4a0d-b9fe-3d37020b62da
\\x767308688adf85ffd7b056875aded376cdf92cebbb8df0452f666481675b4d17	var w = $("#"+id);\n\n\n\n// widget\n\nw.find('#widget').click(function() {\n    var name = prompt('New widget name');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('widget').insert({ name: name })\n    .then(function(widget) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'widget',\n            'id',\n            widget.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: widget, row_id: widget.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n\n// resource\n\nw.find('#resource').click(function() {\n    var path = prompt('Enter the path for this resource');\n    if (!path) { return; }\n\n    endpoint.schema('endpoint').table('resource').insert({ path: path, content: '', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(resource) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'resource',\n            'id',\n            resource.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: resource, row_id: resource.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n// dependency_js\n\nw.find('#dependency_js').click(function() {\n    var name = prompt('Enter the name for this dependency');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('dependency_js').insert({\n        name: name,\n        content: '// add your js library here',\n        version: ''\n    }).then(function(dep) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'dependency_js',\n            'id',\n            dep.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: dep, row_id: dep.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// table\n\nw.find('#table').click(function() {\n    var name = prompt('New table name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('table').insert({\n        schema_name: schema,\n        name: name\n    }).then(function(table) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'table',\n            'id',\n            table.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: table, row_id: table.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// view\n\nw.find('#view').click(function() {\n    var name = prompt('New view name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('view').insert({\n        schema_name: schema,\n        name: name,\n        query: 'select 1'\n    }).then(function(view) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'view',\n            'id',\n            view.id\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: view, row_id: view.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n// function\nw.find('#function').click(function() {\n    var name = prompt('New function name');\n    if (!name) { return; }\n\n    var schema = prompt('What schema should it go in?');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('function').insert({\n        name: name,\n        schema_name: schema,\n        parameters: ['integer'],\n        return_type: 'void',\n        definition: '',\n        language: 'sql'\n    })\n    .then(function(f) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'function',\n            'id',\n            f.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: f, row_id: f.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n
\\x76dea33b5fcdfaaffe69f9081f1cdb9293dafd8abb5a91a9fb3b5955f5af7920	.{{= name }} {\n    width: 100%;\n    height: 1.5rem;\n    color: white;\n    text-align: center;\n    \n    background-color: white;\n    visibility: visible;\n    opacity: 1;\n    \n    -webkit-transition:\n        background-color 500ms,\n        opacity 1s 1s,\n        visibility 0s 2s;\n}\n\n.{{= name }}.fade {\n    opacity: 0;\n    visibility: hidden;\n}\n\n.{{= name }}.success,\n.{{= name }}.good {\n    background-color: green;\n}\n\n.{{= name }}.fail,\n.{{= name }}.failed,\n.{{= name }}.bad {\n    background-color: red;\n}
\\x7785012b278b096f1b6a4988374ed76d9ec10d75530d0ba72376d02506094614	.{{= name }} {\n    display: inline-block;\n    padding: 0 1rem;\n}
\\x778656789a8a318829c8724afd915d3d08785585eb2423e4b11abf8d2ddc3221	workspace_tabs
\\x77fcd296e80da02a0433de2ec8d16754a6a254c95722ce96728b87d6deb8db73	commit_dialog_unstaged_fields
\\x78ad322d4425011c4967d50a70c8b7e8198a0d99a98b267b67629262da46d5f8	list_item_with_edit_button
\\x79307d034dcfaa72e3d62945305195c3331071c9ac17bf9c9096904e3e665194	var w = $("#"+id);\n\nvar remotes = bundle.related_rows('id','bundle.remote','bundle_id');\n\nwidget.sync(remotes, w.find('.remotes'), function(remote) {\n    return widget('ide:bundle_remote', { remote: remote });\n});\n\nw.find('.new_remote').click(function() {\n    w.append(widget('ide:modal', { content: widget('ide:bundle_remote_new', { bundle: bundle }) }));\n});
\\x79ab288df5c841a12746e5b84913f8c57bbc51642c9427b0f0770ea8d16d5910	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar append_new_widget = function() { \n    \n    alert('New widget still loading...\\nTry again in a moment'); \n    \n}\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\n\n// Find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    schema_name: to_relation.schema.name,\n    name: to_relation.name\n}).result(function(to_relation_obj) {\n\n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n\n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n    \n    append_new_widget = function() {\n        \n        w.append(\n            widget('modal_overlay', {\n                content: widget(new_row_widget, { \n                    relation: to_relation_obj,\n                    context_data: context_data\n                })\n            })\n        );\n        \n    }\n\n\n});\n\n\n// Prevent reload tab triggered by 'sem_list_item_new'\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n});\n\n\n// When new_row_widget returns...\nw.on('new_row', function(e, payload) {\n    \n    select_row(payload.new_row);\n    \n});\n\n\n// When a row is selected...\nfunction select_row(row) {\n    \n    if (row == 'new') {\n        \n        append_new_widget();\n        \n    }\n    \n    else if (row == 'none') {\n\n        from_row.set(from_column, null);\n        from_row.update().done(function() {\n\n            console.log('Fkey deleted');\n            w.trigger('fkey_deleted');\n            w.trigger('done');\n\n        });\n        \n    }\n    \n    else {\n        \n        from_row.set(from_column, row.get(to_column));\n        from_row.update().done(function() {\n\n            console.log('Fkey updated');\n            w.trigger('fkey_updated', row);\n            w.trigger('done');\n\n        });\n        \n    }\n    \n    \n}\n\n\n// Prepare autocomplete\norder_by_function(to_relation.rows()).done(function(rows) {\n    \n    var ps2 = Array();\n    var start = 0;\n    \n    ps2.push({\n        value: '[ none ]',\n        data: 'none'\n    });\n    \n    ++start;\n    \n    if (new_enabled) {\n        ps2.push({\n            value: '[ new ]',\n            data: 'new'\n        });\n        \n        ++start;\n    }\n    \n    for (var i = 0; i < rows.length; i++) {\n        \n        ps2[start + i] = { value: label_function(rows[i]), data: rows[i] }\n        \n    }\n\n\n    w.find('.autocomplete').autocomplete({\n        lookup: ps2,\n        appendTo: '.results',\n        onSelect: function (suggestion) {\n            //alert('You selected: ' + suggestion.value + ', ' + suggestion.data);\n            select_row(suggestion.data);\n\n        }\n    });  \n    \n    load_complete();\n});\n\nfunction load_complete() {\n    \n    w.find('.loading').hide();\n    w.find('.loaded').show();\n    console.log('Ready for autocomplete');\n    \n}
\\x7ac5d27b09ab9483000113d349323abb02293db5f3d878958715e0a75f033d85	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id')\n    .html(widget('semantics/text_identifier', real_row))\n    .click(function() {\n        w.trigger('bundle_row_open', {\n            row_id: change.get('row_id'),\n            row: real_row\n        });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n// stage button\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                w.remove();\n            }).catch(function(e) {\n                console.error(e);\n            });\n            break;\n        case 'same':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                w.remove();\n            }).catch(function(e) {\n                console.error(e);\n            });\n            break;            \n        case 'deleted':\n            console.log('not implemented yet');\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});
\\x7b6542580bdea7df0b87e27bd9a74b4d08bb4faeaf6a1f6830acf3c5a1a4c6f4	jQuery.closestDescendent
\\x7b75915c4fcb8e1b7ca36406e11e7af6d5ce327e9c4daab2e321c879ffa3e0de	var w = $('#'+id);\n\nif (typeof field.value == 'object')\n    field.value = JSON.stringify(field.value);\n\nvar editor = CodeMirror(w.get(0), {\n    value: field.value,\n    mode:  language,\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\n\nw.data('codemirror', editor);\n\nfunction change_handler(doc) {\n    field.set(doc.getValue());\n    w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor.on('change', change_handler);\n\n/*\nw.data('disable_code_change_evt', function() { editor.off('change',change_handler); });\nw.data('enable_code_change_evt', function() { editor.on('change',change_handler); });\nw.trigger('code_changed', { codemirror: editor, field: field });\n*/
\\x7bd7e6002b3a3e2b1030e83a500ac4bee004092842488b302210b19379093f18	<div id="{{= id }}" class="{{= name }}">\n    <section class='list'>\n        <div class='header'>\n            <p class='title toggle_options'></p>\n            <span class='arrow toggle_options'>&#10094;</span>\n            <button class='continue hide'>Continue</button>\n            <br>\n            <div class='options hide'>\n                <button class='new'>New row</button>\n                <br>\n                <input class='search' type='text' placeholder='Search'>\n            </div>\n        </div>\n        <ul></ul>\n    </section>\n    <section class='divider'><span>&#10094;</span></section>\n    <section class='detail'></section>\n</div>
\\x7c74c720e217f078083fea7783e171826e88e52bd672af51f805517e2c8db6e7	new_row_dialog
\\x7d9227eba4b75a929e8144dc5c87af061f941c0d0c65409455b199960a542593	f7fb9714-3d99-444d-8b5f-d546ae354637
\\x7de727e6e24583a8b2b34f756d83f72a84bdd04f289ffd9f448b49173817d2d1	81be0e52-9712-42d6-a1c1-fa773db591c1
\\x7deb7a951ec3b81573a7bf1e375e584b444c1bdf4cf5fc820708c663ba57b292	ide
\\x7e6c1de49b8df04ef4b84868ad86102c0ef91b0e9e514535875188c4b9a70932	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .title {\n    padding: 1.5rem 0;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n/*\n.{{= name }} > .title > span:nth-child(2) {\n    padding: 0 1rem;\n    font-size: 1rem;\n}\n*/\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\x7e94dd4d65d6dcbb0ae1464839bac454405dd55e215d372191668e146c9a1392	var w = $("#"+id);\n/*\nsetTimeout(function() {\n\tw.trigger('done');\n}, 4000);\n*/\n\nwidget.sync(endpoint.schema('endpoint').table('mimetype').rows(), w.find('.mimetype'), function(mime) {\n    return widget('core:option', {\n        label: mime.get('mimetype'),\n        value: mime.get('id')\n    });\n});\n\nw.find('.save').on('click', function() {\n    if (w.find('.path').val() == '' || w.find('.mimetype').val() == null) {\n        alert('Path and mimetype needed');\n        return;\n    }\n    endpoint.schema('endpoint').table('resource').insert({\n        path: w.find('.path').val(),\n        mimetype_id: w.find('.mimetype').val(),\n        content: '<!doctype html><html><head></head><body></body></html>'\n    })\n    .then(function(new_row) {\n        w.trigger('insert', { row: new_row });\n        w.trigger('status', ['Resource created', 'success']);\n        w.trigger('done');\n        w.remove();\n    });\n});\n\nw.find('.exit').on('click', function() {\n    w.trigger('done');\n});\n
\\x7e963ee468dfbb62df6e61b5a9dc88a4dcb113ccabea7bbebb0356f65934fe1c	var w = $('#'+id);\n\nvar synced = false;\nw.on('click', function(e) {\n    \n    e.stopPropagation();\n\n    w.toggleClass('expanded');\n    w.find('.empty').addClass('hide');\n\n    if (!synced) {\n\n        rows_function()\n        .then(function(rows) {\n            \n            if (!rows.length) { return empty_result(); }\n                \n            synced = true;\n            widget.sync(rows, w.find('.list'), function(row) {\n                return widget('semantics/list_item', row);\n            });\n        })\n        .catch(empty_result);\n\n    }\n});\n\nfunction empty_result() {\n    setTimeout(function() {\n        w.removeClass('expanded');\n        w.find('.empty').removeClass('hide');\n        synced = false;\n    }, 500);\n}\n
\\x7e974b274f40b67fd45ce3950d74a580c892fc31cf7d97a63efca2c53f8d3a39	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'name'],\n            order_by: {\n                column: 'name'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('core:option', {\n                label: row.get('name'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\x7fd8dce2123d9e4a6fba8d544670c356b9f8f83997661d919962fba007629d7a	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'name'],\n            order_by: {\n                column: 'name'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('ide:option', {\n                label: row.get('name'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\x8037065a125f29d0b16038db7c98544c474e1d1f7ad8f89329e63b1a6d012c8e	form_field_composite
\\x805036ca36c4092967cfad86ed5a76244fdaf506fafa0af46196d109e45e37f0	<div id="{{= id }}" class="{{= name }}">\n    <div class='tabs'>\n        <div class='tab localhost'>bundles</div>\n        <div class='tab untracked'>untracked</div>\n    </div>\n    <div class='container'>\n        <div class='bundles'>\n            <button class='new'>new bundle</button>\n        </div>\n    </div>\n</div>
\\x80e3ebfb4f400448eb3d051ccf3d5d8d033e0e1c18ddc9ecee5bdaf046d2e923	var w = $("#"+id);\n\n// new row button handler\nw.find('button.new_row').click(       function() { w.trigger('open_tab', { tab_id: 'new_row' }); });\nw.find('button.stage').click(         function() { w.trigger('open_tab', { tab_id: 'stage' }); });\nw.find('button.commit_log').click(    function() { w.trigger('open_tab', { tab_id: 'commit_log' }); });\nw.find('button.bundle_config').click( function() { w.trigger('open_tab', { tab_id: 'bundle_config' }); });\nw.find('button.push_pull').click(     function() { w.trigger('open_tab', { tab_id: 'push_pull' }); });\nw.find('button.untracked').click(     function() { w.trigger('open_tab', { tab_id: 'untracked' }); });\nw.find('button.export').click(        function() { w.trigger('open_tab', { tab_id: 'export' }); });\nw.find('button.ignored').click(        function() { w.trigger('open_tab', { tab_id: 'ignored' }); });\n\n// filter handlers\nw.find('.filters .all').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\n// filter handlers\nw.find('.filters .changed').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nvar commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    order_by: {\n        column: 'row_id'\n    }\n});\n\n// filter handlers\nw.find('.filters .head').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_commit_row','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nw.find('.filters .all').click();\n\n// listen for triggers from semantic widgets which indicate crud changes to handle\nw.closest('.ide').bind('insert', function(e, o) {\n    alert('insert detected');\n    \n    var row_id = o.row.id;\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_value = row_id.pk_value;\n\n    endpoint.schema('bundle').function('tracked_row_add', [ \n        bundle.get('name'), \n        schema_name, \n        relation_name, \n        pk_column_name, \n        pk_value\n    ]).then(function() {\n        w.trigger('bundle_row_open', { row: o.row, row_id: row_id });\n    }).catch(function (e) {\n        alert('error calling tracked_row_add');\n    });\n});\n
\\x80e589ef60996cce335845994993101e8637988e0c55947d14a4c6099d05999d	<div id="{{= id }}" class="{{= name }}">\n    <div class='title'>{{= properties.bundle_alias }}:{{= widget_name }}{{? properties.count > 1 }}(&times;{{=properties.count}}){{?}}</div>\n    <div class='children'>\n    </div>\n</div>
\\x8225d01c6781052b4445ba5eada856290c242c119a3f0d65d80ba166edb99acc	0.3.2
\\x8255a2398675fc37acbf48a0862c8e6ee2774f47691a8d84d86b60d438411599	.{{= name }} {\n}\n\n.{{= name }}:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n\n\n.{{= name }} ul {\n    display: none;\n}\n\n.{{= name }} ul.open {\n    display: block;\n}\n
\\x8276af63b9e462f00c98d7f92e3e538c6abb78dca74b3b062b030b7b3715171d	commit_dialog_staged_row
\\x8277bce6ed33db6fe716e8bab6abe4499bb58f8d05695d9458bd2010d2cd4a9b	var w = $("#"+id);\n\nvar commits = bundle.related_rows("id", "bundle.commit", "bundle_id", {\n    order_by: [{\n        column: 'time',\n        direction: 'desc'\n    }]\n});\n\nwidget.sync(commits, w.find(".commits"), function(commit) {\n    return widget("ide:commit_history_commit", {bundle: bundle, commit: commit});\n});
\\x82788b36dada0f70a2814be2924ab5c0d009a39fd021590b2c3910bb71bd329f	// CodeMirror is the only global var we claim\nwindow.CodeMirror = (function() {\n  "use strict";\n\n  // BROWSER SNIFFING\n\n  // Crude, but necessary to handle a number of hard-to-feature-detect\n  // bugs and behavior differences.\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  // IE11 currently doesn't count as 'ie', since it has almost none of\n  // the same bugs as earlier versions. Use ie_gt10 to handle\n  // incompatibilities in that version.\n  var old_ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = old_ie && (document.documentMode == null || document.documentMode < 8);\n  var ie_lt9 = old_ie && (document.documentMode == null || document.documentMode < 9);\n  var ie_gt10 = /Trident\\/([7-9]|\\d{2,})\\./.test(navigator.userAgent);\n  var ie = old_ie || ie_gt10;\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /win/i.test(navigator.platform);\n\n  var opera_version = opera && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (opera_version) opera_version = Number(opera_version[1]);\n  if (opera_version && opera_version >= 15) { opera = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));\n  var captureMiddleClick = gecko || (old_ie && !ie_lt9);\n\n  // Optimize some code when these features are not used\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // CONSTRUCTOR\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options || {};\n    // Determine effective options based on given values and defaults.\n    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))\n      options[opt] = defaults[opt];\n    setGuttersForLineNumbers(options);\n\n    var docStart = typeof options.value == "string" ? 0 : options.value.first;\n    var display = this.display = makeDisplay(place, docStart);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.state = {keyMaps: [],\n                  overlays: [],\n                  modeGen: 0,\n                  overwrite: false, focused: false,\n                  suppressEdits: false,\n                  pasteIncoming: false, cutIncoming: false,\n                  draggingText: false,\n                  highlight: new Delayed()};\n\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += " CodeMirror-wrap";\n\n    var doc = options.value;\n    if (typeof doc == "string") doc = new Doc(options.value, options.mode);\n    operation(this, attachDoc)(this, doc);\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (old_ie) setTimeout(bind(resetInput, this, true), 20);\n\n    registerEventHandlers(this);\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }\n    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);\n    else onBlur(this);\n\n    operation(this, function() {\n      for (var opt in optionHandlers)\n        if (optionHandlers.propertyIsEnumerable(opt))\n          optionHandlers[opt](this, options[opt], Init);\n      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    })();\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  function makeDisplay(place, docStart) {\n    var d = {};\n\n    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");\n    if (webkit) input.style.width = "1000px";\n    else input.setAttribute("wrap", "off");\n    // if border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) input.style.border = "1px solid black";\n    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");\n\n    // Wraps and hides input textarea\n    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");\n    // The actual fake scrollbars.\n    d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");\n    d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");\n    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");\n    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");\n    // DIVs containing the selection and the actual code\n    d.lineDiv = elt("div", null, "CodeMirror-code");\n    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");\n    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n    d.cursor = elt("div", "\\u00a0", "CodeMirror-cursor");\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    d.otherCursor = elt("div", "\\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");\n    // Used to measure text size\n    d.measure = elt("div", null, "CodeMirror-measure");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],\n                         null, "position: relative; outline: none");\n    // Moved around its parent to cover visible view\n    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");\n    // Set to the height of the text, causes scrolling\n    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");\n    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");\n    // Will contain the gutters, if any\n    d.gutters = elt("div", null, "CodeMirror-gutters");\n    d.lineGutter = null;\n    // Provides scrolling\n    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");\n    d.scroller.setAttribute("tabIndex", "-1");\n    // The element in which the editor lives.\n    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");\n    // Work around IE7 z-index bug\n    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = "0px";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";\n\n    // Current visible range (may be bigger than the view window).\n    d.viewOffset = d.lastSizeC = 0;\n    d.showingFrom = d.showingTo = docStart;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = "";\n    // Set to true when a non-horizontal-scrolling widget is added. As\n    // an optimization, widget aligning is skipped when d is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we currently expect input to appear\n    // (after some event like 'keypress' or 'input') and are polling\n    // intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n\n    d.cachedCharWidth = d.cachedTextHeight = null;\n    d.measureLineCache = [];\n    d.measureLineCachePos = 0;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string instead of the (large) selection.\n    d.inaccurateSelection = false;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    return d;\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      cm.display.wrapper.className += " CodeMirror-wrap";\n      cm.display.sizer.style.minWidth = "";\n    } else {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");\n      computeMaxLength(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line))\n        return 0;\n      else if (wrapping)\n        return (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var map = keyMap[cm.options.keyMap], style = map.style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, "") +\n      (style ? " cm-keymap-" + style : "");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));\n      if (gutterClass == "CodeMirror-linenumbers") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";\n      }\n    }\n    gutters.style.display = i ? "" : "none";\n  }\n\n  function lineLength(doc, line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find();\n      cur = getLine(doc, found.from.line);\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find();\n      len -= cur.text.length - found.from.ch;\n      cur = getLine(doc, found.to.line);\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  function computeMaxLength(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(doc, d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(doc, line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // "CodeMirror-linenumbers" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, "CodeMirror-linenumbers");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content. Optionally force a scrollTop.\n  function updateScrollbars(cm) {\n    var d = cm.display, docHeight = cm.doc.height;\n    var totalHeight = docHeight + paddingVert(d);\n    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";\n    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";\n    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);\n    var needsV = scrollHeight > (d.scroller.clientHeight + 1);\n    if (needsV) {\n      d.scrollbarV.style.display = "block";\n      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";\n      d.scrollbarV.firstChild.style.height =\n        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + "px";\n    } else {\n      d.scrollbarV.style.display = "";\n      d.scrollbarV.firstChild.style.height = "0";\n    }\n    if (needsH) {\n      d.scrollbarH.style.display = "block";\n      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";\n      d.scrollbarH.firstChild.style.width =\n        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + "px";\n    } else {\n      d.scrollbarH.style.display = "";\n      d.scrollbarH.firstChild.style.width = "0";\n    }\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = "block";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";\n    } else d.scrollbarFiller.style.display = "";\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = "block";\n      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";\n      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";\n    } else d.gutterFiller.style.display = "";\n\n    if (mac_geLion && scrollbarWidth(d.measure) === 0) {\n      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";\n      d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = "none";\n    }\n  }\n\n  function visibleLines(display, doc, viewPort) {\n    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;\n    if (typeof viewPort == "number") top = viewPort;\n    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}\n    top = Math.floor(top - paddingTop(display));\n    var bottom = Math.ceil(top + height);\n    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};\n  }\n\n  // LINE NUMBERS\n\n  function alignHorizontally(cm) {\n    var display = cm.display;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, l = comp + "px";\n    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {\n      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + "px";\n  }\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt("div", [elt("div", last)],\n                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = "";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + "px";\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n  function compensateForHScroll(display) {\n    return getRect(display.scroller).left - getRect(display.sizer).left;\n  }\n\n  // DISPLAY DRAWING\n\n  function updateDisplay(cm, changes, viewPort, forced) {\n    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;\n    var visible = visibleLines(cm.display, cm.doc, viewPort);\n    for (var first = true;; first = false) {\n      var oldWidth = cm.display.scroller.clientWidth;\n      if (!updateDisplayInner(cm, changes, visible, forced)) break;\n      updated = true;\n      changes = [];\n      updateSelection(cm);\n      updateScrollbars(cm);\n      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {\n        forced = true;\n        continue;\n      }\n      forced = false;\n\n      // Clip forced viewport to actual scrollable area\n      if (viewPort)\n        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,\n                            typeof viewPort == "number" ? viewPort : viewPort.top);\n      visible = visibleLines(cm.display, cm.doc, viewPort);\n      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)\n        break;\n    }\n\n    if (updated) {\n      signalLater(cm, "update", cm);\n      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)\n        signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);\n    }\n    return updated;\n  }\n\n  // Uses a set of changes plus the current scroll position to\n  // determine which DOM updates have to be made, and makes the\n  // updates.\n  function updateDisplayInner(cm, changes, visible, forced) {\n    var display = cm.display, doc = cm.doc;\n    if (!display.wrapper.offsetWidth) {\n      display.showingFrom = display.showingTo = doc.first;\n      display.viewOffset = 0;\n      return;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!forced && changes.length == 0 &&\n        visible.from > display.showingFrom && visible.to < display.showingTo)\n      return;\n\n    if (maybeUpdateLineNumberWidth(cm))\n      changes = [{from: doc.first, to: doc.first + doc.size}];\n    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";\n    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";\n\n    // Used to determine which lines need their line numbers updated\n    var positionsChangedFrom = Infinity;\n    if (cm.options.lineNumbers)\n      for (var i = 0; i < changes.length; ++i)\n        if (changes[i].diff && changes[i].from < positionsChangedFrom) { positionsChangedFrom = changes[i].from; }\n\n    var end = doc.first + doc.size;\n    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, visible.to + cm.options.viewportMargin);\n    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);\n    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);\n    if (sawCollapsedSpans) {\n      from = lineNo(visualLine(doc, getLine(doc, from)));\n      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;\n    }\n\n    // Create a range of theoretically intact lines, and punch holes\n    // in that using the change info.\n    var intact = [{from: Math.max(display.showingFrom, doc.first),\n                   to: Math.min(display.showingTo, end)}];\n    if (intact[0].from >= intact[0].to) intact = [];\n    else intact = computeIntact(intact, changes);\n    // When merged lines are present, we might have to reduce the\n    // intact ranges because changes in continued fragments of the\n    // intact lines do require the lines to be redrawn.\n    if (sawCollapsedSpans)\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i], merged;\n        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {\n          var newTo = merged.find().from.line;\n          if (newTo > range.from) range.to = newTo;\n          else { intact.splice(i--, 1); break; }\n        }\n      }\n\n    // Clip off the parts that won't be visible\n    var intactLines = 0;\n    for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i];\n      if (range.from < from) range.from = from;\n      if (range.to > to) range.to = to;\n      if (range.from >= range.to) intact.splice(i--, 1);\n      else intactLines += range.to - range.from;\n    }\n    if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {\n      updateViewOffset(cm);\n      return;\n    }\n    intact.sort(function(a, b) {return a.from - b.from;});\n\n    // Avoid crashing on IE's "unspecified error" when in iframes\n    try {\n      var focused = document.activeElement;\n    } catch(e) {}\n    if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";\n    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n    display.lineDiv.style.display = "";\n    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();\n\n    var different = from != display.showingFrom || to != display.showingTo ||\n      display.lastSizeC != display.wrapper.clientHeight;\n    // This is just a bogus formula that detects when the editor is\n    // resized or the font size changes.\n    if (different) {\n      display.lastSizeC = display.wrapper.clientHeight;\n      startWorker(cm, 400);\n    }\n    display.showingFrom = from; display.showingTo = to;\n\n    display.gutters.style.height = "";\n    updateHeightsInViewport(cm);\n    updateViewOffset(cm);\n\n    return true;\n  }\n\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {\n      if (ie_lt8) {\n        var bot = node.offsetTop + node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = getRect(node);\n        height = box.bottom - box.top;\n      }\n      var diff = node.lineObj.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(node.lineObj, height);\n        var widgets = node.lineObj.widgets;\n        if (widgets) for (var i = 0; i < widgets.length; ++i)\n          widgets[i].height = widgets[i].node.offsetHeight;\n      }\n    }\n  }\n\n  function updateViewOffset(cm) {\n    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));\n    // Position the mover div to align with the current virtual scroll position\n    cm.display.mover.style.top = off + "px";\n  }\n\n  function computeIntact(intact, changes) {\n    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n      var change = changes[i], intact2 = [], diff = change.diff || 0;\n      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n        var range = intact[j];\n        if (change.to <= range.from && change.diff) {\n          intact2.push({from: range.from + diff, to: range.to + diff});\n        } else if (change.to <= range.from || change.from >= range.to) {\n          intact2.push(range);\n        } else {\n          if (change.from > range.from)\n            intact2.push({from: range.from, to: change.from});\n          if (change.to < range.to)\n            intact2.push({from: change.to + diff, to: range.to + diff});\n        }\n      }\n      intact = intact2;\n    }\n    return intact;\n  }\n\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft;\n      width[cm.options.gutters[i]] = n.offsetWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n    var dims = getDimensions(cm);\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))\n      removeChildren(display.lineDiv);\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = "none";\n        node.lineObj = null;\n      } else {\n        node.parentNode.removeChild(node);\n      }\n      return next;\n    }\n\n    var nextIntact = intact.shift(), lineN = from;\n    cm.doc.iter(from, to, function(line) {\n      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();\n      if (lineIsHidden(cm.doc, line)) {\n        if (line.height != 0) updateLineHeight(line, 0);\n        if (line.widgets && cur && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {\n          var w = line.widgets[i];\n          if (w.showIfHidden) {\n            var prev = cur.previousSibling;\n            if (/pre/i.test(prev.nodeName)) {\n              var wrap = elt("div", null, null, "position: relative");\n              prev.parentNode.replaceChild(wrap, prev);\n              wrap.appendChild(prev);\n              prev = wrap;\n            }\n            var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));\n            if (!w.handleMouseEvents) wnode.ignoreEvents = true;\n            positionLineWidget(w, wnode, prev, dims);\n          }\n        }\n      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {\n        // This line is intact. Skip to the actual node. Update its\n        // line number if needed.\n        while (cur.lineObj != line) cur = rm(cur);\n        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)\n          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));\n        cur = cur.nextSibling;\n      } else {\n        // For lines with widgets, make an attempt to find and reuse\n        // the existing element, so that widgets aren't needlessly\n        // removed and re-inserted into the dom\n        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)\n          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }\n        // This line needs to be generated.\n        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);\n        if (lineNode != reuse) {\n          container.insertBefore(lineNode, cur);\n        } else {\n          while (cur != reuse) cur = rm(cur);\n          cur = cur.nextSibling;\n        }\n\n        lineNode.lineObj = line;\n      }\n      ++lineN;\n    });\n    while (cur) cur = rm(cur);\n  }\n\n  function buildLineElement(cm, line, lineNo, dims, reuse) {\n    var built = buildLineContent(cm, line), lineElement = built.pre;\n    var markers = line.gutterMarkers, display = cm.display, wrap;\n\n    var bgClass = built.bgClass ? built.bgClass + " " + (line.bgClass || "") : line.bgClass;\n    if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets)\n      return lineElement;\n\n    // Lines with gutter elements, widgets or a background class need\n    // to be wrapped again, and have the extra elements added to the\n    // wrapper div\n\n    if (reuse) {\n      reuse.alignable = null;\n      var isOk = true, widgetsSeen = 0, insertBefore = null;\n      for (var n = reuse.firstChild, next; n; n = next) {\n        next = n.nextSibling;\n        if (!/\\bCodeMirror-linewidget\\b/.test(n.className)) {\n          reuse.removeChild(n);\n        } else {\n          for (var i = 0; i < line.widgets.length; ++i) {\n            var widget = line.widgets[i];\n            if (widget.node == n.firstChild) {\n              if (!widget.above && !insertBefore) insertBefore = n;\n              positionLineWidget(widget, n, reuse, dims);\n              ++widgetsSeen;\n              break;\n            }\n          }\n          if (i == line.widgets.length) { isOk = false; break; }\n        }\n      }\n      reuse.insertBefore(lineElement, insertBefore);\n      if (isOk && widgetsSeen == line.widgets.length) {\n        wrap = reuse;\n        reuse.className = line.wrapClass || "";\n      }\n    }\n    if (!wrap) {\n      wrap = elt("div", null, line.wrapClass, "position: relative");\n      wrap.appendChild(lineElement);\n    }\n    // Kludge to make sure the styled element lies behind the selection (by z-index)\n    if (bgClass)\n      wrap.insertBefore(elt("div", null, bgClass + " CodeMirror-linebackground"), wrap.firstChild);\n    if (cm.options.lineNumbers || markers) {\n      var gutterWrap = wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),\n                                         lineElement);\n      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);\n      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))\n        wrap.lineNumber = gutterWrap.appendChild(\n          elt("div", lineNumberFor(cm.options, lineNo),\n              "CodeMirror-linenumber CodeMirror-gutter-elt",\n              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "\n              + display.lineNumInnerWidth + "px"));\n      if (markers)\n        for (var k = 0; k < cm.options.gutters.length; ++k) {\n          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n          if (found)\n            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +\n                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));\n        }\n    }\n    if (ie_lt8) wrap.style.zIndex = 2;\n    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n      positionLineWidget(widget, node, wrap, dims);\n      if (widget.above)\n        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, "redraw");\n    }\n    return wrap;\n  }\n\n  function positionLineWidget(widget, node, wrap, dims) {\n    if (widget.noHScroll) {\n      (wrap.alignable || (wrap.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + "px";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + "px";\n      }\n      node.style.width = width + "px";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = "relative";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";\n    }\n  }\n\n  // SELECTION / CURSOR\n\n  function updateSelection(cm) {\n    var display = cm.display;\n    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      updateSelectionCursor(cm);\n    else\n      display.cursor.style.display = display.otherCursor.style.display = "none";\n    if (!collapsed)\n      updateSelectionRange(cm);\n    else\n      display.selectionDiv.style.display = "none";\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, cm.doc.sel.head, "div");\n      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);\n      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                                        headPos.top + lineOff.top - wrapOff.top)) + "px";\n      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                                         headPos.left + lineOff.left - wrapOff.left)) + "px";\n    }\n  }\n\n  // No selection, plain cursor\n  function updateSelectionCursor(cm) {\n    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, "div");\n    display.cursor.style.left = pos.left + "px";\n    display.cursor.style.top = pos.top + "px";\n    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";\n    display.cursor.style.display = "";\n\n    if (pos.other) {\n      display.otherCursor.style.display = "";\n      display.otherCursor.style.left = pos.other.left + "px";\n      display.otherCursor.style.top = pos.other.top + "px";\n      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";\n    } else { display.otherCursor.style.display = "none"; }\n  }\n\n  // Highlight selection\n  function updateSelectionRange(cm) {\n    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;\n    var fragment = document.createDocumentFragment();\n    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +\n                               "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) +\n                               "px; height: " + (bottom - top) + "px"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, "left"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, "right");\n          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = pl;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = pl;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = clientWidth;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < pl + 1) left = pl;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    if (sel.from.line == sel.to.line) {\n      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n    } else {\n      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);\n      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);\n      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;\n      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(pl, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(pl, leftEnd.bottom, null, rightStart.top);\n    }\n\n    removeChildrenAndAdd(display.selectionDiv, fragment);\n    display.selectionDiv.style.display = "";\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursor.style.visibility = display.otherCursor.style.visibility = "";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";\n      }, cm.options.cursorBlinkRate);\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.showingTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changed = [], prevChange;\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {\n      if (doc.frontier >= cm.display.showingFrom) { // Visible\n        var oldStyles = line.styles;\n        line.styles = highlightLine(cm, line, state, true);\n        var ischange = !oldStyles || oldStyles.length != line.styles.length;\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) {\n          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;\n          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});\n        }\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changed.length)\n      operation(cm, function() {\n        for (var i = 0; i < changed.length; ++i)\n          regChange(this, changed[i].start, changed[i].end);\n      })();\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingLeft(display) {\n    var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));\n    return e.offsetLeft;\n  }\n\n  function measureChar(cm, line, ch, data, bias) {\n    var dir = -1;\n    data = data || measureLine(cm, line);\n    if (data.crude) {\n      var left = data.left + ch * data.width;\n      return {left: left, right: left + data.width, top: data.top, bottom: data.bottom};\n    }\n\n    for (var pos = ch;; pos += dir) {\n      var r = data[pos];\n      if (r) break;\n      if (dir < 0 && pos == 0) dir = 1;\n    }\n    bias = pos > ch ? "left" : pos < ch ? "right" : bias;\n    if (bias == "left" && r.leftSide) r = r.leftSide;\n    else if (bias == "right" && r.rightSide) r = r.rightSide;\n    return {left: pos < ch ? r.right : r.left,\n            right: pos > ch ? r.left : r.right,\n            top: r.top,\n            bottom: r.bottom};\n  }\n\n  function findCachedMeasurement(cm, line) {\n    var cache = cm.display.measureLineCache;\n    for (var i = 0; i < cache.length; ++i) {\n      var memo = cache[i];\n      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&\n          cm.display.scroller.clientWidth == memo.width &&\n          memo.classes == line.textClass + "|" + line.wrapClass)\n        return memo;\n    }\n  }\n\n  function clearCachedMeasurement(cm, line) {\n    var exists = findCachedMeasurement(cm, line);\n    if (exists) exists.text = exists.measure = exists.markedSpans = null;\n  }\n\n  function measureLine(cm, line) {\n    // First look in the cache\n    var cached = findCachedMeasurement(cm, line);\n    if (cached) return cached.measure;\n\n    // Failing that, recompute and store result in cache\n    var measure = measureLineInner(cm, line);\n    var cache = cm.display.measureLineCache;\n    var memo = {text: line.text, width: cm.display.scroller.clientWidth,\n                markedSpans: line.markedSpans, measure: measure,\n                classes: line.textClass + "|" + line.wrapClass};\n    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;\n    else cache.push(memo);\n    return measure;\n  }\n\n  function measureLineInner(cm, line) {\n    if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom)\n      return crudelyMeasureLine(cm, line);\n\n    var display = cm.display, measure = emptyArray(line.text.length);\n    var pre = buildLineContent(cm, line, measure, true).pre;\n\n    // IE does not cache element positions of inline elements between\n    // calls to getBoundingClientRect. This makes the loop below,\n    // which gathers the positions of all the characters on the line,\n    // do an amount of layout work quadratic to the number of\n    // characters. When line wrapping is off, we try to improve things\n    // by first subdividing the line into a bunch of inline blocks, so\n    // that IE can reuse most of the layout information from caches\n    // for those blocks. This does interfere with line wrapping, so it\n    // doesn't work when wrapping is on, but in that case the\n    // situation is slightly better, since IE does cache line-wrapping\n    // information and only recomputes per-line.\n    if (old_ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n      var fragment = document.createDocumentFragment();\n      var chunk = 10, n = pre.childNodes.length;\n      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n        var wrap = elt("div", null, null, "display: inline-block");\n        for (var j = 0; j < chunk && n; ++j) {\n          wrap.appendChild(pre.firstChild);\n          --n;\n        }\n        fragment.appendChild(wrap);\n      }\n      pre.appendChild(fragment);\n    }\n\n    removeChildrenAndAdd(display.measure, pre);\n\n    var outer = getRect(display.lineDiv);\n    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;\n    // Work around an IE7/8 bug where it will sometimes have randomly\n    // replaced our pre with a clone at this point.\n    if (ie_lt9 && display.measure.first != pre)\n      removeChildrenAndAdd(display.measure, pre);\n\n    function measureRect(rect) {\n      var top = rect.top - outer.top, bot = rect.bottom - outer.top;\n      if (bot > maxBot) bot = maxBot;\n      if (top < 0) top = 0;\n      for (var i = vranges.length - 2; i >= 0; i -= 2) {\n        var rtop = vranges[i], rbot = vranges[i+1];\n        if (rtop > bot || rbot < top) continue;\n        if (rtop <= top && rbot >= bot ||\n            top <= rtop && bot >= rbot ||\n            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {\n          vranges[i] = Math.min(top, rtop);\n          vranges[i+1] = Math.max(bot, rbot);\n          break;\n        }\n      }\n      if (i < 0) { i = vranges.length; vranges.push(top, bot); }\n      return {left: rect.left - outer.left,\n              right: rect.right - outer.left,\n              top: i, bottom: null};\n    }\n    function finishRect(rect) {\n      rect.bottom = vranges[rect.top+1];\n      rect.top = vranges[rect.top];\n    }\n\n    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {\n      var node = cur, rect = null;\n      // A widget might wrap, needs special care\n      if (/\\bCodeMirror-widget\\b/.test(cur.className) && cur.getClientRects) {\n        if (cur.firstChild.nodeType == 1) node = cur.firstChild;\n        var rects = node.getClientRects();\n        if (rects.length > 1) {\n          rect = data[i] = measureRect(rects[0]);\n          rect.rightSide = measureRect(rects[rects.length - 1]);\n        }\n      }\n      if (!rect) rect = data[i] = measureRect(getRect(node));\n      if (cur.measureRight) rect.right = getRect(cur.measureRight).left - outer.left;\n      if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));\n    }\n    removeChildren(cm.display.measure);\n    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {\n      finishRect(cur);\n      if (cur.leftSide) finishRect(cur.leftSide);\n      if (cur.rightSide) finishRect(cur.rightSide);\n    }\n    return data;\n  }\n\n  function crudelyMeasureLine(cm, line) {\n    var copy = new Line(line.text.slice(0, 100), null);\n    if (line.textClass) copy.textClass = line.textClass;\n    var measure = measureLineInner(cm, copy);\n    var left = measureChar(cm, copy, 0, measure, "left");\n    var right = measureChar(cm, copy, 99, measure, "right");\n    return {crude: true, top: left.top, left: left.left, bottom: left.bottom, width: (right.right - left.left) / 100};\n  }\n\n  function measureLineWidth(cm, line) {\n    var hasBadSpan = false;\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {\n      var sp = line.markedSpans[i];\n      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;\n    }\n    var cached = !hasBadSpan && findCachedMeasurement(cm, line);\n    if (cached || line.text.length >= cm.options.crudeMeasuringFrom)\n      return measureChar(cm, line, line.text.length, cached && cached.measure, "right").right;\n\n    var pre = buildLineContent(cm, line, null, true).pre;\n    var end = pre.appendChild(zeroWidthElement(cm.display.measure));\n    removeChildrenAndAdd(cm.display.measure, pre);\n    return getRect(end).right - getRect(cm.display.lineDiv).left;\n  }\n\n  function clearCaches(cm) {\n    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == "line") return rect;\n    if (!context) context = "local";\n    var yOff = heightAtLine(cm, lineObj);\n    if (context == "local") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == "page" || context == "window") {\n      var lOff = getRect(cm.display.lineSpace);\n      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Context may be "window", "page", "div", or "local"/null\n  // Result is in "div" coords\n  function fromCoordSystem(cm, coords, context) {\n    if (context == "div") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into "page" coordinate system\n    if (context == "page") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == "local" || !context) {\n      var localBox = getRect(cm.display.sizer);\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = getRect(cm.display.lineSpace);\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);\n  }\n\n  function cursorCoords(cm, pos, context, lineObj, measurement) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!measurement) measurement = measureLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = new Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Coords must be lineSpace-local\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineNo > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find();\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineNo = mergedPos.to.line;\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(cm, lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var measurement = measureLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), "line",\n                            lineObj, measurement);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < 0 ? -1 : xDiff ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt("pre");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode("x"));\n        measureText.appendChild(elt("br"));\n      }\n      measureText.appendChild(document.createTextNode("x"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt("span", "x");\n    var pre = elt("pre", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var width = anchor.offsetWidth;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap changes in such a way that each\n  // change won't have to update the cursor and display (which would\n  // be awkward, slow, and error-prone), but instead updates are\n  // batched and then all combined and executed at once.\n\n  var nextOpId = 0;\n  function startOperation(cm) {\n    cm.curOp = {\n      // An array of ranges of lines that have to be updated. See\n      // updateDisplay.\n      changes: [],\n      forceUpdate: false,\n      updateInput: null,\n      userSelChange: null,\n      textChanged: null,\n      selectionChanged: false,\n      cursorActivity: false,\n      updateMaxLine: false,\n      updateScrollPos: false,\n      id: ++nextOpId\n    };\n    if (!delayedCallbackDepth++) delayedCallbacks = [];\n  }\n\n  function endOperation(cm) {\n    var op = cm.curOp, doc = cm.doc, display = cm.display;\n    cm.curOp = null;\n\n    if (op.updateMaxLine) computeMaxLength(cm);\n    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {\n      var width = measureLineWidth(cm, display.maxLine);\n      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";\n      display.maxLineChanged = false;\n      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);\n      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)\n        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);\n    }\n    var newScrollPos, updated;\n    if (op.updateScrollPos) {\n      newScrollPos = op.updateScrollPos;\n    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible\n      var coords = cursorCoords(cm, doc.sel.head);\n      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n    }\n    if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {\n      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);\n      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;\n    }\n    if (!updated && op.selectionChanged) updateSelection(cm);\n    if (op.updateScrollPos) {\n      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, newScrollPos.scrollTop));\n      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, newScrollPos.scrollLeft));\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\n      alignHorizontally(cm);\n      if (op.scrollToPos)\n        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),\n                          clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);\n    } else if (newScrollPos) {\n      scrollCursorIntoView(cm);\n    }\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      resetInput(cm, op.userSelChange);\n\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], "hide");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");\n\n    var delayed;\n    if (!--delayedCallbackDepth) {\n      delayed = delayedCallbacks;\n      delayedCallbacks = null;\n    }\n    if (op.textChanged)\n      signal(cm, "change", cm, op.textChanged);\n    if (op.cursorActivity) signal(cm, "cursorActivity", cm);\n    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm1, f) {\n    return function() {\n      var cm = cm1 || this, withOp = !cm.curOp;\n      if (withOp) startOperation(cm);\n      try { var result = f.apply(cm, arguments); }\n      finally { if (withOp) endOperation(cm); }\n      return result;\n    };\n  }\n  function docOperation(f) {\n    return function() {\n      var withOp = this.cm && !this.cm.curOp, result;\n      if (withOp) startOperation(this.cm);\n      try { result = f.apply(this, arguments); }\n      finally { if (withOp) endOperation(this.cm); }\n      return result;\n    };\n  }\n  function runInOp(cm, f) {\n    var withOp = !cm.curOp, result;\n    if (withOp) startOperation(cm);\n    try { result = f(); }\n    finally { if (withOp) endOperation(cm); }\n    return result;\n  }\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    cm.curOp.changes.push({from: from, to: to, diff: lendiff});\n  }\n\n  // INPUT HANDLING\n\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // prevInput is a hack to work with IME. If we reset the textarea\n  // on every change, that breaks IME. So we look for changes\n  // compared to the previous content instead. (Modern browsers have\n  // events that indicate IME taking place, but these are not widely\n  // supported or compatible enough yet to rely on.)\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;\n    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.options.disableInput) return false;\n    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\n      input.value = input.value.substring(0, input.value.length - 1);\n      cm.state.fakedLastChar = false;\n    }\n    var text = input.value;\n    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {\n      resetInput(cm, true);\n      return false;\n    }\n\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    sel.shift = false;\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n    var from = sel.from, to = sel.to;\n    var inserted = text.slice(same);\n    if (same < prevInput.length)\n      from = Pos(from.line, from.ch - (prevInput.length - same));\n    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)\n      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + inserted.length));\n\n    var updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: splitLines(inserted),\n                       origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};\n    makeChange(cm.doc, changeEvent, "end");\n    cm.curOp.updateInput = updateInput;\n    signalLater(cm, "inputRead", cm, changeEvent);\n    if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\n        cm.options.smartIndent && sel.head.ch < 100) {\n      var electric = cm.getModeAt(sel.head).electricChars;\n      if (electric) for (var i = 0; i < electric.length; i++)\n        if (inserted.indexOf(electric.charAt(i)) > -1) {\n          indentLine(cm, sel.head.line, "smart");\n          break;\n        }\n    }\n\n    if (text.length > 1000 || text.indexOf("\\n") > -1) input.value = cm.display.prevInput = "";\n    else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n    return true;\n  }\n\n  function resetInput(cm, user) {\n    var minimal, selected, doc = cm.doc;\n    if (!posEq(doc.sel.from, doc.sel.to)) {\n      cm.display.prevInput = "";\n      minimal = hasCopyEvent &&\n        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n      var content = minimal ? "-" : selected || cm.getSelection();\n      cm.display.input.value = content;\n      if (cm.state.focused) selectInput(cm.display.input);\n      if (ie && !ie_lt9) cm.display.inputHasSelection = content;\n    } else if (user) {\n      cm.display.prevInput = cm.display.input.value = "";\n      if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    }\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, "mousedown", operation(cm, onMouseDown));\n    if (old_ie)\n      on(d.scroller, "dblclick", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);\n        extendSelection(cm.doc, word.from, word.to);\n      }));\n    else\n      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    on(d.lineSpace, "selectstart", function(e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!captureMiddleClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});\n\n    on(d.scroller, "scroll", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, "scroll", cm);\n      }\n    });\n    on(d.scrollbarV, "scroll", function() {\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, "scroll", function() {\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});\n\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, "mousedown", reFocus);\n    on(d.scrollbarV, "mousedown", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    var resizeTimer;\n    function onResize() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        // Might be a text scaling operation, clear size caches.\n        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;\n        clearCaches(cm);\n        runInOp(cm, bind(regChange, cm));\n      }, 100);\n    }\n    on(window, "resize", onResize);\n    // Above handler holds on to the editor and its data structures.\n    // Here we poll to unregister it when the editor is no longer in\n    // the document, so that it can be garbage-collected.\n    function unregister() {\n      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n      if (p) setTimeout(unregister, 5000);\n      else off(window, "resize", onResize);\n    }\n    setTimeout(unregister, 5000);\n\n    on(d.input, "keyup", operation(cm, function(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n      if (e.keyCode == 16) cm.doc.sel.shift = false;\n    }));\n    on(d.input, "input", function() {\n      if (ie && !ie_lt9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\n      fastPoll(cm);\n    });\n    on(d.input, "keydown", operation(cm, onKeyDown));\n    on(d.input, "keypress", operation(cm, onKeyPress));\n    on(d.input, "focus", bind(onFocus, cm));\n    on(d.input, "blur", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n      e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});\n      on(d.scroller, "dragenter", drag_);\n      on(d.scroller, "dragover", drag_);\n      on(d.scroller, "drop", operation(cm, onDrop));\n    }\n    on(d.scroller, "paste", function(e) {\n      if (eventInWidget(d, e)) return;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n    on(d.input, "paste", function() {\n      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\n      // Add a char to the end of textarea before paste occur so that\n      // selection doesn't span to the end of textarea.\n      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\n        var start = d.input.selectionStart, end = d.input.selectionEnd;\n        d.input.value += "$";\n        d.input.selectionStart = start;\n        d.input.selectionEnd = end;\n        cm.state.fakedLastChar = true;\n      }\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopy(e) {\n      if (d.inaccurateSelection) {\n        d.prevInput = "";\n        d.inaccurateSelection = false;\n        d.input.value = cm.getSelection();\n        selectInput(d.input);\n      }\n      if (e.type == "cut") cm.state.cutIncoming = true;\n    }\n    on(d.input, "cut", prepareCopy);\n    on(d.input, "copy", prepareCopy);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, "mouseup", function() {\n      if (document.activeElement == d.input) d.input.blur();\n      focusInput(cm);\n    });\n  }\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  function posFromMouse(cm, e, liberal) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||\n          target == display.scrollbarV || target == display.scrollbarV.firstChild ||\n          target == display.scrollbarFiller || target == display.gutterFiller) return null;\n    }\n    var x, y, space = getRect(display.lineSpace);\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n    return coordsChar(cm, x - space.left, y - space.top);\n  }\n\n  var lastClick, lastDoubleClick;\n  function onMouseDown(e) {\n    if (signalDOMEvent(this, e)) return;\n    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;\n    sel.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n\n    switch (e_button(e)) {\n    case 3:\n      if (captureMiddleClick) onContextMenu.call(cm, cm, e);\n      return;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      return;\n    }\n    // For button 1, if it was clicked inside the editor\n    // (posFromMouse returning non-null), we have to adjust the\n    // selection.\n    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}\n\n    if (!cm.state.focused) onFocus(cm);\n\n    var now = +new Date, type = "single";\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n      type = "triple";\n      e_preventDefault(e);\n      setTimeout(bind(focusInput, cm), 20);\n      selectLine(cm, start.line);\n    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n      type = "double";\n      lastDoubleClick = {time: now, pos: start};\n      e_preventDefault(e);\n      var word = findWordAt(getLine(doc, start.line).text, start);\n      extendSelection(cm.doc, word.from, word.to);\n    } else { lastClick = {time: now, pos: start}; }\n\n    var last = start;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&\n        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {\n      var dragEnd = operation(cm, function(e2) {\n        if (webkit) display.scroller.draggable = false;\n        cm.state.draggingText = false;\n        off(document, "mouseup", dragEnd);\n        off(display.scroller, "drop", dragEnd);\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          extendSelection(cm.doc, start);\n          focusInput(cm);\n          // Work around unexplainable focus problem in IE9 (#2127)\n          if (old_ie && !ie_lt9)\n            setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\n        }\n      });\n      // Let the drag handler handle this.\n      if (webkit) display.scroller.draggable = true;\n      cm.state.draggingText = dragEnd;\n      // IE's approach to draggable\n      if (display.scroller.dragDrop) display.scroller.dragDrop();\n      on(document, "mouseup", dragEnd);\n      on(display.scroller, "drop", dragEnd);\n      return;\n    }\n    e_preventDefault(e);\n    if (type == "single") extendSelection(cm.doc, clipPos(doc, start));\n\n    var startstart = sel.from, startend = sel.to, lastPos = start;\n\n    function doSelect(cur) {\n      if (posEq(lastPos, cur)) return;\n      lastPos = cur;\n\n      if (type == "single") {\n        extendSelection(cm.doc, clipPos(doc, start), cur);\n        return;\n      }\n\n      startstart = clipPos(doc, startstart);\n      startend = clipPos(doc, startend);\n      if (type == "double") {\n        var word = findWordAt(getLine(doc, cur.line).text, cur);\n        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);\n        else extendSelection(cm.doc, startstart, word.to);\n      } else if (type == "triple") {\n        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));\n        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));\n      }\n    }\n\n    var editorSize = getRect(display.wrapper);\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true);\n      if (!cur) return;\n      if (!posEq(cur, last)) {\n        if (!cm.state.focused) onFocus(cm);\n        last = cur;\n        doSelect(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, "mousemove", move);\n      off(document, "mouseup", up);\n    }\n\n    var move = operation(cm, function(e) {\n      if (!old_ie && !e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, "mousemove", move);\n    on(document, "mouseup", up);\n  }\n\n  function gutterEvent(cm, e, type, prevent, signalfn) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(getRect(cm.display.gutters).right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = getRect(display.lineDiv);\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && getRect(g).right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalfn(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, "gutterContextMenu")) return false;\n    return gutterEvent(cm, e, "gutterContextMenu", false, signal);\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, "gutterClick", true, signalLater);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join("\\n")), origin: "paste"}, "around");\n          }\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else {\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData("Text");\n        if (text) {\n          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;\n          setSelection(cm.doc, pos, pos);\n          if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");\n          cm.replaceSelection(text, null, "paste");\n          focusInput(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    var txt = cm.getSelection();\n    e.dataTransfer.setData("Text", txt);\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");\n      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n      if (opera) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (opera) img.parentNode.removeChild(img);\n    }\n  }\n\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplay(cm, [], val);\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplay(cm, []);\n    startWorker(cm, 100);\n  }\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (old_ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n        if (cur.lineObj) {\n          cm.display.currentWheelTarget = cur;\n          break;\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplay(cm, [], {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == "string") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var doc = cm.doc, prevShift = doc.sel.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) doc.sel.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      doc.sel.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n    maps.push(cm.options.keyMap);\n    return maps;\n  }\n\n  var maybeTransition;\n  function handleKeyBinding(cm, e) {\n    // Handle auto keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap) {\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n        keyMapChanged(cm);\n      }\n    }, 50);\n\n    var name = keyName(e, true), handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n             || lookupKey(name, keymaps, function(b) {\n                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)\n                    return doHandleBinding(cm, b);\n                });\n    } else {\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n    }\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n      signalLater(cm, "keyHandled", cm, name, e);\n    }\n    return handled;\n  }\n\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);\n    }\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (!cm.state.focused) onFocus(cm);\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    if (old_ie && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    // IE does strange things with escape.\n    cm.doc.sel.shift = code == 16 || e.shiftKey;\n    // First give onKeyEvent option a chance to handle this.\n    var handled = handleKeyBinding(cm, e);\n    if (opera) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection("");\n    }\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    fastPoll(cm);\n  }\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == "nocursor") return;\n    if (!cm.state.focused) {\n      signal(cm, "focus", cm);\n      cm.state.focused = true;\n      if (cm.display.wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n        cm.display.wrapper.className += " CodeMirror-focused";\n      if (!cm.curOp) {\n        resetInput(cm, true);\n        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\n      }\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, "blur", cm);\n      cm.state.focused = false;\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);\n  }\n\n  var detectingSelectAll;\n  function onContextMenu(cm, e) {\n    if (signalDOMEvent(cm, e, "contextmenu")) return;\n    var display = cm.display, sel = cm.doc.sel;\n    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\n\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || opera) return; // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)))\n      operation(cm, setSelection)(cm.doc, pos, pos);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = "absolute";\n    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +\n      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: transparent; outline: none;" +\n      "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";\n    focusInput(cm);\n    resetInput(cm, true);\n    // Adds "Select all" to context menu in FF\n    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";\n\n    function prepareSelectAllHack() {\n      if (display.input.selectionStart != null) {\n        var extval = display.input.value = "\\u200b" + (posEq(sel.from, sel.to) ? "" : display.input.value);\n        display.prevInput = "\\u200b";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n      }\n    }\n    function rehide() {\n      display.inputDiv.style.position = "relative";\n      display.input.style.cssText = oldCSS;\n      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all\n      if (display.input.selectionStart != null) {\n        if (!old_ie || ie_lt9) prepareSelectAllHack();\n        clearTimeout(detectingSelectAll);\n        var i = 0, poll = function(){\n          if (display.prevInput == "\\u200b" && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        };\n        detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (old_ie && !ie_lt9) prepareSelectAllHack();\n    if (captureMiddleClick) {\n      e_stop(e);\n      var mouseup = function() {\n        off(window, "mouseup", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, "mouseup", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  // UPDATING\n\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Make sure a position will be valid after the given change.\n  function clipPostChange(doc, change, pos) {\n    if (!posLess(change.from, pos)) return clipPos(doc, pos);\n    var diff = (change.text.length - 1) - (change.to.line - change.from.line);\n    if (pos.line > change.to.line + diff) {\n      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;\n      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);\n      return clipToLen(pos, getLine(doc, preLine).text.length);\n    }\n    if (pos.line == change.to.line + diff)\n      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +\n                       getLine(doc, change.to.line).text.length - change.to.ch);\n    var inside = pos.line - change.from.line;\n    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));\n  }\n\n  // Hint can be null|"end"|"start"|"around"|{anchor,head}\n  function computeSelAfterChange(doc, change, hint) {\n    if (hint && typeof hint == "object") // Assumed to be {anchor, head} object\n      return {anchor: clipPostChange(doc, change, hint.anchor),\n              head: clipPostChange(doc, change, hint.head)};\n\n    if (hint == "start") return {anchor: change.from, head: change.from};\n\n    var end = changeEnd(change);\n    if (hint == "around") return {anchor: change.from, head: end};\n    if (hint == "end") return {anchor: end, head: end};\n\n    // hint is null, leave the selection alone as much as possible\n    var adjustPos = function(pos) {\n      if (posLess(pos, change.from)) return pos;\n      if (!posLess(change.to, pos)) return end;\n\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n      if (pos.line == change.to.line) ch += end.ch - change.to.ch;\n      return Pos(line, ch);\n    };\n    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};\n  }\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, "beforeChange", doc, obj);\n    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Replace the range from from to to by the strings in replacement.\n  // change is a {from, to, text [, origin]} object\n  function makeChange(doc, change, selUpdate, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [""]});\n      if (split.length)\n        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);\n    } else {\n      makeChangeNoReadonly(doc, change, selUpdate);\n    }\n  }\n\n  function makeChangeNoReadonly(doc, change, selUpdate) {\n    if (change.text.length == 1 && change.text[0] == "" && posEq(change.from, change.to)) return;\n    var selAfter = computeSelAfterChange(doc, change, selUpdate);\n    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  function makeChangeFromHistory(doc, type) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history;\n    var event = (type == "undo" ? hist.done : hist.undone).pop();\n    if (!event) return;\n\n    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,\n                anchorAfter: event.anchorBefore, headAfter: event.headBefore,\n                generation: hist.generation};\n    (type == "undo" ? hist.undone : hist.done).push(anti);\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        (type == "undo" ? hist.done : hist.undone).length = 0;\n        return;\n      }\n\n      anti.changes.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change, null)\n                    : {anchor: event.anchorBefore, head: event.headBefore};\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      var rebased = [];\n\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  function shiftDoc(doc, distance) {\n    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}\n    doc.first += distance;\n    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);\n    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);\n    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);\n  }\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);\n    else updateDoc(doc, change, spans, selAfter);\n  }\n\n  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))\n      cm.curOp.cursorActivity = true;\n\n    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(doc, line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    regChange(cm, from.line, to.line + 1, lendiff);\n\n    if (hasHandler(cm, "change")) {\n      var changeObj = {from: from, to: to,\n                       text: change.text,\n                       removed: change.removed,\n                       origin: change.origin};\n      if (cm.curOp.textChanged) {\n        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else cm.curOp.textChanged = changeObj;\n    }\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == "string") code = splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);\n  }\n\n  // POSITION OBJECT\n\n  function Pos(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  }\n  CodeMirror.Pos = Pos;\n\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function cmp(a, b) {return a.line - b.line || a.ch - b.ch;}\n  function copyPos(x) {return Pos(x.line, x.ch);}\n\n  // SELECTION\n\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\n  // If shift is held, this will move the selection anchor. Otherwise,\n  // it'll set the whole selection.\n  function extendSelection(doc, pos, other, bias) {\n    if (doc.sel.shift || doc.sel.extend) {\n      var anchor = doc.sel.anchor;\n      if (other) {\n        var posBefore = posLess(pos, anchor);\n        if (posBefore != posLess(other, anchor)) {\n          anchor = pos;\n          pos = other;\n        } else if (posBefore != posLess(pos, other)) {\n          pos = other;\n        }\n      }\n      setSelection(doc, anchor, pos, bias);\n    } else {\n      setSelection(doc, pos, other || pos, bias);\n    }\n    if (doc.cm) doc.cm.curOp.userSelChange = true;\n  }\n\n  function filterSelectionChange(doc, anchor, head) {\n    var obj = {anchor: anchor, head: head};\n    signal(doc, "beforeSelectionChange", doc, obj);\n    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);\n    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);\n    return obj;\n  }\n\n  // Update the selection. Last two args are only used by\n  // updateDoc, since they have to be expressed in the line\n  // numbers before the update.\n  function setSelection(doc, anchor, head, bias, checkAtomic) {\n    if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {\n      var filtered = filterSelectionChange(doc, anchor, head);\n      head = filtered.head;\n      anchor = filtered.anchor;\n    }\n\n    var sel = doc.sel;\n    sel.goalColumn = null;\n    if (bias == null) bias = posLess(head, sel.head) ? -1 : 1;\n    // Skip over atomic spans.\n    if (checkAtomic || !posEq(anchor, sel.anchor))\n      anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");\n    if (checkAtomic || !posEq(head, sel.head))\n      head = skipAtomic(doc, head, bias, checkAtomic != "push");\n\n    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n\n    sel.anchor = anchor; sel.head = head;\n    var inv = posLess(head, anchor);\n    sel.from = inv ? head : anchor;\n    sel.to = inv ? anchor : head;\n\n    if (doc.cm)\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =\n        doc.cm.curOp.cursorActivity = true;\n\n    signalLater(doc, "cursorActivity", doc);\n  }\n\n  function reCheckSelection(cm) {\n    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");\n  }\n\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, "beforeCursorEnter");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find()[dir < 0 ? "from" : "to"];\n            if (posEq(newPos, curPos)) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SCROLLING\n\n  function scrollCursorIntoView(cm) {\n    var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);\n    if (!cm.state.focused) return;\n    var display = cm.display, box = getRect(display.sizer), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt("div", "\\u200b", null, "position: absolute; top: " +\n                           (coords.top - display.viewOffset) + "px; height: " +\n                           (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +\n                           coords.left + "px; width: 2px;");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (;;) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;\n    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;\n    var gutterw = display.gutters.offsetWidth;\n    var atLeft = x1 < gutterw + 10;\n    if (x1 < screenleft + gutterw || atLeft) {\n      if (atLeft) x1 = 0;\n      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n    } else if (x2 > screenw + screenleft - 3) {\n      result.scrollLeft = x2 + 10 - screenw;\n    }\n    return result;\n  }\n\n  function updateScrollPos(cm, left, top) {\n    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,\n                                scrollTop: top == null ? cm.doc.scrollTop : top};\n  }\n\n  function addToScrollPos(cm, left, top) {\n    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});\n    var scroll = cm.display.scroller;\n    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));\n    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));\n  }\n\n  // API UTILITIES\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc;\n    if (how == null) how = "add";\n    if (how == "smart") {\n      if (!cm.doc.mode.indent) how = "prev";\n      else var state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = "not";\n    } else if (how == "smart") {\n      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass) {\n        if (!aggressive) return;\n        how = "prev";\n      }\n    }\n    if (how == "prev") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == "add") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == "subtract") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == "number") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = "", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\\t";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString)\n      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");\n    else if (doc.sel.head.line == n && doc.sel.head.ch < curSpaceString.length)\n      setSelection(doc, Pos(n, curSpaceString.length), Pos(n, curSpaceString.length), 1);\n    line.stateAfter = null;\n  }\n\n  function changeLine(cm, handle, op) {\n    var no = handle, line = handle, doc = cm.doc;\n    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no)) regChange(cm, no, no + 1);\n    else return null;\n    return line;\n  }\n\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == "char") moveOnce();\n    else if (unit == "column") moveOnce(true);\n    else if (unit == "word" || unit == "group") {\n      var sawType = null, group = unit == "group";\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || "\\n";\n        var type = isWordChar(cur) ? "w"\n          : !group ? null\n          : /\\s/.test(cur) ? null\n          : "p";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == "page") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == "line") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  function findWordAt(line, pos) {\n    var start = pos.ch, end = pos.ch;\n    if (line) {\n      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n      var startChar = line.charAt(start);\n      var check = isWordChar(startChar) ? isWordChar\n        : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n        : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n      while (start > 0 && check(line.charAt(start - 1))) --start;\n      while (end < line.length && check(line.charAt(end))) ++end;\n    }\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};\n  }\n\n  function selectLine(cm, line) {\n    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));\n  }\n\n  // PROTOTYPE\n\n  // The publicly visible API. Note that operation(null, f) means\n  // 'wrap f in an operation, performed on its `this` parameter'\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != "mode") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? "push" : "unshift"](map);\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: operation(null, function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error("Overlays may not be stateful.");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: operation(null, function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == "string" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: operation(null, function(n, dir, aggressive) {\n      if (typeof dir != "string" && typeof dir != "number") {\n        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";\n        else dir = dir ? "add" : "subtract";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: operation(null, function(how) {\n      var sel = this.doc.sel;\n      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how, true);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      var doc = this.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null, // Deprecated, use 'type' instead\n              type: style || null,\n              state: state};\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      if (ch == 0) return styles[2];\n      for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else return styles[mid * 2 + 2];\n      }\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return helpers;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == "string") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, sel = this.doc.sel;\n      if (start == null) pos = sel.head;\n      else if (typeof start == "object") pos = clipPos(this.doc, start);\n      else pos = start ? sel.from : sel.to;\n      return cursorCoords(this, pos, mode || "page");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || "page");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || "page");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, last = this.doc.first + this.doc.size - 1;\n      if (line < this.doc.first) line = this.doc.first;\n      else if (line > last) { line = last; end = true; }\n      var lineObj = getLine(this.doc, line);\n      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || "page").top +\n        (end ? lineObj.height : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: operation(null, function(line, gutterID, value) {\n      return changeLine(this, line, function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: operation(null, function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regChange(cm, i, i + 1);\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp("(?:^|\\\\s)" + cls + "(?:$|\\\\s)").test(line[prop])) return false;\n        else line[prop] += " " + cls;\n        return true;\n      });\n    }),\n\n    removeLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(new RegExp("(?:^|\\\\s+)" + cls + "(?:$|\\\\s+)"));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: operation(null, function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    lineInfo: function(line) {\n      if (typeof line == "number") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = "absolute";\n      display.sizer.appendChild(node);\n      if (vert == "over") {\n        top = pos.top;\n      } else if (vert == "above" || vert == "near") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + "px";\n      node.style.left = node.style.right = "";\n      if (horiz == "right") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = "0px";\n      } else {\n        if (horiz == "left") left = 0;\n        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + "px";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: operation(null, onKeyDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd](this);\n    },\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, pos;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to))\n        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);\n      else\n        pos = dir < 0 ? sel.from : sel.to;\n      extendSelection(this.doc, pos, pos, dir);\n    }),\n\n    deleteH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel;\n      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");\n      else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");\n      this.curOp.userSelChange = true;\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, "div");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, target, goal;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to)) {\n        var pos = cursorCoords(this, sel.head, "div");\n        if (sel.goalColumn != null) pos.left = sel.goalColumn;\n        target = findPosV(this, pos, dir, unit);\n        if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);\n        goal = pos.left;\n      } else {\n        target = dir < 0 ? sel.from : sel.to;\n      }\n      extendSelection(this.doc, target, target, dir);\n      if (goal != null) sel.goalColumn = goal;\n    }),\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        this.display.cursor.className += " CodeMirror-overwrite";\n      else\n        this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");\n    },\n    hasFocus: function() { return this.state.focused; },\n\n    scrollTo: operation(null, function(x, y) {\n      updateScrollPos(this, x, y);\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: operation(null, function(range, margin) {\n      if (range == null) range = {from: this.doc.sel.head, to: null};\n      else if (typeof range == "number") range = {from: Pos(range, 0), to: null};\n      else if (range.from == null) range = {from: range, to: null};\n      if (!range.to) range.to = range.from;\n      if (!margin) margin = 0;\n\n      var coords = range;\n      if (range.from.line != null) {\n        this.curOp.scrollToPos = {from: range.from, to: range.to, margin: margin};\n        coords = {from: cursorCoords(this, range.from),\n                  to: cursorCoords(this, range.to)};\n      }\n      var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left),\n                                    Math.min(coords.from.top, coords.to.top) - margin,\n                                    Math.max(coords.from.right, coords.to.right),\n                                    Math.max(coords.from.bottom, coords.to.bottom) + margin);\n      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);\n    }),\n\n    setSize: operation(null, function(width, height) {\n      function interpret(val) {\n        return typeof val == "number" || /^\\d+$/.test(String(val)) ? val + "px" : val;\n      }\n      if (width != null) this.display.wrapper.style.width = interpret(width);\n      if (height != null) this.display.wrapper.style.height = interpret(height);\n      if (this.options.lineWrapping)\n        this.display.measureLineCache.length = this.display.measureLineCachePos = 0;\n      this.curOp.forceUpdate = true;\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: operation(null, function() {\n      var badHeight = this.display.cachedTextHeight == null;\n      clearCaches(this);\n      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);\n      regChange(this);\n      if (badHeight) estimateLineHeights(this);\n    }),\n\n    swapDoc: operation(null, function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      resetInput(this, true);\n      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);\n      signalLater(this, "swapDoc", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option("value", "", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option("mode", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option("indentUnit", 2, loadMode, true);\n  option("indentWithTabs", false);\n  option("smartIndent", true);\n  option("tabSize", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option("specialChars", /[\\t\\u0000-\\u0019\\u00ad\\u200b\\u2028\\u2029\\ufeff]/g, function(cm, val) {\n    cm.options.specialChars = new RegExp(val.source + (val.test("\\t") ? "" : "|\\t"), "g");\n    cm.refresh();\n  }, true);\n  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option("electricChars", true);\n  option("rtlMoveVisually", !windows);\n  option("wholeLineUpdateBefore", true);\n\n  option("theme", "default", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option("keyMap", "default", keyMapChanged);\n  option("extraKeys", null);\n\n  option("onKeyEvent", null);\n  option("onDragEvent", null);\n\n  option("lineWrapping", false, wrappingChanged, true);\n  option("gutters", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option("fixedGutter", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";\n    cm.refresh();\n  }, true);\n  option("coverGutterNextToScrollbar", false, updateScrollbars, true);\n  option("lineNumbers", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option("firstLineNumber", 1, guttersChanged, true);\n  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);\n  option("showCursorWhenSelecting", false, updateSelection, true);\n\n  option("resetSelectionOnContextMenu", true);\n\n  option("readOnly", false, function(cm, val) {\n    if (val == "nocursor") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n      if (!val) resetInput(cm, true);\n    }\n  });\n  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm, true);}, true);\n  option("dragDrop", true);\n\n  option("cursorBlinkRate", 530);\n  option("cursorScrollMargin", 0);\n  option("cursorHeight", 1);\n  option("workTime", 100);\n  option("workDelay", 100);\n  option("flattenSpans", true, resetModeState, true);\n  option("addModeClass", false, resetModeState, true);\n  option("pollInterval", 100);\n  option("undoDepth", 40, function(cm, val){cm.doc.history.undoDepth = val;});\n  option("historyEventDelay", 500);\n  option("viewportMargin", 10, function(cm){cm.refresh();}, true);\n  option("maxHighlightLength", 10000, resetModeState, true);\n  option("crudeMeasuringFrom", 10000);\n  option("moveInputWithCursor", true, function(cm, val) {\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n  });\n\n  option("tabindex", null, function(cm, val) {\n    cm.display.input.tabIndex = val || "";\n  });\n  option("autofocus", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode("application/xml");\n    }\n    if (typeof spec == "string") return {name: spec};\n    else return spec || {name: "null"};\n  };\n\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, "text/plain");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  CodeMirror.defineMode("null", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME("text/plain", "null");\n\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // UTILITIES\n\n  CodeMirror.isWordChar = isWordChar;\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch)\n        cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");\n      else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");\n    },\n    deleteLine: function(cm) {\n      var l = cm.getCursor().line;\n      cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");\n    },\n    delLineLeft: function(cm) {\n      var cur = cm.getCursor();\n      cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n    },\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor(), start = lineStart(cm, cur.line);\n      var line = cm.getLineHandle(start.line);\n      var order = getOrder(line);\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));\n      } else cm.extendSelection(start);\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n    },\n    goLineRight: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), "div").top + 5;\n      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div"));\n    },\n    goLineLeft: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), "div").top + 5;\n      cm.extendSelection(cm.coordsChar({left: 0, top: top}, "div"));\n    },\n    goLineUp: function(cm) {cm.moveV(-1, "line");},\n    goLineDown: function(cm) {cm.moveV(1, "line");},\n    goPageUp: function(cm) {cm.moveV(-1, "page");},\n    goPageDown: function(cm) {cm.moveV(1, "page");},\n    goCharLeft: function(cm) {cm.moveH(-1, "char");},\n    goCharRight: function(cm) {cm.moveH(1, "char");},\n    goColumnLeft: function(cm) {cm.moveH(-1, "column");},\n    goColumnRight: function(cm) {cm.moveH(1, "column");},\n    goWordLeft: function(cm) {cm.moveH(-1, "word");},\n    goGroupRight: function(cm) {cm.moveH(1, "group");},\n    goGroupLeft: function(cm) {cm.moveH(-1, "group");},\n    goWordRight: function(cm) {cm.moveH(1, "word");},\n    delCharBefore: function(cm) {cm.deleteH(-1, "char");},\n    delCharAfter: function(cm) {cm.deleteH(1, "char");},\n    delWordBefore: function(cm) {cm.deleteH(-1, "word");},\n    delWordAfter: function(cm) {cm.deleteH(1, "word");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},\n    delGroupAfter: function(cm) {cm.deleteH(1, "group");},\n    indentAuto: function(cm) {cm.indentSelection("smart");},\n    indentMore: function(cm) {cm.indentSelection("add");},\n    indentLess: function(cm) {cm.indentSelection("subtract");},\n    insertTab: function(cm) {\n      cm.replaceSelection("\\t", "end", "+input");\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection("add");\n      else cm.replaceSelection("\\t", "end", "+input");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n    },\n    newlineAndIndent: function(cm) {\n      operation(cm, function() {\n        cm.replaceSelection("\\n", "end", "+input");\n        cm.indentLine(cm.getCursor().line, null, true);\n      })();\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",\n    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",\n    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",\n    "Tab": "defaultTab", "Shift-Tab": "indentAuto",\n    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",\n    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",\n    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",\n    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",\n    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",\n    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",\n    fallthrough: "basic"\n  };\n  keyMap.macDefault = {\n    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",\n    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",\n    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",\n    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",\n    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",\n    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",\n    fallthrough: ["basic", "emacsy"]\n  };\n  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",\n    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",\n    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",\n    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"\n  };\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == "string") return keyMap[val];\n    else return val;\n  }\n\n  function lookupKey(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return "stop";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return "stop";\n\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != "[object Array]")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done != "stop";\n    }\n  }\n  function isModifierKey(event) {\n    var name = keyNames[event.keyCode];\n    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";\n  }\n  function keyName(event, noShift) {\n    if (opera && event.keyCode == 34 && event["char"]) return false;\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = "Alt-" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;\n    if (!noShift && event.shiftKey) name = "Shift-" + name;\n    return name;\n  }\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.keyName = keyName;\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = document.body;\n      // doc.activeElement occasionally throws on IE\n      try { hasFocus = document.activeElement; } catch(e) {}\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute("autofocus") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, "submit", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    textarea.style.display = "none";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = "";\n      if (textarea.form) {\n        off(textarea.form, "submit", save);\n        if (typeof textarea.form.submit == "function")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  }\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == "string") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == "string") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n  CodeMirror.StringStream = StringStream;\n\n  // TEXTMARKERS\n\n  function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  }\n  CodeMirror.TextMarker = TextMarker;\n  eventMixin(TextMarker);\n\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, "clear")) {\n      var found = this.find();\n      if (found) signalLater(this, "clear", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.to != null) max = lineNo(line);\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from != null)\n        min = lineNo(line);\n      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm);\n    }\n    if (withOp) endOperation(cm);\n  };\n\n  TextMarker.prototype.find = function(bothSides) {\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null || span.to != null) {\n        var found = lineNo(line);\n        if (span.from != null) from = Pos(found, span.from);\n        if (span.to != null) to = Pos(found, span.to);\n      }\n    }\n    if (this.type == "bookmark" && !bothSides) return from;\n    return from && {from: from, to: to};\n  };\n\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(), cm = this.doc.cm;\n    if (!pos || !cm) return;\n    if (this.type != "bookmark") pos = pos.from;\n    var line = getLine(this.doc, pos.line);\n    clearCachedMeasurement(cm, line);\n    if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {\n      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {\n        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);\n        break;\n      }\n      runInOp(cm, function() {\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;\n      });\n    }\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  var nextMarkerId = 0;\n\n  function markText(doc, from, to, options, type) {\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type);\n    if (options) copyObj(options, marker);\n    if (posLess(to, from) || posEq(from, to) && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      marker.collapsed = true;\n      marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");\n      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error("Inserting collapsed marker partially overlapping an existing one");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addToHistory(doc, {from: from, to: to, origin: "markText"},\n                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)\n        updateMaxLine = true;\n      var span = {from: null, to: null, marker: marker};\n      if (curLine == from.line) span.from = from.ch;\n      if (curLine == to.line) span.to = to.ch;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, span);\n      ++curLine;\n    });\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      if (marker.atomic) reCheckSelection(cm);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0, me = this; i < markers.length; ++i) {\n      markers[i].parent = this;\n      on(markers[i], "clear", function(){me.clear();});\n    }\n  }\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, "clear");\n  };\n  SharedTextMarker.prototype.find = function() {\n    return this.primary.find();\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.replacedWith;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.replacedWith = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  // TEXTMARKER SPANS\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({from: span.from,\n                                to: endsAfter ? null : span.to,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n                                to: span.to == null ? null : span.to - endCh,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find();\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;\n        var newParts = [j, 1];\n        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))\n          newParts.push({from: p.from, to: m.from});\n        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(true);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||\n          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)\n        return true;\n    }\n  }\n\n  function visualLine(doc, line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(doc, merged.find().from.line);\n    return line;\n  }\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.replacedWith) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find().to, endLine = getLine(doc, end.line);\n      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // LINE WIDGETS\n\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.cm = cm;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n  function widgetOperation(f) {\n    return function() {\n      var withOp = !this.cm.curOp;\n      if (withOp) startOperation(this.cm);\n      try {var result = f.apply(this, arguments);}\n      finally {if (withOp) endOperation(this.cm);}\n      return result;\n    };\n  }\n  LineWidget.prototype.clear = widgetOperation(function() {\n    var ws = this.line.widgets, no = lineNo(this.line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) this.line.widgets = null;\n    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;\n    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));\n    if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);\n    regChange(this.cm, no, no + 1);\n  });\n  LineWidget.prototype.changed = widgetOperation(function() {\n    var oldH = this.height;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(this.line, this.line.height + diff);\n    var no = lineNo(this.line);\n    regChange(this.cm, no, no + 1);\n  });\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)\n      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm, handle, function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {\n        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, 0, widget.height);\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Run the given mode's parser over a line, update the styles\n  // array, which contains alternating fragments of text and CSS\n  // classes.\n  function runMode(cm, text, mode, state, f, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    if (text == "" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = mode.token(stream, state);\n      }\n      if (cm.options.addModeClass) {\n        var mName = CodeMirror.innerMode(mode, state).mode.name;\n        if (mName) style = "m-" + (style ? mName + " " + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        if (curStart < stream.start) f(stream.start, curStyle);\n        curStart = stream.start; curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen];\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = cur ? cur + " " + style : style;\n          }\n        }\n      });\n    }\n\n    return st;\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen)\n      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == "" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n      mode.token(stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, builder) {\n    if (!style) return null;\n    for (;;) {\n      var lineClass = style.match(/(?:^|\\s)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? "bgClass" : "textClass";\n      if (builder[prop] == null)\n        builder[prop] = lineClass[2];\n      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(builder[prop]))\n        builder[prop] += " " + lineClass[2];\n    }\n    var cache = builder.cm.options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = "cm-" + style.replace(/ +/g, " cm-"));\n  }\n\n  function buildLineContent(cm, realLine, measure, copyWidgets) {\n    var merged, line = realLine, empty = true;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(cm.doc, merged.find().from.line);\n\n    var builder = {pre: elt("pre"), col: 0, pos: 0,\n                   measure: null, measuredSomething: false, cm: cm,\n                   copyWidgets: copyWidgets};\n\n    do {\n      if (line.text) empty = false;\n      builder.measure = line == realLine && measure;\n      builder.pos = 0;\n      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n      if ((old_ie || webkit) && cm.getOption("lineWrapping"))\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      var next = insertLineContent(line, builder, getLineStyles(cm, line));\n      if (measure && line == realLine && !builder.measuredSomething) {\n        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n        builder.measuredSomething = true;\n      }\n      if (next) line = getLine(cm.doc, next.to.line);\n    } while (next);\n\n    if (measure && !builder.measuredSomething && !measure[0])\n      measure[0] = builder.pre.appendChild(empty ? elt("span", "\\u00a0") : zeroWidthElement(cm.display.measure));\n    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))\n      builder.pre.appendChild(document.createTextNode("\\u00a0"));\n\n    var order;\n    // Work around problem with the reported dimensions of single-char\n    // direction spans on IE (issue #1129). See also the comment in\n    // cursorCoords.\n    if (measure && ie && (order = getOrder(line))) {\n      var l = order.length - 1;\n      if (order[l].from == order[l].to) --l;\n      var last = order[l], prev = order[l - 1];\n      if (last.from + 1 == last.to && prev && last.level < prev.level) {\n        var span = measure[builder.pos - 1];\n        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),\n                                               span.nextSibling);\n      }\n    }\n\n    var textClass = builder.textClass ? builder.textClass + " " + (realLine.textClass || "") : realLine.textClass;\n    if (textClass) builder.pre.className = textClass;\n\n    signal(cm, "renderLine", cm, realLine, builder.pre);\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt("span", "\\u2022", "cm-invalidchar");\n    token.title = "\\\\u" + ch.charCodeAt(0).toString(16);\n    return token;\n  }\n\n  function buildToken(builder, text, style, startStyle, endStyle, title) {\n    if (!text) return;\n    var special = builder.cm.options.specialChars;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n          builder.col += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == "\\t") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));\n          builder.col += tabWidth;\n        } else {\n          var token = builder.cm.options.specialCharPlaceholder(m[0]);\n          content.appendChild(token);\n          builder.col += 1;\n        }\n      }\n    }\n    if (style || startStyle || endStyle || builder.measure) {\n      var fullStyle = style || "";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt("span", [content], fullStyle);\n      if (title) token.title = title;\n      return builder.pre.appendChild(token);\n    }\n    builder.pre.appendChild(content);\n  }\n\n  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n    var wrapping = builder.cm.options.lineWrapping;\n    for (var i = 0; i < text.length; ++i) {\n      var start = i == 0, to = i + 1;\n      while (to < text.length && isExtendingChar(text.charAt(to))) ++to;\n      var ch = text.slice(i, to);\n      i = to - 1;\n      if (i && wrapping && spanAffectsWrapping(text, i))\n        builder.pre.appendChild(elt("wbr"));\n      var old = builder.measure[builder.pos];\n      var span = builder.measure[builder.pos] =\n        buildToken(builder, ch, style,\n                   start && startStyle, i == text.length - 1 && endStyle);\n      if (old) span.leftSide = old.leftSide || old;\n      // In IE single-space nodes wrap differently than spaces\n      // embedded in larger text nodes, except when set to\n      // white-space: normal (issue #1268).\n      if (old_ie && wrapping && ch == " " && i && !/\\s/.test(text.charAt(i - 1)) &&\n          i < text.length - 1 && !/\\s/.test(text.charAt(i + 1)))\n        span.style.whiteSpace = "normal";\n      builder.pos += ch.length;\n    }\n    if (text.length) builder.measuredSomething = true;\n  }\n\n  function buildTokenSplitSpaces(inner) {\n    function split(old) {\n      var out = " ";\n      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\\u00a0";\n      out += " ";\n      return out;\n    }\n    return function(builder, text, style, startStyle, endStyle, title) {\n      return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.replacedWith;\n    if (widget) {\n      if (builder.copyWidgets) widget = widget.cloneNode(true);\n      builder.pre.appendChild(widget);\n      if (builder.measure) {\n        if (size) {\n          builder.measure[builder.pos] = widget;\n        } else {\n          var elt = zeroWidthElement(builder.cm.display.measure);\n          if (marker.type == "bookmark" && !marker.insertLeft)\n            builder.measure[builder.pos] = builder.pre.appendChild(elt);\n          else if (builder.measure[builder.pos])\n            return;\n          else\n            builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);\n        }\n        builder.measuredSomething = true;\n      }\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = "", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = "";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }\n            if (m.className) spanStyle += " " + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == "bookmark" && sp.from == pos && m.replacedWith) foundBookmarks.push(m);\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return collapsed.marker.find();\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = "";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, "change", line, change);\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // First adjust the line structure\n    if (from.ch == 0 && to.ch == 0 && lastText == "" &&\n        (!doc.cm || doc.cm.options.wholeLineUpdateBefore)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)\n          added.push(new Line(text[i], spansFor(i), estimateHeight));\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, "change", doc, change);\n    setSelection(doc, selAfter.anchor, selAfter.head, null, true);\n  }\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, "delete");\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.history = makeHistory();\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n\n    if (typeof text == "string") text = splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || "\\n");\n    },\n    setValue: function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: splitLines(code), origin: "setValue"},\n                 {head: top, anchor: top}, true);\n    },\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || "\\n");\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n    setLine: function(line, text) {\n      if (isLine(this, line))\n        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));\n    },\n    removeLine: function(line) {\n      if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));\n      else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));\n    },\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == "number") line = getLine(this, line);\n      return visualLine(this, line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var sel = this.sel, pos;\n      if (start == null || start == "head") pos = sel.head;\n      else if (start == "anchor") pos = sel.anchor;\n      else if (start == "end" || start === false) pos = sel.to;\n      else pos = sel.from;\n      return copyPos(pos);\n    },\n    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},\n\n    setCursor: docOperation(function(line, ch, extend) {\n      var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);\n      if (extend) extendSelection(this, pos);\n      else setSelection(this, pos, pos);\n    }),\n    setSelection: docOperation(function(anchor, head, bias) {\n      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);\n    }),\n    extendSelection: docOperation(function(from, to, bias) {\n      extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);\n    }),\n\n    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},\n    replaceSelection: function(code, collapse, origin) {\n      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || "around");\n    },\n    undo: docOperation(function() {makeChangeFromHistory(this, "undo");}),\n    redo: docOperation(function() {makeChangeFromHistory(this, "redo");}),\n\n    setExtending: function(val) {this.sel.extend = val;},\n\n    historySize: function() {\n      var hist = this.history;\n      return {undo: hist.done.length, redo: hist.undone.length};\n    },\n    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = makeHistory(this.history.maxGeneration);\n      hist.done = histData.done.slice(0);\n      hist.undone = histData.undone.slice(0);\n    },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, "bookmark");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,\n                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = makeHistory();\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;}\n  });\n\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // The Doc methods that should be available on CodeMirror instances\n  var dontDelegate = "iter insert remove copy getEditor".split(" ");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error("This document is already in use.");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) computeMaxLength(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  function getLine(chunk, n) {\n    n -= chunk.first;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n  function heightAtLine(cm, lineObj) {\n    lineObj = visualLine(cm.doc, lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function makeHistory(startGen) {\n    return {\n      // Arrays of history events. Doing something adds an event to\n      // done and clears undo. Undoing moves events from done to\n      // undone, redoing moves them in the other direction.\n      done: [], undone: [], undoDepth: Infinity,\n      // Used to track when changes can be merged into a single undo\n      // event\n      lastTime: 0, lastOp: null, lastOrigin: null,\n      // Used by the isClean() method\n      generation: startGen || 1, maxGeneration: startGen || 1\n    };\n  }\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change["spans_" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  function historyChangeFromChange(doc, change) {\n    var from = { line: change.from.line, ch: change.from.ch };\n    var histChange = {from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  function addToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur = lst(hist.done);\n\n    if (cur &&\n        (hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == "*"))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;\n    } else {\n      // Can not be merged, start a new event.\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation,\n             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,\n             anchorAfter: selAfter.anchor, headAfter: selAfter.head};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth)\n        hist.done.shift();\n    }\n    hist.generation = ++hist.maxGeneration;\n    hist.lastTime = time;\n    hist.lastOp = opId;\n    hist.lastOrigin = change.origin;\n  }\n\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  function getOldSpans(doc, change) {\n    var found = change["spans_" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i], changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,\n                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSel(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }\n        if (to < cur.from.line) {\n          cur.from.line += diff;\n          cur.to.line += diff;\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!sub.copied) {\n        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);\n        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);\n        sub.copied = true;\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      } else {\n        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);\n        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT OPERATORS\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  function on(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent("on" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent("on" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  }\n\n  var delayedCallbacks, delayedCallbackDepth = 0;\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    if (!delayedCallbacks) {\n      ++delayedCallbackDepth;\n      delayedCallbacks = [];\n      setTimeout(fireDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      delayedCallbacks.push(bnd(arr[i]));\n  }\n\n  function signalDOMEvent(cm, e, override) {\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function fireDelayed() {\n    --delayedCallbackDepth;\n    var delayed = delayedCallbacks;\n    delayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;\n\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {\n      if (string.charAt(i) == "\\t") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n  CodeMirror.countColumn = countColumn;\n\n  var spaceStrs = [""];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + " ");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else {\n      // Suppress mysterious IE10 errors\n      try { node.select(); }\n      catch(_e) {}\n    }\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  function createObj(base, props) {\n    function Obj() {}\n    Obj.prototype = base;\n    var inst = new Obj();\n    if (props) copyObj(props, inst);\n    return inst;\n  }\n\n  function copyObj(obj, target) {\n    if (!target) target = {};\n    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n    return target;\n  }\n\n  function emptyArray(size) {\n    for (var a = [], i = 0; i < size; ++i) a.push(undefined);\n    return a;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch > "\\x80" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == "string") setTextContent(e, content);\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = "";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  function getRect(node) {\n    return node.getBoundingClientRect();\n  }\n  CodeMirror.replaceGetRect = function(f) { getRect = f; };\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return "draggable" in div || "dragDrop" in div;\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of tests matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  function spanAffectsWrapping() { return false; }\n  if (gecko) // Only for "$'"\n    spanAffectsWrapping = function(str, i) {\n      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;\n    };\n  else if (safari && !/Version\\/([6-9]|\\d\\d)\\b/.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      return /\\-[^ \\-?]|\\?[^ !\\'\\"\\),.\\-\\/:;\\?\\]\\}]/.test(str.slice(i - 1, i + 1));\n    };\n  else if (webkit && /Chrome\\/(?:29|[3-9]\\d|\\d\\d\\d)\\./.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      var code = str.charCodeAt(i - 1);\n      return code >= 8208 && code <= 8212;\n    };\n  else if (webkit)\n    spanAffectsWrapping = function(str, i) {\n      if (i > 1 && str.charCodeAt(i - 1) == 45) {\n        if (/\\w/.test(str.charAt(i - 2)) && /[^\\-?\\.]/.test(str.charAt(i))) return true;\n        if (i > 2 && /[\\d\\.,]/.test(str.charAt(i - 2)) && /[\\d\\.,]/.test(str.charAt(i))) return false;\n      }\n      return /[~!#%&*)=+}\\]\\\\|\\"\\.>,:;][({[<]|-[^\\-?\\.\\u2010-\\u201f\\u2026]|\\?[\\w~`@#$%\\^&*(_=+{[|><]|\\u2026[\\w~`@#$%\\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));\n    };\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt("span", "\\u200b");\n      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n    }\n    if (zwspSupported) return elt("span", "\\u200b");\n    else return elt("span", "\\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");\n  }\n\n  // See if "".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf("\\n", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);\n      var rt = line.indexOf("\\r");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints("StartToEnd", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt("div");\n    if ("oncopy" in e) return true;\n    e.setAttribute("oncopy", "return;");\n    return typeof e.oncopy == 'function';\n  })();\n\n  // KEY NAMING\n\n  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",\n                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",\n                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",\n                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",\n                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\\\",\n                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",\n                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, "ltr");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, "ltr");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(cm.doc, line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line;\n    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))\n      lineN = merged.find().to.line;\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN, ch);\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is somewhat involved. It is needed in order to move\n  // 'visually' through bi-directional text -- i.e., pressing left\n  // should make the cursor go left, even when in RTL text. The\n  // tricky part is the 'jumps', where RTL and LTR text touch each\n  // other. This often requires the cursor offset to move more than\n  // one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";\n    function charType(code) {\n      if (code <= 0xff) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return "R";\n      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);\n      else if (0x700 <= code && code <= 0x8ac) return "r";\n      else return "L";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = "L";\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == "m") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == "1" && cur == "r") types[i] = "n";\n        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";\n        else if (type == "," && prev == types[i+1] &&\n                 (prev == "1" || prev == "n")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == ",") types[i] = "N";\n        else if (type == "%") {\n          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}\n          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == "L" && type == "1") types[i] = "L";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == "L";\n          var after = (end < len ? types[end] : outerType) == "L";\n          var replace = before || after ? "L" : "R";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push({from: start, to: i, level: 0});\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != "L"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, {from: nstart, to: j, level: 2});\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift({from: 0, to: m[0].length, level: 0});\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push({from: len - m[0].length, to: len, level: 0});\n      }\n      if (order[0].level != lst(order).level)\n        order.push({from: len, to: len, level: order[0].level});\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = "3.21.0";\n\n  return CodeMirror;\n})();\n\n\n\n\n\n\n\n\nCodeMirror.defineMode("sql", function(config, parserConfig) {\n  "use strict";\n\n  var client         = parserConfig.client || {},\n      atoms          = parserConfig.atoms || {"false": true, "true": true, "null": true},\n      builtin        = parserConfig.builtin || {},\n      keywords       = parserConfig.keywords || {},\n      operatorChars  = parserConfig.operatorChars || /^[*+\\-%<>!=&|~^]/,\n      support        = parserConfig.support || {},\n      hooks          = parserConfig.hooks || {},\n      dateSQL        = parserConfig.dateSQL || {"date" : true, "time" : true, "timestamp" : true};\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n\n    // call hooks from the mime type\n    if (hooks[ch]) {\n      var result = hooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n\n    if (support.hexNumber == true &&\n      ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/))\n      || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {\n      // hex\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html\n      return "number";\n    } else if (support.binaryNumber == true &&\n      (((ch == "b" || ch == "B") && stream.match(/^'[01]+'/))\n      || (ch == "0" && stream.match(/^b[01]+/)))) {\n      // bitstring\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html\n      return "number";\n    } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {\n      // numbers\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html\n          stream.match(/^[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/);\n      support.decimallessFloat == true && stream.eat('.');\n      return "number";\n    } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {\n      // placeholders\n      return "variable-3";\n    } else if (ch == "'" || (ch == '"' && support.doubleQuote)) {\n      // strings\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html\n      state.tokenize = tokenLiteral(ch);\n      return state.tokenize(stream, state);\n    } else if ((((support.nCharCast == true && (ch == "n" || ch == "N"))\n        || (support.charsetCast == true && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)))\n        && (stream.peek() == "'" || stream.peek() == '"'))) {\n      // charset casting: _utf8'str', N'str', n'str'\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html\n      return "keyword";\n    } else if (/^[\\(\\),\\;\\[\\]]/.test(ch)) {\n      // no highlightning\n      return null;\n    } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {\n      // 1-line comment\n      stream.skipToEnd();\n      return "comment";\n    } else if ((support.commentHash && ch == "#")\n        || (ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" ")))) {\n      // 1-line comments\n      // ref: https://kb.askmonty.org/en/comment-syntax/\n      stream.skipToEnd();\n      return "comment";\n    } else if (ch == "/" && stream.eat("*")) {\n      // multi-line comments\n      // ref: https://kb.askmonty.org/en/comment-syntax/\n      state.tokenize = tokenComment;\n      return state.tokenize(stream, state);\n    } else if (ch == ".") {\n      // .1 for 0.1\n      if (support.zerolessFloat == true && stream.match(/^(?:\\d+(?:e[+-]?\\d+)?)/i)) {\n        return "number";\n      }\n      // .table_name (ODBC)\n      // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html\n      if (support.ODBCdotTable == true && stream.match(/^[a-zA-Z_]+/)) {\n        return "variable-2";\n      }\n    } else if (operatorChars.test(ch)) {\n      // operators\n      stream.eatWhile(operatorChars);\n      return null;\n    } else if (ch == '{' &&\n        (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {\n      // dates (weird ODBC syntax)\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html\n      return "number";\n    } else {\n      stream.eatWhile(/^[_\\w\\d]/);\n      var word = stream.current().toLowerCase();\n      // dates (standard SQL syntax)\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html\n      if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))\n        return "number";\n      if (atoms.hasOwnProperty(word)) return "atom";\n      if (builtin.hasOwnProperty(word)) return "builtin";\n      if (keywords.hasOwnProperty(word)) return "keyword";\n      if (client.hasOwnProperty(word)) return "string-2";\n      return null;\n    }\n  }\n\n  // 'string', with char specified in quote escaped by '\\'\n  function tokenLiteral(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      return "string";\n    };\n  }\n  function tokenComment(stream, state) {\n    while (true) {\n      if (stream.skipTo("*")) {\n        stream.next();\n        if (stream.eat("/")) {\n          state.tokenize = tokenBase;\n          break;\n        }\n      } else {\n        stream.skipToEnd();\n        break;\n      }\n    }\n    return "comment";\n  }\n\n  function pushContext(stream, state, type) {\n    state.context = {\n      prev: state.context,\n      indent: stream.indentation(),\n      col: stream.column(),\n      type: type\n    };\n  }\n\n  function popContext(state) {\n    state.indent = state.context.indent;\n    state.context = state.context.prev;\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: tokenBase, context: null};\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (state.context && state.context.align == null)\n          state.context.align = false;\n      }\n      if (stream.eatSpace()) return null;\n\n      var style = state.tokenize(stream, state);\n      if (style == "comment") return style;\n\n      if (state.context && state.context.align == null)\n        state.context.align = true;\n\n      var tok = stream.current();\n      if (tok == "(")\n        pushContext(stream, state, ")");\n      else if (tok == "[")\n        pushContext(stream, state, "]");\n      else if (state.context && state.context.type == tok)\n        popContext(state);\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context;\n      if (!cx) return 0;\n      var closing = textAfter.charAt(0) == cx.type;\n      if (cx.align) return cx.col + (closing ? 0 : 1);\n      else return cx.indent + (closing ? 0 : config.indentUnit);\n    },\n\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : null\n  };\n});\n\n(function() {\n  "use strict";\n\n  // `identifier`\n  function hookIdentifier(stream) {\n    // MySQL/MariaDB identifiers\n    // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html\n    var ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == "`" && !stream.eat("`")) return "variable-2";\n    }\n    return null;\n  }\n\n  // variable token\n  function hookVar(stream) {\n    // variables\n    // @@prefix.varName @varName\n    // varName can be quoted with ` or ' or "\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html\n    if (stream.eat("@")) {\n      stream.match(/^session\\./);\n      stream.match(/^local\\./);\n      stream.match(/^global\\./);\n    }\n\n    if (stream.eat("'")) {\n      stream.match(/^.*'/);\n      return "variable-2";\n    } else if (stream.eat('"')) {\n      stream.match(/^.*"/);\n      return "variable-2";\n    } else if (stream.eat("`")) {\n      stream.match(/^.*`/);\n      return "variable-2";\n    } else if (stream.match(/^[0-9a-zA-Z$\\.\\_]+/)) {\n      return "variable-2";\n    }\n    return null;\n  };\n\n  // short client keyword token\n  function hookClient(stream) {\n    // \\N means NULL\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html\n    if (stream.eat("N")) {\n        return "atom";\n    }\n    // \\g, etc\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html\n    return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;\n  }\n\n  // these keywords are used by all SQL dialects (however, a mode can still overwrite it)\n  var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from having in insert into is join like not on or order select set table union update values where ";\n\n  // turn a space-separated list into an array\n  function set(str) {\n    var obj = {}, words = str.split(" ");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  // A generic SQL Mode. It's not a standard, it just try to support what is generally supported\n  CodeMirror.defineMIME("text/x-sql", {\n    name: "sql",\n    keywords: set(sqlKeywords + "begin"),\n    builtin: set("bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")\n  });\n\n  CodeMirror.defineMIME("text/x-mssql", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered"),\n    builtin: set("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=]/,\n    dateSQL: set("date datetimeoffset datetime2 smalldatetime datetime time"),\n    hooks: {\n      "@":   hookVar\n    }\n  });\n\n  CodeMirror.defineMIME("text/x-mysql", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group groupby_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),\n    builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=&|^]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),\n    hooks: {\n      "@":   hookVar,\n      "`":   hookIdentifier,\n      "\\\\":  hookClient\n    }\n  });\n\n  CodeMirror.defineMIME("text/x-mariadb", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),\n    builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=&|^]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),\n    hooks: {\n      "@":   hookVar,\n      "`":   hookIdentifier,\n      "\\\\":  hookClient\n    }\n  });\n\n  // the query language used by Apache Cassandra is called CQL, but this mime type\n  // is called Cassandra to avoid confusion with Contextual Query Language\n  CodeMirror.defineMIME("text/x-cassandra", {\n    name: "sql",\n    client: { },\n    keywords: set("use select from using consistency where limit first reversed first and in insert into values using consistency ttl update set delete truncate begin batch apply create keyspace with columnfamily primary key index on drop alter type add any one quorum all local_quorum each_quorum"),\n    builtin: set("ascii bigint blob boolean counter decimal double float int text timestamp uuid varchar varint"),\n    atoms: set("false true"),\n    operatorChars: /^[<>=]/,\n    dateSQL: { },\n    support: set("commentSlashSlash decimallessFloat"),\n    hooks: { }\n  });\n\n  // this is based on Peter Raganitsch's 'plsql' mode\n  CodeMirror.defineMIME("text/x-plsql", {\n    name:       "sql",\n    client:     set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),\n    keywords:   set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),\n    builtin:    set("abs acos add_months ascii asin atan atan2 average bfile bfilename bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least lenght lenghtb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid upper user userenv varchar varchar2 variance varying vsize xml"),\n    operatorChars: /^[*+\\-%<>!=~]/,\n    dateSQL:    set("date time timestamp"),\n    support:    set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")\n  });\n}());\n\n/*\n  How Properties of Mime Types are used by SQL Mode\n  =================================================\n\n  keywords:\n    A list of keywords you want to be highlighted.\n  functions:\n    A list of function names you want to be highlighted.\n  builtin:\n    A list of builtin types you want to be highlighted (if you want types to be of class "builtin" instead of "keyword").\n  operatorChars:\n    All characters that must be handled as operators.\n  client:\n    Commands parsed and executed by the client (not the server).\n  support:\n    A list of supported syntaxes which are not common, but are supported by more than 1 DBMS.\n    * ODBCdotTable: .tableName\n    * zerolessFloat: .1\n    * doubleQuote\n    * nCharCast: N'string'\n    * charsetCast: _utf8'string'\n    * commentHash: use # char for comments\n    * commentSlashSlash: use // for comments\n    * commentSpaceRequired: require a space after -- for comments\n  atoms:\n    Keywords that must be highlighted as atoms,. Some DBMS's support more atoms than others:\n    UNKNOWN, INFINITY, UNDERFLOW, NaN...\n  dateSQL:\n    Used for date/time SQL standard syntax, because not all DBMS's support same temporal types.\n*/\n\n\n\n\n\n\n\n\n// TODO actually recognize syntax of TypeScript constructs\n\nCodeMirror.defineMode("javascript", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonMode = parserConfig.json;\n  var isTS = parserConfig.typescript;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: "keyword"};}\n    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");\n    var operator = kw("operator"), atom = {type: "atom", style: "atom"};\n\n    var jsKeywords = {\n      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,\n      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,\n      "var": kw("var"), "const": kw("var"), "let": kw("var"),\n      "function": kw("function"), "catch": kw("catch"),\n      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),\n      "in": operator, "typeof": operator, "instanceof": operator,\n      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,\n      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),\n      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: "variable", style: "variable-3"};\n      var tsKeywords = {\n        // object-like things\n        "interface": kw("interface"),\n        "extends": kw("extends"),\n        "constructor": kw("constructor"),\n\n        // scope modifiers\n        "public": kw("public"),\n        "private": kw("private"),\n        "protected": kw("protected"),\n        "static": kw("static"),\n\n        // types\n        "string": type, "number": type, "bool": type, "any": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == "/" && !inSet) return;\n        if (next == "[") inSet = true;\n        else if (inSet && next == "]") inSet = false;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '"' || ch == "'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "." && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret("number", "number");\n    } else if (ch == "." && stream.match("..")) {\n      return ret("spread", "meta");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == "=" && stream.eat(">")) {\n      return ret("=>", "operator");\n    } else if (ch == "0" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret("number", "number");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret("number", "number");\n    } else if (ch == "/") {\n      if (stream.eat("*")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat("/")) {\n        stream.skipToEnd();\n        return ret("comment", "comment");\n      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||\n               state.lastType == "sof" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla\n        return ret("regexp", "string-2");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret("operator", "operator", stream.current());\n      }\n    } else if (ch == "`") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == "#") {\n      stream.skipToEnd();\n      return ret("error", "error");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret("operator", "operator", stream.current());\n    } else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :\n                     ret("variable", "variable", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == "\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == "/" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ret("comment", "comment");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n    return ret("quasi", "string-2", stream.current());\n  }\n\n  var brackets = "([{}])";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf("=>", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (/[$\\w]/.test(ch)) {\n        sawSomething = true;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty("align"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == "variable" && inScope(state, content)) return "variable-2";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = "def";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: "this", next: {name: "arguments"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == "stat") indent = state.lexical.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == ")")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function(type) {\n      if (type == wanted) return cont();\n      else if (wanted == ";") return pass();\n      else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type, value) {\n    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);\n    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);\n    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);\n    if (type == "{") return cont(pushlex("}"), block, poplex);\n    if (type == ";") return cont();\n    if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);\n    if (type == "function") return cont(functiondef);\n    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);\n    if (type == "variable") return cont(pushlex("stat"), maybelabel);\n    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),\n                                      block, poplex, poplex);\n    if (type == "case") return cont(expression, expect(":"));\n    if (type == "default") return cont(expect(":"));\n    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),\n                                     statement, poplex, popcontext);\n    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);\n    if (type == "class") return cont(pushlex("form"), className, objlit, poplex);\n    if (type == "export") return cont(pushlex("form"), afterExport, poplex);\n    if (type == "import") return cont(pushlex("form"), afterImport, poplex);\n    return pass(pushlex("stat"), expression, expect(";"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);\n      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == "function") return cont(functiondef);\n    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);\n    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);\n    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);\n    if (type == "{") return contCommasep(objprop, "}", null, maybeop);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == ",") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == "operator") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == "?") return cont(expression, expect(":"), expr);\n      return cont(expr);\n    }\n    if (type == "quasi") { cx.cc.push(me); return quasi(value); }\n    if (type == ";") return;\n    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);\n    if (type == ".") return cont(property, me);\n    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);\n  }\n  function quasi(value) {\n    if (value.slice(value.length - 2) != "${") return cont();\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == "}") {\n      cx.marked = "string-2";\n      cx.state.tokenize = tokenQuasi;\n      return cont();\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == "{") return pass(statement);\n    return pass(expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == "{") return pass(statement);\n    return pass(expressionNoComma);\n  }\n  function maybelabel(type) {\n    if (type == ":") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(";"), poplex);\n  }\n  function property(type) {\n    if (type == "variable") {cx.marked = "property"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == "variable") {\n      cx.marked = "property";\n      if (value == "get" || value == "set") return cont(getterSetter);\n    } else if (type == "number" || type == "string") {\n      cx.marked = type + " property";\n    } else if (type == "[") {\n      return cont(expression, expect("]"), afterprop);\n    }\n    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);\n  }\n  function getterSetter(type) {\n    if (type != "variable") return pass(afterprop);\n    cx.marked = "property";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == ":") return cont(expressionNoComma);\n    if (type == "(") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == ",") {\n        var lex = cx.state.lexical;\n        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == "}") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == ":") return cont(typedef);\n  }\n  function typedef(type) {\n    if (type == "variable"){cx.marked = "variable-3"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == "variable") { register(value); return cont(); }\n    if (type == "[") return contCommasep(pattern, "]");\n    if (type == "{") return contCommasep(proppattern, "}");\n  }\n  function proppattern(type, value) {\n    if (type == "variable" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == "variable") cx.marked = "property";\n    return cont(expect(":"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == "=") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == ",") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);\n  }\n  function forspec1(type) {\n    if (type == "var") return cont(vardef, expect(";"), forspec2);\n    if (type == ";") return cont(forspec2);\n    if (type == "variable") return cont(formaybeinof);\n    return pass(expression, expect(";"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == ";") return cont(forspec3);\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }\n    return pass(expression, expect(";"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != ")") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}\n    if (type == "variable") {register(value); return cont(functiondef);}\n    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == "spread") return cont(funarg);\n    return pass(pattern, maybetype);\n  }\n  function className(type, value) {\n    if (type == "variable") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(_type, value) {\n    if (value == "extends") return cont(expression);\n  }\n  function objlit(type) {\n    if (type == "{") return contCommasep(objprop, "}");\n  }\n  function afterModule(type, value) {\n    if (type == "string") return cont(statement);\n    if (type == "variable") { register(value); return cont(maybeFrom); }\n  }\n  function afterExport(_type, value) {\n    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }\n    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == "string") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == "{") return contCommasep(importSpec, "}");\n    if (type == "variable") register(value);\n    return cont();\n  }\n  function maybeFrom(_type, value) {\n    if (value == "from") { cx.marked = "keyword"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == "]") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == "for") return pass(comprehension, expect("]"));\n    if (type == ",") return cont(commasep(expressionNoComma, "]"));\n    return pass(commasep(expressionNoComma, "]"));\n  }\n  function comprehension(type) {\n    if (type == "for") return cont(forspec, comprehension);\n    if (type == "if") return cont(expression, comprehension);\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: "sof",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty("align"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == "comment") return style;\n      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;\n      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);\n      else if (type == "form" && firstChar == "{") return lexical.indented;\n      else if (type == "form") return lexical.indented + indentUnit;\n      else if (type == "stat")\n        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);\n      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: ":{}",\n    blockCommentStart: jsonMode ? null : "/*",\n    blockCommentEnd: jsonMode ? null : "*/",\n    lineComment: jsonMode ? null : "//",\n    fold: "brace",\n\n    helperType: jsonMode ? "json" : "javascript",\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.defineMIME("text/javascript", "javascript");\nCodeMirror.defineMIME("text/ecmascript", "javascript");\nCodeMirror.defineMIME("application/javascript", "javascript");\nCodeMirror.defineMIME("application/ecmascript", "javascript");\nCodeMirror.defineMIME("application/json", {name: "javascript", json: true});\nCodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});\nCodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });\nCodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });\n\n\n\n\n\n\n        \n        \n        \nCodeMirror.defineMode("xml", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;\n  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag || true;\n\n  var Kludges = parserConfig.htmlMode ? {\n    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                      'track': true, 'wbr': true},\n    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                       'th': true, 'tr': true},\n    contextGrabbers: {\n      'dd': {'dd': true, 'dt': true},\n      'dt': {'dd': true, 'dt': true},\n      'li': {'li': true},\n      'option': {'option': true, 'optgroup': true},\n      'optgroup': {'optgroup': true},\n      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n      'rp': {'rp': true, 'rt': true},\n      'rt': {'rp': true, 'rt': true},\n      'tbody': {'tbody': true, 'tfoot': true},\n      'td': {'td': true, 'th': true},\n      'tfoot': {'tbody': true},\n      'th': {'td': true, 'th': true},\n      'thead': {'tbody': true, 'tfoot': true},\n      'tr': {'tr': true}\n    },\n    doNotIndent: {"pre": true},\n    allowUnquoted: true,\n    allowMissing: true\n  } : {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false\n  };\n  var alignCDATA = parserConfig.alignCDATA;\n\n  // Return variables for tokenizers\n  var tagName, type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == "<") {\n      if (stream.eat("!")) {\n        if (stream.eat("[")) {\n          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));\n          else return null;\n        } else if (stream.match("--")) {\n          return chain(inBlock("comment", "-->"));\n        } else if (stream.match("DOCTYPE", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat("?")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock("meta", "?>");\n        return "meta";\n      } else {\n        var isClose = stream.eat("/");\n        tagName = "";\n        var c;\n        while ((c = stream.eat(/[^\\s\\u00a0=<>\\"\\'\\/?]/))) tagName += c;\n        if (!tagName) return "tag error";\n        type = isClose ? "closeTag" : "openTag";\n        state.tokenize = inTag;\n        return "tag";\n      }\n    } else if (ch == "&") {\n      var ok;\n      if (stream.eat("#")) {\n        if (stream.eat("x")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(";");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(";");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(";");\n      }\n      return ok ? "atom" : "error";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == ">" || (ch == "/" && stream.eat(">"))) {\n      state.tokenize = inText;\n      type = ch == ">" ? "endTag" : "selfcloseTag";\n      return "tag";\n    } else if (ch == "=") {\n      type = "equals";\n      return null;\n    } else if (ch == "<") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + " error" : "error";\n    } else if (/[\\'\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.eatWhile(/[^\\s\\u00a0=<>\\"\\']/);\n      return "word";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return "string";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == "<") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == ">") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return "meta";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName.toLowerCase();\n      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == "openTag") {\n      state.tagName = tagName;\n      state.tagStart = stream.column();\n      return attrState;\n    } else if (type == "closeTag") {\n      var err = false;\n      if (state.context) {\n        if (state.context.tagName != tagName) {\n          if (Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName.toLowerCase()))\n            popContext(state);\n          err = !state.context || state.context.tagName != tagName;\n        }\n      } else {\n        err = true;\n      }\n      if (err) setStyle = "error";\n      return err ? closeStateErr : closeState;\n    } else {\n      return baseState;\n    }\n  }\n  function closeState(type, _stream, state) {\n    if (type != "endTag") {\n      setStyle = "error";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = "error";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == "word") {\n      setStyle = "attribute";\n      return attrEqState;\n    } else if (type == "endTag" || type == "selfcloseTag") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == "selfcloseTag" ||\n          Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) {\n        maybePopContext(state, tagName.toLowerCase());\n      } else {\n        maybePopContext(state, tagName.toLowerCase());\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = "error";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == "equals") return attrValueState;\n    if (!Kludges.allowMissing) setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return attrState;}\n    setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: inText,\n              state: baseState,\n              indented: 0,\n              tagName: null, tagStart: null,\n              context: null};\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      tagName = type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != "comment") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == "error" ? style + " error" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        return state.stringStartCol + 1;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (multilineTagIndentPastTag)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * multilineTagIndentFactor;\n      }\n      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      if (context && /^<\\//.test(textAfter))\n        context = context.prev;\n      while (context && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return 0;\n    },\n\n    electricChars: "/",\n    blockCommentStart: "<!--",\n    blockCommentEnd: "-->",\n\n    configuration: parserConfig.htmlMode ? "html" : "xml",\n    helperType: parserConfig.htmlMode ? "html" : "xml"\n  };\n});\n\nCodeMirror.defineMIME("text/xml", "xml");\nCodeMirror.defineMIME("application/xml", "xml");\nif (!CodeMirror.mimeModes.hasOwnProperty("text/html"))\n  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});        \n        \n        \n        \n        \n        \n        \n\n\n\n// HTMLMIXED\n\nCodeMirror.defineMode("htmlmixed", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});\n  var cssMode = CodeMirror.getMode(config, "css");\n\n  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;\n  scriptTypes.push({matches: /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i,\n                    mode: CodeMirror.getMode(config, "javascript")});\n  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {\n    var conf = scriptTypesConf[i];\n    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});\n  }\n  scriptTypes.push({matches: /./,\n                    mode: CodeMirror.getMode(config, "text/plain")});\n\n  function html(stream, state) {\n    var tagName = state.htmlState.tagName;\n    var style = htmlMode.token(stream, state.htmlState);\n    if (tagName == "script" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      // Script block: mode to change to depends on type attribute\n      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\\btype\\s*=\\s*("[^"]+"|'[^']+'|\\S+)[^<]*$/i);\n      scriptType = scriptType ? scriptType[1] : "";\n      if (scriptType && /[\\"\\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);\n      for (var i = 0; i < scriptTypes.length; ++i) {\n        var tp = scriptTypes[i];\n        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {\n          if (tp.mode) {\n            state.token = script;\n            state.localMode = tp.mode;\n            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));\n          }\n          break;\n        }\n      }\n    } else if (tagName == "style" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      state.token = css;\n      state.localMode = cssMode;\n      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur[0]);\n    }\n    return style;\n  }\n  function script(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       state.localMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localMode: null, localState: null, htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.localMode, state.localState);\n      return {token: state.token, localMode: state.localMode, localState: local,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.localMode || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.localMode.indent)\n        return state.localMode.indent(state.localState, textAfter);\n      else\n        return CodeMirror.Pass;\n    },\n\n    electricChars: "/{}:",\n\n    innerMode: function(state) {\n      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n    }\n  };\n}, "xml", "javascript", "css");\n\nCodeMirror.defineMIME("text/html", "htmlmixed");\n\n\n\n\n\n\n/* 3.21 version, which hash a bug\nCodeMirror.defineMode("htmlmixed", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});\n  var cssMode = CodeMirror.getMode(config, "css");\n\n  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;\n  scriptTypes.push({matches: /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i,\n                    mode: CodeMirror.getMode(config, "javascript")});\n  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {\n    var conf = scriptTypesConf[i];\n    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});\n  }\n  scriptTypes.push({matches: /./,\n                    mode: CodeMirror.getMode(config, "text/plain")});\n\n  function html(stream, state) {\n    var tagName = state.htmlState.tagName;\n    var style = htmlMode.token(stream, state.htmlState);\n    if (tagName == "script" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      // Script block: mode to change to depends on type attribute\n      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\\btype\\s*=\\s*("[^"]+"|'[^']+'|\\S+)[^<]*$/i);\n      scriptType = scriptType ? scriptType[1] : "";\n      if (scriptType && /[\\"\\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);\n      for (var i = 0; i < scriptTypes.length; ++i) {\n        var tp = scriptTypes[i];\n        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {\n          if (tp.mode) {\n            state.token = script;\n            state.localMode = tp.mode;\n            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));\n          }\n          break;\n        }\n      }\n    } else if (tagName == "style" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      state.token = css;\n      state.localMode = cssMode;\n      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n  function script(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       state.localMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localMode: null, localState: null, htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.localMode, state.localState);\n      return {token: state.token, localMode: state.localMode, localState: local,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.localMode || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.localMode.indent)\n        return state.localMode.indent(state.localState, textAfter);\n      else\n        return CodeMirror.Pass;\n    },\n\n    innerMode: function(state) {\n      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n    }\n  };\n}, "xml", "javascript", "css");\n\nCodeMirror.defineMIME("text/html", "htmlmixed");\n\n*/\n\n\n\n\n\nCodeMirror.defineMode("css", function(config, parserConfig) {\n  "use strict";\n\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      allowNested = parserConfig.allowNested;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == "@") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("def", stream.current());\n    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {\n      return ret(null, "compare");\n    } else if (ch == "\\"" || ch == "'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "#") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("atom", "hash");\n    } else if (ch == "!") {\n      stream.match(/^\\s*\\w*/);\n      return ret("keyword", "important");\n    } else if (/\\d/.test(ch) || ch == "." && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret("number", "unit");\n    } else if (ch === "-") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret("number", "unit");\n      } else if (stream.match(/^[^-]+-/)) {\n        return ret("meta", "meta");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, "select-op");\n    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret("qualifier", "qualifier");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (ch == "u" && stream.match("rl(")) {\n      stream.backUp(1);\n      state.tokenize = tokenParenthesized;\n      return ret("property", "word");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("property", "word");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == ")") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      if (ch == quote || !escaped && quote != ")") state.tokenize = null;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\"\\']/, false))\n      state.tokenize = tokenString(")");\n    else\n      state.tokenize = null;\n    return ret(null, "(");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type) {\n    state.context = new Context(type, stream.indentation() + indentUnit, state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = "atom";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = "keyword";\n    else\n      override = "variable";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == "{") {\n      return pushContext(state, stream, "block");\n    } else if (type == "}" && state.context.prev) {\n      return popContext(state);\n    } else if (type == "@media") {\n      return pushContext(state, stream, "media");\n    } else if (type == "@font-face") {\n      return "font_face_before";\n    } else if (type && type.charAt(0) == "@") {\n      return pushContext(state, stream, "at");\n    } else if (type == "hash") {\n      override = "builtin";\n    } else if (type == "word") {\n      override = "tag";\n    } else if (type == "variable-definition") {\n      return "maybeprop";\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    } else if (type == ":") {\n      return "pseudo";\n    } else if (allowNested && type == "(") {\n      return pushContext(state, stream, "params");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == "word") {\n      if (propertyKeywords.hasOwnProperty(stream.current().toLowerCase())) {\n        override = "property";\n        return "maybeprop";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:/, false) ? "property" : "tag";\n        return "block";\n      } else {\n        override += " error";\n        return "maybeprop";\n      }\n    } else if (type == "meta") {\n      return "block";\n    } else if (!allowNested && (type == "hash" || type == "qualifier")) {\n      override = "error";\n      return "block";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == ":") return pushContext(state, stream, "prop");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");\n    if (type == "}" || type == "{") return popAndPass(type, stream, state);\n    if (type == "(") return pushContext(state, stream, "parens");\n\n    if (type == "hash" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {\n      override += " error";\n    } else if (type == "word") {\n      wordAsValue(stream);\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    }\n    return "prop";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") { override = "property"; return "maybeprop"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == ")") return popContext(state);\n    return "parens";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == "word") {\n      override = "variable-3";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.media = function(type, stream, state) {\n    if (type == "(") return pushContext(state, stream, "media_parens");\n    if (type == "}") return popAndPass(type, stream, state);\n    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");\n\n    if (type == "word") {\n      var word = stream.current().toLowerCase();\n      if (word == "only" || word == "not" || word == "and")\n        override = "keyword";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = "attribute";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = "property";\n      else\n        override = "error";\n    }\n    return state.context.type;\n  };\n\n  states.media_parens = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);\n    return states.media(type, stream, state);\n  };\n\n  states.font_face_before = function(type, stream, state) {\n    if (type == "{")\n      return pushContext(state, stream, "font_face");\n    return pass(type, stream, state);\n  };\n\n  states.font_face = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") {\n      if (!fontProperties.hasOwnProperty(stream.current().toLowerCase()))\n        override = "error";\n      else\n        override = "property";\n      return "maybeprop";\n    }\n    return "font_face";\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") override = "tag";\n    else if (type == "hash") override = "builtin";\n    return "at";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "{" || type == ";") return popAndPass(type, stream, state);\n    if (type != "variable") override = "error";\n    return "interpolation";\n  };\n\n  states.params = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") wordAsValue(stream);\n    return "params";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: "top",\n              context: new Context("top", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == "object") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.prev &&\n          (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "font_face") ||\n           ch == ")" && (cx.type == "parens" || cx.type == "params" || cx.type == "media_parens") ||\n           ch == "{" && (cx.type == "at" || cx.type == "media"))) {\n        indent = cx.indent - indentUnit;\n        cx = cx.prev;\n      }\n      return indent;\n    },\n\n    electricChars: "}",\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    fold: "brace"\n  };\n});\n\n(function() {\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i]] = true;\n    }\n    return keys;\n  }\n\n  var mediaTypes_ = [\n    "all", "aural", "braille", "handheld", "print", "projection", "screen",\n    "tty", "tv", "embossed"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    "width", "min-width", "max-width", "height", "min-height", "max-height",\n    "device-width", "min-device-width", "max-device-width", "device-height",\n    "min-device-height", "max-device-height", "aspect-ratio",\n    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",\n    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",\n    "max-color", "color-index", "min-color-index", "max-color-index",\n    "monochrome", "min-monochrome", "max-monochrome", "resolution",\n    "min-resolution", "max-resolution", "scan", "grid"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var propertyKeywords_ = [\n    "align-content", "align-items", "align-self", "alignment-adjust",\n    "alignment-baseline", "anchor-point", "animation", "animation-delay",\n    "animation-direction", "animation-duration", "animation-iteration-count",\n    "animation-name", "animation-play-state", "animation-timing-function",\n    "appearance", "azimuth", "backface-visibility", "background",\n    "background-attachment", "background-clip", "background-color",\n    "background-image", "background-origin", "background-position",\n    "background-repeat", "background-size", "baseline-shift", "binding",\n    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",\n    "bookmark-target", "border", "border-bottom", "border-bottom-color",\n    "border-bottom-left-radius", "border-bottom-right-radius",\n    "border-bottom-style", "border-bottom-width", "border-collapse",\n    "border-color", "border-image", "border-image-outset",\n    "border-image-repeat", "border-image-slice", "border-image-source",\n    "border-image-width", "border-left", "border-left-color",\n    "border-left-style", "border-left-width", "border-radius", "border-right",\n    "border-right-color", "border-right-style", "border-right-width",\n    "border-spacing", "border-style", "border-top", "border-top-color",\n    "border-top-left-radius", "border-top-right-radius", "border-top-style",\n    "border-top-width", "border-width", "bottom", "box-decoration-break",\n    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",\n    "caption-side", "clear", "clip", "color", "color-profile", "column-count",\n    "column-fill", "column-gap", "column-rule", "column-rule-color",\n    "column-rule-style", "column-rule-width", "column-span", "column-width",\n    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",\n    "cue-after", "cue-before", "cursor", "direction", "display",\n    "dominant-baseline", "drop-initial-after-adjust",\n    "drop-initial-after-align", "drop-initial-before-adjust",\n    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",\n    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",\n    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",\n    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",\n    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",\n    "font-stretch", "font-style", "font-synthesis", "font-variant",\n    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",\n    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",\n    "font-weight", "grid-cell", "grid-column", "grid-column-align",\n    "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",\n    "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",\n    "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",\n    "icon", "image-orientation", "image-rendering", "image-resolution",\n    "inline-box-align", "justify-content", "left", "letter-spacing",\n    "line-break", "line-height", "line-stacking", "line-stacking-ruby",\n    "line-stacking-shift", "line-stacking-strategy", "list-style",\n    "list-style-image", "list-style-position", "list-style-type", "margin",\n    "margin-bottom", "margin-left", "margin-right", "margin-top",\n    "marker-offset", "marks", "marquee-direction", "marquee-loop",\n    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",\n    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",\n    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",\n    "outline-color", "outline-offset", "outline-style", "outline-width",\n    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",\n    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",\n    "page", "page-break-after", "page-break-before", "page-break-inside",\n    "page-policy", "pause", "pause-after", "pause-before", "perspective",\n    "perspective-origin", "pitch", "pitch-range", "play-during", "position",\n    "presentation-level", "punctuation-trim", "quotes", "region-break-after",\n    "region-break-before", "region-break-inside", "region-fragment",\n    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",\n    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",\n    "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size",\n    "speak", "speak-as", "speak-header",\n    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",\n    "tab-size", "table-layout", "target", "target-name", "target-new",\n    "target-position", "text-align", "text-align-last", "text-decoration",\n    "text-decoration-color", "text-decoration-line", "text-decoration-skip",\n    "text-decoration-style", "text-emphasis", "text-emphasis-color",\n    "text-emphasis-position", "text-emphasis-style", "text-height",\n    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",\n    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",\n    "text-wrap", "top", "transform", "transform-origin", "transform-style",\n    "transition", "transition-delay", "transition-duration",\n    "transition-property", "transition-timing-function", "unicode-bidi",\n    "vertical-align", "visibility", "voice-balance", "voice-duration",\n    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",\n    "voice-volume", "volume", "white-space", "widows", "width", "word-break",\n    "word-spacing", "word-wrap", "z-index", "zoom",\n    // SVG-specific\n    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",\n    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",\n    "color-interpolation", "color-interpolation-filters", "color-profile",\n    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",\n    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",\n    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",\n    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",\n    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",\n    "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var colorKeywords_ = [\n    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",\n    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",\n    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",\n    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",\n    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",\n    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",\n    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",\n    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",\n    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",\n    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",\n    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",\n    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",\n    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",\n    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",\n    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",\n    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",\n    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",\n    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",\n    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",\n    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",\n    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",\n    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",\n    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",\n    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",\n    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",\n    "whitesmoke", "yellow", "yellowgreen"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    "above", "absolute", "activeborder", "activecaption", "afar",\n    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",\n    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",\n    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page",\n    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",\n    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",\n    "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel",\n    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",\n    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",\n    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",\n    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",\n    "col-resize", "collapse", "column", "compact", "condensed", "contain", "content",\n    "content-box", "context-menu", "continuous", "copy", "cover", "crop",\n    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",\n    "decimal-leading-zero", "default", "default-button", "destination-atop",\n    "destination-in", "destination-out", "destination-over", "devanagari",\n    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",\n    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",\n    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",\n    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",\n    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",\n    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",\n    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",\n    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",\n    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",\n    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",\n    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",\n    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",\n    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",\n    "help", "hidden", "hide", "higher", "highlight", "highlighttext",\n    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",\n    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",\n    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",\n    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",\n    "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer",\n    "landscape", "lao", "large", "larger", "left", "level", "lighter",\n    "line-through", "linear", "lines", "list-item", "listbox", "listitem",\n    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",\n    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",\n    "lower-roman", "lowercase", "ltr", "malayalam", "match",\n    "media-controls-background", "media-current-time-display",\n    "media-fullscreen-button", "media-mute-button", "media-play-button",\n    "media-return-to-realtime-button", "media-rewind-button",\n    "media-seek-back-button", "media-seek-forward-button", "media-slider",\n    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",\n    "media-volume-slider-container", "media-volume-sliderthumb", "medium",\n    "menu", "menulist", "menulist-button", "menulist-text",\n    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",\n    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",\n    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",\n    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",\n    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",\n    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",\n    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",\n    "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer",\n    "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",\n    "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region",\n    "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",\n    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",\n    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",\n    "searchfield-cancel-button", "searchfield-decoration",\n    "searchfield-results-button", "searchfield-results-decoration",\n    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",\n    "single", "skip-white-space", "slide", "slider-horizontal",\n    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",\n    "small", "small-caps", "small-caption", "smaller", "solid", "somali",\n    "source-atop", "source-in", "source-out", "source-over", "space", "square",\n    "square-button", "start", "static", "status-bar", "stretch", "stroke",\n    "sub", "subpixel-antialiased", "super", "sw-resize", "table",\n    "table-caption", "table-cell", "table-column", "table-column-group",\n    "table-footer-group", "table-header-group", "table-row", "table-row-group",\n    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",\n    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",\n    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",\n    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",\n    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",\n    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",\n    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",\n    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",\n    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",\n    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",\n    "xx-large", "xx-small"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var fontProperties_ = [\n    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",\n    "font-stretch", "font-weight", "font-style"\n  ], fontProperties = keySet(fontProperties_);\n\n  var allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);\n  CodeMirror.registerHelper("hintWords", "css", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == "/") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ["comment", "comment"];\n  }\n\n  function tokenSGMLComment(stream, state) {\n    if (stream.skipTo("-->")) {\n      stream.match("-->");\n      state.tokenize = null;\n    } else {\n      stream.skipToEnd();\n    }\n    return ["comment", "comment"];\n  }\n\n  CodeMirror.defineMIME("text/css", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    tokenHooks: {\n      "<": function(stream, state) {\n        if (!stream.match("!--")) return false;\n        state.tokenize = tokenSGMLComment;\n        return tokenSGMLComment(stream, state);\n      },\n      "/": function(stream, state) {\n        if (!stream.eat("*")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: "css"\n  });\n\n  CodeMirror.defineMIME("text/x-scss", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      ":": function(stream) {\n        if (stream.match(/\\s*{/))\n          return [null, "{"];\n        return false;\n      },\n      "$": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "#": function(stream) {\n        if (!stream.eat("{")) return false;\n        return [null, "interpolation"];\n      }\n    },\n    name: "css",\n    helperType: "scss"\n  });\n\n  CodeMirror.defineMIME("text/x-less", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      "@": function(stream) {\n        if (stream.match(/^(charset|document|font-face|import|keyframes|media|namespace|page|supports)\\b/, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "&": function() {\n        return ["atom", "atom"];\n      }\n    },\n    name: "css",\n    helperType: "less"\n  });\n})();\n\n\n\n\n\n\n\nCodeMirror.defineMode("sass", function(config) {\n  var tokenRegexp = function(words){\n    return new RegExp("^" + words.join("|"));\n  };\n\n  var keywords = ["true", "false", "null", "auto"];\n  var keywordsRegexp = new RegExp("^" + keywords.join("|"));\n\n  var operators = ["\\\\(", "\\\\)", "=", ">", "<", "==", ">=", "<=", "\\\\+", "-", "\\\\!=", "/", "\\\\*", "%", "and", "or", "not"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[\\w\\-]+/;\n\n  var urlTokens = function(stream, state){\n    var ch = stream.peek();\n\n    if (ch === ")"){\n      stream.next();\n      state.tokenizer = tokenBase;\n      return "operator";\n    }else if (ch === "("){\n      stream.next();\n      stream.eatSpace();\n\n      return "operator";\n    }else if (ch === "'" || ch === '"'){\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return "string";\n    }else{\n      state.tokenizer = buildStringTokenizer(")", false);\n      return "string";\n    }\n  };\n  var multilineComment = function(stream, state) {\n    if (stream.skipTo("*/")){\n      stream.next();\n      stream.next();\n      state.tokenizer = tokenBase;\n    }else {\n      stream.next();\n    }\n\n    return "comment";\n  };\n\n  var buildStringTokenizer = function(quote, greedy){\n    if(greedy == null){ greedy = true; }\n\n    function stringTokenizer(stream, state){\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== "\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== "\\\\"));\n\n      /*\n      console.log("previousChar: " + previousChar);\n      console.log("nextChar: " + nextChar);\n      console.log("peekChar: " + peekChar);\n      console.log("ending: " + endingString);\n      */\n\n      if (endingString){\n        if (nextChar !== quote && greedy) { stream.next(); }\n        state.tokenizer = tokenBase;\n        return "string";\n      }else if (nextChar === "#" && peekChar === "{"){\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return "operator";\n      }else {\n        return "string";\n      }\n    }\n\n    return stringTokenizer;\n  };\n\n  var buildInterpolationTokenizer = function(currentTokenizer){\n    return function(stream, state){\n      if (stream.peek() === "}"){\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return "operator";\n      }else{\n        return tokenBase(stream, state);\n      }\n    };\n  };\n\n  var indent = function(state){\n    if (state.indentCount == 0){\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  };\n\n  var dedent = function(state){\n    if (state.scopes.length == 1) { return; }\n\n    state.scopes.shift();\n  };\n\n  var tokenBase = function(stream, state) {\n    var ch = stream.peek();\n\n    // Single line Comment\n    if (stream.match('//')) {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Multiline Comment\n    if (stream.match('/*')){\n      state.tokenizer = multilineComment;\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match('#{')){\n    state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return "operator";\n    }\n\n    if (ch === "."){\n      stream.next();\n\n      // Match class selectors\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "atom";\n      }else if (stream.peek() === "#"){\n        indent(state);\n        return "atom";\n      }else{\n        return "operator";\n      }\n    }\n\n    if (ch === "#"){\n      stream.next();\n\n      // Hex numbers\n      if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n        return "number";\n      }\n\n      // ID selectors\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "atom";\n      }\n\n      if (stream.peek() === "#"){\n        indent(state);\n        return "atom";\n      }\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/)){\n      return "number";\n    }\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/)){\n      return "unit";\n    }\n\n    if (stream.match(keywordsRegexp)){\n      return "keyword";\n    }\n\n    if (stream.match(/^url/) && stream.peek() === "("){\n      state.tokenizer = urlTokens;\n      return "atom";\n    }\n\n    // Variables\n    if (ch === "$"){\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n\n      if (stream.peek() === ":"){\n        stream.next();\n        return "variable-2";\n      }else{\n        return "variable-3";\n      }\n    }\n\n    if (ch === "!"){\n      stream.next();\n\n      if (stream.match(/^[\\w]+/)){\n        return "keyword";\n      }\n\n      return "operator";\n    }\n\n    if (ch === "="){\n      stream.next();\n\n      // Match shortcut mixin definition\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "meta";\n      }else {\n        return "operator";\n      }\n    }\n\n    if (ch === "+"){\n      stream.next();\n\n      // Match shortcut mixin definition\n      if (stream.match(/^[\\w-]+/)){\n        return "variable-3";\n      }else {\n        return "operator";\n      }\n    }\n\n    // Indent Directives\n    if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)){\n      indent(state);\n      return "meta";\n    }\n\n    // Other Directives\n    if (ch === "@"){\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      return "meta";\n    }\n\n    // Strings\n    if (ch === '"' || ch === "'"){\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return "string";\n    }\n\n    // Pseudo element selectors\n    if (ch == ':' && stream.match(pseudoElementsRegexp)){\n      return "keyword";\n    }\n\n    // atoms\n    if (stream.eatWhile(/[\\w-&]/)){\n      // matches a property definition\n      if (stream.peek() === ":" && !stream.match(pseudoElementsRegexp, false))\n        return "property";\n      else\n        return "atom";\n    }\n\n    if (stream.match(opRegexp)){\n      return "operator";\n    }\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  };\n\n  var tokenLexer = function(stream, state) {\n    if (stream.sol()){\n      state.indentCount = 0;\n    }\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === "@return"){\n      dedent(state);\n    }\n\n    if (style === "atom"){\n      indent(state);\n    }\n\n    if (style !== null){\n      var startOfToken = stream.pos - current.length;\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++){\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent){\n          newScopes.push(scope);\n        }\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  };\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: 'sass'}],\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    }\n  };\n});\n\nCodeMirror.defineMIME("text/x-sass", "sass");\n\n\n\n\n\n\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\nCodeMirror.defineMode("coffeescript", function(conf) {\n  var ERRORCLASS = "error";\n\n  function wordRegexp(words) {\n    return new RegExp("^((" + words.join(")|(") + "))\\\\b");\n  }\n\n  var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?)/;\n  var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n  var properties = /^(@|this\\.)[_A-Za-z$][_A-Za-z$0-9]*/;\n\n  var wordOperators = wordRegexp(["and", "or", "not",\n                                  "is", "isnt", "in",\n                                  "instanceof", "typeof"]);\n  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",\n                        "switch", "try", "catch", "finally", "class"];\n  var commonKeywords = ["break", "by", "continue", "debugger", "delete",\n                        "do", "in", "of", "new", "return", "then",\n                        "this", "throw", "when", "until"];\n\n  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n  indentKeywords = wordRegexp(indentKeywords);\n\n\n  var stringPrefixes = /^('{3}|\\"{3}|['\\"])/;\n  var regexPrefixes = /^(\\/{3}|\\/)/;\n  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];\n  var constants = wordRegexp(commonConstants);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    // Handle scope changes\n    if (stream.sol()) {\n      if (state.scope.align === null) state.scope.align = false;\n      var scopeOffset = state.scope.offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset && state.scope.type == "coffee") {\n          return "indent";\n        } else if (lineOffset < scopeOffset) {\n          return "dedent";\n        }\n        return null;\n      } else {\n        if (scopeOffset > 0) {\n          dedent(stream, state);\n        }\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle docco title comment (single line)\n    if (stream.match("####")) {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Handle multi line comments\n    if (stream.match("###")) {\n      state.tokenize = longComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Single line comment\n    if (ch === "#") {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Handle number literals\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\d+\\.\\d*/)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\.\\d+/)) {\n        floatLiteral = true;\n      }\n\n      if (floatLiteral) {\n        // prevent from getting extra . on 1..\n        if (stream.peek() == "."){\n          stream.backUp(1);\n        }\n        return "number";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^-?0x[0-9a-f]+/i)) {\n        intLiteral = true;\n      }\n      // Decimal\n      if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^-?0(?![\\dx])/i)) {\n        intLiteral = true;\n      }\n      if (intLiteral) {\n        return "number";\n      }\n    }\n\n    // Handle strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenFactory(stream.current(), false, "string");\n      return state.tokenize(stream, state);\n    }\n    // Handle regex literals\n    if (stream.match(regexPrefixes)) {\n      if (stream.current() != "/" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n        state.tokenize = tokenFactory(stream.current(), true, "string-2");\n        return state.tokenize(stream, state);\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n    // Handle operators and delimiters\n    if (stream.match(operators) || stream.match(wordOperators)) {\n      return "operator";\n    }\n    if (stream.match(delimiters)) {\n      return "punctuation";\n    }\n\n    if (stream.match(constants)) {\n      return "atom";\n    }\n\n    if (stream.match(keywords)) {\n      return "keyword";\n    }\n\n    if (stream.match(identifiers)) {\n      return "variable";\n    }\n\n    if (stream.match(properties)) {\n      return "property";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function tokenFactory(delimiter, singleline, outclass) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'"\\/\\\\]/);\n        if (stream.eat("\\\\")) {\n          stream.next();\n          if (singleline && stream.eol()) {\n            return outclass;\n          }\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          return outclass;\n        } else {\n          stream.eat(/['"\\/]/);\n        }\n      }\n      if (singleline) {\n        if (conf.mode.singleLineStringErrors) {\n          outclass = ERRORCLASS;\n        } else {\n          state.tokenize = tokenBase;\n        }\n      }\n      return outclass;\n    };\n  }\n\n  function longComment(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^#]/);\n      if (stream.match("###")) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.eatWhile("#");\n    }\n    return "comment";\n  }\n\n  function indent(stream, state, type) {\n    type = type || "coffee";\n    var offset = 0, align = false, alignOffset = null;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (scope.type === "coffee") {\n        offset = scope.offset + conf.indentUnit;\n        break;\n      }\n    }\n    if (type !== "coffee") {\n      align = null;\n      alignOffset = stream.column() + stream.current().length;\n    } else if (state.scope.align) {\n      state.scope.align = false;\n    }\n    state.scope = {\n      offset: offset,\n      type: type,\n      prev: state.scope,\n      align: align,\n      alignOffset: alignOffset\n    };\n  }\n\n  function dedent(stream, state) {\n    if (!state.scope.prev) return;\n    if (state.scope.type === "coffee") {\n      var _indent = stream.indentation();\n      var matched = false;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (_indent === scope.offset) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return true;\n      }\n      while (state.scope.prev && state.scope.offset !== _indent) {\n        state.scope = state.scope.prev;\n      }\n      return false;\n    } else {\n      state.scope = state.scope.prev;\n      return false;\n    }\n  }\n\n  function tokenLexer(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle "." connected identifiers\n    if (current === ".") {\n      style = state.tokenize(stream, state);\n      current = stream.current();\n      if (/^\\.[\\w$]+$/.test(current)) {\n        return "variable";\n      } else {\n        return ERRORCLASS;\n      }\n    }\n\n    // Handle scope changes.\n    if (current === "return") {\n      state.dedent += 1;\n    }\n    if (((current === "->" || current === "=>") &&\n         !state.lambda &&\n         !stream.peek())\n        || style === "indent") {\n      indent(stream, state);\n    }\n    var delimiter_index = "[({".indexOf(current);\n    if (delimiter_index !== -1) {\n      indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));\n    }\n    if (indentKeywords.exec(current)){\n      indent(stream, state);\n    }\n    if (current == "then"){\n      dedent(stream, state);\n    }\n\n\n    if (style === "dedent") {\n      if (dedent(stream, state)) {\n        return ERRORCLASS;\n      }\n    }\n    delimiter_index = "])}".indexOf(current);\n    if (delimiter_index !== -1) {\n      while (state.scope.type == "coffee" && state.scope.prev)\n        state.scope = state.scope.prev;\n      if (state.scope.type == current)\n        state.scope = state.scope.prev;\n    }\n    if (state.dedent > 0 && stream.eol() && state.scope.type == "coffee") {\n      if (state.scope.prev) state.scope = state.scope.prev;\n      state.dedent -= 1;\n    }\n\n    return style;\n  }\n\n  var external = {\n    startState: function(basecolumn) {\n      return {\n        tokenize: tokenBase,\n        scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},\n        lastToken: null,\n        lambda: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var fillAlign = state.scope.align === null && state.scope;\n      if (fillAlign && stream.sol()) fillAlign.align = false;\n\n      var style = tokenLexer(stream, state);\n      if (fillAlign && style && style != "comment") fillAlign.align = true;\n\n      state.lastToken = {style:style, content: stream.current()};\n\n      if (stream.eol() && stream.lambda) {\n        state.lambda = false;\n      }\n\n      return style;\n    },\n\n    indent: function(state, text) {\n      if (state.tokenize != tokenBase) return 0;\n      var scope = state.scope;\n      var closer = text && "])}".indexOf(text.charAt(0)) > -1;\n      if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;\n      var closes = closer && scope.type === text.charAt(0);\n      if (scope.align)\n        return scope.alignOffset - (closes ? 1 : 0);\n      else\n        return (closes ? scope.prev : scope).offset;\n    },\n\n    lineComment: "#",\n    fold: "indent"\n  };\n  return external;\n});\n\nCodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
\\x8280fe73c21bcf2b42a987c940e440be0c69bfdff40afe0988232e3468889dba	400e206e-77ed-4b12-9c09-168ee2fc812b
\\x828e8d8d3691e2013a20faa62f21588c67706c4a9d7a121ee682325babf031f9	.{{= name }} {\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n}\n\n.{{= name }} header .logo a {\n    font-size: 200%;\n    color: blue;\n    letter-spacing: 1ex;\n    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\n    text-decoration: none;\n    font-weight: bold;\n\n}\n\n.{{= name }} header a:hover {\n    text-decoration: underline;\n    color: blue;\n}\n\n\n.{{= name }} > .content {\n    display: flex;\n    flex: 2;\n    overflow: auto; /* was 'hidden' -elh */\n}\n\n.{{= name }} .row_list_section {\n    background-color: #222;\n    order: 0;\n    flex: 1 1 auto;\n    align-self: auto;\n    width: 20em;\n    overflow: auto;\n    padding: 4px;\n}\n\n.{{= name }} .workspace_section {\n    order: 0;\n    flex: 5 1 80%;\n    align-self: auto;\n}\n\n.{{= name }} .bundle_icon:hover {\n    cursor: pointer;\n}\n\n\n.{{= name }} .auth {\n    position: absolute;\n    top: 0;\n    right: 0;\n}\n        \n
\\x82b9f1a396e82eff677e73d5648b2a37ef2f8afc2085375714540e68f8c6ff54	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\nconsole.log('tab: my data is ', w.data('tab_id'));\nw.append(content);
\\x82ba9aa995cfa1843ee31f2e83c584904d021085f0a86f43533ce7a4aa266018	ffc4d8c8-9a36-42a6-91af-41ae7a771bf0
\\x82db30862c8f02a8660469a3293bb9b7807d541b9eadc0f05cb958584aa407ca	var w = $("#"+id);\n\nw.find('button.export').click(function() {\n    var dir = w.find('input.directory').val();\n\n\n    if (confirm('export this bundle to '+dir+'?')) {\n        endpoint.schema('bundle').function('bundle_export_csv', [ bundle.get('name'), dir ])\n        .then(function() {\n            alert ('success');\n        })\n        .catch(function(e) {\n            alert('failed:'+e);\n        });\n    }\n});
\\x83939a65527e92fe285304ea49eaec826d45c0a4f8ab74f613bba74a0c980ec7	var w = $("#"+id);\n/*\nTEST FKEY AUTOCOMPLETE\n\n\n\nvar from_column = 'new_row_widget_id';\n\nw.append('<p>Using column: ' + from_column + '</p>');\n\n\nendpoint.schema('semantics').table('relation').row().where({\n    row_detail_widget_id: '40cca2f6-7c35-4118-83db-031e04e4397a'\n}).result(function(row) {\n\n    w.append(widget('sem_fkey_autocomplete', { \n        from_row: row,\n        from_column: from_column,\n        to_relation: endpoint.schema('widget').table('widget'),\n        to_column: 'id',\n        label_function: function(to_row) {\n            return to_row.get('name')\n        },\n        order_by_function: function(rows) {\n            return rows.order_by({ column: 'name' });\n        },\n        new_enabled: true\n    }));\n\n});\n*/\n\nendpoint.schema('mickey').table('post').row().where({\n    name: 'words mickey says'\n}).result(function(row) {    \n    \n    w.append(widget('sem_fkey_one_to_many', { \n        from_row: row,\n        from_column: 'id',\n        to_relation: endpoint.schema('mickey').table('blah'),\n        to_column: 'post_id',\n        label_function: function(to_row) {\n            return to_row.get('name')\n        },\n        order_by_function: function(rows) {\n            return rows.order_by({ column: 'name' });\n        },\n        new_enabled: true\n    }));\n    \n});\n
\\x8413503e76b8d9cfa3b2077a5726a0e74e099776088b20339ea267c4f8f6d3fe	<div id="{{= id }}" class="{{= name }}">\n    <div class='title'>{{= widget_name }}{{? properties.count > 1 }}(&times;{{=properties.count}}){{?}}</div>\n    <div class='children'>\n    </div>\n</div>
\\x8468ab5a3a5b263a8273b99620613c90845bdf9856f279416b7f8cb0141b2103	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <title>Aquameta</title>\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <h1>Aquameta</h1>\n        <p>Huzzah!  If you can see this, it worked.</p>\n        <p>Here are some starting places:</p>\n        <ul>\n            <li><a href='/dev'>/dev</a> - Developer IDE</li>\n            <li><a href='/docs'>/docs</a> - Documentation (coming soon)</li>\n            <li><a href='/snake'>/snake</a> - Snake - a sample game</li>\n        </ul>\n            \n    </body>\n</html>\n\n
\\x851b1c101c1a95d944af5fcb68470f1ec118d96186adb9468c2dd1336bbcdf1c	var w = $("#"+id);\n\nendpoint.schema('bundle').table('untracked_row').rows({\n}).then(function(untracked) {\n    widget.sync(untracked, w.find('.rows'), function(row) {\n        return widget('bundle_untracked_row_li', {\n            row: row\n        });\n    });\n});\n\nw.find('input.checkall').change(function() {\n    console.log('checkall');\n    if(this.checked) {\n        w.find('input.action').prop('checked',true);\n    } else {\n        w.find('input.action').prop('checked', false);\n    }\n\n});\n\nw.find('button.ignore').click(function() {\n    var selected = [];\n    w.find('input.action:checked').each(function() {\n        selected.push($(this).closest('.bundle_untracked_row_li').data('row_id'));\n    });\n    \n    w.append(widget('ide:modal', {\n        content: widget('ide:ignore_modal', {\n            rows: selected\n        })\n    }));\n    \n    /*\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n        \n        endpoint.schema('bundle').function('ignored_row_add', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            li.remove();\n        }).catch(function(e,o) {\n            alert('error ignoring row!');\n            console.log('error ignoring row: ', row_id, e,o);\n        });\n        \n    */\n});\n\n\nw.find('button.track').click(function() {\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n    \n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            li.remove();\n        }).catch(function(e,o) {\n            alert('error tracking row!');\n            console.log('error ignoring row: ', row_id, e,o);\n        });\n    });\n});\n
\\x85709a7c9fbc665e8c33637282c2287a0707d35140a467681175b7de3759e924	.{{= name }} {\n    margin: 0 auto;\n    padding: 1em;\n    text-align: left;\n    height: 100%;\n}\n\n.{{= name }} .hide {\n    display: none;\n}\n\n.{{= name }} > .loaded > .autocomplete {\n}\n\n.{{= name }} > .loaded > .results {\n\n    top: 0;\n    bottom:0;\n    left:0;\n    right:0;\n    \n    margin-top: 2.5em;\n    margin-bottom: 0.5em;\n    margin-right: 1em;\n    margin-left: 1em;\n\n    width: auto;\n    height: auto;\n    overflow-y: auto;\n    position: absolute;\n}\n\n.{{= name }} .autocomplete-suggestions {\n    width: 100% !important;\n}\n\n.{{= name }} .autocomplete-suggestion {\n    color: white;\n    font-size: 12px;\n    \n    margin: 0 auto;\n    padding: 3px;\n    \n    display: block;\n    width: 100%;\n}\n\n.{{= name }} .autocomplete-suggestion.autocomplete-selected {\n    background-color: #555;\n}
\\x85720a0b481509832c947735c853561c1cd1886e50aeadc1a6d0bce26aa5e911	<div id="{{= id }}" class="{{= name }}">\n    <h3>endpoint.resource_binary upload</h3>\n    \n    file: <input class='fileUpload' type='file'><br>\n    path: <input class='path' type='text'><br>\n    <button class='upload'>upload</button>\n</div>
\\x85a19f86abffaa42219721c22ec45a0d11db4bcbadf558a03a2ccf461c650b42	<div id="{{= id }}" class="{{= name }}">\n    <p>url_pattern: <span class='url_pattern'></span></p>\n    <p>args: <span class='args'></span></p>\n    <button class='delete'>delete</button>\n    <button class='save'>save</button>\n</div>
\\x86f19413ba11f8c4a658ed52098fba78ec0c64061bb1794dfe2f82197a227b00	.{{= name }} {\n    font-size: 80%;\n    position: fixed;\n    top: 4ex;\n    bottom: 2ex;\n    right: 0;\n    width: 20em;\n    border: 4px dashed blue;\n    margin-top: 3ex;\n\tbackground-color:rgba(0,0,0,0.95);\n    padding: .5ex .5em .5ex .5em;\n    z-index: 100;\n}
\\x885b6fff9801e7f7c4523f75b2c07f248b7cd9c9cb2375c8a64ba55812bb7e3a	var w = $("#"+id);\n\n\n/* SETUP */\nvar rel_name;\nvar relation = datum;\nif (!(datum instanceof AQ.Rowset)) {\n    datum = datum.rows()\n    .then(function(rows) {\n        rel_name = rows.relation.schema.name + '.' + rows.relation.name;\n        w.find('.title').text(rel_name);\n    });\n}\nelse {\n    rel_name = datum.relation.schema.name + '.' + datum.relation.name;\n    relation = datum.relation;\n    w.find('.title').text(rel_name);\n}\n\nwidget.sync(datum, w.find('> .list > ul'), function(row) {\n    return widget('semantics/list_item', row);\n});\n\n\n\n/* TRIGGERS */\nw.on('list_item_click', function(e, row, list_item) {\n    list_item.toggleClass('selected');\n    w.find('.header .continue').toggle(!!w.find('.header ~ * > .selected').length);\n});\n\nw.find('.divider').on('click', function() {\n    w.find('.list').toggleClass('collapsed');\n});\n\nw.find('.toggle_options').on('click', function() {\n    w.find('.arrow').toggleClass('up');\n    if (w.find('.arrow').hasClass('up')) {\n        w.find('.search').focus();\n    }\n});\n\nw.find('.new').on('click', function() {\n    w.append(\n        widget('core:modal', {\n            content: widget('semantics/new_row', relation)\n        })\n    );\n});\n\nw.find('.continue').on('click', function() {\n    var selected_items = w.find('.header ~ * > .selected').map(function() {\n        return $(this).data('row');\n    }).toArray();\n    w.trigger('list_view_select', [selected_items]);\n});\n\n\n\n/* SEARCH */\nfunction search(e) {\n    var list_items = w.find('li');\n    var val = $(this).val().trim();\n    if (val != '') {\n        \n        var matching_elements = $.grep(\n            list_items, \n            function(e, i) {\n                var re = new RegExp(val, 'i');\n\n                if (re.test($(e).html())) {\n                    return true;\n                }\n                return false;\n            });\n        \n        list_items.hide();\n        $(matching_elements).show();\n    }\n    else {\n        list_items.show();\n    }\n}\n/*\nvar debounced_search = debounce(search, 200, false);\nw.find('.search').on('keyup', debounced_search);\n*/\nw.find('.search').on('keyup', search);\n
\\x88a33366edd8b3c97098db3e4c1cf07685ee98b2299dc9736701504ba1a2f438	layout_tabbed
\\x8920f9a6e3883ee22ee17f0bf209c0c30679e7b696fdf9ef55f15eccdf4a9d67	bundle_untracked_row_li
\\x897e67d3783bc8c4fc6e97f1f6e31ce42cbb3ce9b640f9bbfa56b30fb57af727	row_detail_meta_table
\\x8a1f29e7c944df2b834df2830681c0f09ec34e24699da8062cb34dd2887bd345	var w = $('#'+id);\n\nfunction display() {\n    var val = JSON.stringify(field.value);\n    \n    if (val == null) {\n        val = 'NULL';\n    }\n    \n    else if (val == '') {\n        val = '____';\n    }\n    \n    w.find('.display').html(val);\n    w.find('input').val(val);\n    \n    w.removeClass('saving')\n    .removeClass('editing')\n    .addClass('displaying');\n    \n    //w.find('.edit input').prop('disabled', false);\n}\ndisplay();\n\nfunction edit() {\n    w.removeClass('displaying')\n    .removeClass('saving')\n    .addClass('editing');\n    w.find('input').focus();\n}\n\n\nfunction save(saving_as_null) {\n    \n    w.removeClass('displaying')\n    .removeClass('editing')\n    .addClass('saving');\n    \n    //w.find('.edit input').prop('disabled', true);\n\n    var old_value = field.value;\n\n    // save\n    if (saving_as_null) {\n        field.set(null);\n    }\n    else {\n        field.set(w.find('input').val());\n    }\n    \n    field.update().then(function() {\n        w.trigger('status', ['Saved', 'success']);\n        w.trigger('form_field_save');\n        display();\n        \n    }).catch(function(error) {\n        field.set(old_value);\n        w.trigger('status', ['Failed save', 'fail']);\n        display();\n    });\n}\n\n\n// EVENT BINDINGS\nw.find('.save').on('click', save.bind(this, false));\nw.find('.save_as_null').on('click', save.bind(this, true));\nw.find('.display').on('click', edit);\nw.find('.cancel').on('click', display);\nw.find('input').on('keyup', function(e) {\n    if (e.keyCode == 27) {\n        display();\n    }\n    if (e.keyCode == 13) {\n        save(false);\n    }\n});\n
\\x8a23ad6ca1557216e02f313b460766690c9b0fac9a8f8b09e86b81c49ca302a6	stage_dialog_unstaged_field\n
\\x8a5edab282632443219e051e4ade2d1d5bbc671c781051bf1437897cbdfea0f1	/
\\x8a779718aeacb457ce8ebbd8aae714c45033c907ae6d387f9f5fec23c54d8513	.{{= name }} {\n    border: 2px dotted gray;\n    padding: 10px;\n}\n\n.{{= name }} .comparison {\n    display: none;\n}
\\x8a9f8a9845c5c0e9edc9b4a502f0db618c2181ac285ce8b4ec4c600632b5e25a	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n    w.find('.text_id').click(function() {\n        w.trigger('bundle_row_open', { row_id: change.get('row_id'), row: real_row });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:stage_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:stage_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('.modified_link').click(function() {\n    alert ('coming soon...');\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_stage_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n\n\n\n\n
\\x8adcc0377c276eaa67ff1af64dd8f6ccf772fa668f0921a77005949c58073c96	2bc72050-e4fc-472a-ae7e-bee1f8869c85
\\x8b8c6c9047c2d3083f42e83d8155f901d2055eeb5e77d5e59cd0e7703d50165c	7dfc33c6-9cd9-459d-b98c-e0288f9cd186
\\x8c3699071fa42948874888635f4d445c47aec5659658cfe51d08bf5462e8f32c	.{{= name }} {\n    white-space: nowrap;\n    display: none;\n}\n\n.{{= name }} .label {\n    font-size: 90%;\n}\n\n.{{= name }} .label:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n
\\x8c400e7a853a662b835fd7efffd22c74b11734c897a05169e7b127061b7c0078	bundle_push_pull
\\x8c44be9da009334637868fcdd1eb2eec1de5abee6b2fc5d9e5d1d22ae0d026b1	<div id="{{= id }}" class="{{= name }}">\n    <button class='new_row'>new row</button>\n    <button class='commit'>commit</button>\n    <button class='commit_log'>history</button>\n    <button class='push_pull'>&#8644;push/pull</button>\n    <button class='bundle_config'>&#9881;config</button>\n    \n    \n    \n    <div class='filters'>\n        <span class='tab all'>all</span>\n        <span class='tab changed'>changed</span>\n        <span class='tab head'>head</span>\n    </div>\n    <div class='bundle_contents'>\n    </div>\n</div>
\\x8cbb3253556df9bd179e219cc6bf0bf8c981bab3baad02a4eeefbf76e65ebe9e	<div id="{{= id }}" class="{{= name }}">\n    <span class='path'></span>\n    <button class='delete'>delete</button>\n</div>
\\x8d2f9444c9f30d420222243bb2ef96ef29be8b28bde418b06f462f28f3492af1	bf6e6451-88c6-4642-b034-2c72a83ee6ec
\\x8d34c2b7e40bbb2bbf5931944ddb32b26cc58ef4f1e7df63ac87a64863972296	6046e06d-28c5-4d25-ad3a-4470c2195323
\\x8de79847a2b49948cb8847434202ba848fac61d4f234982bccd12e9475775d7b	var w = $("#"+id);\n\n// inputs:\n// relation {AQ.Relation}\n\n// this widget will insert uploaded file into the given 'relation'\n// the file data will be base64 encoded and set as the 'data' column (column type must be bytea)\n// the name of the file will be saved in the 'name' column\n\nw.find('.fileUpload').on('change', function () {\n    const reader = new FileReader()\n    const file = $(this).get(0).files[0]\n    reader.onload = event => {\n        const { name, size, type } = file\n        const dataURL = event.target.result\n        const data = dataURL.replace(/^data:.+;base64,/, '')\n        relation.insert({ name, data })\n        .then(result => {\n            console.log('file saved')\n        })\n        .catch(error => {\n            alert('file upload no worky\\n' + error)\n        })\n    }\n    reader.readAsDataURL(file)\n})
\\x8e136539889424ba3f3718975d9bbe313d58d232907bfecef62516dfcd4ecae7	<div id="{{= id }}" class="{{= name }}">\n    <h2>New Row</h2>\n    <hr/>\n    \n    <h3>Development</h3>\n    <div class="new_row_buttons">\n        <div id="widget" class="new_row_button">\n            <div class="new_row_icon">⚙</div>\n            <div class="new_row_name">Widget</div>\n        </div>\n        <div id="resource" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Resource</div>\n        </div>\n        <div id="template" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Template</div>\n        </div>        \n        <div id="dependency_js" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Javascript Library</div>\n        </div>\n        <div id="table" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Table</div>\n        </div>\n        <div id="view" class="new_row_button">\n            <div class="new_row_icon">⌕</div>\n            <div class="new_row_name">View</div>\n        </div>\n        <div id="function" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Function</div>\n        </div>\n        <div id="binary" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Binary</div>\n        </div>\n        <div id="fdw" class="new_row_button">\n            <div class="new_row_icon">&#8599;</div>\n            <div class="new_row_name">Foreign Table</div>\n        </div>\n    </div>\n    \n    <h3>Bundle</h3>\n    \n    <h3>Everything</h3>\n</div>
\\x8e352d1ae64536feb4b9b82a391d0b3bf486e6983eee59dd60a31bb8af92b687	var w = $("#"+id);\n\nvar bundle_name = window.location.hash.split('#')[1];\n\n\nif (typeof bundle_name == 'undefined') {\n    w.find('.row_list_section').html(widget('ide:bundle_selector'));\n    w.on('bundle_selected', function(e, payload) {\n        \n        w.find('.bundle_selector').remove();\n        bundle_name = payload.bundle_name;\n        window.location.hash = bundle_name;\n        show_bundle();\n    });\n}\nelse {\n    show_bundle();\n}\n\nfunction show_bundle() {\n    endpoint.schema('bundle').table('bundle').row({\n        where: {\n            name: 'name',\n            op: '=',\n            value: bundle_name\n        }\n    }).then(function(bundle) {\n        // load the workspace\n        w.find('.workspace_section').html(widget('ide:workspace', { bundle: bundle }));\n        w.find('.row_list_section').html(widget('ide:row_list', { bundle: bundle }));\n        w.find('header .title').html(bundle.get('name'));\n    });\n\n}
\\x8e54789afdb68c45fb948ae2e1b2470929186f8fc3f299d7fbf60d0b79410c56	573d40f7-be20-468a-8140-7d8c318b2e08
\\x91444ce3aa3f0193a98bb3de38c0d4fe19dd29c7c993a2cacccf5f3adac63351	c9da1004-c2e8-4fb2-9e9e-cc34ec077c77
\\x91484a142e251b32d818e63cd51fa5df18ef7fb5c11e1983b37f7afb13b276b2	4ed34807-309b-47f0-a796-34850d9937e5
\\x922691d8151ff68081c9c944238ac26fb624e894b5bb516e9e1834fe9ed75096	5d9aa6c9-4e3d-4295-9ddc-f0506fef2e67
\\x9387a4e1685a399cf6a436428db2e244334a8c6137d129da749b68daabfda263	var w = $("#"+id);\n\n\nw.find('> .tabs').html(widget('layout_tabbed', {\n    tabs: {\n        'widgets': function () {\n            return widget('debugger3_widgets', { });\n        },\n        'data': function() {\n            return widget('debugger3_data', { });\n        },\n        'users': function() {\n            return widget('debugger3_users', { });\n        },\n    },\n    tab_colors: {\n        'widgets': 'blue',\n        'data': 'blue',\n        'machines-js': 'blue'\n    } \n}));\n
\\x938b99e3330802a9290b64452b1b303a7efa94dd8f5fc86b6c941cf0644ce220	/dev
\\x93dace93862993fb22d1ce8883d688e38c07dcc1baca8fbf58057db896e4afbd	<li id="{{= id }}" class="{{= name }}">\n    <span class='arrow'>&#10094;</span>\n    <span class='title'>{{= row.get('name') || row.get('id') }}</span>\n    <span class='empty hide'>Empty</span>\n    <div class='list'></div>\n</li>
\\x93e57604055f3df49366f29f59441ffb5019f4066514c0fbc12511e65f03d9e3	<tr id="{{= id }}" class="{{= name }}">\n    <td><nobr><span class='head_commit'>HEAD&#10148;</span></nobr></td>\n    <td>{{= commit.get("role_id") }}</td>\n    <td class='date'></td>\n    <td>{{= commit.get("message") }}</td>\n    <td><button class='checkout'>Check Out</button></td>\n</tr>
\\x959d5aca9cacb643c42991fe095da5a617deb7ed94307f8c824b569aee03b30f	<select id="{{= id }}" class="{{= name }}">\n    <option>Select one.</option>\n</select>
\\x96084372d321eed34c83e03948899508d0fdd6464f4184849ede64d595ec606c	debugger3_widgets_tree
\\x962d9c3c5c831f86d6749ac8cfdc260ac0fdf1d4d3b5c37c43038553a36b8954	32344c09-b6ca-4ecc-b0da-b82c54d6c7b7
\\x973efcb414361eaabee47639410952468f7c19728828be14abe45b8fe547f491	events:\nbinds to close_modal:  closes.\n\n\n\n
\\x97aa140ff4c4017b8f45501de614dadc192738eea67f3aae8566ed1236e72c17	commit_dialog_staged_fields
\\x982221b639a143c8fca743755b932c9738fb383f5c4b3fb956f63622e22c9537	sem_fkey_one_to_many
\\x99af11672e664019bf7643badf53dd89462e108d1a0b97bcd1637f3c84944423	f94cba1e-dbf5-499b-9cf2-fe43ce8ab581
\\x9a5ea6ccd4dc13823617991b0dda4e3070a1cfd6b7d773ea8809175c1ee118b3	/upload
\\x9b0d349fc1bbcc41708a8960ac355e2c7c8acb2b28aaa65b40bfbe66637c3bfa	<div id="{{= id }}" class="{{= name }}">\n    <div class="buttons">\n        <button class="save">Save</button>\n        <button class="copy">Copy</button>\n        <button class="delete">Delete</button>\n    </div>\n    <p class='title'>widget: <span class='name'></span></p>\n    <div class="tabs"></div>\n    <div class="content"></div>\n</div>
\\x9b6277197bde3ae3d62cec10c7645f3369c648ff6ffe76d5802f2244df4b63b5	<div id="{{= id }}" class="{{= name }}">\n    <h1>commit!</h1>\n    \n    <h3>Changes</h3>\n        \n    <table border=1 class='changes'>\n        <tr><th>row</th><th>change</th><th>unstaged</th><th>staged</th></tr>\n    </table>\n\n    <!--\n    <h3>Untracked Rows</h3>\n    <p>These are changes to rows that have not yet been added to this commit.</p>\n    \n    <div class='untracked_rows'>\n        ...\n    </div>\n-->\n    \n    <p><button class='do_commit'>commit these changes</button></p>\n</div>
\\x9bbd7a068758ca9f1551e8c77e1f2166b8f8b391eabb940a0422044e1f787da1	e7087f6f-d536-4fdc-b5a4-aa61de67aa8c
\\x9c53f81bdbbf6e68e1f9cb1ade31210c3a6994ad6f0e890ca57ec25a10b1d760	bundle_config_dialog
\\x9c7b091b7e67bc40d44b61db83ebcdfd80bf2778acd1b81362bf04c5148e0402	<div id="{{= id }}" class="{{= name }}">\n    {{= bundle.get('name') }}\n</div>
\\x9dce81fe6285642a3eb178d3aab38eaf7897651f284c038b006588c7bb8776cc	.{{= name }} button.stage_all {\n    float: right;\n}
\\x9e43cc6a827b137d2a2d7c9a2b4e9266b688a1455d9da164751c1a09cf5a42b2	c2e6b45c-d4eb-4134-b246-84c542718717
\\x9e44fce700dcea51229f54afa6c48ed302c7e70c1d6d16d395aa2bb5630f2650	var w = $("#"+id);\n\nendpoint.schema('bundle').table('untracked_row').rows({\n}).then(function(untracked) {\n    widget.sync(untracked, w.find('.rows'), function(row) {\n        return widget('bundle_untracked_row_li', {\n            row: row\n        });\n    });\n});\n\nw.find('input.checkall').change(function() {\n    console.log('checkall');\n    if(this.checked) {\n        w.find('input.action').prop('checked',true);\n    } else {\n        w.find('input.action').prop('checked', false);\n    }\n\n});\n\nw.find('button.ignore').click(function() {\n    var selected = [];\n    w.find('input.action:checked').each(function() {\n        selected.push($(this).closest('.bundle_untracked_row_li').data('row_id'));\n    });\n\n    w.append(widget('ide:modal', {\n        content: widget('ide:ignore_modal', {\n            rows: selected\n        })\n    }));\n\n    /*\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema('bundle').function('ignored_row_add', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            li.remove();\n        }).catch(function(e,o) {\n            alert('error ignoring row!');\n            console.log('error ignoring row: ', row_id, e,o);\n        });\n\n    */\n});\n\n\nw.find('button.track').click(function() {\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            li.remove();\n        }).catch(function(e,o) {\n            alert('error tracking row!');\n            console.log('error ignoring row: ', row_id, e,o);\n        });\n    });\n});\n\n\n\n\nw.find('button.delete').click(function() {\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema(schema_name).table(relation_name).row(pk_column_name, pk_value)\n        .then(function(row) {\n            row.delete().then(function() {\n                li.remove();\n            }).catch(function(e,o) {\n                alert('error tracking row!');\n                console.log('error ignoring row: ', row_id, e,o);\n            });\n        })\n        .catch(function() {\n            alert('could not find row');\n        });\n    });\n});\n\n
\\x9edff668a3e7cd0e1c1b4e54c6d87a920d521869f5c764ebe75a339880b1da75	var w = $("#"+id);\n\n\n// changes\nbundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    /* first staged, then unstaged modified, then unstaged deleted */\n    order_by: [{\n        column: 'staged'\n    }, {\n        column: 'change_type'\n    }]\n}).then(function(changes) {\n    widget.sync(changes, w.find('.changes'), function(change) {\n        return widget('ide:commit_dialog_changed_row', { bundle: bundle, change: change });\n    });\n});\n\n// commit button handler\nw.find('button.do_commit').click(function() {\n    var message;\n    if (message = prompt('enter a commit message')) {\n        endpoint.schema('bundle').function('commit', [bundle.get('name'), message])\n        .then(function() {\n            w.trigger('close_tab', { tab_id: 'commit' });\n        }).catch(function(e) {\n            alert ('fail! '+e);\n        });\n    }\n});\n\n\n// untracked rows\n/*\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\n\nwidget.sync(untracked_rows, w.find('.untracked_rows'), function(schema) {\n    return widget('ide:bundle_untracked_row_by_schema', { schema: schema, bundle: bundle });\n});\n*/\n\nw.bind('reload_commit_dialog', function() {\n    w.replaceWith(widget('ide:commit_dialog', { bundle: bundle }));\n});\n\n
\\x9f25f9fcf7387de6467bd13798502e9d31d3d53f5549d259b8177535fcf3623c	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'purpose'],\n            order_by: {\n                column: 'purpose'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('ide:option', {\n                label: row.get('purpose'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\xa05888b6d78d604177de9df555a03707ebe002c2f25767b95e6ff134dc9e6f6a	<div id="{{= id }}" class="{{= name }}">\n    <input class='fileUpload' type='file'>\n</div>
\\xa0eee7444fe9193c0ffe33bfef833a47541f79f19afc80ea86ad748b296dfd4f	<div id="{{= id }}" class="{{= name }}">\n    {{= message }}\n</div>
\\xa11a75e0feeecc1a9eff682b06ef0b1461ed4ee7a4d6da4ae333bdc1041d9d51	option
\\xa14b24cb47e213c0bda7883afaba1d328251239a90e06af0f00900455e09dd91	9ba8e45a-4173-4c55-9bc2-97395897498f
\\xa150d3d3bfc5604de5b622c6de92362e7114322ae5244d8dce21c4cb63b9a7f5	f522acae-3fc3-4b9b-83a0-f4990a384210
\\xa15c04004f170a69b7b5d7b55d7c30e2b1619e0108bdd4962aff893edc9f06cd	sem_fkey_many_to_many
\\xa1aacde1972dd3759ede8574b121354edcd8b893e5cb9854c06144431867c149	var w = $("#"+id);\n\n\n// changes\nbundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    /* first staged, then unstaged modified, then unstaged deleted */\n    order_by: [{\n        column: 'staged'\n    }, {\n        column: 'change_type'\n    }]\n}).then(function(changes) {\n    widget.sync(changes, w.find('.changes'), function(change) {\n        return widget('ide:commit_dialog_changed_row', { bundle: bundle, change: change });\n    });\n});\n\n// commit button handler\nw.find('button.do_commit').click(function() {\n    var message;\n    if (message = prompt('enter a commit message')) {\n        endpoint.schema('bundle').function('commit', [bundle.get('name'), message])\n        .then(function() {\n            w.trigger('close_tab', { tab_id: 'commit' });\n        }).catch(function(e) {\n            alert ('fail! '+e);\n        });\n    }\n});\n\nw.find('button.stage_all').click(function() {\n    w.find('button.stage').click();\n});\n\n// untracked rows\n/*\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\n\nwidget.sync(untracked_rows, w.find('.untracked_rows'), function(schema) {\n    return widget('ide:bundle_untracked_row_by_schema', { schema: schema, bundle: bundle });\n});\n*/\n\nw.bind('reload_commit_dialog', function() {\n    w.replaceWith(widget('ide:commit_dialog', { bundle: bundle }));\n});\n\n
\\xa1bda71df500f29e58eca5637f46434b33e2023baa9b6d5a0c20ee022ae345db	stage_dialog_staged_row\n
\\xa1c87ae74a60fad4c660348b3c6ecd646b486ed74d676ea2f8151d9c75711115	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <title>Aquameta</title>\n        \n        <link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n            \n            div.auth {\n                float: right;\n            }\n        </style>\n    </head>\n    <body>\n        <div class='auth'></div>\n        <h1>Aquameta</h1>\n        <p>Here are some starting places:</p>\n        <ul>\n            <li><a href='/dev'>/dev</a> - Developer IDE</li>\n            <li><a href='/docs'>/docs</a> - Documentation (coming soon)</li>\n            <li><a href='/snake'>/snake</a> - Snake - a sample game</li>\n        </ul>\n            \n    </body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.2', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.ui.auth', 'auth', db);\n            \n            $('body > div.auth').append(widget('auth:auth_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\xa1dd0a17ff49aee482562d87ba301d6ba53ffdf50fbf98194c62653ca9dc9415	9e0dfe9c-16eb-48dc-afe5-c064582fe6e4
\\xa353c7639fbb6a8353a248a6dc843b09f119631603d41fa039323361f4abda68	fc2bee4e-a43c-431c-95fe-0cdc61d5c437
\\xa37e21d2cbfa7a4ed78703023ae72ecc6048c7234a4eb18bdb175506e0e45a87	commit_dialog_staged_field
\\xa4a0d0f35b7c7209c75f97dc5c4f9ddf69ceee89de31eee999211eda29042e39	\n/*\n * jwerty - Awesome handling of keyboard events\n *\n * jwerty is a JS lib which allows you to bind, fire and assert key combination\n * strings against elements and events. It normalises the poor std api into\n * something easy to use and clear.\n *\n * This code is licensed under the MIT\n * For the full license see: http://keithamus.mit-license.org/\n * For more information see: http://keithamus.github.com/jwerty\n *\n * @author Keith Cirkel ('keithamus') <jwerty@keithcirkel.co.uk>\n * @license http://keithamus.mit-license.org/\n * @copyright Copyright © 2011, Keith Cirkel\n *\n */\n(function (global, exports) {\n\n    // Try require external librairies in Node.js context\n    function tryRequire(mod) {\n        if (typeof require == 'function' && typeof module !== 'undefined' && module.exports) {\n            try {\n                return require(mod.toLowerCase());\n            } catch (err) {}\n        } else {\n            return global[mod];\n        }\n    }\n\n    // Helper methods & vars:\n    var $d = global.document,\n        $ = (tryRequire('jQuery') || tryRequire('Zepto') || tryRequire('ender') || $d),\n        $$, // Element selector function\n        $b, // Event binding function\n        $u, // Event unbinding function\n        $f, // Event firing function\n        ke = 'keydown';\n\n    function realTypeOf(v, s) {\n        return (v === null) ? s === 'null'\n        : (v === undefined) ? s === 'undefined'\n        : (v.is && v instanceof $) ? s === 'element'\n        : Object.prototype.toString.call(v).toLowerCase().indexOf(s) > 7;\n    }\n\n    if ($ === $d) {\n        $$ = function (selector, context) {\n            return selector ? $.querySelector(selector, context || $) : $;\n        };\n        $b = function (e, fn) { e.addEventListener(ke, fn, false); };\n        $u = function (e, fn) { e.removeEventListener(ke, fn, false); };\n        $f = function (e, jwertyEv) {\n            var ret = $d.createEvent('Event'),\n            i;\n\n            ret.initEvent(ke, true, true);\n\n            for (i in jwertyEv) ret[i] = jwertyEv[i];\n\n            return (e || $).dispatchEvent(ret);\n        };\n    } else {\n        $$ = function (selector, context) { return $(selector || $d, context); };\n        $b = function (e, fn) { $(e).bind(ke + '.jwerty', fn); };\n        $u = function (e, fn) { $(e).unbind(ke + '.jwerty', fn) };\n        $f = function (e, ob) { $(e || $d).trigger($.Event(ke, ob)); };\n    }\n\n    // Private\n    var _modProps = { 16: 'shiftKey', 17: 'ctrlKey', 18: 'altKey', 91: 'metaKey' };\n\n    // Generate key mappings for common keys that are not printable.\n    var _keys = {\n\n        // MOD aka toggleable keys\n        mods: {\n            // Shift key, ⇧\n            '⇧': 16,\n            shift: 16,\n            // CTRL key, on Mac: ⌃\n            '⌃': 17,\n            ctrl: 17,\n            // ALT key, on Mac: ⌥ (Alt)\n            '⌥': 18,\n            alt: 18,\n            option: 18,\n            // META, on Mac: ⌘ (CMD), on Windows (Win), on Linux (Super)\n            '⌘': 91,\n            meta: 91,\n            cmd: 91,\n            'super': 91,\n            win: 91\n        },\n\n        // Normal keys\n        keys: {\n            // Backspace key, on Mac: ⌫ (Backspace)\n            '⌫': 8,\n            backspace: 8,\n            // Tab Key, on Mac: ⇥ (Tab), on Windows ⇥⇥\n            '⇥': 9,\n            '⇆': 9,\n            tab: 9,\n            // Return key, ↩\n            '↩': 13,\n            'return': 13,\n            enter: 13,\n            '⌅': 13,\n            // Pause/Break key\n            'pause': 19,\n            'pause-break': 19,\n            // Caps Lock key, ⇪\n            '⇪': 20,\n            caps: 20,\n            'caps-lock': 20,\n            // Escape key, on Mac: ⎋, on Windows: Esc\n            '⎋': 27,\n            escape: 27,\n            esc: 27,\n            // Space key\n            space: 32,\n            // Page-Up key, or pgup, on Mac: ↖\n            '↖': 33,\n            pgup: 33,\n            'page-up': 33,\n            // Page-Down key, or pgdown, on Mac: ↘\n            '↘': 34,\n            pgdown: 34,\n            'page-down': 34,\n            // END key, on Mac: ⇟\n            '⇟': 35,\n            end: 35,\n            // HOME key, on Mac: ⇞\n            '⇞': 36,\n            home: 36,\n            // Insert key, or ins\n            ins: 45,\n            insert: 45,\n            // Delete key, on Mac: ⌫ (Delete)\n            del: 46,\n            'delete': 46,\n\n            // Left Arrow Key, or ←\n            '←': 37,\n            left: 37,\n            'arrow-left': 37,\n            // Up Arrow Key, or ↑\n            '↑': 38,\n            up: 38,\n            'arrow-up': 38,\n            // Right Arrow Key, or →\n            '→': 39,\n            right: 39,\n            'arrow-right': 39,\n            // Up Arrow Key, or ↓\n            '↓': 40,\n            down: 40,\n            'arrow-down': 40,\n\n            // odities, printing characters that come out wrong:\n            // Num-Multiply, or *\n            '*': 106,\n            star: 106,\n            asterisk: 106,\n            multiply: 106,\n            // Num-Plus or +\n            '+': 107,\n            'plus': 107,\n            // Num-Subtract, or -\n            '-': 109,\n            subtract: 109,\n            'num-.': 110,\n            'num-period': 110,\n            'num-dot': 110,\n            'num-full-stop': 110,\n            'num-delete': 110,\n            // Semicolon\n            ';': 186,\n            semicolon: 186,\n            // = or equals\n            '=': 187,\n            'equals': 187,\n            // Comma, or ,\n            ',': 188,\n            comma: 188,\n            //'-': 189, //???\n            // Period, or ., or full-stop\n            '.': 190,\n            period: 190,\n            'full-stop': 190,\n            // Slash, or /, or forward-slash\n            '/': 191,\n            slash: 191,\n            'forward-slash': 191,\n            // Tick, or `, or back-quote\n            '`': 192,\n            tick: 192,\n            'back-quote': 192,\n            // Open bracket, or [\n            '[': 219,\n            'open-bracket': 219,\n            // Back slash, or \\\n            '\\\\': 220,\n            'back-slash': 220,\n            // Close backet, or ]\n            ']': 221,\n            'close-bracket': 221,\n            // Apostraphe, or Quote, or '\n            '\\'': 222,\n            quote: 222,\n            apostraphe: 222\n        }\n\n    };\n\n    // To minimise code bloat, add all of the 0-9 and NUMPAD 0-9 keys in a loop\n    var i = 47,\n        n = 0;\n    while (++i < 106) {\n        _keys.keys[n] = i;\n        _keys.keys['num-' + n] = i + 48;\n        ++n;\n    }\n\n    // To minimise code bloat, add all of the F1-F25 keys in a loop\n    i = 111,\n    n = 1;\n    while (++i < 136) {\n        _keys.keys['f' + n] = i;\n        ++n;\n    }\n\n    // To minimise code bloat, add all of the letters of the alphabet in a loop\n    i = 64;\n    while (++i < 91) {\n        _keys.keys[String.fromCharCode(i).toLowerCase()] = i;\n    }\n\n    function JwertyCode(jwertyCode) {\n        var i,\n            c,\n            n,\n            z,\n            keyCombo,\n            optionals,\n            jwertyCodeFragment,\n            rangeMatches,\n            rangeI;\n\n        // In-case we get called with an instance of ourselves, just return that.\n        if (jwertyCode instanceof JwertyCode) return jwertyCode;\n\n        // If jwertyCode isn't an array, cast it as a string and split into array.\n        if (!realTypeOf(jwertyCode, 'array')) {\n            jwertyCode = (String(jwertyCode)).replace(/\\s/g, '').toLowerCase()\n                .match(/(?:\\+,|[^,])+/g);\n        }\n\n        // Loop through each key sequence in jwertyCode\n        for (i = 0, c = jwertyCode.length; i < c; ++i) {\n\n            // If the key combo at this part of the sequence isn't an array,\n            // cast as a string and split into an array.\n            if (!realTypeOf(jwertyCode[i], 'array')) {\n                jwertyCode[i] = String(jwertyCode[i])\n                    .match(/(?:\\+\\/|[^\\/])+/g);\n            }\n\n            // Parse the key optionals in this sequence\n            optionals = [],\n            n = jwertyCode[i].length;\n            while (n--) {\n\n                // Begin creating the object for this key combo\n                jwertyCodeFragment = jwertyCode[i][n];\n\n                keyCombo = {\n                    jwertyCombo: String(jwertyCodeFragment),\n                    shiftKey: false,\n                    ctrlKey: false,\n                    altKey: false,\n                    metaKey: false\n                };\n\n                // If jwertyCodeFragment isn't an array then cast as a string\n                // and split it into one.\n                if (!realTypeOf(jwertyCodeFragment, 'array')) {\n                    jwertyCodeFragment = String(jwertyCodeFragment).toLowerCase()\n                        .match(/(?:(?:[^\\+])+|\\+\\+|^\\+$)/g);\n                }\n\n                z = jwertyCodeFragment.length;\n                while (z--) {\n\n                    // Normalise matching errors\n                    if (jwertyCodeFragment[z] === '++') jwertyCodeFragment[z] = '+';\n\n                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo\n                    if (jwertyCodeFragment[z] in _keys.mods) {\n                        keyCombo[_modProps[_keys.mods[jwertyCodeFragment[z]]]] = true;\n                    } else if (jwertyCodeFragment[z] in _keys.keys) {\n                        keyCombo.keyCode = _keys.keys[jwertyCodeFragment[z]];\n                    } else {\n                        rangeMatches = jwertyCodeFragment[z].match(/^\\[([^-]+\\-?[^-]*)-([^-]+\\-?[^-]*)\\]$/);\n                    }\n                }\n                if (realTypeOf(keyCombo.keyCode, 'undefined')) {\n                    // If we picked up a range match earlier...\n                    if (rangeMatches && (rangeMatches[1] in _keys.keys) && (rangeMatches[2] in _keys.keys)) {\n                        rangeMatches[2] = _keys.keys[rangeMatches[2]];\n                        rangeMatches[1] = _keys.keys[rangeMatches[1]];\n\n                        // Go from match 1 and capture all key-comobs up to match 2\n                        for (rangeI = rangeMatches[1]; rangeI < rangeMatches[2]; ++rangeI) {\n                            optionals.push({\n                                altKey: keyCombo.altKey,\n                                shiftKey: keyCombo.shiftKey,\n                                metaKey: keyCombo.metaKey,\n                                ctrlKey: keyCombo.ctrlKey,\n                                keyCode: rangeI,\n                                jwertyCombo: String(jwertyCodeFragment)\n                            });\n\n                        }\n                        keyCombo.keyCode = rangeI;\n                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo\n                    } else {\n                        keyCombo.keyCode = 0;\n                    }\n                }\n                optionals.push(keyCombo);\n\n            }\n            this[i] = optionals;\n        }\n        this.length = i;\n        return this;\n    }\n\n    var jwerty = exports.jwerty = {\n        /**\n         * jwerty.event\n         *\n         * `jwerty.event` will return a function, which expects the first\n         *  argument to be a key event. When the key event matches `jwertyCode`,\n         *  `callbackFunction` is fired. `jwerty.event` is used by `jwerty.key`\n         *  to bind the function it returns. `jwerty.event` is useful for\n         *  attaching to your own event listeners. It can be used as a decorator\n         *  method to encapsulate functionality that you only want to fire after\n         *  a specific key combo. If `callbackContext` is specified then it will\n         *  be supplied as `callbackFunction`'s context - in other words, the\n         *  keyword `this` will be set to `callbackContext` inside the\n         *  `callbackFunction` function.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Function} callbackFucntion is a function (or boolean) which\n         *      is fired when jwertyCode is matched. Return false to\n         *      preventDefault()\n         *   @param {Object} callbackContext (Optional) The context to call\n         *      `callback` with (i.e this)\n         *\n         */\n        event: function (jwertyCode, callbackFunction, callbackContext /*? this */) {\n\n            // Construct a function out of callbackFunction, if it is a boolean.\n            if (realTypeOf(callbackFunction, 'boolean')) {\n                var bool = callbackFunction;\n                callbackFunction = function () { return bool; };\n            }\n\n            jwertyCode = new JwertyCode(jwertyCode);\n\n            // Initialise in-scope vars.\n            var i = 0,\n                c = jwertyCode.length - 1,\n                returnValue,\n                jwertyCodeIs;\n\n            // This is the event listener function that gets returned...\n            return function (event) {\n\n                // if jwertyCodeIs returns truthy (string)...\n                if ((jwertyCodeIs = jwerty.is(jwertyCode, event, i))) {\n                    // ... and this isn't the last key in the sequence,\n                    // incriment the key in sequence to check.\n                    if (i < c) {\n                        ++i;\n                        return;\n                    // ... and this is the last in the sequence (or the only\n                    // one in sequence), then fire the callback\n                    } else {\n                        returnValue = callbackFunction.call(\n                            callbackContext || this, event, jwertyCodeIs);\n\n                        // If the callback returned false, then we should run\n                        // preventDefault();\n                        if (returnValue === false) event.preventDefault();\n\n                        // Reset i for the next sequence to fire.\n                        i = 0;\n                        return;\n                    }\n                }\n\n                // If the event didn't hit this time, we should reset i to 0,\n                // that is, unless this combo was the first in the sequence,\n                // in which case we should reset i to 1.\n                i = jwerty.is(jwertyCode, event) ? 1 : 0;\n            };\n        },\n\n        /**\n         * jwerty.is\n         *\n         * `jwerty.is` will return a boolean value, based on if `event` matches\n         *  `jwertyCode`. `jwerty.is` is called by `jwerty.event` to check\n         *  whether or not to fire the callback. `event` can be a DOM event, or\n         *  a jQuery/Zepto/Ender manufactured event. The properties of\n         *  `jwertyCode` (speficially ctrlKey, altKey, metaKey, shiftKey and\n         *  keyCode) should match `jwertyCode`'s properties - if they do, then\n         *  `jwerty.is` will return `true`. If they don't, `jwerty.is` will\n         *  return `false`.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {KeyboardEvent} event is the KeyboardEvent to assert against\n         *   @param {Integer} i (Optional) checks the `i` key in jwertyCode\n         *      sequence\n         *\n         */\n        is: function (jwertyCode, event, i /*? 0*/) {\n            jwertyCode = new JwertyCode(jwertyCode);\n            // Default `i` to 0\n            i = i || 0;\n            // We are only interested in `i` of jwertyCode;\n            jwertyCode = jwertyCode[i];\n            // jQuery stores the *real* event in `originalEvent`, which we use\n            // because it does annoything stuff to `metaKey`\n            event = event.originalEvent || event;\n\n            // We'll look at each optional in this jwertyCode sequence...\n            var n = jwertyCode.length,\n                returnValue = false;\n\n            // Loop through each fragment of jwertyCode\n            while (n--) {\n                returnValue = jwertyCode[n].jwertyCombo;\n                // For each property in the jwertyCode object, compare to `event`\n                for (var p in jwertyCode[n]) {\n                    // ...except for jwertyCode.jwertyCombo...\n                    if (p !== 'jwertyCombo' && event[p] != jwertyCode[n][p]) returnValue = false;\n                }\n                // If this jwertyCode optional wasn't falsey, then we can return early.\n                if (returnValue !== false) return returnValue;\n            }\n            return returnValue;\n        },\n\n        /**\n         * jwerty.key\n         *\n         *  `jwerty.key` will attach an event listener and fire\n         *   `callbackFunction` when `jwertyCode` matches. The event listener is\n         *   attached to `document`, meaning it will listen for any key events\n         *   on the page (a global shortcut listener). If `callbackContext` is\n         *   specified then it will be supplied as `callbackFunction`'s context\n         *   - in other words, the keyword `this` will be set to\n         *   `callbackContext` inside the `callbackFunction` function.\n         *   returns a subscription handle `h`, by which you may undo the binding\n         *   by calling `h.unbind()`\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Function} callbackFunction is a function (or boolean) which\n         *      is fired when jwertyCode is matched. Return false to\n         *      preventDefault()\n         *   @param {Object} callbackContext (Optional) The context to call\n         *      `callback` with (i.e this)\n         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,\n         *      or an HTML*Element on which to bind the eventListener\n         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender\n         *      object, or an HTML*Element on which to scope the selector\n         *\n         */\n        key: function (jwertyCode, callbackFunction, callbackContext /*? this */, selector /*? document */, selectorContext /*? body */) {\n            // Because callbackContext is optional, we should check if the\n            // `callbackContext` is a string or element, and if it is, then the\n            // function was called without a context, and `callbackContext` is\n            // actually `selector`\n            var realSelector = realTypeOf(callbackContext, 'element') || realTypeOf(callbackContext, 'string') ? callbackContext : selector,\n            // If `callbackContext` is undefined, or if we skipped it (and\n            // therefore it is `realSelector`), set context to `global`.\n                realcallbackContext = realSelector === callbackContext ? global : callbackContext,\n            // Finally if we did skip `callbackContext`, then shift\n            // `selectorContext` to the left (take it from `selector`)\n                realSelectorContext = realSelector === callbackContext ? selector : selectorContext;\n\n            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,\n            // then just use it neat, otherwise find it in DOM using $$()\n            var element = realTypeOf(realSelector, 'element') ? realSelector : $$(realSelector, realSelectorContext);\n            var callback = jwerty.event(jwertyCode, callbackFunction, realcallbackContext);\n            $b( element, callback );\n            \n            return {unbind:function(){ $u( element, callback ) }};\n        },\n        \n        /**\n         * jwerty.fire\n         *\n         * `jwerty.fire` will construct a keyup event to fire, based on\n         *  `jwertyCode`. The event will be fired against `selector`.\n         *  `selectorContext` is used to search for `selector` within\n         *  `selectorContext`, similar to jQuery's\n         *  `$('selector', 'context')`.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,\n         *      or an HTML*Element on which to bind the eventListener\n         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender\n         *      object, or an HTML*Element on which to scope the selector\n         *\n         */\n        fire: function (jwertyCode, selector /*? document */, selectorContext /*? body */, i) {\n            jwertyCode = new JwertyCode(jwertyCode);\n            var realI = realTypeOf(selectorContext, 'number') ? selectorContext : i;\n\n            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,\n            // then just use it neat, otherwise find it in DOM using $$()\n            $f(\n                realTypeOf(selector, 'element') ? selector : $$(selector, selectorContext),\n                jwertyCode[realI || 0][0]\n            );\n        },\n\n        KEYS: _keys\n    };\n\n}(typeof global !== 'undefined' && global.window || this, (typeof module !== 'undefined' && module.exports ? module.exports : this)));\n
\\xa4e2082f71f62d6be17a4efd128d96ebee97306d60d49ae5d0f4b9841aa54c87	var w = $("#"+id);\n\nendpoint.schema('endpoint').table('template_route').rows({\n    where: {\n        name: 'template_id',\n        op: '=',\n        value: template.get('id')\n    }\n}).then(function(routes) {\n    widget.sync(routes, w.find('.routes'), function(route) {\n        return widget('ide:template_route', { route: route });\n    });\n\n});\n\n\nw.find('button.new').click(function() {\n    if (url_pattern = prompt('Enter the URL pattern of the route to add to this template')) {\n        endpoint.schema('endpoint').table('template_route').insert({\n            url_pattern: url_pattern,\n            template_id: template.get('id')\n        }).then(function(route) {\n            w.find('.routes').append(widget('ide:template_route', { route: route }));\n        });\n    }\n});
\\xa4e7f14d497a53593604ca60f1eb024ad97546ed586d68d0b5f76cc05a4120b6	var w = $("#"+id);\n\n\nfunction new_tab(tab_id, label, content) {\n    // console.log('opening new tab');\n    // create the header\n    w.find('.tab_headers').append(widget('ide:workspace_tab_header', {\n        label: label,\n        tab_id: tab_id\n    }));\n\n\n    // create the tab\n    w.find('> .tab_contents').append(widget('ide:workspace_tab', {\n        content: content,\n        tab_id: tab_id\n    }));\n\n    // focus\n    show_tab(tab_id);\n}\n\nfunction current_tab() {\n    return w.find('.workspace_tab_header.highlighted').first().data('tab_id');\n}\n\nfunction show_tab(tab_id) {\n    // console.log('show tab ', tab_id);\n    // show the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).show();\n        } else {\n            $(this).hide();\n        }\n    })\n\n    // highlight the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).addClass('highlighted');\n        } else {\n            $(this).removeClass('highlighted');\n        }\n    })\n}\n\nfunction close_tab(tab_id) {\n    /*\n    why doesn't this work?\n    w.find('.workspace_tab[data-tab_id="'+tab_id+'"]').remove();\n    w.find('.workspace_tab_header[data-tab_id="'+tab_id+'"]').remove();\n    */\n    \n    var current_tab_closed = false;\n    if (tab_id == current_tab()) {\n        current_tab_closed = true;\n    }\n    \n    // remove the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // remove the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // if the current tab is closed, replace it with another\n    if (current_tab_closed) {\n        var last_tab = w.find('.workspace_tab').last();\n        if (last_tab) {\n            show_tab(last_tab.data('tab_id'));\n        }\n    }\n}\n\nfunction tab_is_open(tab_id) {\n    // check to see if it's already open\n    var is_open = false;\n    var tabs = w.find('.workspace_tab');\n    for (var i=0;i<tabs.length;i++) {\n        var this_tab_id = $(tabs[i]).data('tab_id');\n\n        // console.log('comparing '+this_tab_id +' to ' + tab_id);\n        if (this_tab_id == tab_id) {\n            // console.log('already open');\n            return true;\n        }\n    };\n    return false;\n}\n\nw.closest('.ide').bind('close_tab', function(e,o) {\n    close_tab(o.tab_id);\n});\n\nw.closest('.ide').bind('show_tab', function(e,o) {\n    show_tab(o.tab_id);\n});\n\nconsole.log(endpoint);\n// handler for row clicked event\nw.closest('.ide').bind('bundle_row_open', function(e, o) {\n    // console.log('bundle_row_clicked', e, o);\n\n    var row_id = o.row_id;\n    var row = o.row;\n\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_val = row_id.pk_value;\n    var label = widget('semantics/text_identifier', row);\n    var tab_id = schema_name + '.' + relation_name + '.' + pk_val;\n\n    if (!tab_is_open(tab_id)) {\n        console.log(endpoint);\n        // open a new tab for this row\n        endpoint\n        .schema(schema_name)\n        .table(relation_name)\n        .row(pk_column_name, pk_val).then(function(real_row) {\n            new_tab(tab_id, label, widget('semantics/row_detail', real_row));\n        }).catch(function(e) {\n            console.log('error: ',e);\n        });\n    } else {\n        // send to front\n        show_tab(tab_id);\n    }\n\n\n});\n\n// new generic dialog handler\nw.closest('.ide').bind('open_tab', function(e,o) {\n    var tab_id = o.tab_id;\n\n    if (tab_is_open(tab_id)) {\n        show_tab(tab_id);\n    } else {\n        switch (tab_id) {\n            case 'new_row':\n                new_tab('new_row', 'New Row', widget('ide:new_row_dialog', { bundle: bundle }));\n                break;\n            case 'stage':\n                new_tab('stage', 'Stage', widget('ide:stage_dialog', { bundle: bundle }));\n                break;\n            case 'commit_log':\n                new_tab('commit_log', 'Commit History', widget('ide:commit_history_dialog', { bundle: bundle }));\n                break;\n            case 'bundle_config':\n                new_tab('bundle_config', 'Bundle Config', widget('ide:bundle_config_dialog', { bundle: bundle }));\n                break;\n            case 'push_pull':\n                new_tab('push_pull', 'Push Pull', widget('ide:bundle_push_pull', { bundle: bundle }));\n                break;\n            default:\n                alert ('internal error: no such dialog as '+tab_id);\n        }\n    }\n});\n\n// close generic dialog\nw.closest('.ide').bind('close_tab', function(e,o) {\n    var tab_id = o.tab_id;\n    close_tab(o.tab_id);\n});\n\n\n\n\n\n
\\xa4e8c05ab714b81466d49dc41aba1513959e42e40d8189aa182b34d2f72d9978	var w = $('#'+id);\n\nw.find('.content').append(content);\n\nfunction dismiss(e) {\n    e.stopPropagation();\n    w.fadeOut('fast').remove(); \n    return false;\n}\n\nw.on('click done dismiss close_modal', dismiss);\nw.find('.content').on('click', function(e) {\n    e.stopPropagation();\n});\njwerty.key('esc', dismiss);\n
\\xa53d83130450186450af86e8e988db7f32318d6e54dc725e2285484798220fdf	28f80b64-3f7e-4c74-b906-cf266b12da9e
\\xa584f5231af372cbd8fd8268799ec16041db6894d3240a595a84fa3187b81da3	<div id="{{= id }}" class="{{= name }}">\n    <div class="overlay"></div>\n    <div class="content"></div>\n</div>
\\xa5f41780ca09418705e702e25a837c3fe12c6e7032f69af50fe2703beb61ac99	d6e22ebd-0168-4efa-80c9-5f9c097734d2
\\xa882b1d99be9c3a491812e3e07c8e8d83750c823ce722f3650ead5bbc0e4925f	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});\n\nw.find('.edit').on('click', function(e) {\n    e.stopPropagation();\n    w.append(widget('ide:modal', {\n        content: widget('semantics/row_detail', row)\n    }));\n});\n\nw.on('form_field_save', function() {\n    e.stopPropagation();\n    w.replaceWith('semantics/list_item', row)\n});\n
\\xa8a7f9ad925b98435916317dd4f118e3448e61e70e6a1192cfb2e8eb310736ed	var w = $("#"+id);\n\n\n// changes\nbundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    /* first staged, then unstaged modified, then unstaged deleted */\n    order_by: [{\n        column: 'staged'\n    }, {\n        column: 'change_type'\n    }]\n}).then(function(changes) {\n    widget.sync(changes, w.find('.changes'), function(change) {\n        return widget('ide:stage_dialog_changed_row', { bundle: bundle, change: change });\n    });\n});\n\n// commit button handler\nw.find('button.do_commit').click(function() {\n    var message;\n    if (message = prompt('enter a commit message')) {\n        endpoint.schema('bundle').function('commit', [bundle.get('name'), message])\n        .then(function() {\n            w.trigger('close_tab', { tab_id: 'stage' });\n        }).catch(function(e) {\n            alert ('fail! '+e);\n        });\n    }\n});\n\nw.find('button.stage_all').click(function() {\n    w.find('button.stage').click();\n});\n\n// untracked rows\n/*\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\n\nwidget.sync(untracked_rows, w.find('.untracked_rows'), function(schema) {\n    return widget('ide:bundle_untracked_row_by_schema', { schema: schema, bundle: bundle });\n});\n*/\n\nw.bind('reload_stage_dialog', function() {\n    w.replaceWith(widget('ide:stage_dialog', { bundle: bundle }));\n});\n\n
\\xa8ae5aa90a94d908fc7ab35b18702a301e9378f83386f49d4b1dc63c0502a34f	<div id="{{= id }}" class="{{= name }}">\n</div>
\\xa942c9d38f0caf9f3780d9e437d3e5af5aed186b8854788a972a914f7d19e2fc	.{{= name }} {\n}\n\n.{{= name }}:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n\n.{{= name }} ul {\n    display: none;\n}\n\n.{{= name }} ul.open {\n    display: block;\n}\n
\\xa95fa9d7ca9a4b526db69b856e1b4dc987ff5662545f7c4ba6ed904f00b7f317	.{{= name }} {\n    border: 1px solid white;\n    height: 100%;\n    overflow: auto;\n}
\\xaa083fc4c7b929bc5cbb5cbd36d4b9626b1e1344e0b3ef749d24e099f958e552	.{{= name }} div.unstaged {\n    display: none;\n    background-color: pink;\n}\n\n.{{= name }} div.staged {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} div.unstaged_fields {\n    display: none;\n    background-color: pink;\n}\n.{{= name }} div.staged_fields {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.modified_link {\n    font-size: 72%;\n}\n.{{= name }} span.modified_link:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n\n.{{= name }} .text_id span:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n\n.{{= name }} button.untrack {\n    display: none;\n}
\\xaa29e89828d1fb82ed3daf1877c82eac7587275b371196043cd5a410f0280b0b	29b4e0ef-4a15-43a7-930c-21e5f1653e76
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xab183855e463e3297e1df5e465d9c2070e3cc10dfa9159145d09be30c0c806c4	<section id="{{= id }}" class="{{= name }}">\n    <header>\n        <div class='auth'></div>\n        <div class='logo'><a href="/dev">aquameta</a></div>\n        <div class='title'></div>\n    </header>\n\n    <div class="content">\n        <div class='row_list_section'/>\n        <div class='workspace_section'/>\n    </div>\n    \n    <footer>\n        Aquameta\n    </footer>\n</section>
\\xae6c6707c943bfd4d544e99ed6f252d678782341b95132e286d3ff9aa6eea097	ce5a0276-859b-4095-a681-3465453cf648
\\xaebaf1439501b42864cfe817c374e95d5dcc64599d793c19867ad2f15c7d2030	<div id="{{= id }}" class="{{= name }}">\n    <nav><!--\n        {{ Object.keys(tabs).forEach(function(tab_name) { }}\n\t\t--><a {{ if(typeof base_url != 'undefined') { }}\n      \t\t\thref='{{= base_url + "/" + tab_name }}' }}\n    \t  {{ } }} data-tab="{{= tab_name }}">{{= tab_name }}</a><!--\n        {{ }); }}\n    --></nav>\n    <div class="content"></div>\n</div>
\\xaee20f8e464a1cbbd0dded06988a071a7fc5fa37b8468d8e6dd21bf404ae845e	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td class='change_type'>\n        <span title='This row has been modified' class='icon modified'>&Delta;<span class='modified_link'>(diff)</span></span>\n        <span title='This row has been deleted' class='icon deleted'>-</span>\n        <span title='This row has been added' class='icon added'>+</span>\n        <span title='This row has been tracked' class='icon tracked'>&#128065;</span>\n    </td>\n    <td>\n        <div class='unstaged'>\n            <button class='stage'>stage →</button>\n        </div>\n        <div class='unstaged_fields'>\n        </div>\n    </td>    \n    <td>\n        <div class='staged'>\n            <button class='unstage'>← unstage</button>\n        </div>\n        <div class='staged_fields'>\n        </div>\n    </td>\n    <td>{{= change.get('row_exists') }}</td>\n</tr>
\\xaeeb0a04a06d71471eeb56050e6de18516cb6e536d5b27b5448566b578dd6996	var w = $("#"+id);\n\nw.css('padding-left', depth+'em');\n\nfunction get_ids() {\n    var ids = '';\n    if (properties.ids.length > 0)\n        ids = '#'+properties.ids.join(',#');\n    return ids;\n}\n\nw.bind('mouseover', function(e) {\n    $(get_ids()).addClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\nw.bind('mouseout', function(e) {\n    $(get_ids()).removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n// recurse for each child\nfor (var child_name in properties.children) {\n    var child = properties.children[child_name];\n\n    w.after(widget('debugger3_widgets_tree', { \n        widget_name: child_name,\n        properties: child,\n        depth: depth+1\n    }));\n}\n\nw.click(function(e) {\n    e.stopPropagation();\n    console.log(properties);\n    endpoint.schema('widget').table('widget').row('id', properties.widget_row_id).then(function(widget_row) {\n        $('body').append(\n            widget('modal', { \n                content: widget('row_detail_widget', { row: widget_row })\n            })\n        );\n    });\n});\n\n\n
\\xaf30c3b388d83f333b6d8fa7139e563ac246c3d683cc5e085eeb7167ed9fe842	.{{= name }} div.unstaged {\n    display: none;\n    background-color: pink;\n}\n\n.{{= name }} div.staged {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} div.unstaged_fields {\n    display: none;\n    background-color: pink;\n}\n.{{= name }} div.staged_fields {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.modified_link {\n    font-size: 72%;\n}\n.{{= name }} span.modified_link:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n
\\xafaf792781fe012ca176eaef28bea67e00024afefb87ea89f7112cdc1985ded9	var w = $("#"+id);\n\nfunction toggle_show() {\n    if (w.find('.debugger_container').is(':visible')) {\n        w.find('.debugger_container').hide();\n        w.find('input:checkbox').prop('checked', false);\n        ///w.find('.debugger3').data('disable')();\n    }\n    else {\n        w.find('.debugger_container').show();\n        w.find('.debugger_container').html(widget('debugger3'));\n        w.find('input:checkbox').prop('checked', true);\n    }\n}\n\njwerty.key('ctrl+alt+x', toggle_show);\nw.find('input').change(toggle_show)\n\nif ( typeof show != 'undefined' && show == true) {\n    toggle_show();\n}
\\xb085d1ef8898d114223f8c862d1a8cc4b37018687dbcca256a2102abc1c0a941	var w = $("#"+id);\n/*\nsetTimeout(function() {\n\tw.trigger('done');\n}, 4000);\n*/\n\nwidget.sync(endpoint.schema('endpoint').table('mimetype').rows(), w.find('.mimetype'), function(mime) {\n    return widget('ide:option', {\n        label: mime.get('mimetype'),\n        value: mime.get('id')\n    });\n});\n\nw.find('.save').on('click', function() {\n    if (w.find('.path').val() == '' || w.find('.mimetype').val() == null) {\n        alert('Path and mimetype needed');\n        return;\n    }\n    endpoint.schema('endpoint').table('resource').insert({\n        path: w.find('.path').val(),\n        mimetype_id: w.find('.mimetype').val(),\n        content: '<!doctype html><html><head></head><body></body></html>'\n    })\n    .then(function(new_row) {\n        w.trigger('insert', { row: new_row });\n        w.trigger('status', ['Resource created', 'success']);\n        w.trigger('done');\n        w.remove();\n    });\n});\n\nw.find('.exit').on('click', function() {\n    w.trigger('done');\n});\n
\\xb275126432f5699d6f82f0b6108cea4add07ed46511c0a314736d5bd8876baec	<div id="{{= id }}" class="{{= name }}">\n    <div class='header'>\n        <button class='select_bundles'>Change bundles</button>\n        <span class='bundle_manager_container'></span>\n        {{= widget('core:auth') }}\n    </div>\n    <div class='content bundle_list'></div>\n    <div class='content bundle_workspace'></div>\n    <div class='status_container'></div>\n    {{= widget('core:debugger') }}\n</div>
\\xb2a1f3f59177e418b542dcbbfa86e32b4be1458b8393a343a2371b8a19863692	.{{= name }} {\n    cursor: pointer;\n}\n\n.{{= name }} > .open:hover {\n    text-decoration: underline;\n}
\\xb331b53af8ce7e4d9605f585be605d490d41170532af618683fd81d29e80d105	4c9473d4-dba2-4f08-939c-6fe1654fdb6d
\\xb3653e538a52c0ea0c0bbc014000092cb769fd92d1095517f01495c1d5c54f46	var w = $("#"+id);\n\n\nvar show_bundles = function() {\n\n    var retrieved = false;\n\n    return function() {\n        \n        w.removeClass('bundle_edit');\n\n        if (!retrieved) {\n            retrieved = true;\n            endpoint.schema('bundle').table('bundle').rows({ order_by: {\n                column: 'name',\n                direction: 'asc'\n            }}).then(function(bundles) {\n                w.find('.bundle_list').append(widget('core:list_view_gateway', {\n                    datum: bundles\n                }));\n            });\n        }\n    };\n}();\n\n\n\n/* URL */\n// When continue button in list_view_gateway is pressed,\n//   get the bundles and place in url\nw.on('list_view_select', function(e, bundles) {\n    var bundle_names = bundles.map(function(e) {\n        return e.get('name');\n    }).sort().join(',');\n    window.location.href = '#/' + encodeURIComponent(bundle_names);\n});\n\nvar current_state = null;\n    \nfunction select_state() {\n    \n    var slugs = window.location.hash.split('/').slice(1);\n    var new_state = null;\n    if (slugs.length) {\n        new_state = decodeURIComponent(slugs[0]);\n    }\n\n    if (new_state == null) {\n        w.data('bundles', null);\n        return show_bundles();\n    }\n    \n    w.addClass('bundle_edit');\n    if (new_state != current_state) {\n        \n        var bundles = new_state.split(',');\n        w.data('bundles', bundles);\n        \n        w.find('> .bundle_workspace').empty().html(\n            widget('dev_workspace', { base_url: '#/' + slugs[0], url_parts: slugs.slice(1) })\n        );\n        w.find('.bundle_manager_container').empty().append(\n            widget('bundle', { bundles: bundles })\n        );\n        current_state = new_state;\n    }\n\n    $('html, body').animate({\n        scrollTop: 0\n    }, 'fast');\n    \n    // Do nothing if states are the same\n    // Let the widget handle back/forward within itself\n    \n}\n$(window).on('popstate', select_state);\nselect_state();\n\n\nw.find('.select_bundles').on('click', show_bundles);\n\n\n\n/* STATUS */\nw.on('status', add_status);\n\nfunction add_status(e, message, type) {\n    e.stopPropagation();\n    w.find('.status_container').append(widget('status', { message: message, type, type }));\n}\n\n
\\xb3ca587645d5e53ea3a30ba74e31c06e333c339b5fbb1f197f6cc3a8886ad43e	var w = $("#"+id);\n\nw.change(function() {\n    if(!!to_js) {\n        field.value = to_js($(this).val());\n    }\n    else {\n        field.value = $(this).val();\n    }\n    \n    w.trigger("saved");\n});\n\nwidget.sync(\n    rows,\n    w,\n    function(row) {\n        return widget('editable_field_fkey_select_option', {\n            row: row,\n            key_maker: key_maker,\n            current_value: field.value,\n            labeler: labeler\n        });\n    }\n);
\\xb3f09ec5fe711f120fc65581e54039199d4e21c833290f0c3820bcc011526309	.{{= name }} .head_commit {\n    display: none;\n    color: yellow;\n    font-size: 200%;\n}\n\n.{{= name }} td.date {\n    white-space:nowrap;  \n}
\\xb41e5e4919fea7a435803a999ba668ba87fbf46d2a35ab7b12fd93b4e27ab6ab	<span id="{{= id }}" class="{{= name }} highlighted">\n    <nobr>\n        <span class="label">{{= label }}</span>\n    \t<span class="close">&#10006;</span\n    ></nobr\n></span>
\\xb4ca8ca2d8dab0da00957988cbebbd2fa515474a1559816f27e75e7502d957db	<div id="{{= id }}" class="{{= name }}">\n    <p>path: <span class='path'></span></p>\n    <p>args: <span class='args'></span></p>\n    <button class='delete'>delete</button>\n    <button class='save'>save</button>\n</div>
\\xb4d20bd3536aa18119ca6128cc2bdab673fe6df1558408f122d2b24c7632c065	var w = $("#"+id);\n\nfor (var i=0;i<stage_field_changes.length;i++) {\n    w.append(widget('stage_field_changed_diff', {\n        staged: true,\n        change: stage_field_changes[i],\n        old_val: stage_field_changes_old_vals[i],\n        new_val: stage_field_changes_new_vals[i]\n    }));\n}\nfor (var i=0;i<offstage_field_changes.length;i++) {\n    w.append(widget('stage_field_changed_diff', {\n        staged: false,\n        change: offstage_field_changes[i],\n        old_val: offstage_field_changes_old_vals[i],\n        new_val: offstage_field_changes_new_vals[i]\n    }));\n}
\\xb5005d87f01b369a80f9895804002ec54e6a1bdf5a55e0d15d682c5ff608dc98	bundle_selector
\\xb5d285806f38080086517955b7fd1b5e0ff1abf8648fb77cf7b07d33360091a3	461cd150-e88f-4215-8a32-03476084baf4
\\xb63f7d08db443cbe9aed0cad224b1ec9a3ade107cae630dbc064fc90ef71aad7	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.unstage').click(function() {\n    endpoint.schema('bundle').function('unstage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function() {\n        w.trigger('reload_commit_dialog');\n    })\n    .catch(function() {\n        alert('unstage failed');\n        console.error('unstage failed');\n    });\n    \n});
\\xb7243b35a0d490cf15b00b04c86f244b84b35780fb6ffefa4b6b0cd69de32358	stage_dialog_changed_row\n
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb776afbe511a51d0685821119dcbeba4fdba81e61e9187993a4a37ba821e0a6e	commit_history_dialog
\\xb816e141776579d435ae6eb97a2f4bfc19e4b85c4fb152f8d194a8d56c1fdbf7	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\nfunction load_options() {\n    var content = "<option value='none' selected>[ None ]</option>";\n    \n    if (typeof new_enabled != 'undefined' && new_enabled == true) {\n        content += "<option class='new' value='new'>[ Create New ]</option>";\n    }\n    \n    w.find('select').empty().html(content);\n    \n    var to_rows = order_by_function(to_relation.rows());\n    widget.sync(to_rows, w.find('select'), function(to_row) {\n        return widget('option', {\n            label: label_function(to_row),\n            value: to_row.get(to_column),\n            selected: from_row.get(from_column) == to_row.get(to_column)\n        });\n    });\n}\nload_options();\n\n\n// find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    schema_name: to_relation.schema.name,\n    name: to_relation.name\n}).result(function(to_relation_obj) {\n\n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n\n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n\n\n    w.find('select').change(function() {\n\n        var val = w.find('select').val();\n\n        if(val == 'new') {\n            \n            w.append(\n                widget('modal_overlay', {\n                    content: widget(new_row_widget, { \n                        relation: to_relation_obj,\n                        context_data: context_data\n                    })\n                })\n            );\n            \n        }\n        else if (val == 'none') {\n\n            \n            from_row.set(from_column, null);\n\n            from_row.update()\n            .done(function() {\n\n                console.log('Fkey updated');\n                w.trigger('fkey_updated');\n\n            });\n            \n        }\n        else {\n            \n            from_row.set(from_column, val);\n\n            from_row.update()\n            .done(function() {\n\n                console.log('Fkey updated');\n                w.trigger('fkey_updated');\n\n            });\n        }\n    });\n\n});\n\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n});\n\nw.on('new_row', function(e, payload) {\n    \n    from_row.set(from_column, payload.new_row.get(to_column));\n    from_row.update()\n    .done(function() {\n        \n        console.log('Fkey updated');\n        w.trigger('fkey_updated');\n        load_options();\n        \n    });\n});
\\xb8284e732a2e20b74a822edf841205c5504ae87fa6d71ac10ceec9f4585c066e	var w = $("#"+id);\n\n\n/* SETUP */\nvar rel_name;\nvar relation = datum;\nif (!(datum instanceof AQ.Rowset)) {\n    datum = datum.rows()\n    .then(function(rows) {\n        rel_name = rows.relation.schema.name + '.' + rows.relation.name;\n        w.find('.title').text(rel_name);\n    });\n}\nelse {\n    rel_name = datum.relation.schema.name + '.' + datum.relation.name;\n    relation = datum.relation;\n    w.find('.title').text(rel_name);\n}\n\nwidget.sync(datum, w.find('> .list > ul'), function(row) {\n    return widget('semantics/list_item', row);\n});\n\n\n\n/* TRIGGERS */\nw.on('list_item_click', function(e, row, list_item) {\n    list_item.toggleClass('selected');\n    w.find('.header .continue').toggle(!!w.find('.header ~ * > .selected').length);\n});\n\nw.find('.divider').on('click', function() {\n    w.find('.list').toggleClass('collapsed');\n});\n\nw.find('.toggle_options').on('click', function() {\n    w.find('.arrow').toggleClass('up');\n    if (w.find('.arrow').hasClass('up')) {\n        w.find('.search').focus();\n    }\n});\n\nw.find('.new').on('click', function() {\n    w.append(\n        widget('ide:modal', {\n            content: widget('semantics/new_row', relation)\n        })\n    );\n});\n\nw.find('.continue').on('click', function() {\n    var selected_items = w.find('.header ~ * > .selected').map(function() {\n        return $(this).data('row');\n    }).toArray();\n    w.trigger('list_view_select', [selected_items]);\n});\n\n\n\n/* SEARCH */\nfunction search(e) {\n    var list_items = w.find('li');\n    var val = $(this).val().trim();\n    if (val != '') {\n        \n        var matching_elements = $.grep(\n            list_items, \n            function(e, i) {\n                var re = new RegExp(val, 'i');\n\n                if (re.test($(e).html())) {\n                    return true;\n                }\n                return false;\n            });\n        \n        list_items.hide();\n        $(matching_elements).show();\n    }\n    else {\n        list_items.show();\n    }\n}\n/*\nvar debounced_search = debounce(search, 200, false);\nw.find('.search').on('keyup', debounced_search);\n*/\nw.find('.search').on('keyup', search);\n
\\xb99d408fd14d17afc9ae342ad15638aa189c895e065511ee080000bff4147615	<div id="{{= id }}" class="{{= name }}">\n    <div class='header'>\n        <button class='select_bundles'>Change bundles</button>\n        <span class='bundle_manager_container'></span>\n        {{= widget('ide:auth') }}\n    </div>\n    <div class='content bundle_list'></div>\n    <div class='content bundle_workspace'></div>\n    <div class='status_container'></div>\n    {{= widget('ide:debugger') }}\n</div>
\\xba40494e8bfd3e48b307867797b6fd1327d23faf8c219483146856e4f970e855	<div id="{{= id }}" class="{{= name }}">\n    <nav>\n        {{ Object.keys(tabs).forEach(function(tab_name) { }}<a data-tab="{{= tab_name }}">{{= tab_name }}</a>{{ }); }}\n    </nav>\n    \n    <div class="content">\n    </div>\n</div>
\\xba66371919b9ccf49b39a4f393bf006664ee6d7c00d1c4dcabbe52624b230724	62282f67-1366-4313-9585-ea52d8b8fea8
\\xbb0e72c61b393df8915d128c09ab8d8a89ed92497499eb20bb8d80a6180c2746	<div id="{{= id }}" class="{{= name }}">\n    <h2>Commit History</h2>\n    \n    <table class="commits" border=1>\n        <tr>\n            <th></th>\n            <th>author</th>\n            <th>commit time</th>\n            <th>message</th>\n            <th></th>\n        </tr>\n    </table>\n</div>
\\xbb9128109be0601baf9714865819998cd6f86f79af86c8197ff5bec9189c0480	var w = $("#"+id);\n\n\n\n// widget\n\nw.find('#widget').click(function() {\n    var name = prompt('New widget name');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('widget').insert({ name: name })\n    .then(function(widget) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'widget',\n            'id',\n            widget.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: widget, row_id: widget.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n\n// resource\n\nw.find('#resource').click(function() {\n    var path = prompt('Enter the path for this resource');\n    if (!path) { return; }\n\n    endpoint.schema('endpoint').table('resource').insert({ path: path, content: '', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(resource) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'resource',\n            'id',\n            resource.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: resource, row_id: resource.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n// template\n\nw.find('#template').click(function() {\n    endpoint.schema('endpoint').table('template').insert({ content: '<html></html>', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(template) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'template',\n            'id',\n            template.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: template, row_id: template.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n// dependency_js\n\nw.find('#dependency_js').click(function() {\n    var name = prompt('Enter the name for this dependency');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('dependency_js').insert({\n        name: name,\n        content: '// add your js library here',\n        version: ''\n    }).then(function(dep) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'dependency_js',\n            'id',\n            dep.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: dep, row_id: dep.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// table\n\nw.find('#table').click(function() {\n    var name = prompt('New table name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('table').insert({\n        schema_name: schema,\n        name: name\n    }).then(function(table) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'table',\n            'id',\n            table.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: table, row_id: table.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// view\n\nw.find('#view').click(function() {\n    var name = prompt('New view name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('view').insert({\n        schema_name: schema,\n        name: name,\n        query: 'select 1'\n    }).then(function(view) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'view',\n            'id',\n            view.id\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: view, row_id: view.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n// function\nw.find('#function').click(function() {\n    var name = prompt('New function name');\n    if (!name) { return; }\n\n    var schema = prompt('What schema should it go in?');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('function').insert({\n        name: name,\n        schema_name: schema,\n        parameters: ['integer'],\n        return_type: 'void',\n        definition: '',\n        language: 'sql'\n    })\n    .then(function(f) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'function',\n            'id',\n            f.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: f, row_id: f.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n
\\xbc807eae5388d6e243d8e4a9623373052515bbd85e44515a63865d61bd9e19c3	<div id="{{= id }}" class="{{= name }}">\n    <span class='field_name'></span><button class='stage'>stage</button>\n</div>
\\xbc817d81409eb52fc7103d853f61f5f8631899afc9d8d21ab820387dc43706d0	var w = $("#"+id);\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'schema': 9881,\n    'data': 9883,\n    'semantics': 7784\n};\n\n\nvar widget_fn = {\n    'schema': function() {\n        \n        // TODO: endpoint.suffix_clause should support complex types in where clause\n        \n        return widget('semantics/grid_view', endpoint.schema('meta').table('column').rows({\n            where: [{\n                name: 'relation_name',\n                op: '=',\n                value: datum.get('name')\n            }, {\n                name: 'schema_name',\n                op: '=',\n                value: datum.get('schema_name')\n            }],\n            order_by: {\n                column: 'name'\n            },\n            exclude: ['id', 'relation_id', 'schema_name', 'relation_name']\n        }), {\n            context: {\n                relation_id: datum.get('id')\n            }\n        });\n    },\n    'data': function() {\n        return widget('semantics/grid_view', endpoint.schema(datum.get('schema_name')).table(datum.get('name')).rows({\n//            limit: 10\n        }));\n    },\n    'semantics': function() {\n\n        return widget('semantics/grid_view', endpoint.schema('semantics').table('relation').rows({\n            where: {\n                name: 'relation_id',\n                op: '=',\n                value: datum.get('id')\n            }\n        }), {\n            context: {\n                relation_id: datum.get('id')\n            }\n        });\n    }\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\nw.find('.section').on('click', function() {\n    w.find('.section').removeClass('selected');\n    $(this).addClass('selected');\n    w.find('.content').empty().append(\n        widget_fn[$(this).attr('data-section')]()\n    );\n});\n\nw.find('.content').append(\n    widget_fn[w.find('.section.selected').attr('data-section')]()\n);\n
\\xbcd41809048b772413a9b928d029a51f4e5adacd06c5b9bb133e19ad221983d6	var w = $("#"+id);\n\nw.find('.path').append(widget('semantics/form_field', template.field('url_pattern')));\nw.find('.args').append(widget('semantics/form_field', template.field('args')));\nw.find('button.delete').click(function() {\n    template.delete().then(function() {\n        w.remove();\n    });\n});\nw.find('button.save').click(function() {\n    console.log('args is ', template.get('args'));\n    console.log('path is ', template.get('path'));\n    \n    template.update()\n    .then(function() {\n        alert ('saved');\n    }).catch(function() {\n        alert ('failed.');\n    });\n});\n
\\xbd37d14f4da6e36e857986ad8b2e595a8fb14838422fa2ec4d2e7edef4c3a3c1	6159ecb9-3821-4a57-8463-fab618da324b
\\xbd6e0c26f04cc07572679f9e710aee5483abe433d527a4d52eb4a0cf96e02c2f	<div id="{{= id }}" class="{{= name }}">\n    <div class="toggle">\n        <label><input type="checkbox" />debugger</label>\n    </div>\n    \n    <div class="debugger_container"></div>\n</div>
\\xbd7766b4839aa9d723a252cf46de63024768e7b53b4769410bf9a3cb6571a71a	<div id="{{= id }}" class="{{= name }}">\n    <h3>ignored by this bundle</h3>\n    coming soon....\n</div>
\\xbde547ddef2c736ae127e5a4790d550762c58aa78e0b12e527aeb298d8cf3319	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('semantics_manager') }}\n    <!--<p>Testing beehive.practice row from semantics.relation</p>-->\n    <p>Testing sem_fkey_one_to_many with<br>mickey.post row 'words mickey says' referenced by fkeys in mickey.blah</p>\n</div>
\\xbdf49c3c3882102fc017ffb661108c63a836d065888a4093994398cc55c2ea2f	auth
\\xbe06aaa88f4d184b99ca5a36048993ab846c4bc29754124680fc639dbb5abc12	05642077-3e03-40e9-b1e0-c679b283f6a4
\\xbec33bb3e14e86e4004ec3a6b6582f9c02f9c978709374ef41ed4c4b06c53210	<div id="{{= id }}" class="{{= name }}">\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <p class='title'>\n            <span class='path'></span>\n            <a class='path_link' target='_blank'><button>Go to <span class='path_button'>page</span></button></a>\n        </p>\n        <div class='section_content'></div>\n    </div>\n</div>
\\xbf1bbca0c6b5a6f46cf4395724948f7709f8c7b2c9d2a522afb0bb4ccb1dd4e8	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.unstage').click(function() {\n    endpoint.schema('bundle').function('unstage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function() {\n        w.trigger('reload_stage_dialog');\n    })\n    .catch(function() {\n        alert('unstage failed');\n        console.error('unstage failed');\n    });\n    \n});\n
\\xc016856bcd5daedfbbab2c1834a872fe83ecf35548ea1316abc2d31624e96bac	<div id="{{= id }}" class="{{= name }}">\n    <h1>Stage</h1>\n    \n    <table border=1 class='changes'>\n        <tr><th>row</th><th>change</th><th>unstaged</th><th>staged</th></tr>\n    </table>\n\n    <button class='stage_all'>stage all</button>\n\n    <p><button class='do_commit'>commit staged changes</button></p>\n</div>
\\xc05126dc22b15e0cbe45913602453456ae98faefdf6726a7d4f47a64a6d218ab	widget_routes
\\xc0996be32d4eee2e31be61e6c587f9f87c07f69bff4fd64bce7e7b276c9b7ea1	17ad7fc1-e56f-4fd0-9c0a-342174a44e79
\\xc139ed3026ed995bade4532ff22047650962ca141d31bc59525137c458f78a3d	form_field_css
\\xc15d923491e05bcdf2034841e88efbdbb3cb1e555c489bf56d896fc9448e0626	bundle_untracked_row_by_schema
\\xc16941f5fb76d6d09423154bb0bb08b942130103cc07805ba7e9eacd022d8a1a	var w = $("#"+id);\n\nvar bundles = endpoint.schema('bundle').table('bundle').rows({\n    order_by: {\n        column: 'name'\n    }\n})\nwidget.sync(bundles, w.find('.bundles'), function(bundle) {\n    return widget('bundle_selection', { bundle: bundle });\n});\n\nw.find('.bundles .select').on('click', function() {\n    w.trigger('bundle_selected', { bundle_name: w.find(':checked').val() });\n});\n\n\nw.find('.bundles .new').on('click', function() {\n    var name;\n    if (name = prompt('Enter bundle name')) {\n        endpoint.schema('bundle').table('bundle').insert({\n            name: name\n        }).then(function() {\n            w.replaceWith(widget('ide:bundle_selector'));\n        }).catch(function(e,o) {\n            console.log('error creating bundle: ', e, o);\n        });\n    }\n});\n\n\n\n\nw.find('.tabs .untracked').click(function() {\n    var untracked = endpoint.schema('bundle').table('untracked_row').rows();\n    w.find('.bundles').html(widget('ide:bundle_untracked_browser', { untracked: untracked }));\n\n    \n});
\\xc24c85dfdb64d93f1b690fd9e8da313b55e71c0db138cf7d90c77832f74d8d8c	var w = $("#"+id);\n\nw.find('.name').append(widget('semantics/form_field', row.field('name')));\nw.find('.routes').html(widget('ide:template_routes', { template: row }));\nw.find('.content').append(widget('semantics/form_field', row.field('content')));\nw.find('.content_save').click(function() {\n    row.update().then(function() {\n        alert ('saved.');\n    });\n});\n\nw.find('button.delete_template').click(function() {\n    if (confirm('Delete this template?')) {\n        row.delete().then(function() {\n            alert('success');\n            w.remove();\n        }).catch(function(e,o ) {\n            alert('delete failed.');\n            console.log('delete template failed: ',e,o);\n        });\n    }\n});
\\xc3b51901ccb5ba013c9923c4ed7aa7d12fa3c88ba56f8c1454bac18b7227b33d	b2ec28ca-3747-4afb-9096-be88eb2a67f0
\\xc428538c46410f70de5dedb7b337bbbeba284341f19eb706da0f3076155cab58	var w = $('#'+id);\n\nconsole.log('field.value = '+field.value+', type=' + typeof field.value);\n\nif (typeof field.value == 'object')\n    field.value = JSON.stringify(field.value);\n\nvar editor = CodeMirror(w.get(0), {\n    value: field.value,\n    mode:  language,\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\n\nw.data('codemirror', editor);\n\nfunction change_handler(doc) {\n    field.set(doc.getValue());\n    w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor.on('change', change_handler);\n\n/*\nw.data('disable_code_change_evt', function() { editor.off('change',change_handler); });\nw.data('enable_code_change_evt', function() { editor.on('change',change_handler); });\nw.trigger('code_changed', { codemirror: editor, field: field });\n*/
\\xc44e584e33460b6ceaa02ad99a8faf41bf872c827c992327d376938985df0f7c	<div id="{{= id }}" class="{{= name }}">\n    <h2>Bundle Config</h2>\n    \n    <h3>Rename</h3>\n    \n    <p>Change the name of this bundle.</p>\n    \n    <button class='rename'>Rename</button>\n    \n        \n        \n    \n    <h3 style='color: red'>DESTRUCTION</h3>\n    \n    <p>Delete this bundle and remove it from the database permanently.</p>\n    \n    <button class='delete_bundle_oh_no'>DELETE</button>\n</div>
\\xc5803a6e4daa6af400e8af0ae417ff6d7c55a86d11ba4a0cf6d443c15ce6fac5	modal
\\xc5a2087477e54fa9d92356dd50105897b9d345f25b2892bcf9a717c59fbe17dd	var w = $("#"+id);\nvar tab_links = w.find('> nav > a');\nvar content = w.find('.content');\n\n\n// tab colors\ntab_links.each(function() {\n    var tab_name = $(this).attr('data-tab');\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n\t    $(this).css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\n\ntab_links.click(function() {\n    tab_links.removeClass('selected');\n    var tab_name = $(this).attr('data-tab');\n    w.data('selected_tab', $(this));\n\n    content.html(tabs[$(this).addClass('selected').attr('data-tab')]());\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n        w.css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\ntab_links.filter(':first').click();\n\n\n\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n    content.html(tabs[w.data('selected_tab').attr('data-tab')]());\n});
\\xc5a72a863c29b02761b9b458f01307d923386f66f88292c6cc4313d7f6ce9518	<div id="{{= id }}" class="{{= name }}">\n    <h3>ignore rows</h3>\n</div>
\\xc5ebc82e3ed1571e199e15d2dcaabd0f9e8122b07b7469a74877bc79a2c0ccd9	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});\n\nw.find('.edit').on('click', function(e) {\n    e.stopPropagation();\n    w.append(widget('core:modal', {\n        content: widget('semantics/row_detail', row)\n    }));\n});\n\nw.on('form_field_save', function() {\n    e.stopPropagation();\n    w.replaceWith('semantics/list_item', row)\n});\n
\\xc603706564ce13158c3b92ac4eac39fe8b5480c9f4e88c987c80544e1ee8124d	list_item_with_version
\\xc65f304c9fe2c8da29c95148ea7959a3f2ca166ce4065a69412f897bda029b30	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\nw.append(content);
\\xc6929c0578e6e8a568f7f465eb7306c115271572933748121879ffea61b09451	bundle_selection
\\xc6a496e57803970d09090e304968ed5358522f1f17a3b00480cb30e64cec3ff9	bundle_remote
\\xc711896c6f77c7be0f5de215e9d0c61dcd55c1b0654dfc458821a4ef9d31e0a3	modal_overlay
\\xc742009fce9037bc0a70a6f703cd4a599de3a72505404a082d157c044055079e	<li id="{{= id }}" class="{{= name }}">\n    {{= relation.get('relation_name') }}\n    <ul></ul>\n</li>
\\xc7dae8d072bd424528ce065b14bc772c478b4b97e8df4871605e6aaf94dbed9c	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar where_obj = {};\nwhere_obj[to_column] = from_row.get(from_column);\n\nto_relation.row().where(where_obj).result(function(row) {\n    \n    /*\n    console.log(row);\n    \n    if (row != 'undefined') {\n    }\n    */\n    \n    w.find('.open').html(label_function(row));\n    \n});\n\nw.on('fkey_updated', function(e, payload) {\n    \n    w.find('.open').html(label_function(payload));\n    \n});\n\nw.on('fkey_deleted', function(e, payload) {\n    \n    w.find('.open').html('Click to select');\n    \n});\n\nw.find('.open').click(function() {\n    w.append(widget('modal_dialog', {\n        content: widget('sem_fkey_autocomplete_form', {\n            from_row: from_row,\n            from_column: from_column,\n            to_relation: to_relation,\n            to_column: to_column,\n            label_function: label_function,\n            order_by_function: order_by_function,\n            new_enabled: new_enabled\n        })\n    }));\n});\n
\\xc85698a27d3f947530f4fa64fc9dca43fe68b74b91f25e940effdeeb34e9a9f4	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n    w.find('.text_id').click(function() {\n        w.trigger('bundle_row_open', { row_id: change.get('row_id'), row: real_row });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// tracked\nif (change.get('change_type') == 'tracked') {\n    w.find('button.untrack').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:stage_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:stage_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('button.untrack').click(function() {\n    if (confirm('Untrack this row and remove it from the project?')) {\n        endpoint.schema('bundle').function('untrack_row', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            w.remove();\n        }).catch(function(e) {\n            show_error(e);\n        });\n    }\n\n});\n\nw.find('.modified_link').click(function() {\n    alert ('coming soon...');\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_stage_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n
\\xc8812012cc57f9000d7bfe2ab94884beb694371ffcea032066ae6604e5bd97ab	var w = $("#"+id);\n\n\n\n// widget\n\nw.find('#widget').click(function() {\n    var name = prompt('New widget name');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('widget').insert({ name: name })\n    .then(function(widget) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'widget',\n            'id',\n            widget.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: widget, row_id: widget.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n\n// resource\n\nw.find('#resource').click(function() {\n    var path = prompt('Enter the path for this resource');\n    if (!path) { return; }\n\n    endpoint.schema('endpoint').table('resource').insert({ path: path, content: '', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(resource) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'resource',\n            'id',\n            resource.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: resource, row_id: resource.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n\n// resource_binary\n\nw.find('#resource_binary').click(function() {\n    w.trigger('open_tab', {\n        tab_id: 'resource_binary_upload'\n    });\n});\n\n\n\n\n// template\n\nw.find('#template').click(function() {\n    endpoint.schema('endpoint').table('template').insert({ content: '<html></html>', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(template) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'template',\n            'id',\n            template.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: template, row_id: template.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n// dependency_js\n\nw.find('#dependency_js').click(function() {\n    var name = prompt('Enter the name for this dependency');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('dependency_js').insert({\n        name: name,\n        content: '// add your js library here',\n        version: ''\n    }).then(function(dep) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'dependency_js',\n            'id',\n            dep.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: dep, row_id: dep.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// table\n\nw.find('#table').click(function() {\n    var name = prompt('New table name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('table').insert({\n        schema_name: schema,\n        name: name\n    }).then(function(table) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'table',\n            'id',\n            table.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: table, row_id: table.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// view\n\nw.find('#view').click(function() {\n    var name = prompt('New view name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('view').insert({\n        schema_name: schema,\n        name: name,\n        query: 'select 1'\n    }).then(function(view) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'view',\n            'id',\n            view.id\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: view, row_id: view.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n// function\nw.find('#function').click(function() {\n    var name = prompt('New function name');\n    if (!name) { return; }\n\n    var schema = prompt('What schema should it go in?');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('function').insert({\n        name: name,\n        schema_name: schema,\n        parameters: ['integer'],\n        return_type: 'void',\n        definition: '',\n        language: 'sql'\n    })\n    .then(function(f) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'function',\n            'id',\n            f.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: f, row_id: f.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n
\\xc902016231ffc38e85e9085f221a902d8e1163721fa19509097dcd14727b8538	<div id="{{= id }}" class="{{= name }}">\n    <p class='title'>\n        <span class='path'></span>\n        <a class='path_link' target='_blank'><button>Go to <span class='path_button'>page</span></button></a>\n    </p>\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <div class='section_content'></div>\n    </div>\n</div>
\\xc9722ced797b7c66b514260e0899893cf7474127b9b0182753efb27b0eadb8db	<div id="{{= id }}" class="{{= name }}">\n    <label><span class='label'></span>&nbsp;<select><option value='null'>null</option></select></label>&nbsp;\n    <div class='error'><small>Invalid input</small></div>\n</div>
\\xc9f98bc2e1797a91a42344c0c9ad83127275529aa6bc72cac28df3dbaee48b41	ee286dbd-aebe-46a7-b4c6-57c14e75eff8
\\xca781da0ea3a5b291bbb04c54c7ce19baa41853a69609fa505259f23f40859b9	6622e339-25e4-458e-a147-54b67a50fc8a
\\xcb72123e1b694cc32bc87dd6acfce5da583d207407a646a7501f41876b767eb2	fba92725-3bb8-4f3c-bec0-9367df38060c
\\xcb9875eb69ed036dc4175828fca4e12ee363fcd444136fede6a4c42ef23c0c38	0c47b0ff-a846-450b-bee9-6cfe3777ae11
\\xccdf4bf1eb9c38468ecd310bf189564ceeea36185dcff8179e4156e12683d848	stage_dialog_staged_fields
\\xcd8862f71d64ea0bc5cd6933e86b9e22245429dcde0e6932beb28a51e6dafc50	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.1', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:file_input'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n
\\xce307f848f5e4c4d01b38db2c67a78675e18f58fe97656cc8ef49e31e3044c5f	new_field_fkey_name
\\xce72337e78110bcdc2175603da3775df398e1fe422aca78115dd735d67a13562	var w = $("#"+id);\n\nw.find('button.export').click(function() {\n    var dir = w.find('input.directory').val();\n\n\n    if (confirm('export this bundle to '+dir+'?')) {\n        endpoint.schema('bundle').function('bundle_export_csv', [ bundle.get('name'), dir ])\n        .then(function() {\n            alert ('success');\n            w.trigger('close_modal');\n        })\n        .catch(function(e) {\n            alert('failed:'+e);\n        });\n    }\n});
\\xcf51776107c70218ee9c22db966c7db6d02c737a065e561fff77c57a11f1c8e0	var w = $("#"+id);\n\nw.click(function(event) {\n    event.stopPropagation();\n    \n    w.find('> ul').toggleClass('open');\n    if (!w.find('> ul').hasClass('open')) {\n        w.find('> ul').empty();\n    } else {\n        var rows = relation.related_rows('relation_id','bundle.untracked_row','relation_id');\n        widget.sync(rows, w.find('ul'), function(row) {\n            return widget('bundle_untracked_row', { row: row })\n        });\n    }\n});
\\xd014c65e4175bf62bc7cd1c7a9324868cd854985418f29b37a85d7b0d6b7a27c	84335014-52fd-45d8-9a38-3d789aeb1939
\\xd072e4fc93c5c29a0bf068e271faecdc9a40f081fde8a4226ab65a4680cd0307	.{{= name }} {\n    white-space: nowrap;\n    display: none;\n}\n\n.{{= name }} .label {\n    font-size: 90%;\n}\n\n.{{= name }}:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} span.icon {\n    display: none;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n.{{= name }} span.added {\n    color: green;\n}\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.tracked {\n    color: lightblue;\n}\n\n.{{= name }} .expand {\n    cursor: pointer;\n    display: none;\n}\n\n.{{= name }} .expand:hover {\n    background-color: red;\n}
\\xd13751ec05d815b753d0d16a64d58d5d63c7ae0d176a2f14246b20f0a852c992	.{{= name }} {\n\theight: 100%;\n    width: 100%;\n}\n\n.{{= name }} > nav {\n    height: 1.5rem;\n    border-bottom: 0.15rem solid #333;\n}\n\n.{{= name }} > nav a {\n    color: #666;\n    cursor: pointer;\n    padding: 0 .5em 1px 0.5em;\n    display: inline-block;\n    transition: background 200ms ease-in;\n    text-decoration: none;\n}\n\n.{{= name }} > nav a.selected {\n    background: #333;\n    color: white;\n}\n\n.{{= name }} > .content {\n    height: calc(100% - 1.5rem);\n}\n
\\xd24a92b0175dc151c30ac79f189e479e354cbf30dfa06a365acd1db59d0c70ac	/ide
\\xd3b85feb783c903dd34d371df9c700cf8b28f32cdbc1768f64e51f9dd11c0ffd	var w = $("#"+id);\n\n// new row button handler\nw.find('button.new_row').click(       function() { w.trigger('open_tab', { tab_id: 'new_row' }); });\nw.find('button.stage').click(         function() { w.trigger('open_tab', { tab_id: 'stage' }); });\nw.find('button.commit_log').click(    function() { w.trigger('open_tab', { tab_id: 'commit_log' }); });\nw.find('button.bundle_config').click( function() { w.trigger('open_tab', { tab_id: 'bundle_config' }); });\nw.find('button.push_pull').click(     function() { w.trigger('open_tab', { tab_id: 'push_pull' }); });\nw.find('button.untracked').click(     function() { w.trigger('open_tab', { tab_id: 'untracked' }); });\nw.find('button.export').click(        function() { w.trigger('open_tab', { tab_id: 'export' }); });\nw.find('button.ignored').click(        function() { w.trigger('open_tab', { tab_id: 'ignored' }); });\n\n// filter handlers\nw.find('.filters .all').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        },\n        exclude: [\n            'offstage_field_changes_old_vals',\n            'offstage_field_changes_new_vals',\n            'stage_field_changes_old_vals',\n            'stage_field_changes_new_vals'\n        ]\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\n// filter handlers\nw.find('.filters .changed').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        },\n        exclude: [\n            'offstage_field_changes_old_vals',\n            'offstage_field_changes_new_vals',\n            'stage_field_changes_old_vals',\n            'stage_field_changes_new_vals'\n        ]\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nvar commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    order_by: {\n        column: 'row_id'\n    },\n    exclude: [\n        'offstage_field_changes_old_vals',\n        'offstage_field_changes_new_vals',\n        'stage_field_changes_old_vals',\n        'stage_field_changes_new_vals'\n    ]\n});\n\n// filter handlers\nw.find('.filters .head').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_commit_row','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nw.find('.filters .all').click();\n\n// listen for triggers from semantic widgets which indicate crud changes to handle\nw.closest('.ide').bind('insert', function(e, o) {\n    alert('insert detected');\n    \n    var row_id = o.row.id;\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_value = row_id.pk_value;\n\n    endpoint.schema('bundle').function('tracked_row_add', [ \n        bundle.get('name'), \n        schema_name, \n        relation_name, \n        pk_column_name, \n        pk_value\n    ]).then(function() {\n        w.trigger('bundle_row_open', { row: o.row, row_id: row_id });\n    }).catch(function (e) {\n        alert('error calling tracked_row_add');\n    });\n});\n
\\xd3d44900a2e96f3867e65591795f396ad995b1383984b833a255bc23154b2011	var w = $("#"+id);\n\nif (typeof row_id != 'undefined') {\n    $.when(endpoint.schema(row_id.pk_column_id.relation_id.schema_id.name).table(row_id.pk_column_id.relation_id.name).row().where({\n        id: row_id.pk_value\n    })).then(function(mimetype) {\n\t\tdoit(mimetype);\n    });\n} else {\n\tif (typeof row != 'undefined') {\n    \tdoit(row);\n    } else {\n        console.log("No row or row_id passed into semantics_mimetype_listitem_identifier.");\n    }\n}\n\nfunction doit(row) {\n    w.html('widget.widget: '+row.get('name'));\n}\n
\\xd3e25706465fac81dea80e5a2f951c9a3043dad58a65e794773558944c0785fc	\n\n/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n
\\xd4ac13daf116c28eba8520f900072d93e0f8ebe68a3e98645dcf3ba7b10c42be	7d5ba057-2b25-4083-80e7-c37200e20786
\\xd4c008656d1f2b36141f13b9bcef5ad66396d893eaf558cb500ee79d47e97bfa	4e8942d3-1efa-45ec-8ed3-86b2c8a115c5
\\xd50a37066b1348aaf9623ab7341876f42016d2cbaa6c17c29531935080cbbf65	widget-util
\\xd517711abd43634c2703084bf30ed67b0ab77ad771abc84bbb5b6f0da6da961b	var w = $("#"+id);\n\nendpoint.schema('widget').table('widget_route').rows({\n    where: {\n        name: 'widget_id',\n        op: '=',\n        value: widget_id\n    }\n}).then(function(routes) {\n    widget.sync(routes, w.find('.routes'), function(route) {\n        return widget('ide:widget_route', { route: route });\n    });\n\n});\n\n\nw.find('button.new').click(function() {\n    if (path = prompt('Enter the URL path of the route to add to this widget')) {\n        endpoint.schema('widget').table('widget_route').insert({\n            path: path,\n            widget_id: widget_id\n        }).then(function(route) {\n            w.find('.routes').append(widget('ide:widget_route', { route: route }));\n        });\n    }\n});
\\xd5279ef2adc4c52b4f481a14ee5e97b72a852ba58113555870ad0e4036f8016b	46741261-c826-4f49-8c41-d51fec861ea0
\\xd54c446836750c61535b5d8298a6d50a8349b1751f8d0f6eee2e3769d8770289	list_item_expandable
\\xd5bd045f6bcb0e986364ab6e34ca8270af4373658a6cce7b077798830b839421	form_field_html
\\xd60a0fa6ea2fe111ea61f217791f888ce3ae4790d47e51cacdc5bb5c14df8bfe	var w = $("#"+id);\n\nvar bundles = endpoint.schema('bundle').table('bundle').rows({\n    order_by: {\n        column: 'name'\n    }\n})\nwidget.sync(bundles, w.find('.bundles'), function(bundle) {\n    return widget('bundle_selection', { bundle: bundle });\n});\n\nw.find('.bundles .select').on('click', function() {\n    w.trigger('bundle_selected', { bundle_name: w.find(':checked').val() });\n});\n\n\nw.find('.bundles .new').on('click', function() {\n    var name;\n    if (name = prompt('enter bundle name')) {\n        endpoint.schema('bundle').table('bundle').insert({\n            name: name\n        }).then(function() {\n            w.replaceWith(widget('ide:bundle_selector'));\n        }).catch(function(e,o) {\n            console.log('error creating bundle: ', e, o);\n        });\n    }\n});\n\n\n\n\nw.find('.tabs .untracked').click(function() {\n    var untracked = endpoint.schema('bundle').table('untracked_row').rows();\n    w.find('.bundles').html(widget('ide:bundle_untracked', { untracked: untracked }));\n\n    \n});
\\xd61d6ed387785380c64be89332308322074522cad6de87e858fe7ba8db8eacf4	/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.bundle_name = "[non-widget]";\n        widget_node.bundle_alias = "[non-widget]";\n        widget_node.widget_id = "[non-widget]";\n        widget_node.widget_row_id = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n        widget_node.bundle_name = $(element).attr('data-bundle_name');\n        widget_node.bundle_alias = $(element).attr('data-bundle_alias');\n        widget_node.widget_id = $(element).attr('data-widget_id');\n        widget_node.widget_row_id = $(element).attr('data-widget_row_id');\n        widget_node.element = element;\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // bundle stuff\n            smalltree[name]['bundle_name'] = child.bundle_name;\n            smalltree[name]['bundle_alias'] = child.bundle_alias;\n            smalltree[name]['widget_row_id'] = child.widget_row_id;\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n\n
\\xd633cb66d60d4a7d7a21eab4ec8ae6f09991c25750c54a5b5adc41b871aab7b1	("(""(endpoint)"",template)",content)
\\xd641771fd9c44c8625dd75ecf07c31aa45ce6e53e902ceeca6ab34190dc8832b	d8e8c142-1fb4-4298-b6a0-ac5d07b1749c
\\xd6daa69ecb323f5d2fa9f73a609add57a715697bdb2375520bc2550bc59d6775	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td>{{= change.get('change_type') }}</td>\n    <td>{{= change.get('row_exists') }}</td>\n    <td>\n        <button class='unstage'>unstage</button>\n    </td>\n</tr>
\\xd76c6dc6aa6cc98e7fa37d45afb748d882fc28ca6b401b032ef1eae5d7b28886	workspace_tab
\\xd7e1977adb399906843850536db6b42659c2f68dffa0c5d52292902226de850c	tabbed_layout
\\xd7f5451f74d98130774837f8fcae2e481fb5feb206637deaee38bcbd012999ed	<section id="{{= id }}" class="{{= name }}">\n    <header>\n        <nobr>\n            <a href="/ide">a q u a m e t a</a>\n        </nobr>\n        <h1><span class='title'></span></h1>\n    </header>\n\n    <div class="content">\n        <div class='row_list_section'/>\n        <div class='workspace_section'/>\n    </div>\n    \n    <footer>\n        Aquameta\n    </footer>\n</section>
\\xd888130ed284a864891dba5defdbf0c360cac35787871149c125f4b3a56323e4	.{{= name }} {\n} \n\n.{{= name }}:not(.invalid) .error {\n    display: none;\n}\n\n.{{= name }} .error {\n    color: red;\n}
\\xd8eb8d51a933a05ff9da7fead99f2062f87b99a5e7c5ea8aab4da418953b36d0	bc92c925-2114-4e0e-ae01-f2ecbeda6017
\\xda0390ce078a68a4d18b1c4e5a8e96e44972abf397d3c38eb1fd1cbf4a64ef21	commit_history_commit
\\xda0402fc3e90113e0b5f74a5fbbbe38b17dca9ff5b31e499c0957a8e6a2b5172	<div id="{{= id }}" class="{{= name }}">\n    <p>{{= widget('semantics/form_field', row.field('name')) }}</p>\n    <div class="top">\n        <div class="sections">\n            <div class="section schema selected" data-section='schema'>schema</div>\n            <div class="section data" data-section='data'>data</div>\n            <div class="section semantics" data-section='semantics'>semantics</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="delete">Delete</button>\n            </div>\n            <div class="content"></div>\n        </div>\n    </div>\n</div>
\\xda7ea0df9b133400ecd8877ff59d8e5ece3d507ca844c1add7bcdccfda4173f9	var w = $("#"+id);\n\n\nfor (var i=0;i<offstage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:commit_dialog_unstaged_field', {\n        field: offstage_field_changes[i],\n        old_val: offstage_field_changes_old_vals[i],\n        new_val: offstage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}
\\xdad02962e99de15c6e47223dcda4bb6bab96d5d43b2e5c19379678c079981233	226aedab-05e0-4963-965e-914a55625753
\\xdad5af4d24980a4b6ad2fb7551d321f24f13fa48060b435bf2dc4588a02a5a2f	var w = $("#"+id);\n\nvar bundles = endpoint.schema('bundle').table('bundle').rows({\n    order_by: {\n        column: 'name'\n    }\n})\nwidget.sync(bundles, w.find('.bundles'), function(bundle) {\n    return widget('bundle_selection', { bundle: bundle });\n});\n\nw.find('.bundles .select').on('click', function() {\n    w.trigger('bundle_selected', { bundle_name: w.find(':checked').val() });\n});\n\n\nw.find('.bundles .new').on('click', function() {\n    var name;\n    if (name = prompt('Enter bundle name')) {\n        endpoint.schema('bundle').table('bundle').insert({\n            name: name\n        }).then(function() {\n            w.replaceWith(widget('ide:bundle_selector'));\n        }).catch(function(e,o) {\n            console.log('error creating bundle: ', e, o);\n        });\n    }\n});\n\n\n\n\nw.find('.tabs .untracked').click(function() {\n    var untracked = endpoint.schema('bundle').table('untracked_row').rows();\n    w.find('.bundles').html(widget('ide:bundle_untracked', { untracked: untracked }));\n\n    \n});
\\xdb142c56a62ca8bd60f8f4e4a06a1d13f4904167adf4ff6dfab4f6b4d527eb8d	row_detail_resource
\\xdb26df4a9ffca7c416d5c38d87596494c82c846d1b50500f573a1d38dc6665d7	<div id="{{= id }}" class="{{= name }}">\n    <p class='name'></p><span class='widget_id'></span>\n    <div class="top">\n        <div class="sections">\n            <div class="section code selected">code</div>\n            <div class="section data">data</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="save">Save</button>\n                <button class="copy">Copy</button>\n                <button class="delete">Delete</button>\n            </div>\n            <div class="tabs"></div>\n        </div>\n    </div>\n</div>
\\xdd2741e2734916143a6dbf1d1939cbc04396f10356faf54aba282066cec41b5f	944b5a05-be70-45a1-a549-1301d38799e4
\\xdd7ca347ea5dfd810dee338c092cbf63f77557718f24802cc691d5db9c9e1876	<li id="{{= id }}" class="{{= name }}">\n    {{= schema.get('schema_name') }}\n    <ul></ul>\n</li>
\\xde10528e6f0be56f24707680d0dc75f512c31b9a30ec8a6b4a3af40aac1326c9	.{{= name }} {\n\theight: 100%;\n    display: flex;\n    flex-flow: column;\n}\n\n.{{= name }} .tab_contents {\n    flex: 1;\n    overflow: hidden;\n}
\\xde339938e5ec0a1585a8801ae1ba6c8c3f515fad8a14feb788fe0e191e362c84	list_item_with_schema
\\xdf375cfb3bd4e4c10cc9e362aad8fa59cea7ac3d8e929878da26a2cdc3d7be29	.{{= name }} {\n    margin: 3px;\n}\n\n.{{= name }} .filters {\n    padding: 1px 0px;\n}\n\n.{{= name }} .filters .tab {\n    border-color: #888;\n    border-style: solid;\n    border-width: 1px 1px 1px 1px;\n    padding: 0px 1em;\n}\n\n.{{= name }} .filters .tab:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} .filters .tab.highlighted {\n    background-color: #077;\n}
\\xdf3b43a64503272cba04e9d9037c4a827b1199fb4df10557e5cf67904df167cb	new_field_fkey_purpose
\\xdf63cf21ff81e6dab636f93e7417cb0bf71c0429c21b03bbc7cde5ef363f0105	.{{= name }} {\n    margin: 3px;\n}\n\n.{{= name }} .filters {\n    padding: 5px 0px;\n}\n\n.{{= name }} .filters .tab {\n    border-color: #888;\n    border-style: solid;\n    border-width: 1px 1px 1px 0px;\n    padding: 0px 1em 0px 1em;\n}\n\n.{{= name }} .filters .tab:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} .filters .tab.highlighted {\n    background-color: #077;\n}
\\xdf6dbdb75fd52394cb0d820229eef691ba293f479cd6a49069b543369e2e8665	<div id="{{= id }}" class="{{= name }}">\n    <a href="/dev" target="_blank" style="color: white;">Developer Tools</a>\n    <div class="tabs"></div>\n</div>
\\xdfd48e36f8b3eefe58179b35181705f61905bcada913d46ec36af7841b042476	<div id="{{= id }}" class="{{= name }}">\n    <div class='tab_headers'/>\n    <div class='tab_contents'/>\n</div>
\\xe174d21ece6d48ae67f946df8b5efaa7d4414568d4b6cf48fcf780c2249a3c1f	88fccadf-0885-4819-bacb-9359a27a7fc7
\\xe201e36780b1fcbd4046d981a7dcc879f0a74fc5ab7749e029ca20dfbb77cd18	var w = $('#'+id);\n\nvar editor = CodeMirror(w.get(0), {\n    value: field.value,\n    mode:  language,\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\n\nw.data('codemirror', editor);\n\nfunction change_handler(doc) {\n    field.set(doc.getValue());\n    w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor.on('change', change_handler);\n\n/*\nw.data('disable_code_change_evt', function() { editor.off('change',change_handler); });\nw.data('enable_code_change_evt', function() { editor.on('change',change_handler); });\nw.trigger('code_changed', { codemirror: editor, field: field });\n*/
\\xe2ca231bedf67d636e309d60978dfeace0ab01e188f92a9d941e85cc85e67276	<div id="{{= id }}" class="{{= name }}">\n    <select>\n    </select>\n</div>
\\xe3255c1ad607c78391d77f612ca837052c9347c66d369653e6422fdcce174139	<div id="{{= id }}" class="{{= name }}">\n    <button class='new_row'>new row</button>\n    <button class='stage'>stage</button>\n    <button class='commit_log'>history</button>\n    <button class='push_pull'>&#8644;push/pull</button>\n    <button class='bundle_config'>&#9881;config</button>\n\n    <div class='filters'>\n        <span class='tab all'>all</span>\n        <span class='tab changed'>changed</span>\n        <span class='tab head'>head</span>\n    </div>\n    <div class='bundle_contents'>\n    </div>\n</div>
\\xe39400ffe2faa986e99b11ea7e12af8906d586c9f8bd4f642a947aeef1af11e8	<div id="{{= id }}" class="{{= name }}">\n    <ul class='fkeys'></ul>\n    <button class='new'>New</button>\n</div>
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3dccee3ffa77e89772f64c4114ccff051008538451d923a31fb810647c75c23	967ec665-f37e-470e-b5c9-a2eac0eb9c89
\\xe40b8664a81a3eceb8a60921cf70d6b2924e6587c1c78996c789b9233a1a298d	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation;\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\xe4570890bcc7c1639a7e9c37ea67a5c8b56886febe0f2ff235673c0284265a1d	endpoint/template
\\xe49a0c72fe93f29d84871a01ba65d6b34140c8eda18e086e3f49d2d5cdf06970	var w = $("#"+id);\n\nw.find('> .tabs').html(widget('ide:workspace_tabs', { bundle: bundle }));\n\n// config button\nw.find('.tools .config_button').click(function() {\n    console.log('config clicked');\n    w.trigger('open_tab', { tab_id: 'bundle_config' });\n});
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe511ef1b30f50dbd714dc0f68515e40cf0469748d45dcea2c984aa5e363c19bc	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n    w.find('.text_id').click(function() {\n        w.trigger('bundle_row_open', { row_id: change.get('row_id'), row: real_row });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// tracked\nif (change.get('change_type') == 'tracked') {\n    w.find('button.untrack').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:stage_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:stage_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    // console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('button.untrack').click(function() {\n    endpoint.schema('bundle').function('untrack_row', [\n        bundle.get('name'),\n        schema_name,\n        relation_name,\n        pk_column_name,\n        pk_value\n    ]).then(function() {\n        w.remove();\n    }).catch(function(e) {\n        show_error(e);\n    });\n});\n\nw.find('.modified_link').click(function() {\n    w.append(widget('ide:modal', {\n        content: widget('ide:stage_row_changed_diffs', {\n            \n            stage_field_changes: change.get('stage_field_changes'),\n            stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n            stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n            \n            offstage_field_changes: change.get('offstage_field_changes'),\n            offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n            offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n            \n            bundle: bundle\n        })\n    }));\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_stage_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n
\\xe55082b120a35c6728fb6f29159ed00b1f9cc7766ef42a52337ac3c09b0fe077	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    padding-left: 10rem;\n    \n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    padding: 1.5rem;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .sections {\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: 2rem 0.5rem;\n}\n\n.{{= name }} .section {\n    cursor: pointer;\n    cursor: hand;\n    padding: 20px;\n    text-align: center;\n    border: 1px solid gray;\n    color: gray;\n    width: 9em;\n    box-sizing: border-box;\n}\n\n.{{= name }} .icon {\n    font-size: 300%;\n}\n\n.{{= name }} .section:hover {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} .section.selected {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} .section_content > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\xe5c8d4011fa5c9855a8338ca2102b54b9bde74e2de911160e3ad2852e0262f9e	4a7f3178-5d7b-4fab-a1ec-aadb2d2d21fa
\\xe641dedb6e6ebc14c8a8c72833286ef5ddce6c4ab630c2c5eda86aba567e4166	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('ide:code_editor', { field: field, language: 'javascript' }) }}\n</div>
\\xe687a2e26ec080f0bc49de0c128546a927b55fe4e29ff5f66e3c32ceddd92987	.{{= name }} {\n    cursor: pointer;\n}\n\n.{{= name }}:hover {\n    background-color: #336;\n}
\\xe720a1abb1b786bf08e43c5bbe861915676e69db72a0f21cb2d15e04f8baf073	.{{= name }} {\n} \n\n.{{= name }}:not(.displaying) > .display {\n    display: none;\n}\n\n.{{= name }} > .display:hover {\n    text-decoration: underline;\n    cursor: hand;\n    cursor: pointer;\n}\n\n.{{= name }}:not(.editing) > .edit {\n    display: none;\n}\n\n.{{= name }}:not(.saving) > .save {\n    display: none;\n}\n
\\xe78b7062d9e91aa5c0e2e441cec40ddf95c5a0078b122b4e8282eba78b503f02	stage_dialog_staged_row
\\xe7baee6e277a736da524230ecbef33d20a4df2eb12f6ac0d7ac54e31c04522aa	.{{= name }} .bulk_action {\n    border-bottom: 1px solid blue;\n}
\\xe8478dba635e75d3ada40502a942f72d2529ed408734de3075a055cdc7499256	<li id="{{= id }}" class="{{= name }}">\n    {{= label_function(row) }} <button class='delete'>[ X ]</button>\n</li>
\\xea495ce09ad42dce0c81b890fc9c8f41488fbf027e2d8aa711a74485d6d6d112	e74a4129-6e37-49d2-9391-0f6d99d8fd79
\\xea8666058655262c1c3b900b7b44d62ef717b818d88f0feadd8b712bf7d5330b	bundle_untracked_row
\\xebedb8e451010e9c7d2d3aa4482eb18212afdd4da632073c44ac546ee9880dbd	widget_route
\\xec2f71c50cd18956656d1b77ca1ee45b257b9eb5f1a0cf10a37c611fb6a81e4c	bundle_untracked
\\xecab2d79b46cef08ab0e7bb533710433f428c220cc6d0cf6b2f0eb0342a33abf	/// HACKED IN, this should be called via widget-util dep when deps work again\n\n\n\n/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n\n\n\n\nvar w = $("#"+id);\n\n////////////////////////////////////////////////////////////////////\n// clearable timeout - http://stackoverflow.com/questions/5226578/check-if-a-timeout-has-been-cleared\n////////////////////////////////////////////////////////////////////\n\nfunction Timeout(fn, interval, scope, args) {\n    scope = scope || window;\n    var self = this;\n    var wrap = function(){\n        self.clear();\n        fn.apply(scope, args || arguments);\n    }\n    this.id = setTimeout(wrap, interval);\n}\n\n\nTimeout.prototype.id = null\nTimeout.prototype.cleared = false;\nTimeout.prototype.clear = function () {\n    clearTimeout(this.id);\n    this.cleared = true;\n    this.id = null;\n};\n\n////////////////////////////////////////////////////////////////////\n// draw the tree\n////////////////////////////////////////////////////////////////////\n\nfunction draw_tree() {\n    if (timer && !timer.cleared) {\n        timer.clear();\n    }\n\n    \n    var widget_tree = get_widget_tree($('body')[0]);\n    var agg_tree = get_aggregate_widget_tree(widget_tree);\n\n    var c = w.find('.tree_container').empty();\n    for (var widget_name in agg_tree) {\n\n        c.append(widget('debugger3_widgets_tree', { \n            widget_name: widget_name,\n            properties: agg_tree[widget_name],\n            depth: 0\n        }));\n    }\n}\n\nfunction delayed_redraw(e, payload) {\n    var widg = payload.widget.get(0);\n    // don't redraw for any debugger widget loadings\n    if (widg.className.indexOf('debugger3_widgets_tree') != -1) return;\n    \n    if (!timer || timer.cleared) {\n        // console.log('setting up delayed redraw....'+widg.className);\n        timer = new Timeout(draw_tree, 100);\n    }\n    else { \n        // console.log('.....no go on '+widg.className); \n    }\n}\n\nvar timer = false;\ndraw_tree();\n$(document).bind('widget_loaded', delayed_redraw);\n\n\n\n/////////////////////////////////////////////////////////////////////\n// show all\n/////////////////////////////////////////////////////////////////////\n\nw.find('div.show_all').bind('mouseover', function(e) {\n    $("[data-widget]").addClass('debugger3_widget_highlight');\n    e.stopPropagation();    \n}).bind('mouseout', function(e) {\n    $("[data-widget]").removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n\n\n\n/////////////////////////////////////////////////////////////////////\n// new_widget\n/////////////////////////////////////////////////////////////////////\n\nw.find('.new_widget').click(function() {\n    w.append(widget('modal', { \n        content: widget ('widget_new', { \n            widget_table: endpoint.schema('widget').table('widget') \n        })\n    }));\n});
\\xecb616961af41e4f15ece969f756e6cd63d6127f401baa012d6bfc250f386ba1	<div id="{{= id }}" class="{{= name }}">\n    <h1>template: <span class='name'></span></h1>\n    \n    <h3>Routes</h3>\n    <div class='routes'></div>\n    \n    <h3>Content</h3>\n    <button class='content_save'>save</button>\n    <div class='content'></div>\n</div>
\\xed08f26bc4c6c1973fc0a8c69f7139d52dea2aad6fce2bb6e6021f52b4d91be7	129c7484-653d-4206-b81a-a703e87a491a
\\xed2c29cc5add30df75e4ef6f6408691406eed2cdfc17456aff75fecde8c8bfb1	<div id="{{= id }}" class="{{= name }}">\n    <!--\n    <div class='tabs'>\n        <div class='tab localhost'>bundles</div>\n        <div class='tab untracked'>untracked</div>\n    </div>\n\t-->\n    <div class='container'>\n        <div class='bundles'>\n            <button class='new'>new bundle</button>\n            <button class='import'>import</button>\n            <button class='hub'>hub</button>\n        </div>\n    </div>\n</div>
\\xed866cc4841c70ebe74a6ca6b8a4c292102ddcf46de19227ac53802837527663	<div id="{{= id }}" class="{{= name }}">\n    <!--<p>For the time being, use copy to create a new row in this table instead</p>\n\n    <small>Press ESC to return</small>\n    <button class='exit'>Exit</button>\n    <p>You really should have just copied this... but anyway</p>\n-->\n    <input class='path' type='text' placeholder='/my_new_resource'>\n    <select class='mimetype'></select>\n    <button class='save'>Save</button>\n</div>
\\xedb35cc413395a9015378cd74de68f4571dabfc1fc82d7d4bc97b705cecf4051	<div id="{{= id }}" class="{{= name }}">\n    <h3>Untracked Rows</h3>\n    \n    <input type='checkbox' class='checkall'>\n    <button class='ignore'>ignore</button>\n    <button class='track'>add to {{= bundle.get('name') }}</button>\n    \n    <div class='rows'>\n    </div>\n</div>
\\xee283cc44ca38cbce89dfb94a676cbeaee2cbbf4bc59db41e2533a9a91d13b15	18b4a552-9546-4194-89a3-059bd71838db
\\xee71bc9d7dfdcffbfb1c1802b176d215feab560923d5c0f019a1ab1045b7789e	var w = $("#"+id);\n\n/*\nthis is pretty much crap.\nyeah.  this really is total crap.\ndo we really want to ahve to go thru bundle.tracked_row here?  how about just putting bundle_id back on ignored_*?  seems more righter, but means we hae to import/export those tables as well.  but... ignore rules really are a part of the bundle, so it seems to make sense.\n*/\nbundle.related_rows('id','bundle.tracked_row','bundle_id', {\n    where: [\n        {\n            name: 'bundle_id',\n            op: '=',\n            value: bundle.get('id')\n        }, {\n            name: '(row_id::meta.relation_id).name',\n            op: '=',\n            value: 'ignored_schema'\n        }\n    ]\n}).then(function(tracked_row) {\n    widget.sync(ignored_schema, w.find('.schema'), function() {\n        return widget('ide:bundle_ignored_schema', { row_id: tracked_row });\n    });\n});
\\xeec94ccb378026d109db8c2900822aa3ef4d4b60f88505d0ab49fcab2a9f635d	<div id="{{= id }}" class="{{= name }}">\n    A template can be served up at a particular URL path, or multiple paths.\n    \n    <div class='routes'>\n    </div>\n    \n    <button class='new'>add route</button>\n</div>
\\xef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567	dev
\\xef63ee32c7c0c72bb49221edc2bfc5984e2976ee01bc883d6a3880f5aaad4bac	<div id="{{= id }}" class="{{= name }}">\n    <h2>Push/Pull</h2>\n    \n    <h2>Remotes</h2>\n    \n    <p>A remote is another database that you wish to share your bundles with.  You can push and pull changes with another remote.</p>\n    \n    <div class="remotes"></div>\n    \n    <button class='new_remote'>New Remote</button>\n\n</div>
\\xef980b97c7fcc4153f6987bee0a2ee50d29d02da69ba07e483b9c61844cfdee0	var w = $("#"+id);\n\nw.find('.delete_bundle_oh_no').click(function() {\n    if(confirm('Are you sure you really want to PERMANTENTLY DELETE this bundle?')) {\n        bundle.delete().then(function() {\n            alert ('gone.');\n        }).catch(function() {\n            alert('failed.');\n        });\n    }\n});\n\n\nw.find('.rename').click(function() {\n    alert('coming soon....');\n});\n\n\n
\\xefb75975b9f7bc401006e2f691e5fe25de4b13aaf796166b1d6e033636bfc938	5958da09-33b4-455c-a50f-05896aa1a7cc
\\xefc6a7155a884bc7d2a153b03e3200b00e51d995119828ad4a689f56e7367804	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.1', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:file_input'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n
\\xefdd3043fbbbe26ed596c9768485d84b5bd88a440022d1f215b5104527bac43f	206646d9-7fe3-45c2-8db1-56fa22bc62c6
\\xf0365e10595918f36ccf08e105de338d821e34b5ed928ed9d8d937367ebd80f8	<div id="{{= id }}" class="{{= name }}">\n    <h2>Push/Pull</h2>\n    \n    <h2>Remotes</h2>\n    \n    <div class='remotes'>\n    </div>\n</div>
\\xf056fbc142b96c3a3c13788124ada8bd5b4078f10f321ec744fed08d82bbdf12	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}\n\n.{{= name }} > .edit {\n    display: none;\n    padding: 0.25rem;\n    float: right;\n}\n\n.{{= name }}:hover > .edit {\n    display: initial;\n}\n
\\xf05d0f3e21e5cb7a2867cd06f70a9d125b582a67a3aa4c2d9ed673c035e136ae	stage_dialog_staged_fields\n
\\xf0d6bddd4ddfc3cdeba394416cc389bbb98fd1b2a8d4344f97c2bf30da238935	.{{= name }} {\n    position: relative;\n    height: 100%;\n    text-align: left;\n}\n\n\n/* BASICS */\n.CodeMirror {\n    /* Set height, width, borders, and global font properties here */\n    height: 100% !important;\n    font-family: monospace;\n    height: auto;\n}\n\n.CodeMirror-scroll {\n    /* Set scrolling behaviour here */\n    overflow-y: hidden;\n    overflow-x: auto;\n}\n\n.CodeMirror-hscrollbar {\n    display: none;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n    padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre {\n    padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler {\n    background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n    border-right: 1px solid #ddd;\n    background-color: #f7f7f7;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n    padding: 0 3px 0 5px;\n    min-width: 20px;\n    text-align: right;\n    color: #999;\n}\n\n/* CURSOR */\n\n.CodeMirror div.CodeMirror-cursor {\n    border-left: 1px solid black;\n    z-index: 3;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n    border-left: 1px solid silver;\n}\n.CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor {\n    width: auto;\n    border: 0;\n    background: #7e7;\n    z-index: 1;\n}\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror div.CodeMirror-cursor.CodeMirror-overwrite {}\n\n.cm-tab { display: inline-block; }\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable {color: black;}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3 {color: #085;}\n.cm-s-default .cm-property {color: black;}\n.cm-s-default .cm-operator {color: black;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-error {color: #f00;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n\n.cm-invalidchar {color: #f00;}\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\nthe editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n    line-height: 1;\n    position: relative;\n    overflow: hidden;\n    background: white;\n    color: black;\n}\n\n.CodeMirror-scroll {\n    /* 30px is the magic margin used to hide the element's real scrollbars */\n    /* See overflow: hidden in .CodeMirror */\n    margin-bottom: -30px; margin-right: -30px;\n    padding-bottom: 30px; padding-right: 30px;\n    height: 100%;\n    outline: none; /* Prevent dragging from highlighting the element */\n    position: relative;\n}\n.CodeMirror-sizer {\n    position: relative;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\nbefore actuall scrolling happens, thus preventing shaking and\nflickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler {\n    position: absolute;\n    z-index: 6;\n    display: none;\n}\n.CodeMirror-vscrollbar {\n    right: 0; top: 0;\n    overflow-x: hidden;\n    overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n    bottom: 0; left: 0;\n    overflow-y: hidden;\n    overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n    right: 0; bottom: 0;\n    z-index: 6;\n}\n\n.CodeMirror-gutters {\n    position: absolute; left: 0; top: 0;\n    height: 100%;\n    padding-bottom: 30px;\n    z-index: 3;\n}\n.CodeMirror-gutter {\n    height: 100%;\n    padding-bottom: 30px;\n    margin-bottom: -32px;\n    display: inline-block;\n    /* Hack to make IE7 behave */\n    *zoom:1;\n    *display:inline;\n}\n.CodeMirror-gutter-elt {\n    position: absolute;\n    cursor: default;\n    z-index: 4;\n}\n\n.CodeMirror-lines {\n    cursor: text;\n}\n.CodeMirror pre {\n    /* Reset some styles that the rest of the page might have set */\n    -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n    border-width: 0;\n    background: transparent;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    white-space: pre;\n    word-wrap: normal;\n    line-height: inherit;\n    color: inherit;\n    z-index: 2;\n    position: relative;\n    overflow: visible;\n}\n.CodeMirror-wrap pre {\n    word-wrap: break-word;\n    white-space: pre-wrap;\n    word-break: normal;\n}\n.CodeMirror-linebackground {\n    position: absolute;\n    left: 0; right: 0; top: 0; bottom: 0;\n    z-index: 0;\n}\n\n.CodeMirror-linewidget {\n    position: relative;\n    z-index: 2;\n    overflow: auto;\n}\n\n.CodeMirror-widget {\n    display: inline-block;\n}\n\n.CodeMirror-wrap .CodeMirror-scroll {\n    overflow-x: hidden;\n}\n\n.CodeMirror-measure {\n    position: absolute;\n    width: 100%; height: 0px;\n    overflow: hidden;\n    visibility: hidden;\n}\n.CodeMirror-measure pre { position: static; }\n\n.CodeMirror div.CodeMirror-cursor {\n    position: absolute;\n    visibility: hidden;\n    border-right: none;\n    width: 0;\n}\n.CodeMirror-focused div.CodeMirror-cursor {\n    visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n\n.cm-searching {\n    background: #ffa;\n    background: rgba(255, 255, 0, .4);\n}\n\n/* IE7 hack to prevent it from returning funny offsetTops on the spans */\n.CodeMirror span { *vertical-align: text-bottom; }\n\n@media print {\n    /* Hide the cursor when printing */\n    .CodeMirror div.CodeMirror-cursor {\n        visibility: hidden;\n    }\n}\n\n\n\n/* Based on Sublime Text's Monokai theme */\n\n.cm-s-monokai.CodeMirror {background: #272822; color: #f8f8f2;}\n.cm-s-monokai div.CodeMirror-selected {background: #49483E !important;}\n.cm-s-monokai .CodeMirror-gutters {background: #272822; border-right: 0px;}\n.cm-s-monokai .CodeMirror-linenumber {color: #d0d0d0;}\n.cm-s-monokai .CodeMirror-cursor {border-left: 1px solid #f8f8f0 !important;}\n\n.cm-s-monokai span.cm-comment {color: #75715e;}\n.cm-s-monokai span.cm-atom {color: #ae81ff;}\n.cm-s-monokai span.cm-number {color: #ae81ff;}\n\n.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute {color: #a6e22e;}\n.cm-s-monokai span.cm-keyword {color: #f92672;}\n.cm-s-monokai span.cm-string {color: #e6db74;}\n\n.cm-s-monokai span.cm-variable {color: #a6e22e;}\n.cm-s-monokai span.cm-variable-2 {color: #9effff;}\n.cm-s-monokai span.cm-def {color: #fd971f;}\n.cm-s-monokai span.cm-error {background: #f92672; color: #f8f8f0;}\n.cm-s-monokai span.cm-bracket {color: #f8f8f2;}\n.cm-s-monokai span.cm-tag {color: #f92672;}\n.cm-s-monokai span.cm-link {color: #ae81ff;}\n\n.cm-s-monokai .CodeMirror-matchingbracket {\n    text-decoration: underline;\n    color: white !important;\n}\n\n\n.cm-s-blackboard.CodeMirror { background: #0C1021; color: #F8F8F8; }\n.cm-s-blackboard .CodeMirror-selected { background: #253B76 !important; }\n.cm-s-blackboard .CodeMirror-gutters { background: #0C1021; border-right: 0; }\n.cm-s-blackboard .CodeMirror-linenumber { color: #888; }\n.cm-s-blackboard .CodeMirror-cursor { border-left: 1px solid #A7A7A7 !important; }\n\n.cm-s-blackboard .cm-keyword { color: #FBDE2D; }\n.cm-s-blackboard .cm-atom { color: #D8FA3C; }\n.cm-s-blackboard .cm-number { color: #D8FA3C; }\n.cm-s-blackboard .cm-def { color: #8DA6CE; }\n.cm-s-blackboard .cm-variable { color: #FF6400; }\n.cm-s-blackboard .cm-operator { color: #FBDE2D;}\n.cm-s-blackboard .cm-comment { color: #AEAEAE; }\n.cm-s-blackboard .cm-string { color: #61CE3C; }\n.cm-s-blackboard .cm-string-2 { color: #61CE3C; }\n.cm-s-blackboard .cm-meta { color: #D8FA3C; }\n.cm-s-blackboard .cm-error { background: #9D1E15; color: #F8F8F8; }\n.cm-s-blackboard .cm-builtin { color: #8DA6CE; }\n.cm-s-blackboard .cm-tag { color: #8DA6CE; }\n.cm-s-blackboard .cm-attribute { color: #8DA6CE; }\n.cm-s-blackboard .cm-header { color: #FF6400; }\n.cm-s-blackboard .cm-hr { color: #AEAEAE; }\n.cm-s-blackboard .cm-link { color: #8DA6CE; }
\\xf0fb8f51aa4c0bca032e44a39c94cd847fd05ec1d09ad0c9c0cf8d50b20a52f3	<div id="{{= id }}" class="{{= name }}">\n    <span>Logged in</span>\n    <div class='dropdown'>\n        <div class='username'></div>\n        <div class='logout'>Logout</div>\n    </div>\n</div>\n
\\xf17960e717ae9160d4e72ed5c485d5e0d60d90f370541cc87c62a61aaec6bf70	0d106cc7-33b0-4afe-9472-3aca86e66bbb
\\xf1aaa2dc142b42e5a44edc01c95d7e187b1449e175baa360c469c4c2d3d7ce3b	<div id="{{= id }}" class="{{= name }}">\n    <p class='title'>\n        <span class='name'></span>\n        <span class='version'>Version:</span>\n    </p>\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <div class='section_content'></div>\n    </div>\n</div>
\\xf21470e025973b83a41367f261b792f68366d302e6969115a1835991d4ce459b	<div id="{{= id }}" class="{{= name }}">\n    <button class='new_row'>new row</button>\n    <button class='stage'>stage</button>\n    <button class='commit_log'>history</button>\n    <button class='push_pull'>&#8644;push/pull</button>\n    <button class='bundle_config'>&#9881;config</button>\n    <button class='untracked'>&#9881;untracked</button>\n\n    <div class='filters'>\n        <span class='tab all'>all</span>\n        <span class='tab changed'>changed</span>\n        <span class='tab head'>head</span>\n    </div>\n    <div class='bundle_contents'>\n    </div>\n</div>
\\xf23626013ef9bb6465343f06e82c31a8241837f4bad9012633235e1838bda70b	stage_dialog_staged_field\n
\\xf255dd3fc6284e3a5081aadb9275ca0244f158578a44ea1cc6d206983e4cdaa3	<div id="{{= id }}" class="{{= name }}">\n    <h3>CHANGE!</h3>\n    <table width=100%>\n        <tr>\n            <th>old value</th>\n            <th>new value</th>\n        <tr>\n            <td class="old_val" valign=top width=50%></td>\n            <td class="new_val" valign=top width=50%></td>\n        </tr>\n    </table>\n</div>
\\xf29200a3b5ec701ea081b8e73a3a5e56cca184d2ed6603bc97195c2bb74fa66c	template_routes
\\xf3498573b89bfc70aefc01efb96fbae34cdc097e0669c98777f900478813626d	486d1939-8093-40b9-b790-a6d1675727c8
\\xf3704cb0c092b867a28c4dc81c3c9b26a47288bb1755af9698970f8e89842874	290a4947-989a-41fb-bfbb-94e4fe59ebc8
\\xf3a26657ca8798f8bd09bdd0fb8b177f49a1f419a2b215ffb1efc38cb653f0d7	var w = $("#"+id);\n\nconsole.log('remote:',remote);\n\nremote.related_row('endpoint_id','endpoint.remote_endpoint','id')\n.then(function(ep) {\n    console.log('ep:', ep);\n    w.find('h2.url').html(ep.get('url'));\n\n    w.find('button.compare').click(function() {\n        w.find('.comparison').show();\n        endpoint.schema('bundle').function('remote_compare_commits', [\n            remote.get('id')\n        ]).then(function(comparisons) {\n            console.log(comparisons);\n\n            $.each(comparisons.rows, function(i, c) {\n                console.log('####',i,c);\n                w.find('.comparison').append(widget('ide:bundle_remote_commit_comparison_row', {\n                    comparison: c\n                }));\n            });\n        });\n\n    });\n\n\n    w.find('button.push').click(function() {\n        var push_results = endpoint.schema('bundle').function('remote_push', [ remote.get('id') ]);\n        $.when(push_results).then(function(r) {\n            console.log(r);\n        });\n    });\n\n\n    w.find('button.pull').click(function() {\n\n    });\n\n});\n
\\xf3ccbbf2f88909c1cb63bfe2e0b7e7291dc281a62814b7da7cc2530eb2da879e	.{{= name }} .toggle {\n\tposition: fixed;\n    bottom: 0;\n    right: 1em;\n}\n\n.{{= name }} .debugger_container {\n    display: none;\n}
\\xf3e4f44290db4f289df8aa4f1c342048590b37cb000dd310e2cca7eccde852c0	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\xf55bd9d1c136fdf5902305258b433b2602b7be33dc777df5506add0cd15120e3	aad6b1d3-c105-4fba-9fbb-faafa4855ddd
\\xf6b2729d1a9849e4034b325342befb6821024126262f0490ceb24687ac26095f	75abad58-4f0a-48a4-825c-7ac9423cec0d
\\xf6b2ac3a36101b6ee151bf4c0b01c1c23269f51e5bae8fba8096525ef7816c99	d5ff5f93-b643-49f7-87b3-5909b35ad026
\\xf8e96f7a888e247eee11f275e88415f93bf5e2319de54d624e0ab6558231f3cc	.{{= name }} {\n    display: inline-block;\n    width: 50%;\n    padding: 5rem 3rem;\n    background-color: #333;\n    border: 0.25rem solid #222;\n}\n\n.{{= name }} > * {\n    display: block;\n    margin: 0.5rem;\n}\n\n.{{= name }} > input {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > input:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > input:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}
\\xf9453243de260974f29858e3bcc94d7b688933892ef60f9118c4b99d312af9e2	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.stage').click(function() {\n    endpoint.schema('bundle').function('stage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function(e, o) {\n        console.log(e, o);\n        w.trigger('reload_commit_dialog');\n    })\n    .catch(function() {\n        alert('stage failed');\n        console.error('stage failed');\n    });\n    \n});
\\xfa8985c904915f60fc5d56f7fdebdee4df5886dd7feebd8fd90f2af0a1094785	<div id="{{= id }}" class="{{= name }}">\n    <nobr>\n        <span class='label'></span>\n        <span class='changes'>\n            <span title='This row has been modified' class='icon modified'>&Delta;</span>\n            <span title='This row has been deleted' class='icon deleted'>-</span>\n            <span title='This row has been added' class='icon added'>+</span>\n            <span title='This row has been added' class='icon tracked'>&#128065;</span>\n            <span title='This row does not exist in the live database' class='icon doesnt_exist'>&#x1f5d1;</span>\n        </span>\n    </nobr>\n</div>
\\xfac49fa584b6b67c9ac9595fb7b4bca0014df79633b7129e87bdb9ed4b55f5ef	var w = $("#"+id);\n\nw.find('.url_pattern').append(widget('semantics/form_field', route.field('url_pattern')));\nw.find('.args').append(widget('semantics/form_field', route.field('args')));\nw.find('button.delete').click(function() {\n    route.delete().then(function() {\n        w.remove();\n    });\n});\nw.find('button.save').click(function() {\n    console.log('args is ', route.get('args'));\n    console.log('path is ', route.get('path'));\n    \n    route.update()\n    .then(function() {\n        alert ('saved');\n    }).catch(function() {\n        alert ('failed.');\n    });\n});\n
\\xfadb7d95346980c50d40361007f0c36bb621357ee35f9b1c79576be298b6c453	var w = $("#"+id);\nvar tab_links = w.find('> nav > a');\nvar content = w.find('.content');\n\n// tab colors\ntab_links.each(function() {\n    var tab_name = $(this).attr('data-tab');\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n\t    $(this).css('border-left', '10px solid ' + tab_colors[tab_name]);\n    }\n});\n\n\ntab_links.on('click', function() {\n    tab_links.removeClass('selected');\n    var tab_name = $(this).attr('data-tab');\n    w.data('selected_tab', $(this));\n\n    content.html(tabs[$(this).addClass('selected').attr('data-tab')]());\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n        w.css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\n\nif (typeof selected == 'undefined') {\n    tab_links.filter(':first').get(0).click();\n}\nelse {\n    tab_links.filter('[data-tab="' + selected + '"]').get(0).click();\n}\n
\\xfb377d9c156ecb48cad94068fa2bd927b8cc832ffdc4212d6d38cde58d471ae7	var w = $("#"+id);\n\n// new row button handler\nw.find('button.new_row').click(       function() { w.trigger('open_tab', { tab_id: 'new_row' }); });\nw.find('button.stage').click(         function() { w.trigger('open_tab', { tab_id: 'stage' }); });\nw.find('button.commit_log').click(    function() { w.trigger('open_tab', { tab_id: 'commit_log' }); });\nw.find('button.bundle_config').click( function() { w.trigger('open_tab', { tab_id: 'bundle_config' }); });\nw.find('button.push_pull').click(     function() { w.trigger('open_tab', { tab_id: 'push_pull' }); });\nw.find('button.untracked').click(     function() { w.trigger('open_tab', { tab_id: 'untracked' }); });\n\n// filter handlers\nw.find('.filters .all').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\n// filter handlers\nw.find('.filters .changed').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nvar commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    order_by: {\n        column: 'row_id'\n    }\n});\n\n// filter handlers\nw.find('.filters .head').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_commit_row','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nw.find('.filters .all').click();\n\n// listen for triggers from semantic widgets which indicate crud changes to handle\nw.closest('.ide').bind('insert', function(e, o) {\n    alert('insert detected');\n    \n    var row_id = o.row.id;\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_value = row_id.pk_value;\n\n    endpoint.schema('bundle').function('tracked_row_add', [ \n        bundle.get('name'), \n        schema_name, \n        relation_name, \n        pk_column_name, \n        pk_value\n    ]).then(function() {\n        w.trigger('bundle_row_open', { row: o.row, row_id: row_id });\n    }).catch(function (e) {\n        alert('error calling tracked_row_add');\n    });\n});\n
\\xfc8679f396432bf7fbfbadac7e52f586ad1d65727c543dfebe42ab2e057fbdfe	var w = $("#"+id);\n\n/* Flushes current styles \n    so initial opacity/background-color/visibility take effect\n      before adding "fade" class */\nw.css('opacity');\n\nw.addClass(type + ' fade');\n\nsetTimeout(function() {\n    w.remove();\n}, 2000);\n
\\xfca6ce865e413a68645cd47d08b700f24bb84f409112ebeb2a4476e2d871fa8c	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <!-- link href='//fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'-->\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.2', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            AQ.Widget.import('org.aquameta.ui.auth', 'auth', db);\n            \n            $('body').append(widget('ide:ide'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\xfcc7c9cd6722536c56afd1d10c85ed24f7738893f9701b7bff1dbf5239bee0ef	semantics_widget_widget_listitem_identifier
\\xfdb81daf54b07ff652aefe92286b08f38b61ac8ea44b34fd95e25403e4aa69e3	stage_dialog_unstaged_field
\\xfe2d1542a0f1789e9c595873307bd708cab0f32944257d21a5ed2bcf11c7c5ab	<div id="{{= id }}" class="{{= name }}">\n    <div class="show_all">show all</div>\n    <div class="tree_container">\n        \n    </div>\n    <li class="new_widget">new widget</li>\n</div>
\\xff50b6080b72c66d1df97d5c054b1e10f2cad08985f62884cf3897102e83f6de	var w = $("#"+id);\n\nw.find('> .tabs').html(widget('ide:workspace_tabs', { bundle: bundle }));\n\n// config button\nw.find('.tools .config_button').click(function() {\n    w.trigger('open_tab', { tab_id: 'bundle_config' });\n});
\\xff740900365b409052b9a27822712c359cb837baf4d6dfe6076c93cf25d7f72d	row_detail_dependency_js
\\xff968e48f617a279b6f35fc595e6ccbc6460809ab2d0bcf762705caaaa3ed116	var w = $("#"+id);\n\nvar rel_name = datum.schema.name + '.' + datum.name;\nw.find('.rel_name').text(rel_name);\n\nfunction save(save_as_null) {\n    var val = w.find('.name').val().trim();\n\n    if (save_as_null) {\n        val = null;\n    }\n\n    datum.insert({\n        name: val\n    })\n    .then(function() {\n        w.trigger('status', ['New row on ' + rel_name, 'success']);\n        w.trigger('done');\n    }).catch(function() {\n        w.trigger('status', ['Failed insert on ' + rel_name, 'fail']);\n    });\n}\n\n\n/* TRIGGERS */\nw.find('.save_as_null').on('click', save.bind(this, true));\n\nw.find('.name').on('keyup', function(e) {\n    e.stopPropagation();\n    if (e.key == 13) {\n        save(false);\n    }\n});\n\nw.find('.save').on('click', save.bind(this, false));\nw.on('keydown', jwerty.event('ctrl+s', save.bind(this, false)));\n
\\xffbecc06a7cc2b5c212136159b4ade752fd56887a3a0e337772cdf60d8adeaf9	<span id="{{= id }}" class="{{= name }} displaying">\n    <span class='display'></span>\n    <span class='edit'>\n        <input type='text' value='{{= field.value }}'>\n        <button class='save'>Save</button>\n        <button class='cancel'>Cancel</button>\n        <button class='save_as_null'>Save as null</button>\n    </span>\n    <span class='save'>\n        saving...\n    </span>\n</span>\n
\\xffc33aef281d43764c9171c68082c834ab442a606c486f4dd4cf1937e46c410b	a1a8b72b-59ed-45dc-ac50-dfa5dbb71f43
\\xffc61b467dca10634a6a7580562e60483c7cb56bea01e9c911fa299cbdf2cdf4	<section id="{{= id }}" class="{{= name }}">\n    <header>\n        <div class='logo'><a href="/dev">aquameta</a></div>\n        <div class='title'></div>\n    </header>\n\n    <div class="content">\n        <div class='row_list_section'/>\n        <div class='workspace_section'/>\n    </div>\n    \n    <footer>\n        Aquameta\n    </footer>\n</section>
\\xffd1fc1b2ff4eea6ad49b247f7365cede4676c636364eb7864359598abadf437	sem_fkey_one_to_many_li
\\xffeda252dfccacd24617aeafc5497d1277ae10ec0821766b47a6d5770bbdfaeb	d38b4273-997a-49bd-bc23-438423620dc9
]\\011\\313T6\\016t\\030\\237\\365TUE\\305\\301?6Tl\\265\\021\\205\\361\\335\\0139'\\245D\\307\\335\\361	dev_workspace
^9\\346\\241WD\\204\\036pE,\\001{VhHM\\215\\3002\\253\\006S\\272\\3626JZ\\000U\\255\\203	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\n/*\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n*/\n\nendpoint.schema('widget').table('widget').row('id', row.get('id'))\n.then(function(row) {\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n    \n\t// html, css, post_js, server_js\n    ['html','css','server_js','common_js','post_js'].forEach(function(col_name, i) {\n        tabs[col_name] = function() {\n            return widget('semantics/form_field', row.field(col_name));\n        };\n        tab_colors[col_name] = colors[i % colors.length];\n    });\n    \n    // input\n    tabs['input'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('input').rows({\n        where: {\n            name: 'widget_id',\n            op: '=',\n            value: datum.get('id')\n        },\n            exclude: ['id', 'widget_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['input'] = colors[5 % colors.length];\n    \n    // dependency_js\n    tabs['dependencies'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('widget_dependency_js').rows({\n            where: {\n                name: 'widget_id',\n                op: '=',\n                value: datum.get('id')\n            },\n            include: ['dependency_js_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['dependencies'] = colors[6 % colors.length];\n\n\n    /* TABBED LAYOUT */\n    // var preview_row = row.clone();\n\n    w.find('> .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Widget deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            //set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n            w.trigger('row_detail_save');\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n            //setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.on('keydown', jwerty.event('ctrl+alt+s', handle_save_button));\n    w.find('.delete').on('click', handle_delete_button);\n\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Widget copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('inserted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
^\\223nv^\\254\\006z\\365C2h\\357\\374\\206\\230\\250\\342*\\205\\341}JJl%X\\320Y\\014\\345=	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\n// TODO this fails for views\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var columns = [];\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\n    if (row.columns == null) {\n        throw 'Please call this row with "meta_data" set to true. ' + rel_name;\n    }\n    row.columns.forEach(function(col, i) {\n        if (col.name != 'id' && col.name != 'name') {\n            tabs[col.name] = function() {\n                return widget('semantics/form_field', row.field(col.name));\n            };\n            tab_colors[col.name] = colors[i % colors.length];\n            columns.push(col.name);\n        }\n    });\n\n\n    /* TABBED LAYOUT */\n    var preview_row = row.clone();\n\n    w.find('> .top > .section_content > .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Row deleted from ' + rel_name, 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Widget delete failed', 'fail']);\n            setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('button.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.find('button.delete').on('click', handle_delete_button);\n\n    w.find('button.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Row copied from ' + rel_name, 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('isnerted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(xhr) {\n                w.trigger('status', ['Row copy failed on ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
_\\310\\335\\017\\212?\\225'VT\\244@\\213c\\2310(\\266\\212\\020\\256l)\\022\\270\\203\\340\\347\\355\\210\\210\\005	<div id="{{= id }}" class="{{= name }}">\n    Enter the URL of the remote you would like to add:\n\n    <p>\n        URL: <input type='text' value='http://' class='url' /><br>\n        Name: <input type='text' class='name' /><br>\n        <button class='create'>Create</button>\n        <button class='cancel'>Cancel</button>\n    </p>\n</div>
_\\315\\364|\\031n,B\\3245\\321\\231\\2332,\\256\\177\\246gR\\025b\\352\\000\\336\\034\\244\\212\\365\\270\\343\\216	efa37228-3471-4f88-b744-7965d2403dae
_\\354\\353f\\377\\310o8\\331Rxlmily\\302\\333\\3029\\335N\\221\\264g)\\327:'\\373W\\351	0
_\\3641?\\274\\016\\213\\233\\011\\365\\220&\\030k:%\\243\\320\\322\\360\\332\\300\\014\\011\\025\\200}\\250\\007p\\232:	<div id="{{= id }}" class="{{= name }}">\n    {{= row.get('row_id') }}\n</div>
`o\\220Z$\\251\\306\\372\\323\\364\\003\\315%\\211\\267N\\247\\256\\003\\241\\237\\370\\036\\356\\372\\366h\\206O\\010\\352\\265	<div id="{{= id }}" class="{{= name }}">\n    <span class='open'>Click to select</span>\n</div>
a\\353Z\\214W\\252v\\361Ey\\243\\233\\014\\207\\253G\\301\\327\\036\\270\\243\\233\\230\\263q\\323\\352\\257\\266\\346!\\010	0768c4d8-09f6-41b1-9895-6c0c0877f812
a\\366mmx\\376\\\\\\013\\350\\311\\336\\274\\257\\214-\\204\\\\\\214\\340uf\\254}S\\017\\331AAn\\233\\333\\014	.{{= name }} {\n    height: 100%;\n}\n\n.{{= name }} > .header {\n    height: 1.5rem;\n    text-align: right;\n    background-color: #333;\n}\n\n.{{= name }} > .header > .select_bundles {\n    float: left;\n}\n\n.{{= name }} > .header > * {\n\theight: 100%;\n}\n\n.{{= name }}:not(.bundle_edit) > .header > button.select_bundles,\n.{{= name }}:not(.bundle_edit) > .header > span.bundle_manager_container,\n.{{= name }}:not(.bundle_edit) > div.bundle_workspace,\n.{{= name }}.bundle_edit > div.bundle_list {\n    display: none;\n}\n\n.{{= name }} > .content {\n    height: calc(100% - 1.5rem);\n}\n\n.{{= name }} > .status_container {\n    position: fixed;\n    bottom: 0;\n    right: 0;\n    width: 100%;\n    z-index: 100;\n}\n
b?\\353p\\250\\276\\314\\303\\356\\342P\\331\\035\\376\\245l\\336\\235\\272\\323\\210\\032\\201w\\373\\276\\304\\031fY\\375Z	var w = $("#"+id);\n\nw.find('button.refresh').click(function() {\n    w.replaceWith(widget('ide:bundle_untracked', { bundle: bundle }));\n});\n\nendpoint.schema('bundle').table('untracked_row').rows({\n}).then(function(untracked) {\n    widget.sync(untracked, w.find('.rows'), function(row) {\n        return widget('bundle_untracked_row_li', {\n            row: row\n        });\n    });\n});\n\nw.find('input.checkall').change(function() {\n    console.log('checkall');\n    if(this.checked) {\n        w.find('input.action').prop('checked',true);\n        w.find('span.actions').show();\n    } else {\n        w.find('input.action').prop('checked', false);\n        w.find('span.actions').hide();\n    }\n\n});\n\nw.find('button.ignore').click(function() {\n    var selected = [];\n    w.find('input.action:checked').each(function() {\n        selected.push($(this).closest('.bundle_untracked_row_li').data('row_id'));\n    });\n\n    w.append(widget('ide:modal', {\n        content: widget('ide:ignore_modal', {\n            rows: selected\n        })\n    }));\n\n    /*\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema('bundle').function('ignored_row_add', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            li.remove();\n        }).catch(function(e,o) {\n            alert('error ignoring row!');\n            console.log('error ignoring row: ', row_id, e,o);\n        });\n\n    */\n});\n\n\nw.find('button.track').click(function() {\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            schema_name,\n            relation_name,\n            pk_column_name,\n            pk_value\n        ]).then(function() {\n            li.remove();\n        }).catch(function(e,o) {\n            alert('error tracking row!');\n            console.log('error ignoring row: ', row_id, e,o);\n        });\n    });\n});\n\n\n\n\nw.find('button.delete').click(function() {\n    w.find('input.action:checked').each(function() {\n        var li = $(this).closest('.bundle_untracked_row_li');\n        var row_id = li.data('row_id');\n        var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n        var relation_name = row_id.pk_column_id.relation_id.name;\n        var pk_column_name = row_id.pk_column_id.name;\n        var pk_value = row_id.pk_value;\n\n        endpoint.schema(schema_name).table(relation_name).row(pk_column_name, pk_value)\n        .then(function(row) {\n            row.delete().then(function() {\n                li.remove();\n            }).catch(function(e,o) {\n                alert('error tracking row!');\n                console.log('error ignoring row: ', row_id, e,o);\n            });\n        })\n        .catch(function() {\n            alert('could not find row');\n        });\n    });\n});\n\n
b\\237=-B\\335\\225\\362\\263\\265H\\365\\206\\263\\204\\231\\273\\217K\\037e\\\\\\270\\0052)\\311\\301\\225\\241\\304\\365	list_item_path
b\\344(;\\033&\\234\\231\\2622/\\300\\377\\335\\005=n\\241\\355MS\\002!\\017\\3501\\374o5\\316oa	3a598b60-305d-4b23-8e01-855219b33ac2
b\\357\\357\\237\\031\\310I\\337h\\211\\230/xbaV\\354\\006b\\347z\\305\\237!2LZ\\342+;\\370\\003	bundle_import_fs
c\\177\\243\\217\\365\\231\\005\\002\\210\\020\\202\\310\\207\\237\\204\\344\\300\\341\\311\\027\\327\\220\\344udTr n`\\242\\213	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\n\nw.find('.close').click(function(e) {\n    w.trigger('close_tab', { tab_id: tab_id });\n    e.stopPropagation();\n});\n\nw.click(function() {\n    w.trigger('show_tab', { tab_id: tab_id });\n});
e\\012\\341a\\257i\\232\\215\\027\\352U\\345\\350B\\226\\\\U\\246^\\316\\034&\\2047\\265:\\011\\034\\243\\031\\245d	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('path') || row.get('id') }}\n</li>
e\\233\\031UJ\\314\\263\\362y\\212L+\\331\\250\\256X\\261 \\257(\\204\\002\\177\\310q\\350\\333\\341.\\257\\311\\373	<option id="{{= id }}" class="{{= name }}" value="{{= value }}" {{? typeof selected != 'undefined' && selected == true}}selected {{?}}>{{= label }}</option>\n\n
e\\244\\251\\222\\242\\271\\370\\203\\230\\024Ft\\236\\253A\\020;o\\261\\272\\253\\352x9\\316\\323\\014\\217\\231.'\\036	stage_dialog_unstaged_fields
e\\277M\\311.\\001\\205\\011\\322\\363`\\000\\276}\\354'y\\376}\\343\\322*\\014\\315V\\374\\310\\276\\3235\\011\\035	.{{= name }} {\n    cursor: pointer;\n    position: relative;\n}\n\n.{{= name }}:hover {\n    background-color: yellow;\n    color: black;\n}\n\n.debugger3_widget_highlight {\n    border: 4px solid yellow !important;\n}
f\\323{\\247\\376d\\233D_=\\357\\275\\330\\207\\300\\222\\255\\361\\037|\\211Hb,1\\010\\220\\203\\373\\007R\\220	<div id="{{= id }}" class="{{= name }}">\n    <h3>Export to Filesystem</h3>\n    \n    bundle directory: <input type='text' size=100 class='directory' value='/opt/aquameta/bundles-available/{{= bundle.get('name') }}'><br>\n    <button class='export'>export</button>\n</div>
h\\253~\\322\\353\\006\\254\\237\\213d\\365)\\352R\\325\\012D\\033\\252\\302\\343\\271\\202B\\330\\275\\341\\233[.\\005\\265	5b3d0629-48a8-4695-af58-52235349ae00
h\\315\\214L\\026\\251\\025]\\266J\\221\\243v\\264\\016\\341\\256\\306\\300\\020m\\347\\310\\302Y\\016\\272\\240\\354\\337\\324\\360	.{{= name }} {\n    border: 1px solid #999;\n    width: 100px;\n    background-color: #000;\n    padding-left: 5px;\n}\n\n.{{= name }} .close {\n    padding: 0px 5px;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n    cursor: pointer;\n}\n\n.{{= name }}.highlighted {\n    background-color: #0aa;\n}\n\n.{{= name }} span.close:hover {\n    background-color: red;\n    color: white;\n    cursor: pointer;\n}
hc7|\\032\\203c\\036\\207a\\\\N;\\025\\360\\276\\314I\\312\\372\\371AK\\354+\\325\\345\\371\\273|eX	var w = $("#"+id);\n\nvar bundles = endpoint.schema('bundle').table('bundle').rows({\n    order_by: {\n        column: 'name'\n    }\n})\nwidget.sync(bundles, w.find('.bundles'), function(bundle) {\n    return widget('bundle_selection', { bundle: bundle });\n});\n\nw.find('.bundles .select').on('click', function() {\n    w.trigger('bundle_selected', { bundle_name: w.find(':checked').val() });\n});\n\n\nw.find('.bundles .new').on('click', function() {\n    var name;\n    if (name = prompt('Enter bundle name')) {\n        endpoint.schema('bundle').table('bundle').insert({\n            name: name\n        }).then(function() {\n            w.replaceWith(widget('ide:bundle_selector'));\n        }).catch(function(e,o) {\n            console.log('error creating bundle: ', e, o);\n        });\n    }\n});\n\n\nw.find('.bundles button.import').click(function() {\n    w.append(widget('ide:modal', { content: widget('ide:bundle_import_fs') }));\n});\n\n\n\n\nw.find('.tabs .untracked').click(function() {\n    var untracked = endpoint.schema('bundle').table('untracked_row').rows();\n    w.find('.bundles').html(widget('ide:bundle_untracked_browser', { untracked: untracked }));\n\n    \n});
hw1\\002\\020\\255n\\264\\027\\322&\\366\\305\\226\\347\\200\\223k\\261#\\242\\376c\\371eFl\\321\\365\\221Zd	.{{= name }} {\n    display: flex;\n    flex-direction: row;\n    height: 100%;\n}\n\n.{{= name }}.detail_view > section.list {\n    flex: 1;\n}\n\n.{{= name }}.detail_view > section.detail {\n    flex: 2;\n}\n\n\n\n/* LIST */\n.{{= name }} > .list {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.{{= name }} > .list > ul {\n    flex: 9;\n    list-style: none;\n    overflow-y: auto;\n    padding: 0;\n    margin: 0;\n}\n\n.{{= name }}.detail_view > .list {\n    margin: 0;\n    background-color: #888;\n}\n\n.{{= name }}:not(.detail_view) > .list {\n    width: 80%;\n    margin: 0 auto;\n    background-color: none;\n}\n\n.{{= name }} > .list.collapsed {\n    width: 0;\n    display: none;\n}\n\n\n.{{= name }} > .list > .header {\n    flex: 1;\n    text-align: center;\n    border-bottom: 0.5rem solid rgba(0, 0, 100, 0.2);\n}\n\n.{{= name }}.detail_view > .list > .header {\n    flex: 0;\n    display: block;\n    text-align: center;\n}\n\n.{{= name }}.detail_view > .list > .header > .title {\n    font-size: initial;\n}\n\n.{{= name }} > .list > .header > .title {\n    display: inline-block;\n    font-size: x-large;\n    margin-bottom: 1rem;\n}\n\n.{{= name }} > .list > .header > .arrow {\n    display: inline-block;\n    margin: 0 0.5rem;\n    font-size: x-large;\n    vertical-align: sub;\n    \n    transform: rotate(270deg);\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    -moz-transform: rotate(270deg);\n    \n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }} > .list > .header > .arrow.up {\n    transform: rotate(90deg);\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    -moz-transform: rotate(90deg);\n}\n\n.{{= name }}.detail_view > .list > .header > .arrow {\n    font-size: initial;\n    vertical-align: middle;\n}\n\n.{{= name }} > .list > .header > .continue.hide {\n    display: none;\n}\n\n.{{= name }} > .list > .header > .continue {\n    position: relative;\n    width: 25%;\n    padding: 0.75rem;\n    \n    font-size: medium;\n    border: 2px solid darkgreen;\n    border-radius: 0.1rem;\n    color: #ddd;\n    background-color: green;\n}\n\n.{{= name }} > .list > .header > .continue:hover {\n    background-color: darkgreen;\n}\n\n.{{= name }} > .list > .header > .continue:active {\n    top: 1px;\n    background-color: lightgreen;\n}\n\n.{{= name }}.detail_view > .list > .header > button {\n    margin: 1rem auto;\n}\n\n.{{= name }} > .list > .header > button:first-child {\n    margin-left: 2rem;\n}\n\n.{{= name }} > .list > .header > button {\n    margin: 1rem 0;\n}\n\n.{{= name }} > .list > .header > .options {\n    display: inline-block;\n    width: 60%;\n    text-align: left;\n    padding: 0 1rem 1rem;\n}\n\n.{{= name }}.detail_view > .list > .header > .options {\n    width: 100%;\n}\n\n.{{= name }} > .list > .header > .arrow:not(.up) ~ .options {\n    display: none;\n}\n\n.{{= name }} > .list > .header > .options > .search {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > .list > .header > .options > .search:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > .list > .header > .options > .search:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}\n\n\n\n/* DIVIDER */\n.{{= name }}:not(.detail_view) > .divider {\n    display: none;\n}\t\n\n.{{= name }}.detail_view > .divider {\n    padding: 0.25rem;\n    background-color: #333;\n\tcursor: w-resize;\n    pointer: w-resize;\n}\n\n.{{= name }}.detail_view > .divider > span {\n    display: inline-block;\n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }} > .list.collapsed + .divider {\n    cursor: e-resize;\n    pointer: e-resize;\n}\n\n.{{= name }} > .list.collapsed + .divider > span {\n    transform: rotate(180deg);\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    -moz-transform: rotate(180deg);\n}\n\n.{{= name }} > .divider:hover {\n    background-color: #666;\n}\n\n.{{= name }} > .divider:active {\n    background-color: #888;\n}\n\n\n\n/* DETAIL */\n.{{= name }}.detail_view > .detail {\n    padding: 0 1rem 1rem;\n    /* padding: 1rem; */\n}\n
j\\026\\241\\310\\240\\207\\035\\271\\330\\200\\354\\011\\252\\010\\251Q\\257\\364\\252\\330\\244\\315\\364\\001\\262q)\\250\\233v\\027\\310	33e64e6d-87ec-4598-882d-1c5a7560082a
j\\206\\027\\224T\\177J\\256)U\\252_\\245\\354:s\\230@\\341H\\230U\\230\\371\\225-\\236\\351j,\\336\\177	var w = $("#"+id);\n\nw.find('button.upload').click(function () {\n    const reader = new FileReader()\n    const file = w.find('.fileUpload').get(0).files[0];\n    \n    reader.onload = event => {\n        const { name, size, type } = file\n        const dataURL = event.target.result\n        const content = dataURL.replace(/^data:.+;base64,/, '');\n        \n        endpoint.schema('endpoint').table('mimetype_extension').row({\n            where: {\n                name: 'extension',\n                op: '=',\n                value: name.split('.').pop()\n            }\n        }).then(function(ext) {\n            const mimetype_id = ext.get('mimetype_id') || '';\n            endpoint.schema('endpoint').table('resource_binary').insert({\n                path: w.find('input.path').val(),\n                content: content,\n                mimetype_id: mimetype_id\n            }).then(result => {\n                alert('success.');\n                console.log('file saved')\n            }).catch(error => {\n                alert('file upload no worky\\n' + error)\n            })\n        });\n    }\n    reader.readAsDataURL(file)\n});\n\nw.find('.fileUpload').change(function() {\n    if (w.find('input.path').val() == '') {\n        var filename = w.find('input.fileUpload').val().split('\\\\').pop();\n        w.find('input.path').val('/'+bundle.get('name')+'/'+filename);\n    }\n});
j\\373\\\\.\\201z\\316\\266z\\337\\021\\313y`\\374\\234^\\367\\032\\2463]\\033\\233\\276\\317\\030S\\265\\271\\213\\275	<div id="{{= id }}" class="{{= name }}">\n    <h1>template: <span class='name'></span></h1>\n    \n    <div class='actions' style='float: right'>\n        <button class='delete_template'>delete template</button>\n    </div>\n    \n    <h3>Routes</h3>\n    <div class='routes'></div>\n    \n    <h3>Content</h3>\n    <button class='content_save'>save</button>\n    <div class='content'></div>\n</div>
kI?\\011\\006\\371\\376\\331\\220x7\\005=\\204e\\204G\\206\\342\\027c;\\177d\\244\\324\\364w\\336\\246\\346\\273	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n \n * join_table:\n * join_from_column:\n * join_to_column:\n \n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar join_rows;\nvar where_object = {};\nwhere_object[join_from_column] = from_row.get(from_column);\nfunction show_list() {\n    \n    w.find('.join_rows').empty();\n    \n    join_rows = endpoint.schema(join_table.schema.name).table(join_table.name).rows().where(where_object);\n    \n    widget.sync(join_rows, w.find('.join_rows'), function(row) {\n        return widget('sem_fkey_many_to_many_li', { \n            row: row,\n            label_function: label_function\n        });\n    });\n}\n
k\\206\\262s\\3774\\374\\341\\235k\\200N\\377Z?WG\\255\\244\\352\\242/\\035I\\300\\036R\\335\\267\\207[K	1
l\\007\\035s,\\207\\023`*\\251=\\376@\\256\\035\\243~\\366\\271j!\\375\\350\\366\\360\\234\\351\\333?\\275\\012\\261	list_view_gateway
l\\202\\364\\034z\\035\\211\\243T\\350\\303\\234\\327_Y\\357?\\276D\\\\,\\372Il]D\\222\\251*\\023Q\\240	757f5d27-b98c-4e03-9b9a-68457402456d
mA=}`Y\\022\\031\\336\\335\\276>=\\276\\277\\246\\025\\202Iy+\\332\\352S\\3673A\\227\\234I\\035\\177	bundle_export
m\\000|\\021%jK7\\010\\026I\\371=+\\372\\353\\027\\326\\316,\\210\\347\\021g\\356\\306\\373\\372\\314\\022\\357$	11f0af38-f0b0-4fbe-8618-3ba3d6688e75
n\\370v\\310y\\035\\256\\306\\371|\\263\\264~\\3262\\272\\265\\365kt\\276\\343\\376\\320v\\036\\227\\343\\254\\372K\\302	<div id="{{= id }}" class="{{= name }}">\n    <p>{{= widget('semantics/form_field', row.field('name')) }}</p>\n    <div class="top">\n        <div class="sections">\n            <div class="section code selected">code</div>\n            <div class="section data">data</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="save">Save</button>\n                <button class="copy">Copy</button>\n                <button class="delete">Delete</button>\n            </div>\n            <div class="tabs"></div>\n        </div>\n    </div>\n</div>
o\\005c\\321\\223HYsC\\312,\\\\j\\242\\273}\\321\\234bC\\254\\336y4\\002=\\362_"\\322\\023\\346	50d541d0-91d8-4d23-8a16-ef99261ae323
o\\3259g\\200\\320m\\360*\\0035\\342&"\\014H\\272!\\304g\\012u\\377\\377\\357\\363y\\234 z\\005\\225	8ed1284f-340f-4d28-885c-2efea81c7b7e
p\\007T9mR\\013h\\211\\005\\343)3\\223\\035\\0324\\325\\\\\\207\\036\\366\\372ch\\034\\265!R\\233\\262\\230	<div id="{{= id }}" class="{{= name }}">\n    <span class='field_name'></span><button class='unstage'>unstage</button>\n</div>
r\\232\\252\\244e\\032x7\\303DHwu\\245\\264!\\230\\347>\\230\\312{\\275\\371X:\\302\\325\\243V\\303\\352	row_detail_widget
r\\370*\\303\\220JGW3"q@1sm\\003.\\246\\356\\200j'\\300P]\\225\\007\\263\\\\\\334\\312\\376	editable_field_fkey_select
sP\\272\\215/#\\251\\272\\337\\256\\313\\263S\\362\\345\\233"\\321\\017\\220R\\256\\357\\345AM,t\\323k("	<div id="{{= id }}" class="{{= name }}">\r\n</div>
s\\314\\263\\257\\026<\\241Yi\\370\\257\\355\\037\\333\\207\\363\\304\\354\\037\\325T\\336*"\\314\\333\\253\\256\\031\\222\\347\\004	new_row_use_copy_instead
t#N\\230\\257\\347I\\217\\265\\332\\361\\363j\\302\\327\\212\\3143\\224d\\371Pp;\\214\\001\\230\\222\\371\\202\\271\\013	null
t\\204\\312\\236\\375*\\310q\\332>\\221\\321\\216t8Z\\354\\3631\\277\\032'\\271\\035\\213\\322\\243\\237\\356\\031\\334\\251	var w = $("#"+id);\n\n////////////////////////////////////////////////////////////////////\n// clearable timeout - http://stackoverflow.com/questions/5226578/check-if-a-timeout-has-been-cleared\n////////////////////////////////////////////////////////////////////\n\nfunction Timeout(fn, interval, scope, args) {\n    scope = scope || window;\n    var self = this;\n    var wrap = function(){\n        self.clear();\n        fn.apply(scope, args || arguments);\n    }\n    this.id = setTimeout(wrap, interval);\n}\n\n\nTimeout.prototype.id = null\nTimeout.prototype.cleared = false;\nTimeout.prototype.clear = function () {\n    clearTimeout(this.id);\n    this.cleared = true;\n    this.id = null;\n};\n\n////////////////////////////////////////////////////////////////////\n// draw the tree\n////////////////////////////////////////////////////////////////////\n\nfunction draw_tree() {\n    if (timer && !timer.cleared) {\n        timer.clear();\n    }\n\n    \n    var widget_tree = get_widget_tree($('body')[0]);\n    var agg_tree = get_aggregate_widget_tree(widget_tree);\n\n    var c = w.find('.tree_container').empty();\n    for (var widget_name in agg_tree) {\n\n        c.append(widget('debugger3_widgets_tree', { \n            widget_name: widget_name,\n            properties: agg_tree[widget_name],\n            depth: 0\n        }));\n    }\n}\n\nfunction delayed_redraw(e, payload) {\n    var widg = payload.widget.get(0);\n    // don't redraw for any debugger widget loadings\n    if (widg.className.indexOf('debugger3_widgets_tree') != -1) return;\n    \n    if (!timer || timer.cleared) {\n        // console.log('setting up delayed redraw....'+widg.className);\n        timer = new Timeout(draw_tree, 100);\n    }\n    else { \n        // console.log('.....no go on '+widg.className); \n    }\n}\n\nvar timer = false;\ndraw_tree();\n$(document).bind('widget_loaded', delayed_redraw);\n\n\n\n/////////////////////////////////////////////////////////////////////\n// show all\n/////////////////////////////////////////////////////////////////////\n\nw.find('div.show_all').bind('mouseover', function(e) {\n    $("[data-widget]").addClass('debugger3_widget_highlight');\n    e.stopPropagation();    \n}).bind('mouseout', function(e) {\n    $("[data-widget]").removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n
u\\314\\201\\3500U\\022\\345\\356?\\237\\017\\226\\245c\\022&eG\\3130\\326~\\177\\232U(\\311u\\247r\\335	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.stage').click(function() {\n    endpoint.schema('bundle').function('stage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function(e, o) {\n        console.log(e, o);\n        w.trigger('reload_stage_dialog');\n    })\n    .catch(function() {\n        alert('stage failed');\n        console.error('stage failed');\n    });\n    \n});\n
v\\336\\243;_\\315\\372\\257\\376i\\371\\010\\037\\034\\333\\222\\223\\332\\375\\212\\273Z\\221\\251\\373;YU\\365\\257y 	.{{= name }} {\n    width: 100%;\n    height: 1.5rem;\n    color: white;\n    text-align: center;\n    \n    background-color: white;\n    visibility: visible;\n    opacity: 1;\n    \n    -webkit-transition:\n        background-color 500ms,\n        opacity 1s 1s,\n        visibility 0s 2s;\n}\n\n.{{= name }}.fade {\n    opacity: 0;\n    visibility: hidden;\n}\n\n.{{= name }}.success,\n.{{= name }}.good {\n    background-color: green;\n}\n\n.{{= name }}.fail,\n.{{= name }}.failed,\n.{{= name }}.bad {\n    background-color: red;\n}
vi\\354v\\037\\246\\270\\212\\216\\214\\333\\003\\241\\355\\203\\207\\246\\253\\301\\325z\\035CX\\272K\\337\\264\\223"T\\320	89a4a72e-cd33-4a0d-b9fe-3d37020b62da
w\\205\\001+'\\213\\011o\\033jI\\2107N\\327m\\236\\301\\015uS\\015\\013\\247#v\\320%\\006\\011F\\024	.{{= name }} {\n    display: inline-block;\n    padding: 0 1rem;\n}
w\\206Vx\\232\\2121\\210)\\310rJ\\375\\221]=\\010xU\\205\\353$#\\344\\261\\032\\277\\215-\\3342!	workspace_tabs
x\\2552-D%\\001\\034Ig\\325\\012p\\310\\267\\350\\031\\212\\015\\231\\251\\213&{gb\\222b\\332F\\325\\370	list_item_with_edit_button
y0}\\003M\\317\\252r\\343\\326)E0Q\\225\\3033\\020q\\311\\254\\027\\277\\234\\220\\226\\220N>fQ\\224	var w = $("#"+id);\n\nvar remotes = bundle.related_rows('id','bundle.remote','bundle_id');\n\nwidget.sync(remotes, w.find('.remotes'), function(remote) {\n    return widget('ide:bundle_remote', { remote: remote });\n});\n\nw.find('.new_remote').click(function() {\n    w.append(widget('ide:modal', { content: widget('ide:bundle_remote_new', { bundle: bundle }) }));\n});
y\\253(\\215\\365\\310A\\241'F\\345\\270I\\023\\370\\305{\\274Qd,\\224'\\260\\360w\\016\\250\\321mY\\020	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar append_new_widget = function() { \n    \n    alert('New widget still loading...\\nTry again in a moment'); \n    \n}\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\n\n// Find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    schema_name: to_relation.schema.name,\n    name: to_relation.name\n}).result(function(to_relation_obj) {\n\n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n\n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n    \n    append_new_widget = function() {\n        \n        w.append(\n            widget('modal_overlay', {\n                content: widget(new_row_widget, { \n                    relation: to_relation_obj,\n                    context_data: context_data\n                })\n            })\n        );\n        \n    }\n\n\n});\n\n\n// Prevent reload tab triggered by 'sem_list_item_new'\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n});\n\n\n// When new_row_widget returns...\nw.on('new_row', function(e, payload) {\n    \n    select_row(payload.new_row);\n    \n});\n\n\n// When a row is selected...\nfunction select_row(row) {\n    \n    if (row == 'new') {\n        \n        append_new_widget();\n        \n    }\n    \n    else if (row == 'none') {\n\n        from_row.set(from_column, null);\n        from_row.update().done(function() {\n\n            console.log('Fkey deleted');\n            w.trigger('fkey_deleted');\n            w.trigger('done');\n\n        });\n        \n    }\n    \n    else {\n        \n        from_row.set(from_column, row.get(to_column));\n        from_row.update().done(function() {\n\n            console.log('Fkey updated');\n            w.trigger('fkey_updated', row);\n            w.trigger('done');\n\n        });\n        \n    }\n    \n    \n}\n\n\n// Prepare autocomplete\norder_by_function(to_relation.rows()).done(function(rows) {\n    \n    var ps2 = Array();\n    var start = 0;\n    \n    ps2.push({\n        value: '[ none ]',\n        data: 'none'\n    });\n    \n    ++start;\n    \n    if (new_enabled) {\n        ps2.push({\n            value: '[ new ]',\n            data: 'new'\n        });\n        \n        ++start;\n    }\n    \n    for (var i = 0; i < rows.length; i++) {\n        \n        ps2[start + i] = { value: label_function(rows[i]), data: rows[i] }\n        \n    }\n\n\n    w.find('.autocomplete').autocomplete({\n        lookup: ps2,\n        appendTo: '.results',\n        onSelect: function (suggestion) {\n            //alert('You selected: ' + suggestion.value + ', ' + suggestion.data);\n            select_row(suggestion.data);\n\n        }\n    });  \n    \n    load_complete();\n});\n\nfunction load_complete() {\n    \n    w.find('.loading').hide();\n    w.find('.loaded').show();\n    console.log('Ready for autocomplete');\n    \n}
z\\305\\322{\\011\\253\\224\\203\\000\\001\\023\\323I2:\\273\\002)=\\265\\363\\330x\\225\\207\\025\\340\\247_\\003=\\205	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id')\n    .html(widget('semantics/text_identifier', real_row))\n    .click(function() {\n        w.trigger('bundle_row_open', {\n            row_id: change.get('row_id'),\n            row: real_row\n        });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n// stage button\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                w.remove();\n            }).catch(function(e) {\n                console.error(e);\n            });\n            break;\n        case 'same':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                w.remove();\n            }).catch(function(e) {\n                console.error(e);\n            });\n            break;            \n        case 'deleted':\n            console.log('not implemented yet');\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});
{\\327\\346\\000+:>+\\0200\\350:P\\012\\304\\276\\340\\004\\011(BH\\2130"\\020\\261\\223y\\011?\\030	<div id="{{= id }}" class="{{= name }}">\n    <section class='list'>\n        <div class='header'>\n            <p class='title toggle_options'></p>\n            <span class='arrow toggle_options'>&#10094;</span>\n            <button class='continue hide'>Continue</button>\n            <br>\n            <div class='options hide'>\n                <button class='new'>New row</button>\n                <br>\n                <input class='search' type='text' placeholder='Search'>\n            </div>\n        </div>\n        <ul></ul>\n    </section>\n    <section class='divider'><span>&#10094;</span></section>\n    <section class='detail'></section>\n</div>
{eBX\\013\\336\\247\\337\\013\\207\\342{\\331\\247KM\\010\\273O\\256\\257j\\037h0\\254\\363\\305\\241\\244\\306\\364	jQuery.closestDescendent
{u\\221\\\\O\\313\\216\\033|\\243d\\006\\341\\036z\\366\\325\\3162~\\234M\\252\\262\\343!\\310y\\377\\243\\340\\336	var w = $('#'+id);\n\nif (typeof field.value == 'object')\n    field.value = JSON.stringify(field.value);\n\nvar editor = CodeMirror(w.get(0), {\n    value: field.value,\n    mode:  language,\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\n\nw.data('codemirror', editor);\n\nfunction change_handler(doc) {\n    field.set(doc.getValue());\n    w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor.on('change', change_handler);\n\n/*\nw.data('disable_code_change_evt', function() { editor.off('change',change_handler); });\nw.data('enable_code_change_evt', function() { editor.on('change',change_handler); });\nw.trigger('code_changed', { codemirror: editor, field: field });\n*/
|t\\307 \\342\\027\\360x\\010?\\352w\\203\\341q\\202n\\210\\345+\\326r\\257Q\\370\\005Q~,\\215\\266\\347	new_row_dialog
}\\222'\\353\\244\\267Z\\222\\236\\201D\\334\\\\\\207\\257\\006\\037\\224\\034\\015\\014e@\\224U\\261\\231\\226\\012T%\\223	f7fb9714-3d99-444d-8b5f-d546ae354637
}\\347'\\346\\342E\\203\\250\\262\\263Oum\\203\\367*\\204\\275\\320O(\\237\\375\\237D\\213I\\0278\\027\\322\\321	81be0e52-9712-42d6-a1c1-fa773db591c1
}\\353z\\225\\036\\303\\270\\025s\\247\\277\\0367^XKDL\\033\\337L\\365\\374\\202\\007\\010\\306c\\272W\\262\\222	ide
~\\226>\\344h\\337\\273b\\337na\\265\\251\\334\\210\\244\\334\\261\\023\\314\\253\\352{\\276\\273\\003V\\366Y4\\376\\034	var w = $('#'+id);\n\nvar synced = false;\nw.on('click', function(e) {\n    \n    e.stopPropagation();\n\n    w.toggleClass('expanded');\n    w.find('.empty').addClass('hide');\n\n    if (!synced) {\n\n        rows_function()\n        .then(function(rows) {\n            \n            if (!rows.length) { return empty_result(); }\n                \n            synced = true;\n            widget.sync(rows, w.find('.list'), function(row) {\n                return widget('semantics/list_item', row);\n            });\n        })\n        .catch(empty_result);\n\n    }\n});\n\nfunction empty_result() {\n    setTimeout(function() {\n        w.removeClass('expanded');\n        w.find('.empty').removeClass('hide');\n        synced = false;\n    }, 500);\n}\n
