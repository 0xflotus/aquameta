\\x00a6604f711b3951a9c9b92ad213f1ef9ed7907a4736df15c89b1748038e4b63	793960f9-5522-499b-a36e-144f80c8a741
\\x00a6604f711b3951a9c9b92ad213f1ef9ed7907a4736df15c89b1748038e4b63	793960f9-5522-499b-a36e-144f80c8a741
\\x00a6604f711b3951a9c9b92ad213f1ef9ed7907a4736df15c89b1748038e4b63	793960f9-5522-499b-a36e-144f80c8a741
\\x00a6604f711b3951a9c9b92ad213f1ef9ed7907a4736df15c89b1748038e4b63	793960f9-5522-499b-a36e-144f80c8a741
\\x01d77afe570be5cd922566a8e8e5ff47ac697884b293e8402172d79263875b9e	<span id="{{= id }}" class="{{= name }}">\n\tlist_item_identifier\t\n</span>\n
\\x01d77afe570be5cd922566a8e8e5ff47ac697884b293e8402172d79263875b9e	<span id="{{= id }}" class="{{= name }}">\n\tlist_item_identifier\t\n</span>\n
\\x03126132feebd323b61bf18fe2017dc5ef13dd17fd386510fde8e7930df6c429	.{{= name }} {\n    display: inline-block;\n    height: 100%;\n}\n\n.{{= name }} > .dropdown {\n    display: none;\n    position: absolute;\n    z-index: 5;\n    top: 1.5rem;\n    right: 0;\n    background-color: black;\n    opacity: 0.9;\n    border-bottom: 0.25rem solid #333;\n    border-left: 0.25rem solid #333;\n}\n\n.{{= name }} > .dropdown > div {\n    width: 100%;\n    padding: 1rem;\n    text-align: left;\n    color: white;\n}\n\n.{{= name }}:hover > .dropdown {\n    display: block;\n}\n\n.{{= name }} > .dropdown > .logout {\n    cursor: pointer;\n}\n\n.{{= name }} > .dropdown > .logout:hover {\n    background-color: #333;\n}\n\n.{{= name }} > .dropdown > .logout:active {\n    background-color: #666;\n}\n
\\x03126132feebd323b61bf18fe2017dc5ef13dd17fd386510fde8e7930df6c429	.{{= name }} {\n    display: inline-block;\n    height: 100%;\n}\n\n.{{= name }} > .dropdown {\n    display: none;\n    position: absolute;\n    z-index: 5;\n    top: 1.5rem;\n    right: 0;\n    background-color: black;\n    opacity: 0.9;\n    border-bottom: 0.25rem solid #333;\n    border-left: 0.25rem solid #333;\n}\n\n.{{= name }} > .dropdown > div {\n    width: 100%;\n    padding: 1rem;\n    text-align: left;\n    color: white;\n}\n\n.{{= name }}:hover > .dropdown {\n    display: block;\n}\n\n.{{= name }} > .dropdown > .logout {\n    cursor: pointer;\n}\n\n.{{= name }} > .dropdown > .logout:hover {\n    background-color: #333;\n}\n\n.{{= name }} > .dropdown > .logout:active {\n    background-color: #666;\n}\n
\\x0364b9327e9f6db8a4cc665b66a4785186c379322e2d69affbdf29bf392f6872	3.21
\\x0364b9327e9f6db8a4cc665b66a4785186c379322e2d69affbdf29bf392f6872	3.21
\\x03bf25c98d457711c1e8a7ee3788df5650f2a77532db338bcfdbe740465b6271	fae0b7d9-080e-4637-90dc-95a75a74af02
\\x03bf25c98d457711c1e8a7ee3788df5650f2a77532db338bcfdbe740465b6271	fae0b7d9-080e-4637-90dc-95a75a74af02
\\x03d450c88b7375af114af9193638260f8623b418738a0521ff2e6a626cd33c69	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('name') || row.get('id') }}<button class='edit'>Edit</button>\n</li>
\\x03d450c88b7375af114af9193638260f8623b418738a0521ff2e6a626cd33c69	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('name') || row.get('id') }}<button class='edit'>Edit</button>\n</li>
\\x04032455b62fcdb2252b66d4e525ed36c5a7e2dc704f0a6c8db0268c3f5f72a1	<section id="{{= id }}" class="{{= name }}">\n    <header>\n        <nobr>\n            <a href="/dev">a q u a m e t a</a>\n        </nobr>\n        <h1><span class='title'></span></h1>\n    </header>\n\n    <div class="content">\n        <div class='row_list_section'/>\n        <div class='workspace_section'/>\n    </div>\n    \n    <footer>\n        Aquameta\n    </footer>\n</section>
\\x05aa513b891bbe3734cb3032f038e4aeb1ad7b291350bac2edb16c96159ad711	sem_fkey_select
\\x05aa513b891bbe3734cb3032f038e4aeb1ad7b291350bac2edb16c96159ad711	sem_fkey_select
\\x05d53f52c425e2a2d9c91a9ab369e21cfd547a49609e614e16332d90d52fc29d	54461126-acc3-4f77-a3ab-e2b89045828c
\\x05d53f52c425e2a2d9c91a9ab369e21cfd547a49609e614e16332d90d52fc29d	54461126-acc3-4f77-a3ab-e2b89045828c
\\x05d53f52c425e2a2d9c91a9ab369e21cfd547a49609e614e16332d90d52fc29d	54461126-acc3-4f77-a3ab-e2b89045828c
\\x05d53f52c425e2a2d9c91a9ab369e21cfd547a49609e614e16332d90d52fc29d	54461126-acc3-4f77-a3ab-e2b89045828c
\\x0730d16d3355e0797bef6aa38585aab32853a6957ffc4b4b88a54842f043368a	.{{= name }} {\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    \n   \tcursor: pointer;\n  \topacity: 0.95;\n    z-index: 10;\n    overflow: auto;\n    \n  \tbackground-color: black;\n    color: white;\n    font-size: initial;\n    text-align: center;\n}\n\n.{{= name }} > .content {\n    display: inline;\n    cursor: auto;\n}\n
\\x0730d16d3355e0797bef6aa38585aab32853a6957ffc4b4b88a54842f043368a	.{{= name }} {\n    position: fixed;\n    width: 100%;\n    height: 100%;\n    top: 0;\n    left: 0;\n    \n   \tcursor: pointer;\n  \topacity: 0.95;\n    z-index: 10;\n    overflow: auto;\n    \n  \tbackground-color: black;\n    color: white;\n    font-size: initial;\n    text-align: center;\n}\n\n.{{= name }} > .content {\n    display: inline;\n    cursor: auto;\n}\n
\\x073c1634c496cdb649d1afe0a312bbb4b7e1741b271542e4a436c3b8824b1761	status
\\x073c1634c496cdb649d1afe0a312bbb4b7e1741b271542e4a436c3b8824b1761	status
\\x07b81c31ef33ebbc74dbb4a308e0b5c350da8a14a409e0e0afbc657311f67047	89fb8792-4291-4712-b470-6ff89a016f4a
\\x07b81c31ef33ebbc74dbb4a308e0b5c350da8a14a409e0e0afbc657311f67047	89fb8792-4291-4712-b470-6ff89a016f4a
\\x080cc193da25c469a35fe9796dd9a11f381c97d69bb5a0d6cd94be5749d86ceb	6702454c-5f3c-4dd1-8b74-f854fad327ae
\\x080cc193da25c469a35fe9796dd9a11f381c97d69bb5a0d6cd94be5749d86ceb	6702454c-5f3c-4dd1-8b74-f854fad327ae
\\x083a2768f5179d96f11b892b4bb9159fc6e1fbd015acedc99830778a855ddc49	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}
\\x083a2768f5179d96f11b892b4bb9159fc6e1fbd015acedc99830778a855ddc49	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}
\\x083a2768f5179d96f11b892b4bb9159fc6e1fbd015acedc99830778a855ddc49	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}
\\x083a2768f5179d96f11b892b4bb9159fc6e1fbd015acedc99830778a855ddc49	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}
\\x083a2768f5179d96f11b892b4bb9159fc6e1fbd015acedc99830778a855ddc49	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}
\\x083a2768f5179d96f11b892b4bb9159fc6e1fbd015acedc99830778a855ddc49	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}
\\x09787c47226922e272b3b97467749131b99227185fc322133d8d6ad5eec5b9fc	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .title {\n    padding: 1.5rem 0;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .title > span:nth-child(2) {\n    padding: 0 1rem;\n    font-size: 1rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\x09787c47226922e272b3b97467749131b99227185fc322133d8d6ad5eec5b9fc	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .title {\n    padding: 1.5rem 0;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .title > span:nth-child(2) {\n    padding: 0 1rem;\n    font-size: 1rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\x09b94bd3b76ff8f60030c57ccf93148637af21c8c4e31975e335eff8e4c7bf74	commit_dialog_changed_row
\\x09b94bd3b76ff8f60030c57ccf93148637af21c8c4e31975e335eff8e4c7bf74	commit_dialog_changed_row
\\x0b234982b8a26ebbe6ee960838610c1e88e0bb5617b746432c865f0da70c409f	var w = $("#"+id);\n\nw.css('padding-left', depth+'em');\n\nfunction get_ids() {\n    var ids = '';\n    if (properties.ids.length > 0)\n        ids = '#'+properties.ids.join(',#');\n    return ids;\n}\n\nw.bind('mouseover', function(e) {\n    $(get_ids()).addClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\nw.bind('mouseout', function(e) {\n    $(get_ids()).removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n// recurse for each child\nfor (var child_name in properties.children) {\n    var child = properties.children[child_name];\n\n    w.after(widget('debugger3_widgets_tree', { \n        widget_name: child_name,\n        properties: child,\n        depth: depth+1\n    }));\n}\n\n// launches the widget editor in a modal, editing the specified widget\nfunction edit_widget_by_name(widget_name) {\n    endpoint.schema('widget').table('widget').row('name', widget_name).then(function(widget_row) {\n        $('body').append(\n            widget('modal', { \n                content: widget('row_detail_widget', { row: widget_row })\n            })\n        );\n    });\n}\n\nw.click(function(e) {\n    e.stopPropagation();\n    edit_widget_by_name(widget_name);\n});\n\n\n
\\x0b234982b8a26ebbe6ee960838610c1e88e0bb5617b746432c865f0da70c409f	var w = $("#"+id);\n\nw.css('padding-left', depth+'em');\n\nfunction get_ids() {\n    var ids = '';\n    if (properties.ids.length > 0)\n        ids = '#'+properties.ids.join(',#');\n    return ids;\n}\n\nw.bind('mouseover', function(e) {\n    $(get_ids()).addClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\nw.bind('mouseout', function(e) {\n    $(get_ids()).removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n// recurse for each child\nfor (var child_name in properties.children) {\n    var child = properties.children[child_name];\n\n    w.after(widget('debugger3_widgets_tree', { \n        widget_name: child_name,\n        properties: child,\n        depth: depth+1\n    }));\n}\n\n// launches the widget editor in a modal, editing the specified widget\nfunction edit_widget_by_name(widget_name) {\n    endpoint.schema('widget').table('widget').row('name', widget_name).then(function(widget_row) {\n        $('body').append(\n            widget('modal', { \n                content: widget('row_detail_widget', { row: widget_row })\n            })\n        );\n    });\n}\n\nw.click(function(e) {\n    e.stopPropagation();\n    edit_widget_by_name(widget_name);\n});\n\n\n
\\x0b89118d2fe5c31f13d95176dba7ecdc7eb9ebeaaf8d28e28b14a68f337c9276	d1874571-9b11-4ecf-a65d-454de53683b7
\\x0b89118d2fe5c31f13d95176dba7ecdc7eb9ebeaaf8d28e28b14a68f337c9276	d1874571-9b11-4ecf-a65d-454de53683b7
\\x0b89118d2fe5c31f13d95176dba7ecdc7eb9ebeaaf8d28e28b14a68f337c9276	d1874571-9b11-4ecf-a65d-454de53683b7
\\x0b89118d2fe5c31f13d95176dba7ecdc7eb9ebeaaf8d28e28b14a68f337c9276	d1874571-9b11-4ecf-a65d-454de53683b7
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0ba9b693da6b2dbb83cee744e953ac5cb5f3d2cb93a4a0550b607a7fdcca02c2	.{{= name }} {\n}
\\x0e00937fe9c342742e72e9d153d811e309f4f53c94e4d80f3c751bf9562bd9f4	var w = $("#"+id);\n\n\nfor (var i=0;i<stage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:commit_dialog_staged_field', {\n        field: stage_field_changes[i],\n        old_val: stage_field_changes_old_vals[i],\n        new_val: stage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}
\\x0e00937fe9c342742e72e9d153d811e309f4f53c94e4d80f3c751bf9562bd9f4	var w = $("#"+id);\n\n\nfor (var i=0;i<stage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:commit_dialog_staged_field', {\n        field: stage_field_changes[i],\n        old_val: stage_field_changes_old_vals[i],\n        new_val: stage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}
\\x0e45216c1a8e7efbd319887eea33cd6406e2c819154379307aa1c04a712fa0a9	<div id="{{= id }}" class="{{= name }}">\n    <div class='loading'>Loading...</div>\n    <div class='loaded hide'>\n        <input type="text" class="autocomplete" placeholder='Text search'/>\n        <button class="cancel">Cancel</button>\n        <div class='results'></div>\n    </div>\n</div>
\\x0e45216c1a8e7efbd319887eea33cd6406e2c819154379307aa1c04a712fa0a9	<div id="{{= id }}" class="{{= name }}">\n    <div class='loading'>Loading...</div>\n    <div class='loaded hide'>\n        <input type="text" class="autocomplete" placeholder='Text search'/>\n        <button class="cancel">Cancel</button>\n        <div class='results'></div>\n    </div>\n</div>
\\x1046d4df2c53d2eb490738489bb3c64546cd081dec2c3aaae91430a1c624e10d	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    \n    border-top: 1px solid #333;\n}\n\n.{{= name }}.expanded {\n    background-color: #333;\n    color: #aaa;\n}\n\n.{{= name }}:not(.expanded):hover {\n    background-color: #666;\n}\n\n.{{= name }}:not(.expanded):active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }} > .arrow {\n    display: inline-block;\n    margin: 0 0.5rem;\n    font-size: x-large;\n    vertical-align: sub;\n    \n    transform: rotate(270deg);\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    -moz-transform: rotate(270deg);\n    \n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }}.expanded > .arrow {\n    transform: rotate(90deg);\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    -moz-transform: rotate(90deg);\n}\n\n.{{= name }} > .empty {\n    display: block;\n    text-align: center;\n}\n\n.{{= name }} > .empty.hide {\n    display: none;\n}\n\n.{{= name }}:not(.expanded) > .list {\n    display: none;\n}\n
\\x1046d4df2c53d2eb490738489bb3c64546cd081dec2c3aaae91430a1c624e10d	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    \n    border-top: 1px solid #333;\n}\n\n.{{= name }}.expanded {\n    background-color: #333;\n    color: #aaa;\n}\n\n.{{= name }}:not(.expanded):hover {\n    background-color: #666;\n}\n\n.{{= name }}:not(.expanded):active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }} > .arrow {\n    display: inline-block;\n    margin: 0 0.5rem;\n    font-size: x-large;\n    vertical-align: sub;\n    \n    transform: rotate(270deg);\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    -moz-transform: rotate(270deg);\n    \n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }}.expanded > .arrow {\n    transform: rotate(90deg);\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    -moz-transform: rotate(90deg);\n}\n\n.{{= name }} > .empty {\n    display: block;\n    text-align: center;\n}\n\n.{{= name }} > .empty.hide {\n    display: none;\n}\n\n.{{= name }}:not(.expanded) > .list {\n    display: none;\n}\n
\\x14be4b45f18e0d8c67b4f719b5144eee88497e413709d11d85b096d8e2346310	0.1
\\x14be4b45f18e0d8c67b4f719b5144eee88497e413709d11d85b096d8e2346310	0.1
\\x14cf8b4011ab08d78b9bfd12a5fdc1979f8f185da80186cac56ee8008bbe7a24	a88f985c-48c3-4f25-bb95-05901e4fff54
\\x14cf8b4011ab08d78b9bfd12a5fdc1979f8f185da80186cac56ee8008bbe7a24	a88f985c-48c3-4f25-bb95-05901e4fff54
\\x16980d3446c178cb1a427abe8a28ff32a7344ede04abcc59c346813a65aeafc8	12fa26f1-b310-44c1-bd4e-f788d1ba3357
\\x16980d3446c178cb1a427abe8a28ff32a7344ede04abcc59c346813a65aeafc8	12fa26f1-b310-44c1-bd4e-f788d1ba3357
\\x17e41f8d8f86945ea118cd7c0cd24041203c00f69ef12aad9e8283df74b46efc	sem_fkey_many_to_many_li
\\x17e41f8d8f86945ea118cd7c0cd24041203c00f69ef12aad9e8283df74b46efc	sem_fkey_many_to_many_li
\\x189edac99df612a9d7c1707893349300a9287919f92ed7cbbdd6bf5fcd1c19cc	3ec63054-336c-4144-94ba-01edd5138cd4
\\x189edac99df612a9d7c1707893349300a9287919f92ed7cbbdd6bf5fcd1c19cc	3ec63054-336c-4144-94ba-01edd5138cd4
\\x1b926038b754d88681986e1c323220191cb4670bba0feda21ca224fbf1c6d98f	var w = $("#"+id);\n\n/*\n\tWe should really be using list_item_identifier_widget for this label\n    TODO: replace label_function with semantics lookup\n*/\n\n\n// Less destructive way to delete fkey reference\nw.find('.delete').click(function() {\n    row.set(to_column, null);\n    row.update()\n    .done(function(updated_row) {\n        console.log('Fkey updated', updated_row);\n        w.trigger('fkey_updated');\n        w.trigger('reload');\n    });\n});\n\n/*\n//\n// If we want to delete the foreign row\n// But I think it is preferrable that we set foreign key to null instead\n//  \nw.find('.delete').click(function() {\n    row.delete()\n    .done(function() {\n        console.log('Fkey deleted');\n        w.trigger('fkey_deleted');\n        w.remove();\n    });\n});\n*/
\\x1b926038b754d88681986e1c323220191cb4670bba0feda21ca224fbf1c6d98f	var w = $("#"+id);\n\n/*\n\tWe should really be using list_item_identifier_widget for this label\n    TODO: replace label_function with semantics lookup\n*/\n\n\n// Less destructive way to delete fkey reference\nw.find('.delete').click(function() {\n    row.set(to_column, null);\n    row.update()\n    .done(function(updated_row) {\n        console.log('Fkey updated', updated_row);\n        w.trigger('fkey_updated');\n        w.trigger('reload');\n    });\n});\n\n/*\n//\n// If we want to delete the foreign row\n// But I think it is preferrable that we set foreign key to null instead\n//  \nw.find('.delete').click(function() {\n    row.delete()\n    .done(function() {\n        console.log('Fkey deleted');\n        w.trigger('fkey_deleted');\n        w.remove();\n    });\n});\n*/
\\x1b926038b754d88681986e1c323220191cb4670bba0feda21ca224fbf1c6d98f	var w = $("#"+id);\n\n/*\n\tWe should really be using list_item_identifier_widget for this label\n    TODO: replace label_function with semantics lookup\n*/\n\n\n// Less destructive way to delete fkey reference\nw.find('.delete').click(function() {\n    row.set(to_column, null);\n    row.update()\n    .done(function(updated_row) {\n        console.log('Fkey updated', updated_row);\n        w.trigger('fkey_updated');\n        w.trigger('reload');\n    });\n});\n\n/*\n//\n// If we want to delete the foreign row\n// But I think it is preferrable that we set foreign key to null instead\n//  \nw.find('.delete').click(function() {\n    row.delete()\n    .done(function() {\n        console.log('Fkey deleted');\n        w.trigger('fkey_deleted');\n        w.remove();\n    });\n});\n*/
\\x1b926038b754d88681986e1c323220191cb4670bba0feda21ca224fbf1c6d98f	var w = $("#"+id);\n\n/*\n\tWe should really be using list_item_identifier_widget for this label\n    TODO: replace label_function with semantics lookup\n*/\n\n\n// Less destructive way to delete fkey reference\nw.find('.delete').click(function() {\n    row.set(to_column, null);\n    row.update()\n    .done(function(updated_row) {\n        console.log('Fkey updated', updated_row);\n        w.trigger('fkey_updated');\n        w.trigger('reload');\n    });\n});\n\n/*\n//\n// If we want to delete the foreign row\n// But I think it is preferrable that we set foreign key to null instead\n//  \nw.find('.delete').click(function() {\n    row.delete()\n    .done(function() {\n        console.log('Fkey deleted');\n        w.trigger('fkey_deleted');\n        w.remove();\n    });\n});\n*/
\\x1bd8be09f8ed2bbfed93f015b8d642d0bb2cfa87b09d25b026dc7ce32d53079a	var w = $("#"+id);\nvar username = false;\n\n\nfunction get_session_cookie() {\n    return document.cookie.replace(/(?:(?:^|.*;\\s*)SESSION\\s*\\=\\s*([^;]*).*$)|^.*$/, "$1");\n}\n\nfunction logout_and_redirect(url) {\n    // remove session cookie\n    document.cookie='SESSION=';\n\n    // redirect after a timeout\n    setTimeout(function() {\n        w.trigger('auth');\n        //location.reload(true);\n        location.assign(url || '/');\n    }, 1000);\n}\n\nendpoint.schema('endpoint').table('current_user').row()\n.then(function(row) {\n\n    var role_name = row.get('current_user');\n    var role_id = { name: role_name };\n    console.log('role name', role_name);\n\n    if (role_name == 'anonymous') {\n        throw 'Not logged in';\n    }\n    if (role_name == 'postgres') {\n        alert('You\\'re logged in as postgres, that\\'s not right, call mickey');\n    }\n\n    return endpoint.schema('endpoint').table('user').row('role_id', role_id);\n\n}).then(function(row) {\n    username = row.get('name') || row.get('email');\n    w.find('.username').html(username);\n}).catch(function(e) {\n    console.log('not logged in:', e);\n    logout_and_redirect();\n});\n\n\n\nw.find('.logout').click(function() {\n\n    var cookie = get_session_cookie('SESSION');\n    if (cookie != null) {\n\n        // there exists a session cookie\n        // look for session in table\n        endpoint.schema('endpoint').table('session').row('id', cookie)\n        .then(function(session) {\n\n            if(!session) {\n                // not logged in\n                return logout_and_redirect();\n            }\n            session.delete().then(function() {\n                // logged out now\n                // redirect\n                logout_and_redirect();\n            });\n        });\n\n    }\n    else {\n        // there is no session cookie\n        logout_and_redirect();\n    }\n});
\\x1bd8be09f8ed2bbfed93f015b8d642d0bb2cfa87b09d25b026dc7ce32d53079a	var w = $("#"+id);\nvar username = false;\n\n\nfunction get_session_cookie() {\n    return document.cookie.replace(/(?:(?:^|.*;\\s*)SESSION\\s*\\=\\s*([^;]*).*$)|^.*$/, "$1");\n}\n\nfunction logout_and_redirect(url) {\n    // remove session cookie\n    document.cookie='SESSION=';\n\n    // redirect after a timeout\n    setTimeout(function() {\n        w.trigger('auth');\n        //location.reload(true);\n        location.assign(url || '/');\n    }, 1000);\n}\n\nendpoint.schema('endpoint').table('current_user').row()\n.then(function(row) {\n\n    var role_name = row.get('current_user');\n    var role_id = { name: role_name };\n    console.log('role name', role_name);\n\n    if (role_name == 'anonymous') {\n        throw 'Not logged in';\n    }\n    if (role_name == 'postgres') {\n        alert('You\\'re logged in as postgres, that\\'s not right, call mickey');\n    }\n\n    return endpoint.schema('endpoint').table('user').row('role_id', role_id);\n\n}).then(function(row) {\n    username = row.get('name') || row.get('email');\n    w.find('.username').html(username);\n}).catch(function(e) {\n    console.log('not logged in:', e);\n    logout_and_redirect();\n});\n\n\n\nw.find('.logout').click(function() {\n\n    var cookie = get_session_cookie('SESSION');\n    if (cookie != null) {\n\n        // there exists a session cookie\n        // look for session in table\n        endpoint.schema('endpoint').table('session').row('id', cookie)\n        .then(function(session) {\n\n            if(!session) {\n                // not logged in\n                return logout_and_redirect();\n            }\n            session.delete().then(function() {\n                // logged out now\n                // redirect\n                logout_and_redirect();\n            });\n        });\n\n    }\n    else {\n        // there is no session cookie\n        logout_and_redirect();\n    }\n});
\\x1ce71d4c2f0e2284d2ba4a76af907cddbc55a9dae9da51b3d6fb767ce7017f87	var w = $("#"+id);\n\n/**********************************\nSOME HANDY DATE FUNCTIONS\n**********************************/\n\n// https://stackoverflow.com/questions/15396637/comparing-javascript-date-time-and-timestamp-from-postgresql\nDate.fromISO= function(s){\n    var day, tz,\n    rx=/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT ][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):(\\d\\d))?$/,\n    p= rx.exec(s) || [];\n    if(p[1]){\n        day= p[1].split(/\\D/);\n        for(var i= 0, L= day.length;i<L;i++){\n            day[i]= parseInt(day[i], 10) || 0;\n        };\n        day[1]-= 1;\n        day= new Date(Date.UTC.apply(Date, day));\n        if(!day.getDate()) return NaN;\n            //adjust for time zone offset:\n        if(p[5]){\n            tz= (parseInt(p[5], 10)*60);\n            if(p[6]) tz+= parseInt(p[6], 10);\n            if(p[4]== '+') tz*= -1;\n            if(tz) day.setUTCMinutes(day.getUTCMinutes()+ tz);\n        }\n        return day;\n    }\n    return NaN;\n}\n\n// https://gist.github.com/hurjas/2660489\n/**\n * Return a timestamp with the format "m/d/yy h:MM:ss TT"\n * @type {Date}\n */\n\nfunction timeStamp(now) {\n// Create an array with the current month, day and time\n  var date = [ now.getMonth() + 1, now.getDate(), now.getFullYear() ];\n\n// Create an array with the current hour, minute and second\n  var time = [ now.getHours(), now.getMinutes(), now.getSeconds() ];\n\n// Determine AM or PM suffix based on the hour\n  var suffix = ( time[0] < 12 ) ? "AM" : "PM";\n\n// Convert hour from military time\n  time[0] = ( time[0] < 12 ) ? time[0] : time[0] - 12;\n\n// If hour is 0, set it to 12\n  time[0] = time[0] || 12;\n\n// If seconds and minutes are less than 10, add a zero\n  for ( var i = 1; i < 3; i++ ) {\n    if ( time[i] < 10 ) {\n      time[i] = "0" + time[i];\n    }\n  }\n\n// Return the formatted string\n  return date.join("/") + " " + time.join(":") + " " + suffix;\n}\n\n\n\n\n\n\nvar date = Date.fromISO(commit.get('time'));\n\n\nw.find('td.date').html(timeStamp(date));\n\nw.find('button.checkout').click(function() {\n    if (confirm('Checking out this commit will OVERWRITE any uncommitted changes and restore the database to the state at this commit.  This could be DESTRUCTIVE.  Are you sure?')) {\n        endpoint.schema('bundle').function('checkout', [ commit.get('id') ]).then(function() {\n            alert ('done');\n        }).catch(function(e) {\n            alert ('failed: '+e.message);\n        });\n    }\n});\n\nif (bundle.get('head_commit_id') == commit.get('id')) {\n    w.find('.head_commit').show();\n}\n\n\n
\\x1ce71d4c2f0e2284d2ba4a76af907cddbc55a9dae9da51b3d6fb767ce7017f87	var w = $("#"+id);\n\n/**********************************\nSOME HANDY DATE FUNCTIONS\n**********************************/\n\n// https://stackoverflow.com/questions/15396637/comparing-javascript-date-time-and-timestamp-from-postgresql\nDate.fromISO= function(s){\n    var day, tz,\n    rx=/^(\\d{4}\\-\\d\\d\\-\\d\\d([tT ][\\d:\\.]*)?)([zZ]|([+\\-])(\\d\\d):(\\d\\d))?$/,\n    p= rx.exec(s) || [];\n    if(p[1]){\n        day= p[1].split(/\\D/);\n        for(var i= 0, L= day.length;i<L;i++){\n            day[i]= parseInt(day[i], 10) || 0;\n        };\n        day[1]-= 1;\n        day= new Date(Date.UTC.apply(Date, day));\n        if(!day.getDate()) return NaN;\n            //adjust for time zone offset:\n        if(p[5]){\n            tz= (parseInt(p[5], 10)*60);\n            if(p[6]) tz+= parseInt(p[6], 10);\n            if(p[4]== '+') tz*= -1;\n            if(tz) day.setUTCMinutes(day.getUTCMinutes()+ tz);\n        }\n        return day;\n    }\n    return NaN;\n}\n\n// https://gist.github.com/hurjas/2660489\n/**\n * Return a timestamp with the format "m/d/yy h:MM:ss TT"\n * @type {Date}\n */\n\nfunction timeStamp(now) {\n// Create an array with the current month, day and time\n  var date = [ now.getMonth() + 1, now.getDate(), now.getFullYear() ];\n\n// Create an array with the current hour, minute and second\n  var time = [ now.getHours(), now.getMinutes(), now.getSeconds() ];\n\n// Determine AM or PM suffix based on the hour\n  var suffix = ( time[0] < 12 ) ? "AM" : "PM";\n\n// Convert hour from military time\n  time[0] = ( time[0] < 12 ) ? time[0] : time[0] - 12;\n\n// If hour is 0, set it to 12\n  time[0] = time[0] || 12;\n\n// If seconds and minutes are less than 10, add a zero\n  for ( var i = 1; i < 3; i++ ) {\n    if ( time[i] < 10 ) {\n      time[i] = "0" + time[i];\n    }\n  }\n\n// Return the formatted string\n  return date.join("/") + " " + time.join(":") + " " + suffix;\n}\n\n\n\n\n\n\nvar date = Date.fromISO(commit.get('time'));\n\n\nw.find('td.date').html(timeStamp(date));\n\nw.find('button.checkout').click(function() {\n    if (confirm('Checking out this commit will OVERWRITE any uncommitted changes and restore the database to the state at this commit.  This could be DESTRUCTIVE.  Are you sure?')) {\n        endpoint.schema('bundle').function('checkout', [ commit.get('id') ]).then(function() {\n            alert ('done');\n        }).catch(function(e) {\n            alert ('failed: '+e.message);\n        });\n    }\n});\n\nif (bundle.get('head_commit_id') == commit.get('id')) {\n    w.find('.head_commit').show();\n}\n\n\n
\\x1d03540dbbd0491fd9fe1ad4a5a6a12220ce9d0adc353a0556ac73a6779e3d51	form_field_javascript
\\x1d03540dbbd0491fd9fe1ad4a5a6a12220ce9d0adc353a0556ac73a6779e3d51	form_field_javascript
\\x1e61db13980716dac6aac448bc652ca078b8e3aa3ac681bdfaa98c40b3b70573	82fa4009-7abb-4f6a-aa42-0d3216516956
\\x1e61db13980716dac6aac448bc652ca078b8e3aa3ac681bdfaa98c40b3b70573	82fa4009-7abb-4f6a-aa42-0d3216516956
\\x1e61db13980716dac6aac448bc652ca078b8e3aa3ac681bdfaa98c40b3b70573	82fa4009-7abb-4f6a-aa42-0d3216516956
\\x1e61db13980716dac6aac448bc652ca078b8e3aa3ac681bdfaa98c40b3b70573	82fa4009-7abb-4f6a-aa42-0d3216516956
\\x1e6ed65d77d6364eeaed5a745ba5c4985ae2b700dd85d7cf7f027bdf294a33fc	bundle
\\x1e6ed65d77d6364eeaed5a745ba5c4985ae2b700dd85d7cf7f027bdf294a33fc	bundle
\\x1f357b8a6a355eae126179aee326c97919e105dbd3fb4b76858efc8ea0b016e1	row_list_row
\\x1f357b8a6a355eae126179aee326c97919e105dbd3fb4b76858efc8ea0b016e1	row_list_row
\\x1ff1d3c2ce61ee0a6f6ac55cb37d78caeeb550c2dfb98fa45509f3061ec8b96b	var w = $("#"+id);\n\n\n//endpoint.schema('widget').table('widget').row('name', 'dev_workspace').then(rewrite);\nfunction rewrite(r) {\n    \n    function get_data(str) {\n        // If this does not have 'g' flag there will be an infinite loop\n        var re = /\\/\\*editable_object-(.*)\\*\\/([\\s\\S]*?)\\/\\*end\\*\\//g,\n            arr,\n            obj = {};\n\n        // Safety measure\n        var MAX = 5,\n            counter = 0;\n\n        while ((arr = re.exec(str)) !== null) {\n            if (counter++ > MAX) {\n                break;\n            }\n            /* arr[0] is whole match; arr[1] is object identifier; arr[2] is object data only */\n            obj[arr[1]] = eval(arr[2]);\n        }\n        return obj;\n    }\n \n    function replace(str, ident, new_data) {\n        var re = new RegExp('(\\/\\\\*editable_object-' + ident + '\\\\*\\/)([\\\\s\\\\S]*)(\\/\\\\*end\\\\*\\/)');\n        return str.replace(re, '$1' + JSON.stringify(new_data, null, '\\t') + '$3');\n    }\n    \n    var js = r.get('post_js');\n    var data = get_data(js);\n    var new_js = replace(js, 'tables', data.tables.filter(function(e) {\n        return !(e.schema_name == 'widget' && e.relation_name == 'widget');\n    }));\n\n    // r.set('post_js', new_js).update().then(function(a) { console.log(a); });\n}\n\nvar colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\nvar available_tables = \n    /*editable_object-available*/\n    [\n    {\n        schema_name: 'widget',\n        relation_name: 'widget',\n        order_by: {\n            column: 'name'\n        },\n        include: ['id', 'name']\n    }, {\n        schema_name: 'widget',\n        relation_name: 'bundled_widget',\n    }, {\n        schema_name: 'meta',\n        relation_name: 'table'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'view'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'function'\n    }, {\n        schema_name: 'widget',\n        relation_name: 'dependency_js',\n        order_by: { column: 'name' },\n        include: ['id', 'name', 'version']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'resource',\n        order_by: { column: 'path' },\n        include: ['id', 'path']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'user',\n        order_by: { column: 'name' }\n    }]\n/*end*/\n;\n\nvar tables = \n    /*editable_object-tables*/\n    [\n    {\n        schema_name: 'widget',\n        relation_name: 'widget',\n        order_by: {\n            column: 'name'\n        },\n        include: ['id', 'name']\n    }, {\n        schema_name: 'widget',\n        relation_name: 'bundled_widget',\n    }, {\n        schema_name: 'meta',\n        relation_name: 'table'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'view'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'function'\n    }, {\n        schema_name: 'widget',\n        relation_name: 'dependency_js',\n        order_by: { column: 'name' },\n        include: ['id', 'name', 'version']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'resource',\n        order_by: { column: 'path' },\n        include: ['id', 'path']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'user',\n        order_by: { column: 'name' }\n    }]\n/*end*/\n;\n\n\nvar tabs = {};\nvar tab_colors = {};\ntables.forEach(function(t, i) {\n    var schema_name = t.schema_name;\n    var name = t.relation_name;\n    var relation = endpoint.schema(schema_name).table(name);\n    \n    var obj = {};\n    var keys = Object.keys(t);\n    keys.forEach(function(o) {\n        if (o != 'relation_name' && o != 'schema_name') {\n            obj[o] = t[o];\n        }\n    });\n    \n    tabs[name] = function() {\n        if (!Object.keys(obj).length) {\n            return widget('semantics/list_view', relation);\n        }\n        return widget('semantics/list_view', relation.rows(obj));\n    };\n    \n    tab_colors[name] = colors[i % colors.length];\n});\n\nw.append(\n    widget('tabbed_layout', {\n        base_url: base_url,\n        selected: url_parts[0],\n        tabs: tabs,\n        tab_colors: tab_colors\n    })\n);\n
\\x1ff1d3c2ce61ee0a6f6ac55cb37d78caeeb550c2dfb98fa45509f3061ec8b96b	var w = $("#"+id);\n\n\n//endpoint.schema('widget').table('widget').row('name', 'dev_workspace').then(rewrite);\nfunction rewrite(r) {\n    \n    function get_data(str) {\n        // If this does not have 'g' flag there will be an infinite loop\n        var re = /\\/\\*editable_object-(.*)\\*\\/([\\s\\S]*?)\\/\\*end\\*\\//g,\n            arr,\n            obj = {};\n\n        // Safety measure\n        var MAX = 5,\n            counter = 0;\n\n        while ((arr = re.exec(str)) !== null) {\n            if (counter++ > MAX) {\n                break;\n            }\n            /* arr[0] is whole match; arr[1] is object identifier; arr[2] is object data only */\n            obj[arr[1]] = eval(arr[2]);\n        }\n        return obj;\n    }\n \n    function replace(str, ident, new_data) {\n        var re = new RegExp('(\\/\\\\*editable_object-' + ident + '\\\\*\\/)([\\\\s\\\\S]*)(\\/\\\\*end\\\\*\\/)');\n        return str.replace(re, '$1' + JSON.stringify(new_data, null, '\\t') + '$3');\n    }\n    \n    var js = r.get('post_js');\n    var data = get_data(js);\n    var new_js = replace(js, 'tables', data.tables.filter(function(e) {\n        return !(e.schema_name == 'widget' && e.relation_name == 'widget');\n    }));\n\n    // r.set('post_js', new_js).update().then(function(a) { console.log(a); });\n}\n\nvar colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\nvar available_tables = \n    /*editable_object-available*/\n    [\n    {\n        schema_name: 'widget',\n        relation_name: 'widget',\n        order_by: {\n            column: 'name'\n        },\n        include: ['id', 'name']\n    }, {\n        schema_name: 'widget',\n        relation_name: 'bundled_widget',\n    }, {\n        schema_name: 'meta',\n        relation_name: 'table'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'view'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'function'\n    }, {\n        schema_name: 'widget',\n        relation_name: 'dependency_js',\n        order_by: { column: 'name' },\n        include: ['id', 'name', 'version']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'resource',\n        order_by: { column: 'path' },\n        include: ['id', 'path']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'user',\n        order_by: { column: 'name' }\n    }]\n/*end*/\n;\n\nvar tables = \n    /*editable_object-tables*/\n    [\n    {\n        schema_name: 'widget',\n        relation_name: 'widget',\n        order_by: {\n            column: 'name'\n        },\n        include: ['id', 'name']\n    }, {\n        schema_name: 'widget',\n        relation_name: 'bundled_widget',\n    }, {\n        schema_name: 'meta',\n        relation_name: 'table'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'view'\n    }, {\n        schema_name: 'meta',\n        relation_name: 'function'\n    }, {\n        schema_name: 'widget',\n        relation_name: 'dependency_js',\n        order_by: { column: 'name' },\n        include: ['id', 'name', 'version']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'resource',\n        order_by: { column: 'path' },\n        include: ['id', 'path']\n    }, {\n        schema_name: 'endpoint',\n        relation_name: 'user',\n        order_by: { column: 'name' }\n    }]\n/*end*/\n;\n\n\nvar tabs = {};\nvar tab_colors = {};\ntables.forEach(function(t, i) {\n    var schema_name = t.schema_name;\n    var name = t.relation_name;\n    var relation = endpoint.schema(schema_name).table(name);\n    \n    var obj = {};\n    var keys = Object.keys(t);\n    keys.forEach(function(o) {\n        if (o != 'relation_name' && o != 'schema_name') {\n            obj[o] = t[o];\n        }\n    });\n    \n    tabs[name] = function() {\n        if (!Object.keys(obj).length) {\n            return widget('semantics/list_view', relation);\n        }\n        return widget('semantics/list_view', relation.rows(obj));\n    };\n    \n    tab_colors[name] = colors[i % colors.length];\n});\n\nw.append(\n    widget('tabbed_layout', {\n        base_url: base_url,\n        selected: url_parts[0],\n        tabs: tabs,\n        tab_colors: tab_colors\n    })\n);\n
\\x20948542f9ed46ea7b75a04a6b76db4c15324eed0ed52f2d00fdb5cb8bafc847	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\nendpoint.schema('widget').table('widget').row('id', row.get('id'))\n.then(function(row) {\n    \n    w.find('.widget_id').text(row.get('id'));\n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n    \n\t// html, css, post_js\n    ['html','css','post_js'].forEach(function(col_name, i) {\n        tabs[col_name] = function() {\n            return widget('semantics/form_field', row.field(col_name));\n        };\n        tab_colors[col_name] = colors[i % colors.length];\n    });\n    \n    // input\n    tabs['input'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('input').rows({\n        where: {\n            name: 'widget_id',\n            op: '=',\n            value: datum.get('id')\n        },\n            exclude: ['id', 'widget_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['input'] = colors[4 % colors.length];\n    \n    // dependency_js\n    tabs['dependencies'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('widget_dependency_js').rows({\n            where: {\n                name: 'widget_id',\n                op: '=',\n                value: datum.get('id')\n            },\n            include: ['dependency_js_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['dependencies'] = colors[5 % colors.length];\n\n\n    /* TABBED LAYOUT */\n    // var preview_row = row.clone();\n\n    w.find('> .top > .section_content > .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Widget deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            //set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n            w.trigger('row_detail_save');\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n            //setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.find('.delete').on('click', handle_delete_button);\n\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Widget copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('inserted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x20948542f9ed46ea7b75a04a6b76db4c15324eed0ed52f2d00fdb5cb8bafc847	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\nendpoint.schema('widget').table('widget').row('id', row.get('id'))\n.then(function(row) {\n    \n    w.find('.widget_id').text(row.get('id'));\n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n    \n\t// html, css, post_js\n    ['html','css','post_js'].forEach(function(col_name, i) {\n        tabs[col_name] = function() {\n            return widget('semantics/form_field', row.field(col_name));\n        };\n        tab_colors[col_name] = colors[i % colors.length];\n    });\n    \n    // input\n    tabs['input'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('input').rows({\n        where: {\n            name: 'widget_id',\n            op: '=',\n            value: datum.get('id')\n        },\n            exclude: ['id', 'widget_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['input'] = colors[4 % colors.length];\n    \n    // dependency_js\n    tabs['dependencies'] = function() {\n        return widget('semantics/grid_view', endpoint.schema('widget').table('widget_dependency_js').rows({\n            where: {\n                name: 'widget_id',\n                op: '=',\n                value: datum.get('id')\n            },\n            include: ['dependency_js_id']\n        }, {\n            context: {\n                widget_id: datum.get('id')\n            }\n        }));\n    };\n    tab_colors['dependencies'] = colors[5 % colors.length];\n\n\n    /* TABBED LAYOUT */\n    // var preview_row = row.clone();\n\n    w.find('> .top > .section_content > .tabs').append(\n        widget('ide:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Widget deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            //set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n            w.trigger('row_detail_save');\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n            //setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.find('.delete').on('click', handle_delete_button);\n\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Widget copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('inserted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x2127fcee590bf0397ca4a10a003788ff7eef62056cd3c082c2c2eb4a361ca712	var w = $("#"+id);\n\n\nvar rel_name = row.relation.schema.name + '.' + row.relation.name;\n\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    w.find('.section_content').append(widget('semantics/form_field', row.field('content')));\n    \n    w.find('.path').append(widget('semantics/form_field', row.field('path')));\n    w.find('.path_link').attr('href', row.get('path'));\n    w.find('.path_button').text(row.get('path'));\n\n    // SAVE\n    function save() {\n        row.update()\n        .then(function() {\n            w.trigger('status', ['Resource saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n        });\n    }\n\n\n    w.find('.save').on('click', save);\n    w.on('keydown', jwerty.event('ctrl+s', save));\n\n\n    // DELETE\n    w.find('.delete').on('click', function() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Resource deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    });\n    \n\n\n    // COPY\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_path = row.get('path') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('path', new_path);\n\n            row.relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Resource copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n\n});
\\x2127fcee590bf0397ca4a10a003788ff7eef62056cd3c082c2c2eb4a361ca712	var w = $("#"+id);\n\n\nvar rel_name = row.relation.schema.name + '.' + row.relation.name;\n\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    w.find('.section_content').append(widget('semantics/form_field', row.field('content')));\n    \n    w.find('.path').append(widget('semantics/form_field', row.field('path')));\n    w.find('.path_link').attr('href', row.get('path'));\n    w.find('.path_button').text(row.get('path'));\n\n    // SAVE\n    function save() {\n        row.update()\n        .then(function() {\n            w.trigger('status', ['Resource saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n        });\n    }\n\n\n    w.find('.save').on('click', save);\n    w.on('keydown', jwerty.event('ctrl+s', save));\n\n\n    // DELETE\n    w.find('.delete').on('click', function() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Resource deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    });\n    \n\n\n    // COPY\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_path = row.get('path') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('path', new_path);\n\n            row.relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Resource copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n\n});
\\x215096f44ab5f27a3442c5ba3849ade94122de549ab58d15cc2719591e6e92f9	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('name') + ' ' + row.get('version') }}\n</li>
\\x215096f44ab5f27a3442c5ba3849ade94122de549ab58d15cc2719591e6e92f9	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('name') + ' ' + row.get('version') }}\n</li>
\\x21867e0014e56249cf8b6272582e570529f7e517e1650baee71317c0eea9893b	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.1', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:ide'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\x21867e0014e56249cf8b6272582e570529f7e517e1650baee71317c0eea9893b	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.1', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:ide'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n\n
\\x21a3230e03772a58aff1b3709a9e232850916337e1fba95c434076b6668c6e08	workspace
\\x21a3230e03772a58aff1b3709a9e232850916337e1fba95c434076b6668c6e08	workspace
\\x227ae55bd869eedf9afbc17dfc4aa0e4722725413ae5f3fd6ad8644f8e1de4f6	c7e98fc9-4324-4006-9738-ac3d869201ba
\\x227ae55bd869eedf9afbc17dfc4aa0e4722725413ae5f3fd6ad8644f8e1de4f6	c7e98fc9-4324-4006-9738-ac3d869201ba
\\x239df2de3a3fe418de896855176bf769af52c84a3914f39556847da5dc87b528	<div id="{{= id }}" class="{{= name }}">\n    <ul class='join_rows'></ul>\n    <button class='new'>New</button>\n</div>
\\x239df2de3a3fe418de896855176bf769af52c84a3914f39556847da5dc87b528	<div id="{{= id }}" class="{{= name }}">\n    <ul class='join_rows'></ul>\n    <button class='new'>New</button>\n</div>
\\x249542a6858902bca05224cc1fe94e34a34e0e666287ec148e7ff53383963ccb	89a53440-2cd0-4dca-a500-24569c49f29c
\\x249542a6858902bca05224cc1fe94e34a34e0e666287ec148e7ff53383963ccb	89a53440-2cd0-4dca-a500-24569c49f29c
\\x249e1d0a70b7445c18235f45b5f4a51f6dcc5517c997689e9799882b895d7e81	.{{= name }} {\n}\n\n.{{= name }} .tab {\n    display: inline-block;\n    border: 1px 1px 1px 0px solid green;\n}\n\n.{{= name }} .tab:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n
\\x249e1d0a70b7445c18235f45b5f4a51f6dcc5517c997689e9799882b895d7e81	.{{= name }} {\n}\n\n.{{= name }} .tab {\n    display: inline-block;\n    border: 1px 1px 1px 0px solid green;\n}\n\n.{{= name }} .tab:hover {\n    background-color: #333;\n    cursor: pointer;\n}\n
\\x252b8ff88d3201ce1dbbf47370308c5e999e7a1bad7a769bf6e70ba8d1d8e50d	.{{= name }} {\n\theight: 100%;\n    width: 100%;\n    color: white;\n    /*\n    display: flex;\n    flex-flow: column nowrap;\n    position: relative;\n    */\n}\n\n.{{= name }} > nav {\n    border-bottom: 0.2rem solid #333;\n    flex: 1.5em 0 0;\n}\n\n.{{= name }} > nav a {\n    color: #555;\n    cursor: pointer;\n    padding: 0 .5em 1px 0.5em;\n    display: inline-block;\n    transition: background 0.15s ease-in;\n}\n\n.{{= name }} > nav a.selected {\n    background: #444;\n    color: white;\n}\n\n.{{= name }} > .content {\n    /* flex: 0px 1; */\n    height: 95%;\n}\n\n\n.{{= name }} > .content > div {\n    height: 100%;\n}\n\n\n.{{= name }} > .content > div.selected {\n    display: block;\n}\n
\\x252b8ff88d3201ce1dbbf47370308c5e999e7a1bad7a769bf6e70ba8d1d8e50d	.{{= name }} {\n\theight: 100%;\n    width: 100%;\n    color: white;\n    /*\n    display: flex;\n    flex-flow: column nowrap;\n    position: relative;\n    */\n}\n\n.{{= name }} > nav {\n    border-bottom: 0.2rem solid #333;\n    flex: 1.5em 0 0;\n}\n\n.{{= name }} > nav a {\n    color: #555;\n    cursor: pointer;\n    padding: 0 .5em 1px 0.5em;\n    display: inline-block;\n    transition: background 0.15s ease-in;\n}\n\n.{{= name }} > nav a.selected {\n    background: #444;\n    color: white;\n}\n\n.{{= name }} > .content {\n    /* flex: 0px 1; */\n    height: 95%;\n}\n\n\n.{{= name }} > .content > div {\n    height: 100%;\n}\n\n\n.{{= name }} > .content > div.selected {\n    display: block;\n}\n
\\x283ba2dd18572f58e69e962579a3b1dc948bfb66c5cbc2301852cffbe5005402	e9bf57c1-8616-4407-96c4-29cd79208868
\\x283ba2dd18572f58e69e962579a3b1dc948bfb66c5cbc2301852cffbe5005402	e9bf57c1-8616-4407-96c4-29cd79208868
\\x28deec000112f80eba04dd52fb6d397b66fae30323808f1d47fa4ae6e507d6ad	debugger3
\\x28deec000112f80eba04dd52fb6d397b66fae30323808f1d47fa4ae6e507d6ad	debugger3
\\x295d7dc9653dc1608b6e4743e087350a69598d2b2e34c50b836fe13e59b22792	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'javascript' }) }}\n</div>
\\x295d7dc9653dc1608b6e4743e087350a69598d2b2e34c50b836fe13e59b22792	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'javascript' }) }}\n</div>
\\x29bd8f0a60658db033c8ee6d1c29a1506eaef8e44b2c7d1c53ae9fd5e355bd39	c307d345-15c6-4690-a152-10b272fd8589
\\x29bd8f0a60658db033c8ee6d1c29a1506eaef8e44b2c7d1c53ae9fd5e355bd39	c307d345-15c6-4690-a152-10b272fd8589
\\x2a5225842f5a3cc192e147296831824b0a877b10d88039780f3c09defae32481	This is the top level widget for the Spacebase IDE.\n
\\x2a5225842f5a3cc192e147296831824b0a877b10d88039780f3c09defae32481	This is the top level widget for the Spacebase IDE.\n
\\x2ae25daa4b211fa1bf4cd99780a7a5e903da30710c05a8c4e97402201086b1ea	ee265dda-bb3b-4c27-9270-d91cdf8eda75
\\x2ae25daa4b211fa1bf4cd99780a7a5e903da30710c05a8c4e97402201086b1ea	ee265dda-bb3b-4c27-9270-d91cdf8eda75
\\x2b6bb5452d5baa848fb25b1e0e32f142cdc059586f2b114fd1b5f54a3f12d6b4	var w = $('#'+id);\nw.find('.content').append(content);\n\nfunction dismiss(event) {\n    w.fadeOut('fast').remove(); \n    return false;\n}\n\n/*\nwtf is this:  screwing up form elements in modals.\nfunction stop_event(event) {\n    event.stopPropagation();\n    return false;\n}\nw.find('> .content > *').click(stop_event);\n*/\n\nw.on('dismiss', dismiss);\n\nw.find('> .overlay').click(dismiss);\nw.on('done', dismiss);\nw.bind('close_modal', dismiss); // redundant to above?\njwerty.key('esc', dismiss);
\\x2b6bb5452d5baa848fb25b1e0e32f142cdc059586f2b114fd1b5f54a3f12d6b4	var w = $('#'+id);\nw.find('.content').append(content);\n\nfunction dismiss(event) {\n    w.fadeOut('fast').remove(); \n    return false;\n}\n\n/*\nwtf is this:  screwing up form elements in modals.\nfunction stop_event(event) {\n    event.stopPropagation();\n    return false;\n}\nw.find('> .content > *').click(stop_event);\n*/\n\nw.on('dismiss', dismiss);\n\nw.find('> .overlay').click(dismiss);\nw.on('done', dismiss);\nw.bind('close_modal', dismiss); // redundant to above?\njwerty.key('esc', dismiss);
\\x2b84078e337bbdbe8438cc1baf4b55968c29e50a2d3085171f4fa6a628b23da5	ce5ce449-1c74-40ee-85f8-316d60eb8d9a
\\x2b84078e337bbdbe8438cc1baf4b55968c29e50a2d3085171f4fa6a628b23da5	ce5ce449-1c74-40ee-85f8-316d60eb8d9a
\\x2c781f81da566b69615c12c6bb6b54b2b7f4379a48ac9c1c35770fc72c5a2785	f38dce36-f77b-43e9-9a2c-4da393c04e6b
\\x2c781f81da566b69615c12c6bb6b54b2b7f4379a48ac9c1c35770fc72c5a2785	f38dce36-f77b-43e9-9a2c-4da393c04e6b
\\x2cf0e333359e6c47c696df1efda7cbac77499a5f708fdfa7cb0b120bba3ae351	sem_fkey_autocomplete
\\x2cf0e333359e6c47c696df1efda7cbac77499a5f708fdfa7cb0b120bba3ae351	sem_fkey_autocomplete
\\x2d7a9f36e2077964ddf2990649abe80e102e6fdaecc5dad3865bbef0520b90af	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\nvar fkeys;\nvar where_obj = {};\nwhere_obj[to_column] = from_row.get(from_column);\nfunction load_fkeys() {\n    \n    w.find('.fkeys').empty();\n    \n    fkeys = order_by_function(to_relation.rows().where(where_obj));\n    \n    widget.sync(fkeys, w.find('.fkeys'), function(row) {\n        return widget('sem_fkey_one_to_many_li', { \n            row: row,\n            to_column: to_column,\n            label_function: label_function\n        });\n    });\n    \n}\nload_fkeys();\n\n\n// Find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    name: to_relation.name,\n    schema_name: to_relation.schema.name\n}).result(function(to_relation_obj) {\n    \n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n    \n    context_data[to_column] = from_row.get(from_column);\n    \n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n    \n    w.find('.new').click(function() {\n        w.append(widget('modal_overlay', {\n            content: widget(new_row_widget, {\n                relation: to_relation_obj,\n                context_data: context_data\n            })\n        }));\n    });\n\n});\n\nw.on('reload', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});\n\nw.on('fkey_updated', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});\n\nw.on('fkey_deleted', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});
\\x2d7a9f36e2077964ddf2990649abe80e102e6fdaecc5dad3865bbef0520b90af	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\nvar fkeys;\nvar where_obj = {};\nwhere_obj[to_column] = from_row.get(from_column);\nfunction load_fkeys() {\n    \n    w.find('.fkeys').empty();\n    \n    fkeys = order_by_function(to_relation.rows().where(where_obj));\n    \n    widget.sync(fkeys, w.find('.fkeys'), function(row) {\n        return widget('sem_fkey_one_to_many_li', { \n            row: row,\n            to_column: to_column,\n            label_function: label_function\n        });\n    });\n    \n}\nload_fkeys();\n\n\n// Find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    name: to_relation.name,\n    schema_name: to_relation.schema.name\n}).result(function(to_relation_obj) {\n    \n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n    \n    context_data[to_column] = from_row.get(from_column);\n    \n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n    \n    w.find('.new').click(function() {\n        w.append(widget('modal_overlay', {\n            content: widget(new_row_widget, {\n                relation: to_relation_obj,\n                context_data: context_data\n            })\n        }));\n    });\n\n});\n\nw.on('reload', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});\n\nw.on('fkey_updated', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});\n\nw.on('fkey_deleted', function(e) {\n    e.stopPropagation();\n    load_fkeys();\n});
\\x2fe8e53b780becb1df0722b5a40cbb13dbb21b2e22229c531de6775c0be29557	.{{= name }} {\n}\n\n.{{= name }} .new_row_button {\n    display: inline-block;\n    text-align: center;\n    border-style: solid;\n    border-width: 1px;\n    padding: 10px;\n    margin: 5px;\n    min-height: 75px;\n    min-width: 100px;\n    vertical-align: top;\n    cursor: pointer;\n}\n\n.{{= name }} .new_row_button:hover {\n    background-color: gray;\n}\n\n.{{= name }} .new_row_button:active {\n    background-color: green;\n}\n\n.{{= name }} .new_row_icon {\n    min-height: 27px;\n}
\\x2fe8e53b780becb1df0722b5a40cbb13dbb21b2e22229c531de6775c0be29557	.{{= name }} {\n}\n\n.{{= name }} .new_row_button {\n    display: inline-block;\n    text-align: center;\n    border-style: solid;\n    border-width: 1px;\n    padding: 10px;\n    margin: 5px;\n    min-height: 75px;\n    min-width: 100px;\n    vertical-align: top;\n    cursor: pointer;\n}\n\n.{{= name }} .new_row_button:hover {\n    background-color: gray;\n}\n\n.{{= name }} .new_row_button:active {\n    background-color: green;\n}\n\n.{{= name }} .new_row_icon {\n    min-height: 27px;\n}
\\x301a4427bfb14951997c4a44e3a1c3fc10f4ca779a93c99433712ceb78d2275c	commit_dialog
\\x301a4427bfb14951997c4a44e3a1c3fc10f4ca779a93c99433712ceb78d2275c	commit_dialog
\\x303bdf18a0978a13fcc9836778ff1e83dd9880d461db6c907ad067fdb009ce8c	jwerty
\\x303bdf18a0978a13fcc9836778ff1e83dd9880d461db6c907ad067fdb009ce8c	jwerty
\\x303bdf18a0978a13fcc9836778ff1e83dd9880d461db6c907ad067fdb009ce8c	jwerty
\\x303bdf18a0978a13fcc9836778ff1e83dd9880d461db6c907ad067fdb009ce8c	jwerty
\\x30f3b7dfb46cd14ffbfbf29832b350155149d0e73412787c0083cd49b99c0952	/*jshint smarttabs:true */\n\n/**\n * closestDescendant - 0.1.1 - 2013-04-09\n * https://github.com/tlindig/jquery-closest-descendant \n *\n * Copyright (c) 2013 Tobias Lindig\n * http://tlindig.de/ \n *\n * Licensed MIT\n */\n(function( $ ) {\n    \n    /**\n\t * Get the first element(s) that matches the selector by traversing down\n\t * through descendants in the DOM tree level by level. It use a breadth\n\t * first search (BFS), that mean it will stop search and not going deeper in\n\t * the current subtree if the first matching descendant was found.\n\t *\n\t * @param  {selectors} selector -required- a jQuery selector\n\t * @param  {boolean} findAll -optional- default is false, if true, every\n\t *                           subtree will be visited until first match\n\t * @return {jQuery} matched element(s)\n\t */\n    $.fn.closestDescendant = function(selector, findAll) {\n        \n        if (!selector || selector === '') {\n            return $();\n        }\n        \n        findAll = findAll ? true : false;\n        \n        var resultSet = $();\n        \n        this.each(function() {\n            \n            var $this = $(this);\n            \n            // breadth first search for every matched node,\n            // go deeper, until a child was found in the current subtree or the leave was reached.\n            var queue = [];\n            queue.push( $this );\n            while ( queue.length > 0 ) {\n                var node = queue.shift();\n                var children = node.children();\n                for ( var i = 0; i < children.length; ++i ) {\n                    var $child = $(children[i]);\n                    if ( $child.is( selector ) ) {\n                        resultSet.push( $child[0] ); //well, we found one\n                        if ( ! findAll ) {\n                            return false;//stop processing\n                        }\n                    } else {\n                        queue.push( $child ); //go deeper\n                    }\n                }\n            }\n        });\n        \n        return resultSet;\n    };\n})($);\n\n\n
\\x30f3b7dfb46cd14ffbfbf29832b350155149d0e73412787c0083cd49b99c0952	/*jshint smarttabs:true */\n\n/**\n * closestDescendant - 0.1.1 - 2013-04-09\n * https://github.com/tlindig/jquery-closest-descendant \n *\n * Copyright (c) 2013 Tobias Lindig\n * http://tlindig.de/ \n *\n * Licensed MIT\n */\n(function( $ ) {\n    \n    /**\n\t * Get the first element(s) that matches the selector by traversing down\n\t * through descendants in the DOM tree level by level. It use a breadth\n\t * first search (BFS), that mean it will stop search and not going deeper in\n\t * the current subtree if the first matching descendant was found.\n\t *\n\t * @param  {selectors} selector -required- a jQuery selector\n\t * @param  {boolean} findAll -optional- default is false, if true, every\n\t *                           subtree will be visited until first match\n\t * @return {jQuery} matched element(s)\n\t */\n    $.fn.closestDescendant = function(selector, findAll) {\n        \n        if (!selector || selector === '') {\n            return $();\n        }\n        \n        findAll = findAll ? true : false;\n        \n        var resultSet = $();\n        \n        this.each(function() {\n            \n            var $this = $(this);\n            \n            // breadth first search for every matched node,\n            // go deeper, until a child was found in the current subtree or the leave was reached.\n            var queue = [];\n            queue.push( $this );\n            while ( queue.length > 0 ) {\n                var node = queue.shift();\n                var children = node.children();\n                for ( var i = 0; i < children.length; ++i ) {\n                    var $child = $(children[i]);\n                    if ( $child.is( selector ) ) {\n                        resultSet.push( $child[0] ); //well, we found one\n                        if ( ! findAll ) {\n                            return false;//stop processing\n                        }\n                    } else {\n                        queue.push( $child ); //go deeper\n                    }\n                }\n            }\n        });\n        \n        return resultSet;\n    };\n})($);\n\n\n
\\x323515a276c543825a403ef1dfaa2bd1a2063407d5c1ca4680c478ff5a8be32f	.{{= name }} {\n\n}\n\n.{{= name }} { position: relative; } \n
\\x323515a276c543825a403ef1dfaa2bd1a2063407d5c1ca4680c478ff5a8be32f	.{{= name }} {\n\n}\n\n.{{= name }} { position: relative; } \n
\\x335c996971ae280046f30253e6381c1618a34e987ca4f4ea3aaa44214b829b25	.{{= name }} {\n  \tbackground: #000;\n    color: white;\n    \n   \tcursor: pointer;\n  \topacity: 0.9;\n\n    height: 100%;\n    width: 100%; \n    \n    position: fixed;\n    left: 0;\n    top: 0;\n    \n    z-index: 9;\n    \n    display: table;\n\n}\n\n.{{= name }} > .content {\n    position: absolute;\n    \n    width: 100%;\n    height: 100%;\n    \n    overflow-y: auto;\n        \n    left: 0;\n    top: 0;\n        \n    text-align: center;\n    display: table-cell;\n    vertical-align: middle;\n}\n\n
\\x335c996971ae280046f30253e6381c1618a34e987ca4f4ea3aaa44214b829b25	.{{= name }} {\n  \tbackground: #000;\n    color: white;\n    \n   \tcursor: pointer;\n  \topacity: 0.9;\n\n    height: 100%;\n    width: 100%; \n    \n    position: fixed;\n    left: 0;\n    top: 0;\n    \n    z-index: 9;\n    \n    display: table;\n\n}\n\n.{{= name }} > .content {\n    position: absolute;\n    \n    width: 100%;\n    height: 100%;\n    \n    overflow-y: auto;\n        \n    left: 0;\n    top: 0;\n        \n    text-align: center;\n    display: table-cell;\n    vertical-align: middle;\n}\n\n
\\x346164397f7f0425c4b6ce95da2a77a260e58ad34213c57b062397ac754e18d9	var w = $('#'+id);\n
\\x346164397f7f0425c4b6ce95da2a77a260e58ad34213c57b062397ac754e18d9	var w = $('#'+id);\n
\\x346164397f7f0425c4b6ce95da2a77a260e58ad34213c57b062397ac754e18d9	var w = $('#'+id);\n
\\x346164397f7f0425c4b6ce95da2a77a260e58ad34213c57b062397ac754e18d9	var w = $('#'+id);\n
\\x346164397f7f0425c4b6ce95da2a77a260e58ad34213c57b062397ac754e18d9	var w = $('#'+id);\n
\\x346164397f7f0425c4b6ce95da2a77a260e58ad34213c57b062397ac754e18d9	var w = $('#'+id);\n
\\x347dd5042d86a602736aba80182866b9571b56e88c74567a5142624179f35de8	row_detail_tabbed
\\x347dd5042d86a602736aba80182866b9571b56e88c74567a5142624179f35de8	row_detail_tabbed
\\x34eb02a2ec6d73f0af6a5fa7f18da91f8bb542b9916aad5a7322f1d1c3db9282	sem_fkey_autocomplete_form
\\x34eb02a2ec6d73f0af6a5fa7f18da91f8bb542b9916aad5a7322f1d1c3db9282	sem_fkey_autocomplete_form
\\x360442d725f35393b0ec2ab68ad64c4dd6495a5a4496c4943539d2fa9aa3060b	bb20fbd6-05bc-45df-b6b4-669e58d0b47a
\\x360442d725f35393b0ec2ab68ad64c4dd6495a5a4496c4943539d2fa9aa3060b	bb20fbd6-05bc-45df-b6b4-669e58d0b47a
\\x363a0e488af6bc8882ef62395b9550a8a744107b5d06d0cc2127943a840b662e	a7ec4e00-8bc5-4901-aa20-fe3d31f44705
\\x363a0e488af6bc8882ef62395b9550a8a744107b5d06d0cc2127943a840b662e	a7ec4e00-8bc5-4901-aa20-fe3d31f44705
\\x363ce6b74e6242abd74fd7e49e8113f2b0fab6982afe5d45ebef42a209cf0f82	c5ca1ee1-932d-4802-93f1-ebb97de837ff
\\x363ce6b74e6242abd74fd7e49e8113f2b0fab6982afe5d45ebef42a209cf0f82	c5ca1ee1-932d-4802-93f1-ebb97de837ff
\\x375d750e37e2cebfd2909e93f5b6507fd24d2f174c659f2636708b2168b171b3	.{{= name }} {\n    position: relative;\n\tbottom: 0;\n    top: 0;\n    height: 100px;\n}\n\n.{{= name }} .new_widget {\n    padding-top: 10px;\n    color: red;\n}\n\n\n
\\x375d750e37e2cebfd2909e93f5b6507fd24d2f174c659f2636708b2168b171b3	.{{= name }} {\n    position: relative;\n\tbottom: 0;\n    top: 0;\n    height: 100px;\n}\n\n.{{= name }} .new_widget {\n    padding-top: 10px;\n    color: red;\n}\n\n\n
\\x385d11f809c9983f8bfc371dc5b6ee4ebdb81f8faef950050d91801f87c9a410	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:commit_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:commit_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('.modified_link').click(function() {\n    alert ('coming soon...');\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_commit_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n\n\n\n\n
\\x385d11f809c9983f8bfc371dc5b6ee4ebdb81f8faef950050d91801f87c9a410	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\n\n// fire off text_identifier\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id').html(widget('semantics/text_identifier', real_row));\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n// stage setup\n// staged\nif (change.get('staged')) {\n    w.find('div.staged').show();\n}\n// not staged\nelse if (change.get('staged') === false) {\n    w.find('div.unstaged').show();\n}\n// null means modified fields -- can be partially staged, so we show the field staging section\nelse if (change.get('staged') == null && change.get('change_type') == 'modified') {\n    var offstage_field_changes = change.get('offstage_field_changes');\n    var stage_field_changes = change.get('stage_field_changes');\n    \n    w.find('.unstaged_fields').show().html(widget('ide:commit_dialog_unstaged_fields', {\n        offstage_field_changes: change.get('offstage_field_changes'),\n        offstage_field_changes_old_vals: change.get('offstage_field_changes_old_vals'),\n        offstage_field_changes_new_vals: change.get('offstage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    w.find('.staged_fields').show().html(widget('ide:commit_dialog_staged_fields', {\n        stage_field_changes: change.get('stage_field_changes'),\n        stage_field_changes_old_vals: change.get('stage_field_changes_old_vals'),\n        stage_field_changes_new_vals: change.get('stage_field_changes_new_vals'),\n        bundle: bundle\n    }));\n\n    console.log('changed fields: ', offstage_field_changes, stage_field_changes);\n}\n\n// setup change_type icons\nswitch (change.get('change_type')) {\n    case 'added':\n\t    w.find('.added').show();\n        break;\n    case 'deleted':\n\t    w.find('.deleted').show();\n        break;\n    case 'modified':\n\t    w.find('.modified').show();\n        break;\n    case 'tracked':\n\t    w.find('.tracked').show();\n        break;\n    default:\n        console.log('UNKNOWN CHANGE TYPE: '+change.get('change_type'));\n        break;\n}\n\n// stage button\nw.find('button.stage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('stage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'tracked':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet', change);\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\n\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'deleted':\n\t\t    endpoint.schema('bundle').function('unstage_row_delete', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                reload();\n                // w.remove();\n            }).catch(function(e) {\n                show_error(e);\n            });\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});\n\nw.find('.modified_link').click(function() {\n    alert ('coming soon...');\n});\n\n\n\nfunction reload () {\n    w.trigger('reload_commit_dialog');\n    // return;\n    \n    // THIS DOESN'T WORK. See https://github.com/aquametalabs/aquameta/issues/57\n    console.log(change);\n    \n    var self = endpoint.schema('bundle').table('head_db_stage').row({\n        where: [{\n            name: 'row_id',\n            op: '=',\n            value: change.get('row_id')\n        }]\n    }).then(function(self) {\n        w.replaceWith(widget(name, self));\n    }).catch(function(e) {\n        console.error('error reloadig widget: ', e);\n    });\n}\n\nfunction show_error (e) {\n    alert('Error!\\n' + e)\n    console.error(e);\n}\n\n\n\n\n
\\x38e274caa98e1c81efac39e9396a20ffb836c061397fb6ebdf017cf74f4b375e	bf19b949-74d3-4938-ab5d-ad092884053d
\\x38e274caa98e1c81efac39e9396a20ffb836c061397fb6ebdf017cf74f4b375e	bf19b949-74d3-4938-ab5d-ad092884053d
\\x38e274caa98e1c81efac39e9396a20ffb836c061397fb6ebdf017cf74f4b375e	bf19b949-74d3-4938-ab5d-ad092884053d
\\x38e274caa98e1c81efac39e9396a20ffb836c061397fb6ebdf017cf74f4b375e	bf19b949-74d3-4938-ab5d-ad092884053d
\\x38e274caa98e1c81efac39e9396a20ffb836c061397fb6ebdf017cf74f4b375e	bf19b949-74d3-4938-ab5d-ad092884053d
\\x38e274caa98e1c81efac39e9396a20ffb836c061397fb6ebdf017cf74f4b375e	bf19b949-74d3-4938-ab5d-ad092884053d
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x39931eccbc22d36dd20a10232d45e7474ac2c22398cf88004b857da89c6db559	.{{= name }} {\r\n}
\\x3abcbfe2e2ab75cacb52e302924e2bda0550be8f30becd95dfed6eabbd9ea6c5	<div id="{{= id }}" class="{{= name }}">\n    Bundle manager\n</div>
\\x3abcbfe2e2ab75cacb52e302924e2bda0550be8f30becd95dfed6eabbd9ea6c5	<div id="{{= id }}" class="{{= name }}">\n    Bundle manager\n</div>
\\x3c6ee223373bfd2019b46acd5c74b35b369a64a70f2fe8755266fc667bc437ab	code_editor
\\x3c6ee223373bfd2019b46acd5c74b35b369a64a70f2fe8755266fc667bc437ab	code_editor
\\x3cd6f0248e628061efe3bee3c0c950854d89be5dff754681a774cf2727a9b2aa	<div id="{{= id }}" class="{{= name }}">\n    <div class='tabs'>\n        <div class='tab localhost'>bundles</div>\n        <div class='tab untracked'>untracked</div>\n    </div>\n    <div class='container'>\n        <div class='bundles'>\n            <button class='select'>select bundle</button>\n            <button class='new'>new bundle</button>\n        </div>\n    </div>\n</div>
\\x3cd6f0248e628061efe3bee3c0c950854d89be5dff754681a774cf2727a9b2aa	<div id="{{= id }}" class="{{= name }}">\n    <div class='tabs'>\n        <div class='tab localhost'>bundles</div>\n        <div class='tab untracked'>untracked</div>\n    </div>\n    <div class='container'>\n        <div class='bundles'>\n            <button class='select'>select bundle</button>\n            <button class='new'>new bundle</button>\n        </div>\n    </div>\n</div>
\\x3d05b227178ca5a294b67e387f6c05560a8326a10161fde87ca35f0d31200e78	debugger3_manager
\\x3d05b227178ca5a294b67e387f6c05560a8326a10161fde87ca35f0d31200e78	debugger3_manager
\\x3e0be0f7454e57c4110567e8a4c669513cab084a3fcf86b039c610afca335d1c	abd67d40-5fcc-499d-be81-8f23eed50855
\\x3e0be0f7454e57c4110567e8a4c669513cab084a3fcf86b039c610afca335d1c	abd67d40-5fcc-499d-be81-8f23eed50855
\\x3e28439bbcf1736f7fe5593f4df731afd2e7bb6d5050b9e377dd8ca0935212d5	<div id="{{= id }}" class="{{= name }}">\n    <div class="content"></div>\n</div>
\\x3e28439bbcf1736f7fe5593f4df731afd2e7bb6d5050b9e377dd8ca0935212d5	<div id="{{= id }}" class="{{= name }}">\n    <div class="content"></div>\n</div>
\\x3e32c790682dc359a9d122e57cb4408d89a5ea112a067bdcf61c47661e326538	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('schema_name') + '.' + row.get('name') }}\n</li>
\\x3e32c790682dc359a9d122e57cb4408d89a5ea112a067bdcf61c47661e326538	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('schema_name') + '.' + row.get('name') }}\n</li>
\\x3e48a45305b2f6bed65c918160c5eb9baef2bbd2380f5e506b5e63182578eeb7	33a37d92-671d-4988-93c6-e18742636808
\\x3e48a45305b2f6bed65c918160c5eb9baef2bbd2380f5e506b5e63182578eeb7	33a37d92-671d-4988-93c6-e18742636808
\\x3e48a45305b2f6bed65c918160c5eb9baef2bbd2380f5e506b5e63182578eeb7	33a37d92-671d-4988-93c6-e18742636808
\\x3e48a45305b2f6bed65c918160c5eb9baef2bbd2380f5e506b5e63182578eeb7	33a37d92-671d-4988-93c6-e18742636808
\\x3e49f390f5b85d2e80ed98b4b91ebd4afd7b5f2a2193c7208cc202dc8a848379	<div id="{{= id }}" class="{{= name }}">\n    <h2>New Row</h2>\n    <hr/>\n    \n    <h3>Development</h3>\n    <div class="new_row_buttons">\n        <div id="widget" class="new_row_button">\n            <div class="new_row_icon">⚙</div>\n            <div class="new_row_name">Widget</div>\n        </div>\n        <div id="resource" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Resource</div>\n        </div>\n        <div id="dependency_js" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Javascript Library</div>\n        </div>\n        <div id="table" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Table</div>\n        </div>\n        <div id="view" class="new_row_button">\n            <div class="new_row_icon">⌕</div>\n            <div class="new_row_name">View</div>\n        </div>\n        <div id="function" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Function</div>\n        </div>\n        <div id="binary" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Binary</div>\n        </div>\n        <div id="fdw" class="new_row_button">\n            <div class="new_row_icon">&#8599;</div>\n            <div class="new_row_name">Foreign Table</div>\n        </div>\n    </div>\n    \n    <h3>Bundle</h3>\n    \n    <h3>Everything</h3>\n</div>
\\x3e49f390f5b85d2e80ed98b4b91ebd4afd7b5f2a2193c7208cc202dc8a848379	<div id="{{= id }}" class="{{= name }}">\n    <h2>New Row</h2>\n    <hr/>\n    \n    <h3>Development</h3>\n    <div class="new_row_buttons">\n        <div id="widget" class="new_row_button">\n            <div class="new_row_icon">⚙</div>\n            <div class="new_row_name">Widget</div>\n        </div>\n        <div id="resource" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Resource</div>\n        </div>\n        <div id="dependency_js" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Javascript Library</div>\n        </div>\n        <div id="table" class="new_row_button">\n            <div class="new_row_icon">☰</div>\n            <div class="new_row_name">Table</div>\n        </div>\n        <div id="view" class="new_row_button">\n            <div class="new_row_icon">⌕</div>\n            <div class="new_row_name">View</div>\n        </div>\n        <div id="function" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Function</div>\n        </div>\n        <div id="binary" class="new_row_button">\n            <div class="new_row_icon">⚾</div>\n            <div class="new_row_name">Binary</div>\n        </div>\n        <div id="fdw" class="new_row_button">\n            <div class="new_row_icon">&#8599;</div>\n            <div class="new_row_name">Foreign Table</div>\n        </div>\n    </div>\n    \n    <h3>Bundle</h3>\n    \n    <h3>Everything</h3>\n</div>
\\x3eaf593f950a29b38bd9ed67aad93cad0c7bea497a8633922a58ff34fd701ab3	.{{= name }} {\n}\n\n.{{= name }} > .fkeys {\n    list-style: none;\n}
\\x3eaf593f950a29b38bd9ed67aad93cad0c7bea497a8633922a58ff34fd701ab3	.{{= name }} {\n}\n\n.{{= name }} > .fkeys {\n    list-style: none;\n}
\\x3ed59cae8358ff4b661c092d2b94f0d52a7f08d5a1ecd693c6f1f229d9d27159	8e0abc5c-3346-493c-895c-c3236d18ff33
\\x3ed59cae8358ff4b661c092d2b94f0d52a7f08d5a1ecd693c6f1f229d9d27159	8e0abc5c-3346-493c-895c-c3236d18ff33
\\x3fba2f328b9a7cd5a7c22717d4a6a4f3e0fb79363f6281beda89699d12f289b5	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'css' }) }}\n</div>
\\x3fba2f328b9a7cd5a7c22717d4a6a4f3e0fb79363f6281beda89699d12f289b5	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'css' }) }}\n</div>
\\x4086cf69c099bba946cbd45569e9bc47bc2a0f1f9956b8651df73f4aef03a015	var w = $("#"+id);\n\n\n// new row button handler\nw.find('button.new_row').click(function() {\n    console.log('new row trigger fired.');\n    w.trigger('open_tab', { tab_id: 'new_row' });\n});\n\n\n// new row button handler\nw.find('button.commit').click(function() {\n    w.trigger('open_tab', { tab_id: 'commit' });\n});\n\nw.find('button.commit_log').click(function() {\n    w.trigger('open_tab', { tab_id: 'commit_log' });\n});\n\n\n\nw.find('button.bundle_config').click(function() {\n    w.trigger('open_tab', { tab_id: 'bundle_config' });\n});\n\n\n\nw.find('button.push_pull').click(function() {\n    w.trigger('open_tab', { tab_id: 'push_pull' });\n});\n\n\n\n\n\n\n\n\n// filter handlers\nw.find('.filters .all').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\n// filter handlers\nw.find('.filters .changed').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nvar commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    order_by: {\n        column: 'row_id'\n    }\n});\n\n// filter handlers\nw.find('.filters .head').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_commit_row','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nw.find('.filters .all').click();\n\n// listen for triggers from semantic widgets which indicate crud changes to handle\nw.closest('.ide').bind('insert', function(e, o) {\n    alert('insert detected');\n    \n    var row_id = o.row.id;\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_value = row_id.pk_value;\n\n    endpoint.schema('bundle').function('tracked_row_add', [ \n        bundle.get('name'), \n        schema_name, \n        relation_name, \n        pk_column_name, \n        pk_value\n    ]).then(function() {\n        w.trigger('bundle_row_open', { row: o.row, row_id: row_id });\n    }).catch(function (e) {\n        alert('error calling tracked_row_add');\n    });\n});\n\n\nfunction refresh_active_window() {\n}\n\n\n
\\x4086cf69c099bba946cbd45569e9bc47bc2a0f1f9956b8651df73f4aef03a015	var w = $("#"+id);\n\n\n// new row button handler\nw.find('button.new_row').click(function() {\n    console.log('new row trigger fired.');\n    w.trigger('open_tab', { tab_id: 'new_row' });\n});\n\n\n// new row button handler\nw.find('button.commit').click(function() {\n    w.trigger('open_tab', { tab_id: 'commit' });\n});\n\nw.find('button.commit_log').click(function() {\n    w.trigger('open_tab', { tab_id: 'commit_log' });\n});\n\n\n\nw.find('button.bundle_config').click(function() {\n    w.trigger('open_tab', { tab_id: 'bundle_config' });\n});\n\n\n\nw.find('button.push_pull').click(function() {\n    w.trigger('open_tab', { tab_id: 'push_pull' });\n});\n\n\n\n\n\n\n\n\n// filter handlers\nw.find('.filters .all').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\n// filter handlers\nw.find('.filters .changed').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nvar commit_rows = bundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    order_by: {\n        column: 'row_id'\n    }\n});\n\n// filter handlers\nw.find('.filters .head').click(function() {\n    w.find('> .filters .tab').removeClass('highlighted');\n    $(this).addClass('highlighted');\n\n    var commit_rows = bundle.related_rows('id','bundle.head_commit_row','bundle_id', {\n        order_by: {\n            column: 'row_id'\n        }\n    });\n    widget.sync(commit_rows, w.find('.bundle_contents').empty(), function(commit_row) {\n        return widget('row_list_row', {\n            commit_row: commit_row\n        })\n    });\n});\n\nw.find('.filters .all').click();\n\n// listen for triggers from semantic widgets which indicate crud changes to handle\nw.closest('.ide').bind('insert', function(e, o) {\n    alert('insert detected');\n    \n    var row_id = o.row.id;\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_value = row_id.pk_value;\n\n    endpoint.schema('bundle').function('tracked_row_add', [ \n        bundle.get('name'), \n        schema_name, \n        relation_name, \n        pk_column_name, \n        pk_value\n    ]).then(function() {\n        w.trigger('bundle_row_open', { row: o.row, row_id: row_id });\n    }).catch(function (e) {\n        alert('error calling tracked_row_add');\n    });\n});\n\n\nfunction refresh_active_window() {\n}\n\n\n
\\x41c18b9209140e16dc2f5aec74cf7f627dddba1e54b757a268373e54cb3ad347	fkey_test
\\x41c18b9209140e16dc2f5aec74cf7f627dddba1e54b757a268373e54cb3ad347	fkey_test
\\x425c3c83339aad5de458f764ae5bfb8bd47e61ca2121074179889c0c5ff1c7aa	<div id="{{= id }}" class="{{= name }}">\n    <h2>New row</h2>\n    <input class='name' type='text' placeholder='New name'>\n    <button class='save'>Create</button>\n    <button class='save_as_null'>Save as null</button>\n</div>
\\x425c3c83339aad5de458f764ae5bfb8bd47e61ca2121074179889c0c5ff1c7aa	<div id="{{= id }}" class="{{= name }}">\n    <h2>New row</h2>\n    <input class='name' type='text' placeholder='New name'>\n    <button class='save'>Create</button>\n    <button class='save_as_null'>Save as null</button>\n</div>
\\x432b1a5aa2ce105118a633e322633a24add43777ad9691b285194ab0118b5ff8	var w = $("#"+id);\n\nvar change = commit_row.get('change_type');\n\nif (change != 'same') {\n    if (change == 'added')\n\t    w.find('.added').show();\n    else if (change == 'deleted')\n\t    w.find('.deleted').show();\n    else if (change == 'modified')\n\t    w.find('.modified').show();\n    else if (change == 'tracked')\n\t    w.find('.tracked').show();\n    else w.append('UNKNOWN CHANGE TYPE: '+change);\n}\n\nvar exists = commit_row.get('row_exists');\nif (exists == false) {\n    w.find('.doesnt_exist').show();\n}\n\nvar schema_name = commit_row.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = commit_row.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = commit_row.get('row_id').pk_column_id.name;\nvar pk_value = commit_row.get('row_id').pk_value;\n\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n    \n    w.find('.label').html(widget('semantics/text_identifier', real_row ));\n    \n\t// click handler needs real_row, so put the handler in here after real_row is loaded\n    w.click(function() {\n        w.trigger('bundle_row_open', { row_id: commit_row.get('row_id'), row: real_row });\n    });\n    return real_row;\n\n}).catch(function(e) {\n    console.log(e);\n\tw.find('.label').html(schema_name+'.'+relation_name+'.'+pk_value);\n}).then(function() {\n    //w.show();\n    w.find('.label > *').ready(function() {\n        w.show();\n    });\n});\n\n\n
\\x432b1a5aa2ce105118a633e322633a24add43777ad9691b285194ab0118b5ff8	var w = $("#"+id);\n\nvar change = commit_row.get('change_type');\n\nif (change != 'same') {\n    if (change == 'added')\n\t    w.find('.added').show();\n    else if (change == 'deleted')\n\t    w.find('.deleted').show();\n    else if (change == 'modified')\n\t    w.find('.modified').show();\n    else if (change == 'tracked')\n\t    w.find('.tracked').show();\n    else w.append('UNKNOWN CHANGE TYPE: '+change);\n}\n\nvar exists = commit_row.get('row_exists');\nif (exists == false) {\n    w.find('.doesnt_exist').show();\n}\n\nvar schema_name = commit_row.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = commit_row.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = commit_row.get('row_id').pk_column_id.name;\nvar pk_value = commit_row.get('row_id').pk_value;\n\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n    \n    w.find('.label').html(widget('semantics/text_identifier', real_row ));\n    \n\t// click handler needs real_row, so put the handler in here after real_row is loaded\n    w.click(function() {\n        w.trigger('bundle_row_open', { row_id: commit_row.get('row_id'), row: real_row });\n    });\n    return real_row;\n\n}).catch(function(e) {\n    console.log(e);\n\tw.find('.label').html(schema_name+'.'+relation_name+'.'+pk_value);\n}).then(function() {\n    //w.show();\n    w.find('.label > *').ready(function() {\n        w.show();\n    });\n});\n\n\n
\\x43a7a359077a6699d1fef86b2ca9203a636976b5d01c2f5d52fab18988ee2172	var w = $("#"+id);\n\nvar bundle_name = window.location.hash.split('#')[1];\n\n\nif (typeof bundle_name == 'undefined') {\n    w.find('header .title').html('Select a bundle');\n    w.find('.row_list_section').html(widget('ide:bundle_selector'));\n    w.on('bundle_selected', function(e, payload) {\n        \n        w.find('.bundle_selector').remove();\n        bundle_name = payload.bundle_name;\n        window.location.hash = bundle_name;\n        show_bundle();\n    });\n}\nelse {\n    show_bundle();\n}\n\nfunction show_bundle() {\n    endpoint.schema('bundle').table('bundle').row({\n        where: {\n            name: 'name',\n            op: '=',\n            value: bundle_name\n        }\n    }).then(function(bundle) {\n        // load the workspace\n        w.find('.workspace_section').html(widget('ide:workspace', { bundle: bundle }));\n        w.find('.row_list_section').html(widget('ide:row_list', { bundle: bundle }));\n        w.find('header .title').html(bundle.get('name'));\n    });\n\n}
\\x43a7a359077a6699d1fef86b2ca9203a636976b5d01c2f5d52fab18988ee2172	var w = $("#"+id);\n\nvar bundle_name = window.location.hash.split('#')[1];\n\n\nif (typeof bundle_name == 'undefined') {\n    w.find('header .title').html('Select a bundle');\n    w.find('.row_list_section').html(widget('ide:bundle_selector'));\n    w.on('bundle_selected', function(e, payload) {\n        \n        w.find('.bundle_selector').remove();\n        bundle_name = payload.bundle_name;\n        window.location.hash = bundle_name;\n        show_bundle();\n    });\n}\nelse {\n    show_bundle();\n}\n\nfunction show_bundle() {\n    endpoint.schema('bundle').table('bundle').row({\n        where: {\n            name: 'name',\n            op: '=',\n            value: bundle_name\n        }\n    }).then(function(bundle) {\n        // load the workspace\n        w.find('.workspace_section').html(widget('ide:workspace', { bundle: bundle }));\n        w.find('.row_list_section').html(widget('ide:row_list', { bundle: bundle }));\n        w.find('header .title').html(bundle.get('name'));\n    });\n\n}
\\x46720f6ea15d33e05713d3ac8dee758de8f01e74ca63dcedf569c5995d76cb07	row_list
\\x46720f6ea15d33e05713d3ac8dee758de8f01e74ca63dcedf569c5995d76cb07	row_list
\\x46975344ee6d8d7c570f1aebf2f9926683d219f3a5579f09bd1b6be5e02909dd	.{{= name }} {\n    height: 100%;\n}\n\n.{{= name }} .tabs {\n    height: 100%;\n}
\\x46975344ee6d8d7c570f1aebf2f9926683d219f3a5579f09bd1b6be5e02909dd	.{{= name }} {\n    height: 100%;\n}\n\n.{{= name }} .tabs {\n    height: 100%;\n}
\\x4812bb60aeec2400a63245f25cd9627e8ae11398592538307494b2380216326c	<div id="{{= id }}" class="{{= name }}">\n    <div class='fields'>\n    </div>\n</div>
\\x4812bb60aeec2400a63245f25cd9627e8ae11398592538307494b2380216326c	<div id="{{= id }}" class="{{= name }}">\n    <div class='fields'>\n    </div>\n</div>
\\x4812bb60aeec2400a63245f25cd9627e8ae11398592538307494b2380216326c	<div id="{{= id }}" class="{{= name }}">\n    <div class='fields'>\n    </div>\n</div>
\\x4812bb60aeec2400a63245f25cd9627e8ae11398592538307494b2380216326c	<div id="{{= id }}" class="{{= name }}">\n    <div class='fields'>\n    </div>\n</div>
\\x482a80f74412a47b7bcbf661efcb68b5108ece60d2a37ac00dd9458a0efa5437	var w = $("#"+id);\n\n\nfunction new_tab(tab_id, label, content) {\n    // console.log('opening new tab');\n    // create the header\n    w.find('.tab_headers').append(widget('ide:workspace_tab_header', {\n        label: label,\n        tab_id: tab_id\n    }));\n\n\n    // create the tab\n    w.find('> .tab_contents').append(widget('ide:workspace_tab', {\n        content: content,\n        tab_id: tab_id\n    }));\n\n    // focus\n    show_tab(tab_id);\n}\n\nfunction current_tab() {\n    return w.find('.workspace_tab_header.highlighted').first().data('tab_id');\n}\n\nfunction show_tab(tab_id) {\n    // console.log('show tab ', tab_id);\n    // show the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).show();\n        } else {\n            $(this).hide();\n        }\n    })\n\n    // highlight the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).addClass('highlighted');\n        } else {\n            $(this).removeClass('highlighted');\n        }\n    })\n}\n\nfunction close_tab(tab_id) {\n    /*\n    why doesn't this work?\n    w.find('.workspace_tab[data-tab_id="'+tab_id+'"]').remove();\n    w.find('.workspace_tab_header[data-tab_id="'+tab_id+'"]').remove();\n    */\n    \n    var current_tab_closed = false;\n    if (tab_id == current_tab()) {\n        current_tab_closed = true;\n    }\n    \n    // remove the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // remove the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // if the current tab is closed, replace it with another\n    if (current_tab_closed) {\n        var last_tab = w.find('.workspace_tab').last();\n        if (last_tab) {\n            show_tab(last_tab.data('tab_id'));\n        }\n    }\n}\n\nfunction tab_is_open(tab_id) {\n    // check to see if it's already open\n    var is_open = false;\n    var tabs = w.find('.workspace_tab');\n    for (var i=0;i<tabs.length;i++) {\n        var this_tab_id = $(tabs[i]).data('tab_id');\n\n        // console.log('comparing '+this_tab_id +' to ' + tab_id);\n        if (this_tab_id == tab_id) {\n            // console.log('already open');\n            return true;\n        }\n    };\n    return false;\n}\n\nw.closest('.ide').bind('close_tab', function(e,o) {\n    close_tab(o.tab_id);\n});\n\nw.closest('.ide').bind('show_tab', function(e,o) {\n    show_tab(o.tab_id);\n});\n\nconsole.log(endpoint);\n// handler for row clicked event\nw.closest('.ide').bind('bundle_row_open', function(e, o) {\n    // console.log('bundle_row_clicked', e, o);\n\n    var row_id = o.row_id;\n    var row = o.row;\n\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_val = row_id.pk_value;\n    var label = widget('semantics/text_identifier', row);\n    var tab_id = schema_name + '.' + relation_name + '.' + pk_val;\n\n    if (!tab_is_open(tab_id)) {\n        console.log(endpoint);\n        // open a new tab for this row\n        endpoint\n        .schema(schema_name)\n        .table(relation_name)\n        .row(pk_column_name, pk_val).then(function(real_row) {\n            new_tab(tab_id, label, widget('semantics/row_detail', real_row));\n        }).catch(function(e) {\n            console.log('error: ',e);\n        });\n    } else {\n        // send to front\n        show_tab(tab_id);\n    }\n\n\n});\n\n// new generic dialog handler\nw.closest('.ide').bind('open_tab', function(e,o) {\n    var tab_id = o.tab_id;\n\n    if (tab_is_open(tab_id)) {\n        show_tab(tab_id);\n    } else {\n        switch (tab_id) {\n            case 'new_row':\n                new_tab('new_row', 'New Row', widget('ide:new_row_dialog', { bundle: bundle }));\n                break;\n            case 'commit':\n                new_tab('commit', 'Commit', widget('ide:commit_dialog', { bundle: bundle }));\n                break;\n            case 'commit_log':\n                new_tab('commit_log', 'Commit History', widget('ide:commit_history_dialog', { bundle: bundle }));\n                break;\n            case 'bundle_config':\n                new_tab('bundle_config', 'Bundle Config', widget('ide:bundle_config_dialog', { bundle: bundle }));\n                break;\n            case 'push_pull':\n                new_tab('push_pull', 'Push Pull', widget('ide:bundle_push_pull', { bundle: bundle }));\n                break;\n            default:\n                alert ('internal error: no such dialog as '+tab_id);\n        }\n    }\n});\n\n// close generic dialog\nw.closest('.ide').bind('close_tab', function(e,o) {\n    var tab_id = o.tab_id;\n    close_tab(o.tab_id);\n});\n\n\n\n\n\n
\\x482a80f74412a47b7bcbf661efcb68b5108ece60d2a37ac00dd9458a0efa5437	var w = $("#"+id);\n\n\nfunction new_tab(tab_id, label, content) {\n    // console.log('opening new tab');\n    // create the header\n    w.find('.tab_headers').append(widget('ide:workspace_tab_header', {\n        label: label,\n        tab_id: tab_id\n    }));\n\n\n    // create the tab\n    w.find('> .tab_contents').append(widget('ide:workspace_tab', {\n        content: content,\n        tab_id: tab_id\n    }));\n\n    // focus\n    show_tab(tab_id);\n}\n\nfunction current_tab() {\n    return w.find('.workspace_tab_header.highlighted').first().data('tab_id');\n}\n\nfunction show_tab(tab_id) {\n    // console.log('show tab ', tab_id);\n    // show the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).show();\n        } else {\n            $(this).hide();\n        }\n    })\n\n    // highlight the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).addClass('highlighted');\n        } else {\n            $(this).removeClass('highlighted');\n        }\n    })\n}\n\nfunction close_tab(tab_id) {\n    /*\n    why doesn't this work?\n    w.find('.workspace_tab[data-tab_id="'+tab_id+'"]').remove();\n    w.find('.workspace_tab_header[data-tab_id="'+tab_id+'"]').remove();\n    */\n    \n    var current_tab_closed = false;\n    if (tab_id == current_tab()) {\n        current_tab_closed = true;\n    }\n    \n    // remove the tab\n    w.find('.workspace_tab').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // remove the tab header\n    w.find('.workspace_tab_header').each(function(e) {\n        if ($(this).data('tab_id') == tab_id) {\n            $(this).remove();\n        }\n    });\n\n    // if the current tab is closed, replace it with another\n    if (current_tab_closed) {\n        var last_tab = w.find('.workspace_tab').last();\n        if (last_tab) {\n            show_tab(last_tab.data('tab_id'));\n        }\n    }\n}\n\nfunction tab_is_open(tab_id) {\n    // check to see if it's already open\n    var is_open = false;\n    var tabs = w.find('.workspace_tab');\n    for (var i=0;i<tabs.length;i++) {\n        var this_tab_id = $(tabs[i]).data('tab_id');\n\n        // console.log('comparing '+this_tab_id +' to ' + tab_id);\n        if (this_tab_id == tab_id) {\n            // console.log('already open');\n            return true;\n        }\n    };\n    return false;\n}\n\nw.closest('.ide').bind('close_tab', function(e,o) {\n    close_tab(o.tab_id);\n});\n\nw.closest('.ide').bind('show_tab', function(e,o) {\n    show_tab(o.tab_id);\n});\n\nconsole.log(endpoint);\n// handler for row clicked event\nw.closest('.ide').bind('bundle_row_open', function(e, o) {\n    // console.log('bundle_row_clicked', e, o);\n\n    var row_id = o.row_id;\n    var row = o.row;\n\n    var schema_name = row_id.pk_column_id.relation_id.schema_id.name;\n    var relation_name = row_id.pk_column_id.relation_id.name;\n    var pk_column_name = row_id.pk_column_id.name;\n    var pk_val = row_id.pk_value;\n    var label = widget('semantics/text_identifier', row);\n    var tab_id = schema_name + '.' + relation_name + '.' + pk_val;\n\n    if (!tab_is_open(tab_id)) {\n        console.log(endpoint);\n        // open a new tab for this row\n        endpoint\n        .schema(schema_name)\n        .table(relation_name)\n        .row(pk_column_name, pk_val).then(function(real_row) {\n            new_tab(tab_id, label, widget('semantics/row_detail', real_row));\n        }).catch(function(e) {\n            console.log('error: ',e);\n        });\n    } else {\n        // send to front\n        show_tab(tab_id);\n    }\n\n\n});\n\n// new generic dialog handler\nw.closest('.ide').bind('open_tab', function(e,o) {\n    var tab_id = o.tab_id;\n\n    if (tab_is_open(tab_id)) {\n        show_tab(tab_id);\n    } else {\n        switch (tab_id) {\n            case 'new_row':\n                new_tab('new_row', 'New Row', widget('ide:new_row_dialog', { bundle: bundle }));\n                break;\n            case 'commit':\n                new_tab('commit', 'Commit', widget('ide:commit_dialog', { bundle: bundle }));\n                break;\n            case 'commit_log':\n                new_tab('commit_log', 'Commit History', widget('ide:commit_history_dialog', { bundle: bundle }));\n                break;\n            case 'bundle_config':\n                new_tab('bundle_config', 'Bundle Config', widget('ide:bundle_config_dialog', { bundle: bundle }));\n                break;\n            case 'push_pull':\n                new_tab('push_pull', 'Push Pull', widget('ide:bundle_push_pull', { bundle: bundle }));\n                break;\n            default:\n                alert ('internal error: no such dialog as '+tab_id);\n        }\n    }\n});\n\n// close generic dialog\nw.closest('.ide').bind('close_tab', function(e,o) {\n    var tab_id = o.tab_id;\n    close_tab(o.tab_id);\n});\n\n\n\n\n\n
\\x4938388f0c68650a2120ab03dfbf8e39b08edca0d086b3c3fd02e84e501a5fab	var w = $("#"+id);
\\x4938388f0c68650a2120ab03dfbf8e39b08edca0d086b3c3fd02e84e501a5fab	var w = $("#"+id);
\\x4938388f0c68650a2120ab03dfbf8e39b08edca0d086b3c3fd02e84e501a5fab	var w = $("#"+id);
\\x4938388f0c68650a2120ab03dfbf8e39b08edca0d086b3c3fd02e84e501a5fab	var w = $("#"+id);
\\x49ed84d05b59d4c96dc196182eb54212f36dc0ac0aad4eaac284212cf2ebe87c	if (typeof data_name != 'undefined' && typeof data != 'undefined') {\n    $('#'+id).data(data_name, data);\n}
\\x49ed84d05b59d4c96dc196182eb54212f36dc0ac0aad4eaac284212cf2ebe87c	if (typeof data_name != 'undefined' && typeof data != 'undefined') {\n    $('#'+id).data(data_name, data);\n}
\\x4c37e2ce9e5b1d3200064c3eca14a4027a1088b0bc406d35cf476b9ea2cb8fab	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\n// TODO this fails for views\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var columns = [];\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\n    if (row.columns == null) {\n        throw 'Please call this row with "meta_data" set to true. ' + rel_name;\n    }\n    row.columns.forEach(function(col, i) {\n        if (col.name != 'id' && col.name != 'name') {\n            tabs[col.name] = function() {\n                return widget('semantics/form_field', row.field(col.name));\n            };\n            tab_colors[col.name] = colors[i % colors.length];\n            columns.push(col.name);\n        }\n    });\n\n\n    /* TABBED LAYOUT */\n    var preview_row = row.clone();\n\n    w.find('> .top > .section_content > .tabs').append(\n        widget('core:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Row deleted from ' + rel_name, 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Widget delete failed', 'fail']);\n            setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('button.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.find('button.delete').on('click', handle_delete_button);\n\n    w.find('button.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Row copied from ' + rel_name, 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('isnerted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(xhr) {\n                w.trigger('status', ['Row copy failed on ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x4c37e2ce9e5b1d3200064c3eca14a4027a1088b0bc406d35cf476b9ea2cb8fab	var w = $("#"+id);\n\n// Row detail tabbed\n/* Originally created for widget editing\n * - id field is ignored\n * - name field is editing above, such as editable_field\n * - the rest of fields are edited in tabs\n */\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'code': 9881,\n    'data': 9883\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\n// TODO this fails for views\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    /* SETUP */\n    var rel_name = row.relation.schema.name + '.' + row.relation.name;\n    var relation = row.relation;\n\n    var tabs = {};\n    var tab_colors = {};\n    var columns = [];\n    var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet'];\n\n    if (row.columns == null) {\n        throw 'Please call this row with "meta_data" set to true. ' + rel_name;\n    }\n    row.columns.forEach(function(col, i) {\n        if (col.name != 'id' && col.name != 'name') {\n            tabs[col.name] = function() {\n                return widget('semantics/form_field', row.field(col.name));\n            };\n            tab_colors[col.name] = colors[i % colors.length];\n            columns.push(col.name);\n        }\n    });\n\n\n    /* TABBED LAYOUT */\n    var preview_row = row.clone();\n\n    w.find('> .top > .section_content > .tabs').append(\n        widget('core:tabbed_layout', {\n            tabs: tabs,\n            tab_colors: tab_colors\n        })\n    );\n\n    function handle_delete_button() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Row deleted from ' + rel_name, 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    }\n\n\n    function set_have_unsaved_changes(is_unsaved){\n        /*\n    var save_button = w.find("> .save");\n    save_button.text(is_unsaved ? 'Save' : 'Saved');\n    window.onbeforeunload = is_unsaved ? function() { return "You have unsaved changes!" } : null;\n    */\n    } \n\n\n\n    function handle_save_button() {\n\n        update_row()\n        .then(function() {\n            set_have_unsaved_changes(false);\n            w.trigger('status', ['Widget saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Widget delete failed', 'fail']);\n            setTimeout(set_have_unsaved_changes.bind(this,false), 2000)\n        });\n\n    }\n\n\n\n    function update_row() {\n\n        row.set('pre_js',  row.get('pre_js'));\n        row.set('css',     row.get('css'));\n        row.set('html',    row.get('html'));\n        row.set('post_js', row.get('post_js'));\n\n        return row.update();\n\n    }\n\n    w.find('button.save').on('click', handle_save_button);\n    w.on('keydown', jwerty.event('ctrl+s', handle_save_button));\n    w.find('button.delete').on('click', handle_delete_button);\n\n    w.find('button.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n\n            relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Row copied from ' + rel_name, 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    console.log('isnerted row', new_row);\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(xhr) {\n                w.trigger('status', ['Row copy failed on ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n});\n
\\x4c7702bcc44b6c5b360449c1a15e643d4114f5f70b789c7cf0b8f9ced4b40e98	commit_dialog_unstaged_field
\\x4c7702bcc44b6c5b360449c1a15e643d4114f5f70b789c7cf0b8f9ced4b40e98	commit_dialog_unstaged_field
\\x4d2b4793a5f45e14036938937bb1cd40961d0d0ccefd56a0a7d50a5a5f6744d9	workspace_tab_header
\\x4d2b4793a5f45e14036938937bb1cd40961d0d0ccefd56a0a7d50a5a5f6744d9	workspace_tab_header
\\x50235897630bafa5cada43a34fd3e8e8d20fb04f6d04d319bb73dbd8fed86d91	.{{= name }} {\n    white-space: nowrap;\n    display: none;\n}\n\n.{{= name }}:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.tracked {\n    color: lightblue;\n}\n\n.{{= name }} .expand {\n    cursor: pointer;\n    display: none;\n}\n.{{= name }} .expand:hover {\n    background-color: red;\n}
\\x50235897630bafa5cada43a34fd3e8e8d20fb04f6d04d319bb73dbd8fed86d91	.{{= name }} {\n    white-space: nowrap;\n    display: none;\n}\n\n.{{= name }}:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.tracked {\n    color: lightblue;\n}\n\n.{{= name }} .expand {\n    cursor: pointer;\n    display: none;\n}\n.{{= name }} .expand:hover {\n    background-color: red;\n}
\\x51111600a316ca942f14150d605eabe2534f7d9984a3d6756cab4de7cf2e3729	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'htmlmixed' }) }}\n</div>
\\x51111600a316ca942f14150d605eabe2534f7d9984a3d6756cab4de7cf2e3729	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('core:code_editor', { field: field, language: 'htmlmixed' }) }}\n</div>
\\x52a04589e8e0d5c378e277f333866aec7a0563f3818442be7f4268eb8c2fdabd	a4d101f6-3d5f-464b-87d6-637525254ed8
\\x52a04589e8e0d5c378e277f333866aec7a0563f3818442be7f4268eb8c2fdabd	a4d101f6-3d5f-464b-87d6-637525254ed8
\\x52a04589e8e0d5c378e277f333866aec7a0563f3818442be7f4268eb8c2fdabd	a4d101f6-3d5f-464b-87d6-637525254ed8
\\x52a04589e8e0d5c378e277f333866aec7a0563f3818442be7f4268eb8c2fdabd	a4d101f6-3d5f-464b-87d6-637525254ed8
\\x52bd16217e8b90894703f18f78be37ecb0bfff0e1873114f43f6ca1da71eb67d	var w = $("#"+id);\n\n\nvar rel_name = row.relation.schema.name + '.' + row.relation.name;\n\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    w.find('.section_content').append(widget('semantics/form_field', row.field('content')));\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    w.find('.version').append(widget('semantics/form_field', row.field('version')));\n\n    // SAVE\n    function save() {\n        row.update()\n        .then(function() {\n            w.trigger('status', ['Dependency saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n        });\n    }\n\n\n    w.find('.save').on('click', save);\n    w.on('keydown', jwerty.event('ctrl+s', save));\n\n\n    // DELETE\n    w.find('.delete').on('click', function() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Dependency deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    });\n    \n\n\n    // COPY\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n            row.relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Dependency copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n\n});
\\x52bd16217e8b90894703f18f78be37ecb0bfff0e1873114f43f6ca1da71eb67d	var w = $("#"+id);\n\n\nvar rel_name = row.relation.schema.name + '.' + row.relation.name;\n\nrow.relation.row(row.pk_column_name, row.pk_value)\n.then(function(row) {\n    \n    w.find('.section_content').append(widget('semantics/form_field', row.field('content')));\n    \n    w.find('.name').append(widget('semantics/form_field', row.field('name')));\n    \n    w.find('.version').append(widget('semantics/form_field', row.field('version')));\n\n    // SAVE\n    function save() {\n        row.update()\n        .then(function() {\n            w.trigger('status', ['Dependency saved', 'success']);\n        }).catch(function() {\n            w.trigger('status', ['Failed save on ' + rel_name, 'fail']);\n        });\n    }\n\n\n    w.find('.save').on('click', save);\n    w.on('keydown', jwerty.event('ctrl+s', save));\n\n\n    // DELETE\n    w.find('.delete').on('click', function() {\n        if(confirm("Are you sure you\\'d like to delete this row?")) {\n            row.delete()\n            .then(function() {\n                w.trigger('status', ['Dependency deleted', 'success']);\n                w.trigger('row_detail_delete');\n                w.trigger('done');\n                w.remove();\n            }).catch(function() {\n                w.trigger('status', ['Failed row delete on ' + rel_name, 'fail']);\n                w.trigger('done');\n            });\n        }\n    });\n    \n\n\n    // COPY\n    w.find('.copy').click(function() {\n\n        if (confirm('Copy this row?')) {\n\n            var cloned_row = row.clone();\n            var new_name = row.get('name') + '_COPY';\n\n            cloned_row.set('id', undefined);\n            cloned_row.set('name', new_name);\n\n            row.relation.insert(cloned_row.row_data)\n            .then(function(new_row) {\n                w.trigger('status', ['Dependency copy saved', 'success']);\n                if (confirm('Would you like to edit the new row now?\\nPress cancel to resume editing original')) {\n                    w.replaceWith(\n                        widget('semantics/row_detail', new_row)\n                    );\n                }\n            }).catch(function(err) {\n                w.trigger('status', ['Failed save while copying from  ' + rel_name, 'fail']);\n            });\n        }\n\n    });\n\n});
\\x5358ff53681056ae0356462ae3387d63d678d4d4b649586509fda2e5e1506fa8	fcda24f0-1c2a-4b7d-a488-da24c13fef6c
\\x5358ff53681056ae0356462ae3387d63d678d4d4b649586509fda2e5e1506fa8	fcda24f0-1c2a-4b7d-a488-da24c13fef6c
\\x53e8601e9073fa3019b40cdc5d25740665535c929287b6e67d9c840001857fa0	file_input
\\x53e8601e9073fa3019b40cdc5d25740665535c929287b6e67d9c840001857fa0	file_input
\\x55a2c50c268113c589166dacb53c4f9aa8dd3cbe551aac17732e3964bea2e7d5	8ab2e8c6-93be-4367-b5ee-1e2c14579929
\\x55a2c50c268113c589166dacb53c4f9aa8dd3cbe551aac17732e3964bea2e7d5	8ab2e8c6-93be-4367-b5ee-1e2c14579929
\\x5703f774560776175843c001581d09995d668491531534a2cfdea7bc56b51e7a	<div id="{{= id }}" class="{{= name }}">\n    <div class='tools'>\n    </div>\n    <div class='tabs'></div>\n\n</div>
\\x5703f774560776175843c001581d09995d668491531534a2cfdea7bc56b51e7a	<div id="{{= id }}" class="{{= name }}">\n    <div class='tools'>\n    </div>\n    <div class='tabs'></div>\n\n</div>
\\x57ae1612b9692014484953cfe0da9216432bd372ab84a1b8041cf3b991fc9a87	506990f8-99c0-4441-a3fd-04ec402d7e22
\\x57ae1612b9692014484953cfe0da9216432bd372ab84a1b8041cf3b991fc9a87	506990f8-99c0-4441-a3fd-04ec402d7e22
\\x57d02e31a15cc04634064013f94ed94694ab920c67305f4c72a3cf820581240a	f71fad4d-4284-47f5-9dbf-bffdded7973b
\\x57d02e31a15cc04634064013f94ed94694ab920c67305f4c72a3cf820581240a	f71fad4d-4284-47f5-9dbf-bffdded7973b
\\x585002546fa8b30771ec448dc759adaf5a8faf42c14d6f40316718ae3fc05243	debugger3_widgets
\\x585002546fa8b30771ec448dc759adaf5a8faf42c14d6f40316718ae3fc05243	debugger3_widgets
\\x59c6f94018afaecb43687ba36fdb933ccca4f9223ecd72356d9823252e0d59c7	.{{= name }} {\n    height: 100%;\n}
\\x59c6f94018afaecb43687ba36fdb933ccca4f9223ecd72356d9823252e0d59c7	.{{= name }} {\n    height: 100%;\n}
\\x5ace3d25ce6590a5e97cd1b482c97a8c803308ef40a4c9a6351dac8ed514a8af	b6638ea9-df8f-409e-990b-34ffee6ab4f3
\\x5ace3d25ce6590a5e97cd1b482c97a8c803308ef40a4c9a6351dac8ed514a8af	b6638ea9-df8f-409e-990b-34ffee6ab4f3
\\x5ba997e85188d885358bbeb791b71b1ba8650bb217a3e1d4f661feae68f097b9	codemirror
\\x5ba997e85188d885358bbeb791b71b1ba8650bb217a3e1d4f661feae68f097b9	codemirror
\\x5bae293baf08571e4ff4e5779171c82f68d15e88475ab4a300180c84cfe0c315	.{{= name }} h3 {\n    text-decoration: underline;\n}
\\x5bae293baf08571e4ff4e5779171c82f68d15e88475ab4a300180c84cfe0c315	.{{= name }} h3 {\n    text-decoration: underline;\n}
\\x5c41cadbfa6994e300ff10c1e7c19b7bcca2de2214e5353de4ae89bfcbba9230	new_row_by_name
\\x5c41cadbfa6994e300ff10c1e7c19b7bcca2de2214e5353de4ae89bfcbba9230	new_row_by_name
\\x5d09cb54360e74189ff5545545c5c13f36546cb51185f1dd0b3927a544c7ddf1	dev_workspace
\\x5d09cb54360e74189ff5545545c5c13f36546cb51185f1dd0b3927a544c7ddf1	dev_workspace
\\x5d528502a7f157dae91beedda534ceb9995d86bc71e377fb9791b7608d1c655d	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'purpose'],\n            order_by: {\n                column: 'purpose'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('core:option', {\n                label: row.get('purpose'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\x5d528502a7f157dae91beedda534ceb9995d86bc71e377fb9791b7608d1c655d	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'purpose'],\n            order_by: {\n                column: 'purpose'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('core:option', {\n                label: row.get('purpose'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\x5eb69aaa28a8760f69907d4773a4ff4b55547c9b0f729fa8c718933a65f58c34	.{{= name }} {\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n}\n\n.{{= name }} > header {\n    margin: 0;\n}\n\n.{{= name }} > header img {\n    display: inline;\n    vertical-align: middle;\n}\n\n.{{= name }} > header .text {\n    display: inline;\n    vertical-align: middle;\n}\n\n\n.{{= name }} > .content {\n    display: flex;\n    flex: 2;\n    overflow: auto; /* was 'hidden' -elh */\n}\n\n.{{= name }} .row_list_section {\n    order: 0;\n    flex: 1 1 auto;\n    align-self: auto;\n    border: 1px solid white;\n    width: 20em;\n    overflow: auto;\n}\n\n.{{= name }} .workspace_section {\n    order: 0;\n    flex: 5 1 80%;\n    align-self: auto;\n}\n\n.{{= name }} .bundle_icon:hover {\n    cursor: pointer;\n}\n\n.{{= name }} header {\n    padding-bottom: 0px;\n}\n.{{= name }} header a {\n    font-size: 200%;\n    color: blue;\n    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\n    text-decoration: none;\n    font-weight: bold;\n\n}\n\n.{{= name }} header a:hover {\n    text-decoration: underline;\n    color: blue;\n}\n
\\x5eb69aaa28a8760f69907d4773a4ff4b55547c9b0f729fa8c718933a65f58c34	.{{= name }} {\n    display: flex;\n    flex-flow: column;\n    height: 100%;\n}\n\n.{{= name }} > header {\n    margin: 0;\n}\n\n.{{= name }} > header img {\n    display: inline;\n    vertical-align: middle;\n}\n\n.{{= name }} > header .text {\n    display: inline;\n    vertical-align: middle;\n}\n\n\n.{{= name }} > .content {\n    display: flex;\n    flex: 2;\n    overflow: auto; /* was 'hidden' -elh */\n}\n\n.{{= name }} .row_list_section {\n    order: 0;\n    flex: 1 1 auto;\n    align-self: auto;\n    border: 1px solid white;\n    width: 20em;\n    overflow: auto;\n}\n\n.{{= name }} .workspace_section {\n    order: 0;\n    flex: 5 1 80%;\n    align-self: auto;\n}\n\n.{{= name }} .bundle_icon:hover {\n    cursor: pointer;\n}\n\n.{{= name }} header {\n    padding-bottom: 0px;\n}\n.{{= name }} header a {\n    font-size: 200%;\n    color: blue;\n    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\n    text-decoration: none;\n    font-weight: bold;\n\n}\n\n.{{= name }} header a:hover {\n    text-decoration: underline;\n    color: blue;\n}\n
\\x606f905a24a9c6fad3f403cd2589b74ea7ae03a19ff81eeefaf668864f08eab5	<div id="{{= id }}" class="{{= name }}">\n    <span class='open'>Click to select</span>\n</div>
\\x606f905a24a9c6fad3f403cd2589b74ea7ae03a19ff81eeefaf668864f08eab5	<div id="{{= id }}" class="{{= name }}">\n    <span class='open'>Click to select</span>\n</div>
\\x614896271504fde786be2226571345aec077456d9151454c17a2f931723c3938	var w = $("#"+id);\n\nvar remotes = bundle.related_rows('id','bundle.remote','bundle_id');\n\nw.find('.remotes').html(widget('semantics/list_view', remotes));
\\x614896271504fde786be2226571345aec077456d9151454c17a2f931723c3938	var w = $("#"+id);\n\nvar remotes = bundle.related_rows('id','bundle.remote','bundle_id');\n\nw.find('.remotes').html(widget('semantics/list_view', remotes));
\\x61f66d6d78fe5c0be8c9debcaf8c2d845c8ce07566ac7d530fd941416e9bdb0c	.{{= name }} {\n    height: 100%;\n}\n\n.{{= name }} > .header {\n    height: 1.5rem;\n    text-align: right;\n    background-color: #333;\n}\n\n.{{= name }} > .header > .select_bundles {\n    float: left;\n}\n\n.{{= name }} > .header > * {\n\theight: 100%;\n}\n\n.{{= name }}:not(.bundle_edit) > .header > button.select_bundles,\n.{{= name }}:not(.bundle_edit) > .header > span.bundle_manager_container,\n.{{= name }}:not(.bundle_edit) > div.bundle_workspace,\n.{{= name }}.bundle_edit > div.bundle_list {\n    display: none;\n}\n\n.{{= name }} > .content {\n    height: calc(100% - 1.5rem);\n}\n\n.{{= name }} > .status_container {\n    position: fixed;\n    bottom: 0;\n    right: 0;\n    width: 100%;\n    z-index: 100;\n}\n
\\x61f66d6d78fe5c0be8c9debcaf8c2d845c8ce07566ac7d530fd941416e9bdb0c	.{{= name }} {\n    height: 100%;\n}\n\n.{{= name }} > .header {\n    height: 1.5rem;\n    text-align: right;\n    background-color: #333;\n}\n\n.{{= name }} > .header > .select_bundles {\n    float: left;\n}\n\n.{{= name }} > .header > * {\n\theight: 100%;\n}\n\n.{{= name }}:not(.bundle_edit) > .header > button.select_bundles,\n.{{= name }}:not(.bundle_edit) > .header > span.bundle_manager_container,\n.{{= name }}:not(.bundle_edit) > div.bundle_workspace,\n.{{= name }}.bundle_edit > div.bundle_list {\n    display: none;\n}\n\n.{{= name }} > .content {\n    height: calc(100% - 1.5rem);\n}\n\n.{{= name }} > .status_container {\n    position: fixed;\n    bottom: 0;\n    right: 0;\n    width: 100%;\n    z-index: 100;\n}\n
\\x62698de7ebb236b44c3e0b61bd82139bec11aa423e76504b58a6a0fd421b1212	<div id="{{= id }}" class="{{= name }}">\n    <label><input type='radio' name='{{= name }}' value='{{= bundle.get("name") }}'> {{= bundle.get('name') }}</label>\n</div>
\\x62698de7ebb236b44c3e0b61bd82139bec11aa423e76504b58a6a0fd421b1212	<div id="{{= id }}" class="{{= name }}">\n    <label><input type='radio' name='{{= name }}' value='{{= bundle.get("name") }}'> {{= bundle.get('name') }}</label>\n</div>
\\x629f3d2d42dd95f2b3b548f586b38499bb8f4b1f655cb8053229c9c195a1c4f5	list_item_path
\\x629f3d2d42dd95f2b3b548f586b38499bb8f4b1f655cb8053229c9c195a1c4f5	list_item_path
\\x62e4283b1b269c99b2322fc0ffdd053d6ea1ed4d5302210fe831fc6f35ce6f61	3a598b60-305d-4b23-8e01-855219b33ac2
\\x62e4283b1b269c99b2322fc0ffdd053d6ea1ed4d5302210fe831fc6f35ce6f61	3a598b60-305d-4b23-8e01-855219b33ac2
\\x637fa38ff5990502881082c8879f84e4c0e1c917d790e475645472206e60a28b	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\n\nw.find('.close').click(function(e) {\n    w.trigger('close_tab', { tab_id: tab_id });\n    e.stopPropagation();\n});\n\nw.click(function() {\n    w.trigger('show_tab', { tab_id: tab_id });\n});
\\x637fa38ff5990502881082c8879f84e4c0e1c917d790e475645472206e60a28b	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\n\nw.find('.close').click(function(e) {\n    w.trigger('close_tab', { tab_id: tab_id });\n    e.stopPropagation();\n});\n\nw.click(function() {\n    w.trigger('show_tab', { tab_id: tab_id });\n});
\\x650ae161af699a8d17ea55e5e842965c55a65ece1c268437b53a091ca319a564	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('path') || row.get('id') }}\n</li>
\\x650ae161af699a8d17ea55e5e842965c55a65ece1c268437b53a091ca319a564	<li id="{{= id }}" class="{{= name }}">\n    {{= row.get('path') || row.get('id') }}\n</li>
\\x659b19554accb3f2798a4c2bd9a8ae58b120af2884027fc871e8dbe12eafc9fb	<option id="{{= id }}" class="{{= name }}" value="{{= value }}" {{? typeof selected != 'undefined' && selected == true}}selected {{?}}>{{= label }}</option>\n\n
\\x659b19554accb3f2798a4c2bd9a8ae58b120af2884027fc871e8dbe12eafc9fb	<option id="{{= id }}" class="{{= name }}" value="{{= value }}" {{? typeof selected != 'undefined' && selected == true}}selected {{?}}>{{= label }}</option>\n\n
\\x65bf4dc92e018509d2f36000be7dec2779fe7de3d22a0ccd56fcc8bed335091d	.{{= name }} {\n    cursor: pointer;\n    position: relative;\n}\n\n.{{= name }}:hover {\n    background-color: yellow;\n    color: black;\n}\n\n.debugger3_widget_highlight {\n    border: 4px solid yellow !important;\n}
\\x65bf4dc92e018509d2f36000be7dec2779fe7de3d22a0ccd56fcc8bed335091d	.{{= name }} {\n    cursor: pointer;\n    position: relative;\n}\n\n.{{= name }}:hover {\n    background-color: yellow;\n    color: black;\n}\n\n.debugger3_widget_highlight {\n    border: 4px solid yellow !important;\n}
\\x6877310210ad6eb417d226f6c596e780936bb123a2fe63f965466cd1f5915a64	.{{= name }} {\n    display: flex;\n    flex-direction: row;\n    height: 100%;\n}\n\n.{{= name }}.detail_view > section.list {\n    flex: 1;\n}\n\n.{{= name }}.detail_view > section.detail {\n    flex: 2;\n}\n\n\n\n/* LIST */\n.{{= name }} > .list {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.{{= name }} > .list > ul {\n    flex: 9;\n    list-style: none;\n    overflow-y: auto;\n    padding: 0;\n    margin: 0;\n}\n\n.{{= name }}.detail_view > .list {\n    margin: 0;\n    background-color: #888;\n}\n\n.{{= name }}:not(.detail_view) > .list {\n    width: 80%;\n    margin: 0 auto;\n    background-color: none;\n}\n\n.{{= name }} > .list.collapsed {\n    width: 0;\n    display: none;\n}\n\n\n.{{= name }} > .list > .header {\n    flex: 1;\n    text-align: center;\n    border-bottom: 0.5rem solid rgba(0, 0, 100, 0.2);\n}\n\n.{{= name }}.detail_view > .list > .header {\n    flex: 0;\n    display: block;\n    text-align: center;\n}\n\n.{{= name }}.detail_view > .list > .header > .title {\n    font-size: initial;\n}\n\n.{{= name }} > .list > .header > .title {\n    display: inline-block;\n    font-size: x-large;\n    margin-bottom: 1rem;\n}\n\n.{{= name }} > .list > .header > .arrow {\n    display: inline-block;\n    margin: 0 0.5rem;\n    font-size: x-large;\n    vertical-align: sub;\n    \n    transform: rotate(270deg);\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    -moz-transform: rotate(270deg);\n    \n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }} > .list > .header > .arrow.up {\n    transform: rotate(90deg);\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    -moz-transform: rotate(90deg);\n}\n\n.{{= name }}.detail_view > .list > .header > .arrow {\n    font-size: initial;\n    vertical-align: middle;\n}\n\n.{{= name }} > .list > .header > .continue.hide {\n    display: none;\n}\n\n.{{= name }} > .list > .header > .continue {\n    position: relative;\n    width: 25%;\n    padding: 0.75rem;\n    \n    font-size: medium;\n    border: 2px solid darkgreen;\n    border-radius: 0.1rem;\n    color: #ddd;\n    background-color: green;\n}\n\n.{{= name }} > .list > .header > .continue:hover {\n    background-color: darkgreen;\n}\n\n.{{= name }} > .list > .header > .continue:active {\n    top: 1px;\n    background-color: lightgreen;\n}\n\n.{{= name }}.detail_view > .list > .header > button {\n    margin: 1rem auto;\n}\n\n.{{= name }} > .list > .header > button:first-child {\n    margin-left: 2rem;\n}\n\n.{{= name }} > .list > .header > button {\n    margin: 1rem 0;\n}\n\n.{{= name }} > .list > .header > .options {\n    display: inline-block;\n    width: 60%;\n    text-align: left;\n    padding: 0 1rem 1rem;\n}\n\n.{{= name }}.detail_view > .list > .header > .options {\n    width: 100%;\n}\n\n.{{= name }} > .list > .header > .arrow:not(.up) ~ .options {\n    display: none;\n}\n\n.{{= name }} > .list > .header > .options > .search {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > .list > .header > .options > .search:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > .list > .header > .options > .search:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}\n\n\n\n/* DIVIDER */\n.{{= name }}:not(.detail_view) > .divider {\n    display: none;\n}\t\n\n.{{= name }}.detail_view > .divider {\n    padding: 0.25rem;\n    background-color: #333;\n\tcursor: w-resize;\n    pointer: w-resize;\n}\n\n.{{= name }}.detail_view > .divider > span {\n    display: inline-block;\n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }} > .list.collapsed + .divider {\n    cursor: e-resize;\n    pointer: e-resize;\n}\n\n.{{= name }} > .list.collapsed + .divider > span {\n    transform: rotate(180deg);\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    -moz-transform: rotate(180deg);\n}\n\n.{{= name }} > .divider:hover {\n    background-color: #666;\n}\n\n.{{= name }} > .divider:active {\n    background-color: #888;\n}\n\n\n\n/* DETAIL */\n.{{= name }}.detail_view > .detail {\n    padding: 0 1rem 1rem;\n    /* padding: 1rem; */\n}\n
\\x6877310210ad6eb417d226f6c596e780936bb123a2fe63f965466cd1f5915a64	.{{= name }} {\n    display: flex;\n    flex-direction: row;\n    height: 100%;\n}\n\n.{{= name }}.detail_view > section.list {\n    flex: 1;\n}\n\n.{{= name }}.detail_view > section.detail {\n    flex: 2;\n}\n\n\n\n/* LIST */\n.{{= name }} > .list {\n    display: flex;\n    flex-direction: column;\n    height: 100%;\n}\n\n.{{= name }} > .list > ul {\n    flex: 9;\n    list-style: none;\n    overflow-y: auto;\n    padding: 0;\n    margin: 0;\n}\n\n.{{= name }}.detail_view > .list {\n    margin: 0;\n    background-color: #888;\n}\n\n.{{= name }}:not(.detail_view) > .list {\n    width: 80%;\n    margin: 0 auto;\n    background-color: none;\n}\n\n.{{= name }} > .list.collapsed {\n    width: 0;\n    display: none;\n}\n\n\n.{{= name }} > .list > .header {\n    flex: 1;\n    text-align: center;\n    border-bottom: 0.5rem solid rgba(0, 0, 100, 0.2);\n}\n\n.{{= name }}.detail_view > .list > .header {\n    flex: 0;\n    display: block;\n    text-align: center;\n}\n\n.{{= name }}.detail_view > .list > .header > .title {\n    font-size: initial;\n}\n\n.{{= name }} > .list > .header > .title {\n    display: inline-block;\n    font-size: x-large;\n    margin-bottom: 1rem;\n}\n\n.{{= name }} > .list > .header > .arrow {\n    display: inline-block;\n    margin: 0 0.5rem;\n    font-size: x-large;\n    vertical-align: sub;\n    \n    transform: rotate(270deg);\n    -webkit-transform: rotate(270deg);\n    -ms-transform: rotate(270deg);\n    -moz-transform: rotate(270deg);\n    \n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }} > .list > .header > .arrow.up {\n    transform: rotate(90deg);\n    -webkit-transform: rotate(90deg);\n    -ms-transform: rotate(90deg);\n    -moz-transform: rotate(90deg);\n}\n\n.{{= name }}.detail_view > .list > .header > .arrow {\n    font-size: initial;\n    vertical-align: middle;\n}\n\n.{{= name }} > .list > .header > .continue.hide {\n    display: none;\n}\n\n.{{= name }} > .list > .header > .continue {\n    position: relative;\n    width: 25%;\n    padding: 0.75rem;\n    \n    font-size: medium;\n    border: 2px solid darkgreen;\n    border-radius: 0.1rem;\n    color: #ddd;\n    background-color: green;\n}\n\n.{{= name }} > .list > .header > .continue:hover {\n    background-color: darkgreen;\n}\n\n.{{= name }} > .list > .header > .continue:active {\n    top: 1px;\n    background-color: lightgreen;\n}\n\n.{{= name }}.detail_view > .list > .header > button {\n    margin: 1rem auto;\n}\n\n.{{= name }} > .list > .header > button:first-child {\n    margin-left: 2rem;\n}\n\n.{{= name }} > .list > .header > button {\n    margin: 1rem 0;\n}\n\n.{{= name }} > .list > .header > .options {\n    display: inline-block;\n    width: 60%;\n    text-align: left;\n    padding: 0 1rem 1rem;\n}\n\n.{{= name }}.detail_view > .list > .header > .options {\n    width: 100%;\n}\n\n.{{= name }} > .list > .header > .arrow:not(.up) ~ .options {\n    display: none;\n}\n\n.{{= name }} > .list > .header > .options > .search {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > .list > .header > .options > .search:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > .list > .header > .options > .search:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}\n\n\n\n/* DIVIDER */\n.{{= name }}:not(.detail_view) > .divider {\n    display: none;\n}\t\n\n.{{= name }}.detail_view > .divider {\n    padding: 0.25rem;\n    background-color: #333;\n\tcursor: w-resize;\n    pointer: w-resize;\n}\n\n.{{= name }}.detail_view > .divider > span {\n    display: inline-block;\n    transition: all 200ms;\n    -webkit-transition: all 200ms;\n    -moz-transition: all 200ms;\n    -ms-transition: all 200ms;\n}\n\n.{{= name }} > .list.collapsed + .divider {\n    cursor: e-resize;\n    pointer: e-resize;\n}\n\n.{{= name }} > .list.collapsed + .divider > span {\n    transform: rotate(180deg);\n    -webkit-transform: rotate(180deg);\n    -ms-transform: rotate(180deg);\n    -moz-transform: rotate(180deg);\n}\n\n.{{= name }} > .divider:hover {\n    background-color: #666;\n}\n\n.{{= name }} > .divider:active {\n    background-color: #888;\n}\n\n\n\n/* DETAIL */\n.{{= name }}.detail_view > .detail {\n    padding: 0 1rem 1rem;\n    /* padding: 1rem; */\n}\n
\\x68ab7ed2eb06ac9f8b64f529ea52d50a441baac2e3b98242d8bde19b5b2e05b5	5b3d0629-48a8-4695-af58-52235349ae00
\\x68ab7ed2eb06ac9f8b64f529ea52d50a441baac2e3b98242d8bde19b5b2e05b5	5b3d0629-48a8-4695-af58-52235349ae00
\\x68ab7ed2eb06ac9f8b64f529ea52d50a441baac2e3b98242d8bde19b5b2e05b5	5b3d0629-48a8-4695-af58-52235349ae00
\\x68ab7ed2eb06ac9f8b64f529ea52d50a441baac2e3b98242d8bde19b5b2e05b5	5b3d0629-48a8-4695-af58-52235349ae00
\\x68cd8c4c16a9155db64a91a376b40ee1aec6c0106de7c8c2590ebaa0ecdfd4f0	.{{= name }} {\n    border: 1px solid #999;\n    width: 100px;\n    background-color: #000;\n    padding-left: 5px;\n}\n\n.{{= name }} .close {\n    padding: 0px 5px;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n    cursor: pointer;\n}\n\n.{{= name }}.highlighted {\n    background-color: #0aa;\n}\n\n.{{= name }} span.close:hover {\n    background-color: red;\n    color: white;\n    cursor: pointer;\n}
\\x68cd8c4c16a9155db64a91a376b40ee1aec6c0106de7c8c2590ebaa0ecdfd4f0	.{{= name }} {\n    border: 1px solid #999;\n    width: 100px;\n    background-color: #000;\n    padding-left: 5px;\n}\n\n.{{= name }} .close {\n    padding: 0px 5px;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n    cursor: pointer;\n}\n\n.{{= name }}.highlighted {\n    background-color: #0aa;\n}\n\n.{{= name }} span.close:hover {\n    background-color: red;\n    color: white;\n    cursor: pointer;\n}
\\x6a16a1c8a0871db9d880ec09aa08a951aff4aad8a4cdf401b27129a89b7617c8	33e64e6d-87ec-4598-882d-1c5a7560082a
\\x6a16a1c8a0871db9d880ec09aa08a951aff4aad8a4cdf401b27129a89b7617c8	33e64e6d-87ec-4598-882d-1c5a7560082a
\\x6b493f0906f9fed9907837053d8465844786e217633b7f64a4d4f477dea6e6bb	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n \n * join_table:\n * join_from_column:\n * join_to_column:\n \n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar join_rows;\nvar where_object = {};\nwhere_object[join_from_column] = from_row.get(from_column);\nfunction show_list() {\n    \n    w.find('.join_rows').empty();\n    \n    join_rows = endpoint.schema(join_table.schema.name).table(join_table.name).rows().where(where_object);\n    \n    widget.sync(join_rows, w.find('.join_rows'), function(row) {\n        return widget('sem_fkey_many_to_many_li', { \n            row: row,\n            label_function: label_function\n        });\n    });\n}\n
\\x6b493f0906f9fed9907837053d8465844786e217633b7f64a4d4f477dea6e6bb	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n \n * join_table:\n * join_from_column:\n * join_to_column:\n \n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar join_rows;\nvar where_object = {};\nwhere_object[join_from_column] = from_row.get(from_column);\nfunction show_list() {\n    \n    w.find('.join_rows').empty();\n    \n    join_rows = endpoint.schema(join_table.schema.name).table(join_table.name).rows().where(where_object);\n    \n    widget.sync(join_rows, w.find('.join_rows'), function(row) {\n        return widget('sem_fkey_many_to_many_li', { \n            row: row,\n            label_function: label_function\n        });\n    });\n}\n
\\x6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b	1
\\x6b86b273ff34fce19d6b804eff5a3f5747ada4eaa22f1d49c01e52ddb7875b4b	1
\\x6c071d732c8713602aa93dfe40ae1da37ef6b96a21fde8f6f09ce9db3fbd0ab1	list_view_gateway
\\x6c071d732c8713602aa93dfe40ae1da37ef6b96a21fde8f6f09ce9db3fbd0ab1	list_view_gateway
\\x6c82f41c7a1d89a354e8c39cd75f59ef3fbe445c2cfa496c5d4492a92a1351a0	757f5d27-b98c-4e03-9b9a-68457402456d
\\x6c82f41c7a1d89a354e8c39cd75f59ef3fbe445c2cfa496c5d4492a92a1351a0	757f5d27-b98c-4e03-9b9a-68457402456d
\\x6d007c11256a4b37081649f93d2bfaeb17d6ce2c88e71167eec6fbfacc12ef24	11f0af38-f0b0-4fbe-8618-3ba3d6688e75
\\x6d007c11256a4b37081649f93d2bfaeb17d6ce2c88e71167eec6fbfacc12ef24	11f0af38-f0b0-4fbe-8618-3ba3d6688e75
\\x6ef876c8791daec6f97cb3b47ed632bab5f56b74bee3fed0761e97e3acfa4bc2	<div id="{{= id }}" class="{{= name }}">\n    <p>{{= widget('semantics/form_field', row.field('name')) }}</p>\n    <div class="top">\n        <div class="sections">\n            <div class="section code selected">code</div>\n            <div class="section data">data</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="save">Save</button>\n                <button class="copy">Copy</button>\n                <button class="delete">Delete</button>\n            </div>\n            <div class="tabs"></div>\n        </div>\n    </div>\n</div>
\\x6ef876c8791daec6f97cb3b47ed632bab5f56b74bee3fed0761e97e3acfa4bc2	<div id="{{= id }}" class="{{= name }}">\n    <p>{{= widget('semantics/form_field', row.field('name')) }}</p>\n    <div class="top">\n        <div class="sections">\n            <div class="section code selected">code</div>\n            <div class="section data">data</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="save">Save</button>\n                <button class="copy">Copy</button>\n                <button class="delete">Delete</button>\n            </div>\n            <div class="tabs"></div>\n        </div>\n    </div>\n</div>
\\x6f0563d19348597343ca2c5c6aa2bb7dd19c6243acde7934023df25f22d213e6	50d541d0-91d8-4d23-8a16-ef99261ae323
\\x6f0563d19348597343ca2c5c6aa2bb7dd19c6243acde7934023df25f22d213e6	50d541d0-91d8-4d23-8a16-ef99261ae323
\\x6fd5396780d06df02a0335e226220c48ba21c4670a75ffffeff3799c207a0595	8ed1284f-340f-4d28-885c-2efea81c7b7e
\\x6fd5396780d06df02a0335e226220c48ba21c4670a75ffffeff3799c207a0595	8ed1284f-340f-4d28-885c-2efea81c7b7e
\\x6fd5396780d06df02a0335e226220c48ba21c4670a75ffffeff3799c207a0595	8ed1284f-340f-4d28-885c-2efea81c7b7e
\\x6fd5396780d06df02a0335e226220c48ba21c4670a75ffffeff3799c207a0595	8ed1284f-340f-4d28-885c-2efea81c7b7e
\\x700754396d520b688905e32933931d1a34d55c871ef6fa63681cb521529bb298	<div id="{{= id }}" class="{{= name }}">\n    <span class='field_name'></span><button class='unstage'>unstage</button>\n</div>
\\x700754396d520b688905e32933931d1a34d55c871ef6fa63681cb521529bb298	<div id="{{= id }}" class="{{= name }}">\n    <span class='field_name'></span><button class='unstage'>unstage</button>\n</div>
\\x729aaaa4651a7837c344487775a5b42198e73e98ca7bbdf9583ac2d5a356c3ea	row_detail_widget
\\x729aaaa4651a7837c344487775a5b42198e73e98ca7bbdf9583ac2d5a356c3ea	row_detail_widget
\\x72f82ac3904a47573322714031736d032ea6ee806a27c0505d9507b35cdccafe	editable_field_fkey_select
\\x72f82ac3904a47573322714031736d032ea6ee806a27c0505d9507b35cdccafe	editable_field_fkey_select
\\x7350ba8d2f23a9badfaecbb353f2e59b22d10f9052aeefe5414d2c74d36b2822	<div id="{{= id }}" class="{{= name }}">\r\n</div>
\\x7350ba8d2f23a9badfaecbb353f2e59b22d10f9052aeefe5414d2c74d36b2822	<div id="{{= id }}" class="{{= name }}">\r\n</div>
\\x73ccb3af163ca15969f8afed1fdb87f3c4ec1fd554de2a22ccdbabae1992e704	new_row_use_copy_instead
\\x73ccb3af163ca15969f8afed1fdb87f3c4ec1fd554de2a22ccdbabae1992e704	new_row_use_copy_instead
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x74234e98afe7498fb5daf1f36ac2d78acc339464f950703b8c019892f982b90b	null
\\x7669ec761fa6b88a8e8cdb03a1ed8387a6abc1d57a1d4358ba4bdfb4932254d0	89a4a72e-cd33-4a0d-b9fe-3d37020b62da
\\x7669ec761fa6b88a8e8cdb03a1ed8387a6abc1d57a1d4358ba4bdfb4932254d0	89a4a72e-cd33-4a0d-b9fe-3d37020b62da
\\x767308688adf85ffd7b056875aded376cdf92cebbb8df0452f666481675b4d17	var w = $("#"+id);\n\n\n\n// widget\n\nw.find('#widget').click(function() {\n    var name = prompt('New widget name');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('widget').insert({ name: name })\n    .then(function(widget) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'widget',\n            'id',\n            widget.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: widget, row_id: widget.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n\n// resource\n\nw.find('#resource').click(function() {\n    var path = prompt('Enter the path for this resource');\n    if (!path) { return; }\n\n    endpoint.schema('endpoint').table('resource').insert({ path: path, content: '', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(resource) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'resource',\n            'id',\n            resource.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: resource, row_id: resource.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n// dependency_js\n\nw.find('#dependency_js').click(function() {\n    var name = prompt('Enter the name for this dependency');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('dependency_js').insert({\n        name: name,\n        content: '// add your js library here',\n        version: ''\n    }).then(function(dep) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'dependency_js',\n            'id',\n            dep.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: dep, row_id: dep.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// table\n\nw.find('#table').click(function() {\n    var name = prompt('New table name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('table').insert({\n        schema_name: schema,\n        name: name\n    }).then(function(table) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'table',\n            'id',\n            table.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: table, row_id: table.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// view\n\nw.find('#view').click(function() {\n    var name = prompt('New view name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('view').insert({\n        schema_name: schema,\n        name: name,\n        query: 'select 1'\n    }).then(function(view) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'view',\n            'id',\n            view.id\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: view, row_id: view.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n// function\nw.find('#function').click(function() {\n    var name = prompt('New function name');\n    if (!name) { return; }\n\n    var schema = prompt('What schema should it go in?');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('function').insert({\n        name: name,\n        schema_name: schema,\n        parameters: ['integer'],\n        return_type: 'void',\n        definition: '',\n        language: 'sql'\n    })\n    .then(function(f) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'function',\n            'id',\n            f.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: f, row_id: f.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n
\\x767308688adf85ffd7b056875aded376cdf92cebbb8df0452f666481675b4d17	var w = $("#"+id);\n\n\n\n// widget\n\nw.find('#widget').click(function() {\n    var name = prompt('New widget name');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('widget').insert({ name: name })\n    .then(function(widget) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'widget',\n            'id',\n            widget.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: widget, row_id: widget.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n\n// resource\n\nw.find('#resource').click(function() {\n    var path = prompt('Enter the path for this resource');\n    if (!path) { return; }\n\n    endpoint.schema('endpoint').table('resource').insert({ path: path, content: '', mimetype_id: '944b5a05-be70-45a1-a549-1301d38799e4' })\n    .then(function(resource) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'endpoint',\n            'resource',\n            'id',\n            resource.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: resource, row_id: resource.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n// dependency_js\n\nw.find('#dependency_js').click(function() {\n    var name = prompt('Enter the name for this dependency');\n    if (!name) { return; }\n\n    endpoint.schema('widget').table('dependency_js').insert({\n        name: name,\n        content: '// add your js library here',\n        version: ''\n    }).then(function(dep) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'widget',\n            'dependency_js',\n            'id',\n            dep.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: dep, row_id: dep.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// table\n\nw.find('#table').click(function() {\n    var name = prompt('New table name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('table').insert({\n        schema_name: schema,\n        name: name\n    }).then(function(table) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'table',\n            'id',\n            table.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: table, row_id: table.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n\n\n\n// view\n\nw.find('#view').click(function() {\n    var name = prompt('New view name');\n    if (!name) { return; }\n\n    var schema = prompt('New schema name');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('view').insert({\n        schema_name: schema,\n        name: name,\n        query: 'select 1'\n    }).then(function(view) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'view',\n            'id',\n            view.id\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: view, row_id: view.id });\n        }).catch(function(e) {\n            alert('error: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n\n\n\n// function\nw.find('#function').click(function() {\n    var name = prompt('New function name');\n    if (!name) { return; }\n\n    var schema = prompt('What schema should it go in?');\n    if (!schema) { return; }\n\n    endpoint.schema('meta').table('function').insert({\n        name: name,\n        schema_name: schema,\n        parameters: ['integer'],\n        return_type: 'void',\n        definition: '',\n        language: 'sql'\n    })\n    .then(function(f) {\n        endpoint.schema('bundle').function('tracked_row_add', [\n            bundle.get('name'),\n            'meta',\n            'function',\n            'id',\n            f.get('id')\n        ]).then(function() {\n            w.trigger('bundle_row_open', { row: f, row_id: f.id });\n        }).catch(function(e) {\n            console.error(e);\n            alert('error adding tracked row: ' + e.title + e.message);\n        });\n    }).catch(function(e) {\n        console.error(e);\n        alert('error creating row: ' + e.title + e.message);\n    });\n});\n
\\x76dea33b5fcdfaaffe69f9081f1cdb9293dafd8abb5a91a9fb3b5955f5af7920	.{{= name }} {\n    width: 100%;\n    height: 1.5rem;\n    color: white;\n    text-align: center;\n    \n    background-color: white;\n    visibility: visible;\n    opacity: 1;\n    \n    -webkit-transition:\n        background-color 500ms,\n        opacity 1s 1s,\n        visibility 0s 2s;\n}\n\n.{{= name }}.fade {\n    opacity: 0;\n    visibility: hidden;\n}\n\n.{{= name }}.success,\n.{{= name }}.good {\n    background-color: green;\n}\n\n.{{= name }}.fail,\n.{{= name }}.failed,\n.{{= name }}.bad {\n    background-color: red;\n}
\\x76dea33b5fcdfaaffe69f9081f1cdb9293dafd8abb5a91a9fb3b5955f5af7920	.{{= name }} {\n    width: 100%;\n    height: 1.5rem;\n    color: white;\n    text-align: center;\n    \n    background-color: white;\n    visibility: visible;\n    opacity: 1;\n    \n    -webkit-transition:\n        background-color 500ms,\n        opacity 1s 1s,\n        visibility 0s 2s;\n}\n\n.{{= name }}.fade {\n    opacity: 0;\n    visibility: hidden;\n}\n\n.{{= name }}.success,\n.{{= name }}.good {\n    background-color: green;\n}\n\n.{{= name }}.fail,\n.{{= name }}.failed,\n.{{= name }}.bad {\n    background-color: red;\n}
\\x7785012b278b096f1b6a4988374ed76d9ec10d75530d0ba72376d02506094614	.{{= name }} {\n    display: inline-block;\n    padding: 0 1rem;\n}
\\x7785012b278b096f1b6a4988374ed76d9ec10d75530d0ba72376d02506094614	.{{= name }} {\n    display: inline-block;\n    padding: 0 1rem;\n}
\\x778656789a8a318829c8724afd915d3d08785585eb2423e4b11abf8d2ddc3221	workspace_tabs
\\x778656789a8a318829c8724afd915d3d08785585eb2423e4b11abf8d2ddc3221	workspace_tabs
\\x77fcd296e80da02a0433de2ec8d16754a6a254c95722ce96728b87d6deb8db73	commit_dialog_unstaged_fields
\\x77fcd296e80da02a0433de2ec8d16754a6a254c95722ce96728b87d6deb8db73	commit_dialog_unstaged_fields
\\x78ad322d4425011c4967d50a70c8b7e8198a0d99a98b267b67629262da46d5f8	list_item_with_edit_button
\\x78ad322d4425011c4967d50a70c8b7e8198a0d99a98b267b67629262da46d5f8	list_item_with_edit_button
\\x79ab288df5c841a12746e5b84913f8c57bbc51642c9427b0f0770ea8d16d5910	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar append_new_widget = function() { \n    \n    alert('New widget still loading...\\nTry again in a moment'); \n    \n}\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\n\n// Find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    schema_name: to_relation.schema.name,\n    name: to_relation.name\n}).result(function(to_relation_obj) {\n\n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n\n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n    \n    append_new_widget = function() {\n        \n        w.append(\n            widget('modal_overlay', {\n                content: widget(new_row_widget, { \n                    relation: to_relation_obj,\n                    context_data: context_data\n                })\n            })\n        );\n        \n    }\n\n\n});\n\n\n// Prevent reload tab triggered by 'sem_list_item_new'\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n});\n\n\n// When new_row_widget returns...\nw.on('new_row', function(e, payload) {\n    \n    select_row(payload.new_row);\n    \n});\n\n\n// When a row is selected...\nfunction select_row(row) {\n    \n    if (row == 'new') {\n        \n        append_new_widget();\n        \n    }\n    \n    else if (row == 'none') {\n\n        from_row.set(from_column, null);\n        from_row.update().done(function() {\n\n            console.log('Fkey deleted');\n            w.trigger('fkey_deleted');\n            w.trigger('done');\n\n        });\n        \n    }\n    \n    else {\n        \n        from_row.set(from_column, row.get(to_column));\n        from_row.update().done(function() {\n\n            console.log('Fkey updated');\n            w.trigger('fkey_updated', row);\n            w.trigger('done');\n\n        });\n        \n    }\n    \n    \n}\n\n\n// Prepare autocomplete\norder_by_function(to_relation.rows()).done(function(rows) {\n    \n    var ps2 = Array();\n    var start = 0;\n    \n    ps2.push({\n        value: '[ none ]',\n        data: 'none'\n    });\n    \n    ++start;\n    \n    if (new_enabled) {\n        ps2.push({\n            value: '[ new ]',\n            data: 'new'\n        });\n        \n        ++start;\n    }\n    \n    for (var i = 0; i < rows.length; i++) {\n        \n        ps2[start + i] = { value: label_function(rows[i]), data: rows[i] }\n        \n    }\n\n\n    w.find('.autocomplete').autocomplete({\n        lookup: ps2,\n        appendTo: '.results',\n        onSelect: function (suggestion) {\n            //alert('You selected: ' + suggestion.value + ', ' + suggestion.data);\n            select_row(suggestion.data);\n\n        }\n    });  \n    \n    load_complete();\n});\n\nfunction load_complete() {\n    \n    w.find('.loading').hide();\n    w.find('.loaded').show();\n    console.log('Ready for autocomplete');\n    \n}
\\x79ab288df5c841a12746e5b84913f8c57bbc51642c9427b0f0770ea8d16d5910	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar append_new_widget = function() { \n    \n    alert('New widget still loading...\\nTry again in a moment'); \n    \n}\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\n\n// Find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    schema_name: to_relation.schema.name,\n    name: to_relation.name\n}).result(function(to_relation_obj) {\n\n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n\n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n    \n    append_new_widget = function() {\n        \n        w.append(\n            widget('modal_overlay', {\n                content: widget(new_row_widget, { \n                    relation: to_relation_obj,\n                    context_data: context_data\n                })\n            })\n        );\n        \n    }\n\n\n});\n\n\n// Prevent reload tab triggered by 'sem_list_item_new'\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n});\n\n\n// When new_row_widget returns...\nw.on('new_row', function(e, payload) {\n    \n    select_row(payload.new_row);\n    \n});\n\n\n// When a row is selected...\nfunction select_row(row) {\n    \n    if (row == 'new') {\n        \n        append_new_widget();\n        \n    }\n    \n    else if (row == 'none') {\n\n        from_row.set(from_column, null);\n        from_row.update().done(function() {\n\n            console.log('Fkey deleted');\n            w.trigger('fkey_deleted');\n            w.trigger('done');\n\n        });\n        \n    }\n    \n    else {\n        \n        from_row.set(from_column, row.get(to_column));\n        from_row.update().done(function() {\n\n            console.log('Fkey updated');\n            w.trigger('fkey_updated', row);\n            w.trigger('done');\n\n        });\n        \n    }\n    \n    \n}\n\n\n// Prepare autocomplete\norder_by_function(to_relation.rows()).done(function(rows) {\n    \n    var ps2 = Array();\n    var start = 0;\n    \n    ps2.push({\n        value: '[ none ]',\n        data: 'none'\n    });\n    \n    ++start;\n    \n    if (new_enabled) {\n        ps2.push({\n            value: '[ new ]',\n            data: 'new'\n        });\n        \n        ++start;\n    }\n    \n    for (var i = 0; i < rows.length; i++) {\n        \n        ps2[start + i] = { value: label_function(rows[i]), data: rows[i] }\n        \n    }\n\n\n    w.find('.autocomplete').autocomplete({\n        lookup: ps2,\n        appendTo: '.results',\n        onSelect: function (suggestion) {\n            //alert('You selected: ' + suggestion.value + ', ' + suggestion.data);\n            select_row(suggestion.data);\n\n        }\n    });  \n    \n    load_complete();\n});\n\nfunction load_complete() {\n    \n    w.find('.loading').hide();\n    w.find('.loaded').show();\n    console.log('Ready for autocomplete');\n    \n}
\\x7ac5d27b09ab9483000113d349323abb02293db5f3d878958715e0a75f033d85	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id')\n    .html(widget('semantics/text_identifier', real_row))\n    .click(function() {\n        w.trigger('bundle_row_open', {\n            row_id: change.get('row_id'),\n            row: real_row\n        });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n// stage button\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                w.remove();\n            }).catch(function(e) {\n                console.error(e);\n            });\n            break;\n        case 'same':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                w.remove();\n            }).catch(function(e) {\n                console.error(e);\n            });\n            break;            \n        case 'deleted':\n            console.log('not implemented yet');\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});
\\x7ac5d27b09ab9483000113d349323abb02293db5f3d878958715e0a75f033d85	var w = $("#"+id);\n\n// setup label\nvar schema_name = change.get('row_id').pk_column_id.relation_id.schema_id.name;\nvar relation_name = change.get('row_id').pk_column_id.relation_id.name;\nvar pk_column_name = change.get('row_id').pk_column_id.name;\nvar pk_value = change.get('row_id').pk_value;\nvar change_type = change.get('change_type');\n\nendpoint.schema(schema_name).relation(relation_name).row(pk_column_name, pk_value).then(function(real_row) {\n\tw.find('.text_id')\n    .html(widget('semantics/text_identifier', real_row))\n    .click(function() {\n        w.trigger('bundle_row_open', {\n            row_id: change.get('row_id'),\n            row: real_row\n        });\n    });\n}).catch(function(e) {\n\tw.find('.text_id').html(schema_name+'.'+relation_name+'.'+pk_value);\n});\n\n// stage button\nw.find('button.unstage').click(function() {\n    switch(change_type) {\n        case 'added':\n\t\t    endpoint.schema('bundle').function('unstage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                w.remove();\n            }).catch(function(e) {\n                console.error(e);\n            });\n            break;\n        case 'same':\n\t\t    endpoint.schema('bundle').function('stage_row_add', [\n                bundle.get('name'),\n                schema_name,\n                relation_name,\n                pk_column_name,\n                pk_value\n            ]).then(function() {\n                w.remove();\n            }).catch(function(e) {\n                console.error(e);\n            });\n            break;            \n        case 'deleted':\n            console.log('not implemented yet');\n            break;\n        case 'modified':\n            console.log('not implemented yet');\n            break;\n        default:\n            console.error ('no such change as '+change_type);\n    }\n});
\\x7b6542580bdea7df0b87e27bd9a74b4d08bb4faeaf6a1f6830acf3c5a1a4c6f4	jQuery.closestDescendent
\\x7b6542580bdea7df0b87e27bd9a74b4d08bb4faeaf6a1f6830acf3c5a1a4c6f4	jQuery.closestDescendent
\\x7bd7e6002b3a3e2b1030e83a500ac4bee004092842488b302210b19379093f18	<div id="{{= id }}" class="{{= name }}">\n    <section class='list'>\n        <div class='header'>\n            <p class='title toggle_options'></p>\n            <span class='arrow toggle_options'>&#10094;</span>\n            <button class='continue hide'>Continue</button>\n            <br>\n            <div class='options hide'>\n                <button class='new'>New row</button>\n                <br>\n                <input class='search' type='text' placeholder='Search'>\n            </div>\n        </div>\n        <ul></ul>\n    </section>\n    <section class='divider'><span>&#10094;</span></section>\n    <section class='detail'></section>\n</div>
\\x7bd7e6002b3a3e2b1030e83a500ac4bee004092842488b302210b19379093f18	<div id="{{= id }}" class="{{= name }}">\n    <section class='list'>\n        <div class='header'>\n            <p class='title toggle_options'></p>\n            <span class='arrow toggle_options'>&#10094;</span>\n            <button class='continue hide'>Continue</button>\n            <br>\n            <div class='options hide'>\n                <button class='new'>New row</button>\n                <br>\n                <input class='search' type='text' placeholder='Search'>\n            </div>\n        </div>\n        <ul></ul>\n    </section>\n    <section class='divider'><span>&#10094;</span></section>\n    <section class='detail'></section>\n</div>
\\x7c74c720e217f078083fea7783e171826e88e52bd672af51f805517e2c8db6e7	new_row_dialog
\\x7c74c720e217f078083fea7783e171826e88e52bd672af51f805517e2c8db6e7	new_row_dialog
\\x7d9227eba4b75a929e8144dc5c87af061f941c0d0c65409455b199960a542593	f7fb9714-3d99-444d-8b5f-d546ae354637
\\x7d9227eba4b75a929e8144dc5c87af061f941c0d0c65409455b199960a542593	f7fb9714-3d99-444d-8b5f-d546ae354637
\\x7de727e6e24583a8b2b34f756d83f72a84bdd04f289ffd9f448b49173817d2d1	81be0e52-9712-42d6-a1c1-fa773db591c1
\\x7de727e6e24583a8b2b34f756d83f72a84bdd04f289ffd9f448b49173817d2d1	81be0e52-9712-42d6-a1c1-fa773db591c1
\\x7deb7a951ec3b81573a7bf1e375e584b444c1bdf4cf5fc820708c663ba57b292	ide
\\x7deb7a951ec3b81573a7bf1e375e584b444c1bdf4cf5fc820708c663ba57b292	ide
\\x7e6c1de49b8df04ef4b84868ad86102c0ef91b0e9e514535875188c4b9a70932	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .title {\n    padding: 1.5rem 0;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n/*\n.{{= name }} > .title > span:nth-child(2) {\n    padding: 0 1rem;\n    font-size: 1rem;\n}\n*/\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\x7e6c1de49b8df04ef4b84868ad86102c0ef91b0e9e514535875188c4b9a70932	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > .title {\n    padding: 1.5rem 0;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n/*\n.{{= name }} > .title > span:nth-child(2) {\n    padding: 0 1rem;\n    font-size: 1rem;\n}\n*/\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n
\\x7e94dd4d65d6dcbb0ae1464839bac454405dd55e215d372191668e146c9a1392	var w = $("#"+id);\n/*\nsetTimeout(function() {\n\tw.trigger('done');\n}, 4000);\n*/\n\nwidget.sync(endpoint.schema('endpoint').table('mimetype').rows(), w.find('.mimetype'), function(mime) {\n    return widget('core:option', {\n        label: mime.get('mimetype'),\n        value: mime.get('id')\n    });\n});\n\nw.find('.save').on('click', function() {\n    if (w.find('.path').val() == '' || w.find('.mimetype').val() == null) {\n        alert('Path and mimetype needed');\n        return;\n    }\n    endpoint.schema('endpoint').table('resource').insert({\n        path: w.find('.path').val(),\n        mimetype_id: w.find('.mimetype').val(),\n        content: '<!doctype html><html><head></head><body></body></html>'\n    })\n    .then(function(new_row) {\n        w.trigger('insert', { row: new_row });\n        w.trigger('status', ['Resource created', 'success']);\n        w.trigger('done');\n        w.remove();\n    });\n});\n\nw.find('.exit').on('click', function() {\n    w.trigger('done');\n});\n
\\x7e94dd4d65d6dcbb0ae1464839bac454405dd55e215d372191668e146c9a1392	var w = $("#"+id);\n/*\nsetTimeout(function() {\n\tw.trigger('done');\n}, 4000);\n*/\n\nwidget.sync(endpoint.schema('endpoint').table('mimetype').rows(), w.find('.mimetype'), function(mime) {\n    return widget('core:option', {\n        label: mime.get('mimetype'),\n        value: mime.get('id')\n    });\n});\n\nw.find('.save').on('click', function() {\n    if (w.find('.path').val() == '' || w.find('.mimetype').val() == null) {\n        alert('Path and mimetype needed');\n        return;\n    }\n    endpoint.schema('endpoint').table('resource').insert({\n        path: w.find('.path').val(),\n        mimetype_id: w.find('.mimetype').val(),\n        content: '<!doctype html><html><head></head><body></body></html>'\n    })\n    .then(function(new_row) {\n        w.trigger('insert', { row: new_row });\n        w.trigger('status', ['Resource created', 'success']);\n        w.trigger('done');\n        w.remove();\n    });\n});\n\nw.find('.exit').on('click', function() {\n    w.trigger('done');\n});\n
\\x7e963ee468dfbb62df6e61b5a9dc88a4dcb113ccabea7bbebb0356f65934fe1c	var w = $('#'+id);\n\nvar synced = false;\nw.on('click', function(e) {\n    \n    e.stopPropagation();\n\n    w.toggleClass('expanded');\n    w.find('.empty').addClass('hide');\n\n    if (!synced) {\n\n        rows_function()\n        .then(function(rows) {\n            \n            if (!rows.length) { return empty_result(); }\n                \n            synced = true;\n            widget.sync(rows, w.find('.list'), function(row) {\n                return widget('semantics/list_item', row);\n            });\n        })\n        .catch(empty_result);\n\n    }\n});\n\nfunction empty_result() {\n    setTimeout(function() {\n        w.removeClass('expanded');\n        w.find('.empty').removeClass('hide');\n        synced = false;\n    }, 500);\n}\n
\\x7e963ee468dfbb62df6e61b5a9dc88a4dcb113ccabea7bbebb0356f65934fe1c	var w = $('#'+id);\n\nvar synced = false;\nw.on('click', function(e) {\n    \n    e.stopPropagation();\n\n    w.toggleClass('expanded');\n    w.find('.empty').addClass('hide');\n\n    if (!synced) {\n\n        rows_function()\n        .then(function(rows) {\n            \n            if (!rows.length) { return empty_result(); }\n                \n            synced = true;\n            widget.sync(rows, w.find('.list'), function(row) {\n                return widget('semantics/list_item', row);\n            });\n        })\n        .catch(empty_result);\n\n    }\n});\n\nfunction empty_result() {\n    setTimeout(function() {\n        w.removeClass('expanded');\n        w.find('.empty').removeClass('hide');\n        synced = false;\n    }, 500);\n}\n
\\x7e974b274f40b67fd45ce3950d74a580c892fc31cf7d97a63efca2c53f8d3a39	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'name'],\n            order_by: {\n                column: 'name'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('core:option', {\n                label: row.get('name'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\x7e974b274f40b67fd45ce3950d74a580c892fc31cf7d97a63efca2c53f8d3a39	var w = $('#'+id);\n\n// This semantic widget purpose is unique in that it receives an AQ.Column object\n\nendpoint.schema('meta').table('column').row('id', datum.id)\n.then(function(datum) {\n\n    // TODO: Replace this with a regex that capitalizes the beginning of every word\n    var name = datum.get('name').replace('_', ' ');\n    var label = name.slice(0, 1).toUpperCase() + name.slice(1);\n    w.find('.label').text(label);\n\n    w.data('valid', (datum.get('nullable') || datum.get('default') != null));\n    w.data('name', datum.get('name'));\n\n    endpoint.schema('ide').table('foreign_key').row('from_column_id', datum.get('id'))\n    .then(function(fkey) {\n        \n        var col_id = fkey.get('to_column_id');\n        var fkey_rows = endpoint.schema(col_id.relation_id.schema_id.name).table(col_id.relation_id.name).rows({\n            include: ['id', 'name'],\n            order_by: {\n                column: 'name'\n            }\n        });\n        \n        widget.sync(fkey_rows, w.find('select'), function(row) {\n            return widget('core:option', {\n                label: row.get('name'),\n                value: row.get('id'),\n                selected: row.get('id') === datum.get('default')\n            });\n        });\n    });\n\n    // EVENT BINDINGS\n    w.find('select').on('change', function(e) {\n        // set value to the input\n        w.data('value', $(this).val());\n        w.data('valid', true);\n    });\n    \n});\n
\\x8037065a125f29d0b16038db7c98544c474e1d1f7ad8f89329e63b1a6d012c8e	form_field_composite
\\x8037065a125f29d0b16038db7c98544c474e1d1f7ad8f89329e63b1a6d012c8e	form_field_composite
\\x8225d01c6781052b4445ba5eada856290c242c119a3f0d65d80ba166edb99acc	0.3.2
\\x8225d01c6781052b4445ba5eada856290c242c119a3f0d65d80ba166edb99acc	0.3.2
\\x8276af63b9e462f00c98d7f92e3e538c6abb78dca74b3b062b030b7b3715171d	commit_dialog_staged_row
\\x8276af63b9e462f00c98d7f92e3e538c6abb78dca74b3b062b030b7b3715171d	commit_dialog_staged_row
\\x8277bce6ed33db6fe716e8bab6abe4499bb58f8d05695d9458bd2010d2cd4a9b	var w = $("#"+id);\n\nvar commits = bundle.related_rows("id", "bundle.commit", "bundle_id", {\n    order_by: [{\n        column: 'time',\n        direction: 'desc'\n    }]\n});\n\nwidget.sync(commits, w.find(".commits"), function(commit) {\n    return widget("ide:commit_history_commit", {bundle: bundle, commit: commit});\n});
\\x8277bce6ed33db6fe716e8bab6abe4499bb58f8d05695d9458bd2010d2cd4a9b	var w = $("#"+id);\n\nvar commits = bundle.related_rows("id", "bundle.commit", "bundle_id", {\n    order_by: [{\n        column: 'time',\n        direction: 'desc'\n    }]\n});\n\nwidget.sync(commits, w.find(".commits"), function(commit) {\n    return widget("ide:commit_history_commit", {bundle: bundle, commit: commit});\n});
\\x82788b36dada0f70a2814be2924ab5c0d009a39fd021590b2c3910bb71bd329f	// CodeMirror is the only global var we claim\nwindow.CodeMirror = (function() {\n  "use strict";\n\n  // BROWSER SNIFFING\n\n  // Crude, but necessary to handle a number of hard-to-feature-detect\n  // bugs and behavior differences.\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  // IE11 currently doesn't count as 'ie', since it has almost none of\n  // the same bugs as earlier versions. Use ie_gt10 to handle\n  // incompatibilities in that version.\n  var old_ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = old_ie && (document.documentMode == null || document.documentMode < 8);\n  var ie_lt9 = old_ie && (document.documentMode == null || document.documentMode < 9);\n  var ie_gt10 = /Trident\\/([7-9]|\\d{2,})\\./.test(navigator.userAgent);\n  var ie = old_ie || ie_gt10;\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /win/i.test(navigator.platform);\n\n  var opera_version = opera && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (opera_version) opera_version = Number(opera_version[1]);\n  if (opera_version && opera_version >= 15) { opera = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));\n  var captureMiddleClick = gecko || (old_ie && !ie_lt9);\n\n  // Optimize some code when these features are not used\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // CONSTRUCTOR\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options || {};\n    // Determine effective options based on given values and defaults.\n    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))\n      options[opt] = defaults[opt];\n    setGuttersForLineNumbers(options);\n\n    var docStart = typeof options.value == "string" ? 0 : options.value.first;\n    var display = this.display = makeDisplay(place, docStart);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.state = {keyMaps: [],\n                  overlays: [],\n                  modeGen: 0,\n                  overwrite: false, focused: false,\n                  suppressEdits: false,\n                  pasteIncoming: false, cutIncoming: false,\n                  draggingText: false,\n                  highlight: new Delayed()};\n\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += " CodeMirror-wrap";\n\n    var doc = options.value;\n    if (typeof doc == "string") doc = new Doc(options.value, options.mode);\n    operation(this, attachDoc)(this, doc);\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (old_ie) setTimeout(bind(resetInput, this, true), 20);\n\n    registerEventHandlers(this);\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }\n    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);\n    else onBlur(this);\n\n    operation(this, function() {\n      for (var opt in optionHandlers)\n        if (optionHandlers.propertyIsEnumerable(opt))\n          optionHandlers[opt](this, options[opt], Init);\n      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    })();\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  function makeDisplay(place, docStart) {\n    var d = {};\n\n    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");\n    if (webkit) input.style.width = "1000px";\n    else input.setAttribute("wrap", "off");\n    // if border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) input.style.border = "1px solid black";\n    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");\n\n    // Wraps and hides input textarea\n    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");\n    // The actual fake scrollbars.\n    d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");\n    d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");\n    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");\n    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");\n    // DIVs containing the selection and the actual code\n    d.lineDiv = elt("div", null, "CodeMirror-code");\n    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");\n    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n    d.cursor = elt("div", "\\u00a0", "CodeMirror-cursor");\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    d.otherCursor = elt("div", "\\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");\n    // Used to measure text size\n    d.measure = elt("div", null, "CodeMirror-measure");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],\n                         null, "position: relative; outline: none");\n    // Moved around its parent to cover visible view\n    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");\n    // Set to the height of the text, causes scrolling\n    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");\n    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");\n    // Will contain the gutters, if any\n    d.gutters = elt("div", null, "CodeMirror-gutters");\n    d.lineGutter = null;\n    // Provides scrolling\n    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");\n    d.scroller.setAttribute("tabIndex", "-1");\n    // The element in which the editor lives.\n    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");\n    // Work around IE7 z-index bug\n    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = "0px";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";\n\n    // Current visible range (may be bigger than the view window).\n    d.viewOffset = d.lastSizeC = 0;\n    d.showingFrom = d.showingTo = docStart;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = "";\n    // Set to true when a non-horizontal-scrolling widget is added. As\n    // an optimization, widget aligning is skipped when d is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we currently expect input to appear\n    // (after some event like 'keypress' or 'input') and are polling\n    // intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n\n    d.cachedCharWidth = d.cachedTextHeight = null;\n    d.measureLineCache = [];\n    d.measureLineCachePos = 0;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string instead of the (large) selection.\n    d.inaccurateSelection = false;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    return d;\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      cm.display.wrapper.className += " CodeMirror-wrap";\n      cm.display.sizer.style.minWidth = "";\n    } else {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");\n      computeMaxLength(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line))\n        return 0;\n      else if (wrapping)\n        return (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var map = keyMap[cm.options.keyMap], style = map.style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, "") +\n      (style ? " cm-keymap-" + style : "");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));\n      if (gutterClass == "CodeMirror-linenumbers") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";\n      }\n    }\n    gutters.style.display = i ? "" : "none";\n  }\n\n  function lineLength(doc, line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find();\n      cur = getLine(doc, found.from.line);\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find();\n      len -= cur.text.length - found.from.ch;\n      cur = getLine(doc, found.to.line);\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  function computeMaxLength(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(doc, d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(doc, line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // "CodeMirror-linenumbers" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, "CodeMirror-linenumbers");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content. Optionally force a scrollTop.\n  function updateScrollbars(cm) {\n    var d = cm.display, docHeight = cm.doc.height;\n    var totalHeight = docHeight + paddingVert(d);\n    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";\n    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";\n    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);\n    var needsV = scrollHeight > (d.scroller.clientHeight + 1);\n    if (needsV) {\n      d.scrollbarV.style.display = "block";\n      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";\n      d.scrollbarV.firstChild.style.height =\n        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + "px";\n    } else {\n      d.scrollbarV.style.display = "";\n      d.scrollbarV.firstChild.style.height = "0";\n    }\n    if (needsH) {\n      d.scrollbarH.style.display = "block";\n      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";\n      d.scrollbarH.firstChild.style.width =\n        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + "px";\n    } else {\n      d.scrollbarH.style.display = "";\n      d.scrollbarH.firstChild.style.width = "0";\n    }\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = "block";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";\n    } else d.scrollbarFiller.style.display = "";\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = "block";\n      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";\n      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";\n    } else d.gutterFiller.style.display = "";\n\n    if (mac_geLion && scrollbarWidth(d.measure) === 0) {\n      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";\n      d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = "none";\n    }\n  }\n\n  function visibleLines(display, doc, viewPort) {\n    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;\n    if (typeof viewPort == "number") top = viewPort;\n    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}\n    top = Math.floor(top - paddingTop(display));\n    var bottom = Math.ceil(top + height);\n    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};\n  }\n\n  // LINE NUMBERS\n\n  function alignHorizontally(cm) {\n    var display = cm.display;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, l = comp + "px";\n    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {\n      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + "px";\n  }\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt("div", [elt("div", last)],\n                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = "";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + "px";\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n  function compensateForHScroll(display) {\n    return getRect(display.scroller).left - getRect(display.sizer).left;\n  }\n\n  // DISPLAY DRAWING\n\n  function updateDisplay(cm, changes, viewPort, forced) {\n    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;\n    var visible = visibleLines(cm.display, cm.doc, viewPort);\n    for (var first = true;; first = false) {\n      var oldWidth = cm.display.scroller.clientWidth;\n      if (!updateDisplayInner(cm, changes, visible, forced)) break;\n      updated = true;\n      changes = [];\n      updateSelection(cm);\n      updateScrollbars(cm);\n      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {\n        forced = true;\n        continue;\n      }\n      forced = false;\n\n      // Clip forced viewport to actual scrollable area\n      if (viewPort)\n        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,\n                            typeof viewPort == "number" ? viewPort : viewPort.top);\n      visible = visibleLines(cm.display, cm.doc, viewPort);\n      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)\n        break;\n    }\n\n    if (updated) {\n      signalLater(cm, "update", cm);\n      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)\n        signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);\n    }\n    return updated;\n  }\n\n  // Uses a set of changes plus the current scroll position to\n  // determine which DOM updates have to be made, and makes the\n  // updates.\n  function updateDisplayInner(cm, changes, visible, forced) {\n    var display = cm.display, doc = cm.doc;\n    if (!display.wrapper.offsetWidth) {\n      display.showingFrom = display.showingTo = doc.first;\n      display.viewOffset = 0;\n      return;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!forced && changes.length == 0 &&\n        visible.from > display.showingFrom && visible.to < display.showingTo)\n      return;\n\n    if (maybeUpdateLineNumberWidth(cm))\n      changes = [{from: doc.first, to: doc.first + doc.size}];\n    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";\n    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";\n\n    // Used to determine which lines need their line numbers updated\n    var positionsChangedFrom = Infinity;\n    if (cm.options.lineNumbers)\n      for (var i = 0; i < changes.length; ++i)\n        if (changes[i].diff && changes[i].from < positionsChangedFrom) { positionsChangedFrom = changes[i].from; }\n\n    var end = doc.first + doc.size;\n    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, visible.to + cm.options.viewportMargin);\n    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);\n    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);\n    if (sawCollapsedSpans) {\n      from = lineNo(visualLine(doc, getLine(doc, from)));\n      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;\n    }\n\n    // Create a range of theoretically intact lines, and punch holes\n    // in that using the change info.\n    var intact = [{from: Math.max(display.showingFrom, doc.first),\n                   to: Math.min(display.showingTo, end)}];\n    if (intact[0].from >= intact[0].to) intact = [];\n    else intact = computeIntact(intact, changes);\n    // When merged lines are present, we might have to reduce the\n    // intact ranges because changes in continued fragments of the\n    // intact lines do require the lines to be redrawn.\n    if (sawCollapsedSpans)\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i], merged;\n        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {\n          var newTo = merged.find().from.line;\n          if (newTo > range.from) range.to = newTo;\n          else { intact.splice(i--, 1); break; }\n        }\n      }\n\n    // Clip off the parts that won't be visible\n    var intactLines = 0;\n    for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i];\n      if (range.from < from) range.from = from;\n      if (range.to > to) range.to = to;\n      if (range.from >= range.to) intact.splice(i--, 1);\n      else intactLines += range.to - range.from;\n    }\n    if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {\n      updateViewOffset(cm);\n      return;\n    }\n    intact.sort(function(a, b) {return a.from - b.from;});\n\n    // Avoid crashing on IE's "unspecified error" when in iframes\n    try {\n      var focused = document.activeElement;\n    } catch(e) {}\n    if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";\n    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n    display.lineDiv.style.display = "";\n    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();\n\n    var different = from != display.showingFrom || to != display.showingTo ||\n      display.lastSizeC != display.wrapper.clientHeight;\n    // This is just a bogus formula that detects when the editor is\n    // resized or the font size changes.\n    if (different) {\n      display.lastSizeC = display.wrapper.clientHeight;\n      startWorker(cm, 400);\n    }\n    display.showingFrom = from; display.showingTo = to;\n\n    display.gutters.style.height = "";\n    updateHeightsInViewport(cm);\n    updateViewOffset(cm);\n\n    return true;\n  }\n\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {\n      if (ie_lt8) {\n        var bot = node.offsetTop + node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = getRect(node);\n        height = box.bottom - box.top;\n      }\n      var diff = node.lineObj.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(node.lineObj, height);\n        var widgets = node.lineObj.widgets;\n        if (widgets) for (var i = 0; i < widgets.length; ++i)\n          widgets[i].height = widgets[i].node.offsetHeight;\n      }\n    }\n  }\n\n  function updateViewOffset(cm) {\n    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));\n    // Position the mover div to align with the current virtual scroll position\n    cm.display.mover.style.top = off + "px";\n  }\n\n  function computeIntact(intact, changes) {\n    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n      var change = changes[i], intact2 = [], diff = change.diff || 0;\n      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n        var range = intact[j];\n        if (change.to <= range.from && change.diff) {\n          intact2.push({from: range.from + diff, to: range.to + diff});\n        } else if (change.to <= range.from || change.from >= range.to) {\n          intact2.push(range);\n        } else {\n          if (change.from > range.from)\n            intact2.push({from: range.from, to: change.from});\n          if (change.to < range.to)\n            intact2.push({from: change.to + diff, to: range.to + diff});\n        }\n      }\n      intact = intact2;\n    }\n    return intact;\n  }\n\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft;\n      width[cm.options.gutters[i]] = n.offsetWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n    var dims = getDimensions(cm);\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))\n      removeChildren(display.lineDiv);\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = "none";\n        node.lineObj = null;\n      } else {\n        node.parentNode.removeChild(node);\n      }\n      return next;\n    }\n\n    var nextIntact = intact.shift(), lineN = from;\n    cm.doc.iter(from, to, function(line) {\n      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();\n      if (lineIsHidden(cm.doc, line)) {\n        if (line.height != 0) updateLineHeight(line, 0);\n        if (line.widgets && cur && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {\n          var w = line.widgets[i];\n          if (w.showIfHidden) {\n            var prev = cur.previousSibling;\n            if (/pre/i.test(prev.nodeName)) {\n              var wrap = elt("div", null, null, "position: relative");\n              prev.parentNode.replaceChild(wrap, prev);\n              wrap.appendChild(prev);\n              prev = wrap;\n            }\n            var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));\n            if (!w.handleMouseEvents) wnode.ignoreEvents = true;\n            positionLineWidget(w, wnode, prev, dims);\n          }\n        }\n      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {\n        // This line is intact. Skip to the actual node. Update its\n        // line number if needed.\n        while (cur.lineObj != line) cur = rm(cur);\n        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)\n          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));\n        cur = cur.nextSibling;\n      } else {\n        // For lines with widgets, make an attempt to find and reuse\n        // the existing element, so that widgets aren't needlessly\n        // removed and re-inserted into the dom\n        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)\n          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }\n        // This line needs to be generated.\n        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);\n        if (lineNode != reuse) {\n          container.insertBefore(lineNode, cur);\n        } else {\n          while (cur != reuse) cur = rm(cur);\n          cur = cur.nextSibling;\n        }\n\n        lineNode.lineObj = line;\n      }\n      ++lineN;\n    });\n    while (cur) cur = rm(cur);\n  }\n\n  function buildLineElement(cm, line, lineNo, dims, reuse) {\n    var built = buildLineContent(cm, line), lineElement = built.pre;\n    var markers = line.gutterMarkers, display = cm.display, wrap;\n\n    var bgClass = built.bgClass ? built.bgClass + " " + (line.bgClass || "") : line.bgClass;\n    if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets)\n      return lineElement;\n\n    // Lines with gutter elements, widgets or a background class need\n    // to be wrapped again, and have the extra elements added to the\n    // wrapper div\n\n    if (reuse) {\n      reuse.alignable = null;\n      var isOk = true, widgetsSeen = 0, insertBefore = null;\n      for (var n = reuse.firstChild, next; n; n = next) {\n        next = n.nextSibling;\n        if (!/\\bCodeMirror-linewidget\\b/.test(n.className)) {\n          reuse.removeChild(n);\n        } else {\n          for (var i = 0; i < line.widgets.length; ++i) {\n            var widget = line.widgets[i];\n            if (widget.node == n.firstChild) {\n              if (!widget.above && !insertBefore) insertBefore = n;\n              positionLineWidget(widget, n, reuse, dims);\n              ++widgetsSeen;\n              break;\n            }\n          }\n          if (i == line.widgets.length) { isOk = false; break; }\n        }\n      }\n      reuse.insertBefore(lineElement, insertBefore);\n      if (isOk && widgetsSeen == line.widgets.length) {\n        wrap = reuse;\n        reuse.className = line.wrapClass || "";\n      }\n    }\n    if (!wrap) {\n      wrap = elt("div", null, line.wrapClass, "position: relative");\n      wrap.appendChild(lineElement);\n    }\n    // Kludge to make sure the styled element lies behind the selection (by z-index)\n    if (bgClass)\n      wrap.insertBefore(elt("div", null, bgClass + " CodeMirror-linebackground"), wrap.firstChild);\n    if (cm.options.lineNumbers || markers) {\n      var gutterWrap = wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),\n                                         lineElement);\n      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);\n      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))\n        wrap.lineNumber = gutterWrap.appendChild(\n          elt("div", lineNumberFor(cm.options, lineNo),\n              "CodeMirror-linenumber CodeMirror-gutter-elt",\n              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "\n              + display.lineNumInnerWidth + "px"));\n      if (markers)\n        for (var k = 0; k < cm.options.gutters.length; ++k) {\n          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n          if (found)\n            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +\n                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));\n        }\n    }\n    if (ie_lt8) wrap.style.zIndex = 2;\n    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n      positionLineWidget(widget, node, wrap, dims);\n      if (widget.above)\n        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, "redraw");\n    }\n    return wrap;\n  }\n\n  function positionLineWidget(widget, node, wrap, dims) {\n    if (widget.noHScroll) {\n      (wrap.alignable || (wrap.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + "px";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + "px";\n      }\n      node.style.width = width + "px";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = "relative";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";\n    }\n  }\n\n  // SELECTION / CURSOR\n\n  function updateSelection(cm) {\n    var display = cm.display;\n    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      updateSelectionCursor(cm);\n    else\n      display.cursor.style.display = display.otherCursor.style.display = "none";\n    if (!collapsed)\n      updateSelectionRange(cm);\n    else\n      display.selectionDiv.style.display = "none";\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, cm.doc.sel.head, "div");\n      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);\n      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                                        headPos.top + lineOff.top - wrapOff.top)) + "px";\n      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                                         headPos.left + lineOff.left - wrapOff.left)) + "px";\n    }\n  }\n\n  // No selection, plain cursor\n  function updateSelectionCursor(cm) {\n    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, "div");\n    display.cursor.style.left = pos.left + "px";\n    display.cursor.style.top = pos.top + "px";\n    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";\n    display.cursor.style.display = "";\n\n    if (pos.other) {\n      display.otherCursor.style.display = "";\n      display.otherCursor.style.left = pos.other.left + "px";\n      display.otherCursor.style.top = pos.other.top + "px";\n      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";\n    } else { display.otherCursor.style.display = "none"; }\n  }\n\n  // Highlight selection\n  function updateSelectionRange(cm) {\n    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;\n    var fragment = document.createDocumentFragment();\n    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +\n                               "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) +\n                               "px; height: " + (bottom - top) + "px"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, "left"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, "right");\n          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = pl;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = pl;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = clientWidth;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < pl + 1) left = pl;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    if (sel.from.line == sel.to.line) {\n      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n    } else {\n      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);\n      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);\n      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;\n      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(pl, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(pl, leftEnd.bottom, null, rightStart.top);\n    }\n\n    removeChildrenAndAdd(display.selectionDiv, fragment);\n    display.selectionDiv.style.display = "";\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursor.style.visibility = display.otherCursor.style.visibility = "";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";\n      }, cm.options.cursorBlinkRate);\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.showingTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changed = [], prevChange;\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {\n      if (doc.frontier >= cm.display.showingFrom) { // Visible\n        var oldStyles = line.styles;\n        line.styles = highlightLine(cm, line, state, true);\n        var ischange = !oldStyles || oldStyles.length != line.styles.length;\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) {\n          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;\n          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});\n        }\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changed.length)\n      operation(cm, function() {\n        for (var i = 0; i < changed.length; ++i)\n          regChange(this, changed[i].start, changed[i].end);\n      })();\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingLeft(display) {\n    var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));\n    return e.offsetLeft;\n  }\n\n  function measureChar(cm, line, ch, data, bias) {\n    var dir = -1;\n    data = data || measureLine(cm, line);\n    if (data.crude) {\n      var left = data.left + ch * data.width;\n      return {left: left, right: left + data.width, top: data.top, bottom: data.bottom};\n    }\n\n    for (var pos = ch;; pos += dir) {\n      var r = data[pos];\n      if (r) break;\n      if (dir < 0 && pos == 0) dir = 1;\n    }\n    bias = pos > ch ? "left" : pos < ch ? "right" : bias;\n    if (bias == "left" && r.leftSide) r = r.leftSide;\n    else if (bias == "right" && r.rightSide) r = r.rightSide;\n    return {left: pos < ch ? r.right : r.left,\n            right: pos > ch ? r.left : r.right,\n            top: r.top,\n            bottom: r.bottom};\n  }\n\n  function findCachedMeasurement(cm, line) {\n    var cache = cm.display.measureLineCache;\n    for (var i = 0; i < cache.length; ++i) {\n      var memo = cache[i];\n      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&\n          cm.display.scroller.clientWidth == memo.width &&\n          memo.classes == line.textClass + "|" + line.wrapClass)\n        return memo;\n    }\n  }\n\n  function clearCachedMeasurement(cm, line) {\n    var exists = findCachedMeasurement(cm, line);\n    if (exists) exists.text = exists.measure = exists.markedSpans = null;\n  }\n\n  function measureLine(cm, line) {\n    // First look in the cache\n    var cached = findCachedMeasurement(cm, line);\n    if (cached) return cached.measure;\n\n    // Failing that, recompute and store result in cache\n    var measure = measureLineInner(cm, line);\n    var cache = cm.display.measureLineCache;\n    var memo = {text: line.text, width: cm.display.scroller.clientWidth,\n                markedSpans: line.markedSpans, measure: measure,\n                classes: line.textClass + "|" + line.wrapClass};\n    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;\n    else cache.push(memo);\n    return measure;\n  }\n\n  function measureLineInner(cm, line) {\n    if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom)\n      return crudelyMeasureLine(cm, line);\n\n    var display = cm.display, measure = emptyArray(line.text.length);\n    var pre = buildLineContent(cm, line, measure, true).pre;\n\n    // IE does not cache element positions of inline elements between\n    // calls to getBoundingClientRect. This makes the loop below,\n    // which gathers the positions of all the characters on the line,\n    // do an amount of layout work quadratic to the number of\n    // characters. When line wrapping is off, we try to improve things\n    // by first subdividing the line into a bunch of inline blocks, so\n    // that IE can reuse most of the layout information from caches\n    // for those blocks. This does interfere with line wrapping, so it\n    // doesn't work when wrapping is on, but in that case the\n    // situation is slightly better, since IE does cache line-wrapping\n    // information and only recomputes per-line.\n    if (old_ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n      var fragment = document.createDocumentFragment();\n      var chunk = 10, n = pre.childNodes.length;\n      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n        var wrap = elt("div", null, null, "display: inline-block");\n        for (var j = 0; j < chunk && n; ++j) {\n          wrap.appendChild(pre.firstChild);\n          --n;\n        }\n        fragment.appendChild(wrap);\n      }\n      pre.appendChild(fragment);\n    }\n\n    removeChildrenAndAdd(display.measure, pre);\n\n    var outer = getRect(display.lineDiv);\n    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;\n    // Work around an IE7/8 bug where it will sometimes have randomly\n    // replaced our pre with a clone at this point.\n    if (ie_lt9 && display.measure.first != pre)\n      removeChildrenAndAdd(display.measure, pre);\n\n    function measureRect(rect) {\n      var top = rect.top - outer.top, bot = rect.bottom - outer.top;\n      if (bot > maxBot) bot = maxBot;\n      if (top < 0) top = 0;\n      for (var i = vranges.length - 2; i >= 0; i -= 2) {\n        var rtop = vranges[i], rbot = vranges[i+1];\n        if (rtop > bot || rbot < top) continue;\n        if (rtop <= top && rbot >= bot ||\n            top <= rtop && bot >= rbot ||\n            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {\n          vranges[i] = Math.min(top, rtop);\n          vranges[i+1] = Math.max(bot, rbot);\n          break;\n        }\n      }\n      if (i < 0) { i = vranges.length; vranges.push(top, bot); }\n      return {left: rect.left - outer.left,\n              right: rect.right - outer.left,\n              top: i, bottom: null};\n    }\n    function finishRect(rect) {\n      rect.bottom = vranges[rect.top+1];\n      rect.top = vranges[rect.top];\n    }\n\n    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {\n      var node = cur, rect = null;\n      // A widget might wrap, needs special care\n      if (/\\bCodeMirror-widget\\b/.test(cur.className) && cur.getClientRects) {\n        if (cur.firstChild.nodeType == 1) node = cur.firstChild;\n        var rects = node.getClientRects();\n        if (rects.length > 1) {\n          rect = data[i] = measureRect(rects[0]);\n          rect.rightSide = measureRect(rects[rects.length - 1]);\n        }\n      }\n      if (!rect) rect = data[i] = measureRect(getRect(node));\n      if (cur.measureRight) rect.right = getRect(cur.measureRight).left - outer.left;\n      if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));\n    }\n    removeChildren(cm.display.measure);\n    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {\n      finishRect(cur);\n      if (cur.leftSide) finishRect(cur.leftSide);\n      if (cur.rightSide) finishRect(cur.rightSide);\n    }\n    return data;\n  }\n\n  function crudelyMeasureLine(cm, line) {\n    var copy = new Line(line.text.slice(0, 100), null);\n    if (line.textClass) copy.textClass = line.textClass;\n    var measure = measureLineInner(cm, copy);\n    var left = measureChar(cm, copy, 0, measure, "left");\n    var right = measureChar(cm, copy, 99, measure, "right");\n    return {crude: true, top: left.top, left: left.left, bottom: left.bottom, width: (right.right - left.left) / 100};\n  }\n\n  function measureLineWidth(cm, line) {\n    var hasBadSpan = false;\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {\n      var sp = line.markedSpans[i];\n      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;\n    }\n    var cached = !hasBadSpan && findCachedMeasurement(cm, line);\n    if (cached || line.text.length >= cm.options.crudeMeasuringFrom)\n      return measureChar(cm, line, line.text.length, cached && cached.measure, "right").right;\n\n    var pre = buildLineContent(cm, line, null, true).pre;\n    var end = pre.appendChild(zeroWidthElement(cm.display.measure));\n    removeChildrenAndAdd(cm.display.measure, pre);\n    return getRect(end).right - getRect(cm.display.lineDiv).left;\n  }\n\n  function clearCaches(cm) {\n    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == "line") return rect;\n    if (!context) context = "local";\n    var yOff = heightAtLine(cm, lineObj);\n    if (context == "local") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == "page" || context == "window") {\n      var lOff = getRect(cm.display.lineSpace);\n      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Context may be "window", "page", "div", or "local"/null\n  // Result is in "div" coords\n  function fromCoordSystem(cm, coords, context) {\n    if (context == "div") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into "page" coordinate system\n    if (context == "page") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == "local" || !context) {\n      var localBox = getRect(cm.display.sizer);\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = getRect(cm.display.lineSpace);\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);\n  }\n\n  function cursorCoords(cm, pos, context, lineObj, measurement) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!measurement) measurement = measureLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = new Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Coords must be lineSpace-local\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineNo > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find();\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineNo = mergedPos.to.line;\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(cm, lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var measurement = measureLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), "line",\n                            lineObj, measurement);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < 0 ? -1 : xDiff ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt("pre");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode("x"));\n        measureText.appendChild(elt("br"));\n      }\n      measureText.appendChild(document.createTextNode("x"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt("span", "x");\n    var pre = elt("pre", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var width = anchor.offsetWidth;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap changes in such a way that each\n  // change won't have to update the cursor and display (which would\n  // be awkward, slow, and error-prone), but instead updates are\n  // batched and then all combined and executed at once.\n\n  var nextOpId = 0;\n  function startOperation(cm) {\n    cm.curOp = {\n      // An array of ranges of lines that have to be updated. See\n      // updateDisplay.\n      changes: [],\n      forceUpdate: false,\n      updateInput: null,\n      userSelChange: null,\n      textChanged: null,\n      selectionChanged: false,\n      cursorActivity: false,\n      updateMaxLine: false,\n      updateScrollPos: false,\n      id: ++nextOpId\n    };\n    if (!delayedCallbackDepth++) delayedCallbacks = [];\n  }\n\n  function endOperation(cm) {\n    var op = cm.curOp, doc = cm.doc, display = cm.display;\n    cm.curOp = null;\n\n    if (op.updateMaxLine) computeMaxLength(cm);\n    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {\n      var width = measureLineWidth(cm, display.maxLine);\n      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";\n      display.maxLineChanged = false;\n      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);\n      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)\n        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);\n    }\n    var newScrollPos, updated;\n    if (op.updateScrollPos) {\n      newScrollPos = op.updateScrollPos;\n    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible\n      var coords = cursorCoords(cm, doc.sel.head);\n      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n    }\n    if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {\n      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);\n      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;\n    }\n    if (!updated && op.selectionChanged) updateSelection(cm);\n    if (op.updateScrollPos) {\n      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, newScrollPos.scrollTop));\n      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, newScrollPos.scrollLeft));\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\n      alignHorizontally(cm);\n      if (op.scrollToPos)\n        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),\n                          clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);\n    } else if (newScrollPos) {\n      scrollCursorIntoView(cm);\n    }\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      resetInput(cm, op.userSelChange);\n\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], "hide");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");\n\n    var delayed;\n    if (!--delayedCallbackDepth) {\n      delayed = delayedCallbacks;\n      delayedCallbacks = null;\n    }\n    if (op.textChanged)\n      signal(cm, "change", cm, op.textChanged);\n    if (op.cursorActivity) signal(cm, "cursorActivity", cm);\n    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm1, f) {\n    return function() {\n      var cm = cm1 || this, withOp = !cm.curOp;\n      if (withOp) startOperation(cm);\n      try { var result = f.apply(cm, arguments); }\n      finally { if (withOp) endOperation(cm); }\n      return result;\n    };\n  }\n  function docOperation(f) {\n    return function() {\n      var withOp = this.cm && !this.cm.curOp, result;\n      if (withOp) startOperation(this.cm);\n      try { result = f.apply(this, arguments); }\n      finally { if (withOp) endOperation(this.cm); }\n      return result;\n    };\n  }\n  function runInOp(cm, f) {\n    var withOp = !cm.curOp, result;\n    if (withOp) startOperation(cm);\n    try { result = f(); }\n    finally { if (withOp) endOperation(cm); }\n    return result;\n  }\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    cm.curOp.changes.push({from: from, to: to, diff: lendiff});\n  }\n\n  // INPUT HANDLING\n\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // prevInput is a hack to work with IME. If we reset the textarea\n  // on every change, that breaks IME. So we look for changes\n  // compared to the previous content instead. (Modern browsers have\n  // events that indicate IME taking place, but these are not widely\n  // supported or compatible enough yet to rely on.)\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;\n    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.options.disableInput) return false;\n    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\n      input.value = input.value.substring(0, input.value.length - 1);\n      cm.state.fakedLastChar = false;\n    }\n    var text = input.value;\n    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {\n      resetInput(cm, true);\n      return false;\n    }\n\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    sel.shift = false;\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n    var from = sel.from, to = sel.to;\n    var inserted = text.slice(same);\n    if (same < prevInput.length)\n      from = Pos(from.line, from.ch - (prevInput.length - same));\n    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)\n      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + inserted.length));\n\n    var updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: splitLines(inserted),\n                       origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};\n    makeChange(cm.doc, changeEvent, "end");\n    cm.curOp.updateInput = updateInput;\n    signalLater(cm, "inputRead", cm, changeEvent);\n    if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\n        cm.options.smartIndent && sel.head.ch < 100) {\n      var electric = cm.getModeAt(sel.head).electricChars;\n      if (electric) for (var i = 0; i < electric.length; i++)\n        if (inserted.indexOf(electric.charAt(i)) > -1) {\n          indentLine(cm, sel.head.line, "smart");\n          break;\n        }\n    }\n\n    if (text.length > 1000 || text.indexOf("\\n") > -1) input.value = cm.display.prevInput = "";\n    else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n    return true;\n  }\n\n  function resetInput(cm, user) {\n    var minimal, selected, doc = cm.doc;\n    if (!posEq(doc.sel.from, doc.sel.to)) {\n      cm.display.prevInput = "";\n      minimal = hasCopyEvent &&\n        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n      var content = minimal ? "-" : selected || cm.getSelection();\n      cm.display.input.value = content;\n      if (cm.state.focused) selectInput(cm.display.input);\n      if (ie && !ie_lt9) cm.display.inputHasSelection = content;\n    } else if (user) {\n      cm.display.prevInput = cm.display.input.value = "";\n      if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    }\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, "mousedown", operation(cm, onMouseDown));\n    if (old_ie)\n      on(d.scroller, "dblclick", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);\n        extendSelection(cm.doc, word.from, word.to);\n      }));\n    else\n      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    on(d.lineSpace, "selectstart", function(e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!captureMiddleClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});\n\n    on(d.scroller, "scroll", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, "scroll", cm);\n      }\n    });\n    on(d.scrollbarV, "scroll", function() {\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, "scroll", function() {\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});\n\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, "mousedown", reFocus);\n    on(d.scrollbarV, "mousedown", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    var resizeTimer;\n    function onResize() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        // Might be a text scaling operation, clear size caches.\n        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;\n        clearCaches(cm);\n        runInOp(cm, bind(regChange, cm));\n      }, 100);\n    }\n    on(window, "resize", onResize);\n    // Above handler holds on to the editor and its data structures.\n    // Here we poll to unregister it when the editor is no longer in\n    // the document, so that it can be garbage-collected.\n    function unregister() {\n      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n      if (p) setTimeout(unregister, 5000);\n      else off(window, "resize", onResize);\n    }\n    setTimeout(unregister, 5000);\n\n    on(d.input, "keyup", operation(cm, function(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n      if (e.keyCode == 16) cm.doc.sel.shift = false;\n    }));\n    on(d.input, "input", function() {\n      if (ie && !ie_lt9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\n      fastPoll(cm);\n    });\n    on(d.input, "keydown", operation(cm, onKeyDown));\n    on(d.input, "keypress", operation(cm, onKeyPress));\n    on(d.input, "focus", bind(onFocus, cm));\n    on(d.input, "blur", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n      e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});\n      on(d.scroller, "dragenter", drag_);\n      on(d.scroller, "dragover", drag_);\n      on(d.scroller, "drop", operation(cm, onDrop));\n    }\n    on(d.scroller, "paste", function(e) {\n      if (eventInWidget(d, e)) return;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n    on(d.input, "paste", function() {\n      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\n      // Add a char to the end of textarea before paste occur so that\n      // selection doesn't span to the end of textarea.\n      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\n        var start = d.input.selectionStart, end = d.input.selectionEnd;\n        d.input.value += "$";\n        d.input.selectionStart = start;\n        d.input.selectionEnd = end;\n        cm.state.fakedLastChar = true;\n      }\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopy(e) {\n      if (d.inaccurateSelection) {\n        d.prevInput = "";\n        d.inaccurateSelection = false;\n        d.input.value = cm.getSelection();\n        selectInput(d.input);\n      }\n      if (e.type == "cut") cm.state.cutIncoming = true;\n    }\n    on(d.input, "cut", prepareCopy);\n    on(d.input, "copy", prepareCopy);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, "mouseup", function() {\n      if (document.activeElement == d.input) d.input.blur();\n      focusInput(cm);\n    });\n  }\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  function posFromMouse(cm, e, liberal) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||\n          target == display.scrollbarV || target == display.scrollbarV.firstChild ||\n          target == display.scrollbarFiller || target == display.gutterFiller) return null;\n    }\n    var x, y, space = getRect(display.lineSpace);\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n    return coordsChar(cm, x - space.left, y - space.top);\n  }\n\n  var lastClick, lastDoubleClick;\n  function onMouseDown(e) {\n    if (signalDOMEvent(this, e)) return;\n    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;\n    sel.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n\n    switch (e_button(e)) {\n    case 3:\n      if (captureMiddleClick) onContextMenu.call(cm, cm, e);\n      return;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      return;\n    }\n    // For button 1, if it was clicked inside the editor\n    // (posFromMouse returning non-null), we have to adjust the\n    // selection.\n    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}\n\n    if (!cm.state.focused) onFocus(cm);\n\n    var now = +new Date, type = "single";\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n      type = "triple";\n      e_preventDefault(e);\n      setTimeout(bind(focusInput, cm), 20);\n      selectLine(cm, start.line);\n    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n      type = "double";\n      lastDoubleClick = {time: now, pos: start};\n      e_preventDefault(e);\n      var word = findWordAt(getLine(doc, start.line).text, start);\n      extendSelection(cm.doc, word.from, word.to);\n    } else { lastClick = {time: now, pos: start}; }\n\n    var last = start;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&\n        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {\n      var dragEnd = operation(cm, function(e2) {\n        if (webkit) display.scroller.draggable = false;\n        cm.state.draggingText = false;\n        off(document, "mouseup", dragEnd);\n        off(display.scroller, "drop", dragEnd);\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          extendSelection(cm.doc, start);\n          focusInput(cm);\n          // Work around unexplainable focus problem in IE9 (#2127)\n          if (old_ie && !ie_lt9)\n            setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\n        }\n      });\n      // Let the drag handler handle this.\n      if (webkit) display.scroller.draggable = true;\n      cm.state.draggingText = dragEnd;\n      // IE's approach to draggable\n      if (display.scroller.dragDrop) display.scroller.dragDrop();\n      on(document, "mouseup", dragEnd);\n      on(display.scroller, "drop", dragEnd);\n      return;\n    }\n    e_preventDefault(e);\n    if (type == "single") extendSelection(cm.doc, clipPos(doc, start));\n\n    var startstart = sel.from, startend = sel.to, lastPos = start;\n\n    function doSelect(cur) {\n      if (posEq(lastPos, cur)) return;\n      lastPos = cur;\n\n      if (type == "single") {\n        extendSelection(cm.doc, clipPos(doc, start), cur);\n        return;\n      }\n\n      startstart = clipPos(doc, startstart);\n      startend = clipPos(doc, startend);\n      if (type == "double") {\n        var word = findWordAt(getLine(doc, cur.line).text, cur);\n        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);\n        else extendSelection(cm.doc, startstart, word.to);\n      } else if (type == "triple") {\n        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));\n        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));\n      }\n    }\n\n    var editorSize = getRect(display.wrapper);\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true);\n      if (!cur) return;\n      if (!posEq(cur, last)) {\n        if (!cm.state.focused) onFocus(cm);\n        last = cur;\n        doSelect(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, "mousemove", move);\n      off(document, "mouseup", up);\n    }\n\n    var move = operation(cm, function(e) {\n      if (!old_ie && !e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, "mousemove", move);\n    on(document, "mouseup", up);\n  }\n\n  function gutterEvent(cm, e, type, prevent, signalfn) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(getRect(cm.display.gutters).right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = getRect(display.lineDiv);\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && getRect(g).right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalfn(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, "gutterContextMenu")) return false;\n    return gutterEvent(cm, e, "gutterContextMenu", false, signal);\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, "gutterClick", true, signalLater);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join("\\n")), origin: "paste"}, "around");\n          }\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else {\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData("Text");\n        if (text) {\n          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;\n          setSelection(cm.doc, pos, pos);\n          if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");\n          cm.replaceSelection(text, null, "paste");\n          focusInput(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    var txt = cm.getSelection();\n    e.dataTransfer.setData("Text", txt);\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");\n      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n      if (opera) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (opera) img.parentNode.removeChild(img);\n    }\n  }\n\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplay(cm, [], val);\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplay(cm, []);\n    startWorker(cm, 100);\n  }\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (old_ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n        if (cur.lineObj) {\n          cm.display.currentWheelTarget = cur;\n          break;\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplay(cm, [], {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == "string") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var doc = cm.doc, prevShift = doc.sel.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) doc.sel.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      doc.sel.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n    maps.push(cm.options.keyMap);\n    return maps;\n  }\n\n  var maybeTransition;\n  function handleKeyBinding(cm, e) {\n    // Handle auto keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap) {\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n        keyMapChanged(cm);\n      }\n    }, 50);\n\n    var name = keyName(e, true), handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n             || lookupKey(name, keymaps, function(b) {\n                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)\n                    return doHandleBinding(cm, b);\n                });\n    } else {\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n    }\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n      signalLater(cm, "keyHandled", cm, name, e);\n    }\n    return handled;\n  }\n\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);\n    }\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (!cm.state.focused) onFocus(cm);\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    if (old_ie && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    // IE does strange things with escape.\n    cm.doc.sel.shift = code == 16 || e.shiftKey;\n    // First give onKeyEvent option a chance to handle this.\n    var handled = handleKeyBinding(cm, e);\n    if (opera) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection("");\n    }\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    fastPoll(cm);\n  }\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == "nocursor") return;\n    if (!cm.state.focused) {\n      signal(cm, "focus", cm);\n      cm.state.focused = true;\n      if (cm.display.wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n        cm.display.wrapper.className += " CodeMirror-focused";\n      if (!cm.curOp) {\n        resetInput(cm, true);\n        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\n      }\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, "blur", cm);\n      cm.state.focused = false;\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);\n  }\n\n  var detectingSelectAll;\n  function onContextMenu(cm, e) {\n    if (signalDOMEvent(cm, e, "contextmenu")) return;\n    var display = cm.display, sel = cm.doc.sel;\n    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\n\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || opera) return; // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)))\n      operation(cm, setSelection)(cm.doc, pos, pos);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = "absolute";\n    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +\n      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: transparent; outline: none;" +\n      "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";\n    focusInput(cm);\n    resetInput(cm, true);\n    // Adds "Select all" to context menu in FF\n    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";\n\n    function prepareSelectAllHack() {\n      if (display.input.selectionStart != null) {\n        var extval = display.input.value = "\\u200b" + (posEq(sel.from, sel.to) ? "" : display.input.value);\n        display.prevInput = "\\u200b";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n      }\n    }\n    function rehide() {\n      display.inputDiv.style.position = "relative";\n      display.input.style.cssText = oldCSS;\n      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all\n      if (display.input.selectionStart != null) {\n        if (!old_ie || ie_lt9) prepareSelectAllHack();\n        clearTimeout(detectingSelectAll);\n        var i = 0, poll = function(){\n          if (display.prevInput == "\\u200b" && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        };\n        detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (old_ie && !ie_lt9) prepareSelectAllHack();\n    if (captureMiddleClick) {\n      e_stop(e);\n      var mouseup = function() {\n        off(window, "mouseup", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, "mouseup", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  // UPDATING\n\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Make sure a position will be valid after the given change.\n  function clipPostChange(doc, change, pos) {\n    if (!posLess(change.from, pos)) return clipPos(doc, pos);\n    var diff = (change.text.length - 1) - (change.to.line - change.from.line);\n    if (pos.line > change.to.line + diff) {\n      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;\n      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);\n      return clipToLen(pos, getLine(doc, preLine).text.length);\n    }\n    if (pos.line == change.to.line + diff)\n      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +\n                       getLine(doc, change.to.line).text.length - change.to.ch);\n    var inside = pos.line - change.from.line;\n    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));\n  }\n\n  // Hint can be null|"end"|"start"|"around"|{anchor,head}\n  function computeSelAfterChange(doc, change, hint) {\n    if (hint && typeof hint == "object") // Assumed to be {anchor, head} object\n      return {anchor: clipPostChange(doc, change, hint.anchor),\n              head: clipPostChange(doc, change, hint.head)};\n\n    if (hint == "start") return {anchor: change.from, head: change.from};\n\n    var end = changeEnd(change);\n    if (hint == "around") return {anchor: change.from, head: end};\n    if (hint == "end") return {anchor: end, head: end};\n\n    // hint is null, leave the selection alone as much as possible\n    var adjustPos = function(pos) {\n      if (posLess(pos, change.from)) return pos;\n      if (!posLess(change.to, pos)) return end;\n\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n      if (pos.line == change.to.line) ch += end.ch - change.to.ch;\n      return Pos(line, ch);\n    };\n    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};\n  }\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, "beforeChange", doc, obj);\n    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Replace the range from from to to by the strings in replacement.\n  // change is a {from, to, text [, origin]} object\n  function makeChange(doc, change, selUpdate, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [""]});\n      if (split.length)\n        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);\n    } else {\n      makeChangeNoReadonly(doc, change, selUpdate);\n    }\n  }\n\n  function makeChangeNoReadonly(doc, change, selUpdate) {\n    if (change.text.length == 1 && change.text[0] == "" && posEq(change.from, change.to)) return;\n    var selAfter = computeSelAfterChange(doc, change, selUpdate);\n    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  function makeChangeFromHistory(doc, type) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history;\n    var event = (type == "undo" ? hist.done : hist.undone).pop();\n    if (!event) return;\n\n    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,\n                anchorAfter: event.anchorBefore, headAfter: event.headBefore,\n                generation: hist.generation};\n    (type == "undo" ? hist.undone : hist.done).push(anti);\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        (type == "undo" ? hist.done : hist.undone).length = 0;\n        return;\n      }\n\n      anti.changes.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change, null)\n                    : {anchor: event.anchorBefore, head: event.headBefore};\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      var rebased = [];\n\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  function shiftDoc(doc, distance) {\n    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}\n    doc.first += distance;\n    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);\n    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);\n    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);\n  }\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);\n    else updateDoc(doc, change, spans, selAfter);\n  }\n\n  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))\n      cm.curOp.cursorActivity = true;\n\n    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(doc, line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    regChange(cm, from.line, to.line + 1, lendiff);\n\n    if (hasHandler(cm, "change")) {\n      var changeObj = {from: from, to: to,\n                       text: change.text,\n                       removed: change.removed,\n                       origin: change.origin};\n      if (cm.curOp.textChanged) {\n        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else cm.curOp.textChanged = changeObj;\n    }\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == "string") code = splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);\n  }\n\n  // POSITION OBJECT\n\n  function Pos(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  }\n  CodeMirror.Pos = Pos;\n\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function cmp(a, b) {return a.line - b.line || a.ch - b.ch;}\n  function copyPos(x) {return Pos(x.line, x.ch);}\n\n  // SELECTION\n\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\n  // If shift is held, this will move the selection anchor. Otherwise,\n  // it'll set the whole selection.\n  function extendSelection(doc, pos, other, bias) {\n    if (doc.sel.shift || doc.sel.extend) {\n      var anchor = doc.sel.anchor;\n      if (other) {\n        var posBefore = posLess(pos, anchor);\n        if (posBefore != posLess(other, anchor)) {\n          anchor = pos;\n          pos = other;\n        } else if (posBefore != posLess(pos, other)) {\n          pos = other;\n        }\n      }\n      setSelection(doc, anchor, pos, bias);\n    } else {\n      setSelection(doc, pos, other || pos, bias);\n    }\n    if (doc.cm) doc.cm.curOp.userSelChange = true;\n  }\n\n  function filterSelectionChange(doc, anchor, head) {\n    var obj = {anchor: anchor, head: head};\n    signal(doc, "beforeSelectionChange", doc, obj);\n    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);\n    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);\n    return obj;\n  }\n\n  // Update the selection. Last two args are only used by\n  // updateDoc, since they have to be expressed in the line\n  // numbers before the update.\n  function setSelection(doc, anchor, head, bias, checkAtomic) {\n    if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {\n      var filtered = filterSelectionChange(doc, anchor, head);\n      head = filtered.head;\n      anchor = filtered.anchor;\n    }\n\n    var sel = doc.sel;\n    sel.goalColumn = null;\n    if (bias == null) bias = posLess(head, sel.head) ? -1 : 1;\n    // Skip over atomic spans.\n    if (checkAtomic || !posEq(anchor, sel.anchor))\n      anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");\n    if (checkAtomic || !posEq(head, sel.head))\n      head = skipAtomic(doc, head, bias, checkAtomic != "push");\n\n    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n\n    sel.anchor = anchor; sel.head = head;\n    var inv = posLess(head, anchor);\n    sel.from = inv ? head : anchor;\n    sel.to = inv ? anchor : head;\n\n    if (doc.cm)\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =\n        doc.cm.curOp.cursorActivity = true;\n\n    signalLater(doc, "cursorActivity", doc);\n  }\n\n  function reCheckSelection(cm) {\n    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");\n  }\n\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, "beforeCursorEnter");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find()[dir < 0 ? "from" : "to"];\n            if (posEq(newPos, curPos)) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SCROLLING\n\n  function scrollCursorIntoView(cm) {\n    var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);\n    if (!cm.state.focused) return;\n    var display = cm.display, box = getRect(display.sizer), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt("div", "\\u200b", null, "position: absolute; top: " +\n                           (coords.top - display.viewOffset) + "px; height: " +\n                           (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +\n                           coords.left + "px; width: 2px;");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (;;) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;\n    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;\n    var gutterw = display.gutters.offsetWidth;\n    var atLeft = x1 < gutterw + 10;\n    if (x1 < screenleft + gutterw || atLeft) {\n      if (atLeft) x1 = 0;\n      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n    } else if (x2 > screenw + screenleft - 3) {\n      result.scrollLeft = x2 + 10 - screenw;\n    }\n    return result;\n  }\n\n  function updateScrollPos(cm, left, top) {\n    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,\n                                scrollTop: top == null ? cm.doc.scrollTop : top};\n  }\n\n  function addToScrollPos(cm, left, top) {\n    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});\n    var scroll = cm.display.scroller;\n    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));\n    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));\n  }\n\n  // API UTILITIES\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc;\n    if (how == null) how = "add";\n    if (how == "smart") {\n      if (!cm.doc.mode.indent) how = "prev";\n      else var state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = "not";\n    } else if (how == "smart") {\n      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass) {\n        if (!aggressive) return;\n        how = "prev";\n      }\n    }\n    if (how == "prev") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == "add") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == "subtract") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == "number") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = "", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\\t";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString)\n      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");\n    else if (doc.sel.head.line == n && doc.sel.head.ch < curSpaceString.length)\n      setSelection(doc, Pos(n, curSpaceString.length), Pos(n, curSpaceString.length), 1);\n    line.stateAfter = null;\n  }\n\n  function changeLine(cm, handle, op) {\n    var no = handle, line = handle, doc = cm.doc;\n    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no)) regChange(cm, no, no + 1);\n    else return null;\n    return line;\n  }\n\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == "char") moveOnce();\n    else if (unit == "column") moveOnce(true);\n    else if (unit == "word" || unit == "group") {\n      var sawType = null, group = unit == "group";\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || "\\n";\n        var type = isWordChar(cur) ? "w"\n          : !group ? null\n          : /\\s/.test(cur) ? null\n          : "p";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == "page") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == "line") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  function findWordAt(line, pos) {\n    var start = pos.ch, end = pos.ch;\n    if (line) {\n      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n      var startChar = line.charAt(start);\n      var check = isWordChar(startChar) ? isWordChar\n        : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n        : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n      while (start > 0 && check(line.charAt(start - 1))) --start;\n      while (end < line.length && check(line.charAt(end))) ++end;\n    }\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};\n  }\n\n  function selectLine(cm, line) {\n    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));\n  }\n\n  // PROTOTYPE\n\n  // The publicly visible API. Note that operation(null, f) means\n  // 'wrap f in an operation, performed on its `this` parameter'\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != "mode") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? "push" : "unshift"](map);\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: operation(null, function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error("Overlays may not be stateful.");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: operation(null, function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == "string" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: operation(null, function(n, dir, aggressive) {\n      if (typeof dir != "string" && typeof dir != "number") {\n        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";\n        else dir = dir ? "add" : "subtract";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: operation(null, function(how) {\n      var sel = this.doc.sel;\n      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how, true);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      var doc = this.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null, // Deprecated, use 'type' instead\n              type: style || null,\n              state: state};\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      if (ch == 0) return styles[2];\n      for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else return styles[mid * 2 + 2];\n      }\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return helpers;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == "string") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, sel = this.doc.sel;\n      if (start == null) pos = sel.head;\n      else if (typeof start == "object") pos = clipPos(this.doc, start);\n      else pos = start ? sel.from : sel.to;\n      return cursorCoords(this, pos, mode || "page");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || "page");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || "page");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, last = this.doc.first + this.doc.size - 1;\n      if (line < this.doc.first) line = this.doc.first;\n      else if (line > last) { line = last; end = true; }\n      var lineObj = getLine(this.doc, line);\n      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || "page").top +\n        (end ? lineObj.height : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: operation(null, function(line, gutterID, value) {\n      return changeLine(this, line, function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: operation(null, function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regChange(cm, i, i + 1);\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp("(?:^|\\\\s)" + cls + "(?:$|\\\\s)").test(line[prop])) return false;\n        else line[prop] += " " + cls;\n        return true;\n      });\n    }),\n\n    removeLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(new RegExp("(?:^|\\\\s+)" + cls + "(?:$|\\\\s+)"));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: operation(null, function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    lineInfo: function(line) {\n      if (typeof line == "number") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = "absolute";\n      display.sizer.appendChild(node);\n      if (vert == "over") {\n        top = pos.top;\n      } else if (vert == "above" || vert == "near") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + "px";\n      node.style.left = node.style.right = "";\n      if (horiz == "right") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = "0px";\n      } else {\n        if (horiz == "left") left = 0;\n        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + "px";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: operation(null, onKeyDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd](this);\n    },\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, pos;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to))\n        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);\n      else\n        pos = dir < 0 ? sel.from : sel.to;\n      extendSelection(this.doc, pos, pos, dir);\n    }),\n\n    deleteH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel;\n      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");\n      else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");\n      this.curOp.userSelChange = true;\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, "div");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, target, goal;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to)) {\n        var pos = cursorCoords(this, sel.head, "div");\n        if (sel.goalColumn != null) pos.left = sel.goalColumn;\n        target = findPosV(this, pos, dir, unit);\n        if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);\n        goal = pos.left;\n      } else {\n        target = dir < 0 ? sel.from : sel.to;\n      }\n      extendSelection(this.doc, target, target, dir);\n      if (goal != null) sel.goalColumn = goal;\n    }),\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        this.display.cursor.className += " CodeMirror-overwrite";\n      else\n        this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");\n    },\n    hasFocus: function() { return this.state.focused; },\n\n    scrollTo: operation(null, function(x, y) {\n      updateScrollPos(this, x, y);\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: operation(null, function(range, margin) {\n      if (range == null) range = {from: this.doc.sel.head, to: null};\n      else if (typeof range == "number") range = {from: Pos(range, 0), to: null};\n      else if (range.from == null) range = {from: range, to: null};\n      if (!range.to) range.to = range.from;\n      if (!margin) margin = 0;\n\n      var coords = range;\n      if (range.from.line != null) {\n        this.curOp.scrollToPos = {from: range.from, to: range.to, margin: margin};\n        coords = {from: cursorCoords(this, range.from),\n                  to: cursorCoords(this, range.to)};\n      }\n      var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left),\n                                    Math.min(coords.from.top, coords.to.top) - margin,\n                                    Math.max(coords.from.right, coords.to.right),\n                                    Math.max(coords.from.bottom, coords.to.bottom) + margin);\n      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);\n    }),\n\n    setSize: operation(null, function(width, height) {\n      function interpret(val) {\n        return typeof val == "number" || /^\\d+$/.test(String(val)) ? val + "px" : val;\n      }\n      if (width != null) this.display.wrapper.style.width = interpret(width);\n      if (height != null) this.display.wrapper.style.height = interpret(height);\n      if (this.options.lineWrapping)\n        this.display.measureLineCache.length = this.display.measureLineCachePos = 0;\n      this.curOp.forceUpdate = true;\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: operation(null, function() {\n      var badHeight = this.display.cachedTextHeight == null;\n      clearCaches(this);\n      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);\n      regChange(this);\n      if (badHeight) estimateLineHeights(this);\n    }),\n\n    swapDoc: operation(null, function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      resetInput(this, true);\n      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);\n      signalLater(this, "swapDoc", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option("value", "", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option("mode", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option("indentUnit", 2, loadMode, true);\n  option("indentWithTabs", false);\n  option("smartIndent", true);\n  option("tabSize", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option("specialChars", /[\\t\\u0000-\\u0019\\u00ad\\u200b\\u2028\\u2029\\ufeff]/g, function(cm, val) {\n    cm.options.specialChars = new RegExp(val.source + (val.test("\\t") ? "" : "|\\t"), "g");\n    cm.refresh();\n  }, true);\n  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option("electricChars", true);\n  option("rtlMoveVisually", !windows);\n  option("wholeLineUpdateBefore", true);\n\n  option("theme", "default", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option("keyMap", "default", keyMapChanged);\n  option("extraKeys", null);\n\n  option("onKeyEvent", null);\n  option("onDragEvent", null);\n\n  option("lineWrapping", false, wrappingChanged, true);\n  option("gutters", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option("fixedGutter", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";\n    cm.refresh();\n  }, true);\n  option("coverGutterNextToScrollbar", false, updateScrollbars, true);\n  option("lineNumbers", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option("firstLineNumber", 1, guttersChanged, true);\n  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);\n  option("showCursorWhenSelecting", false, updateSelection, true);\n\n  option("resetSelectionOnContextMenu", true);\n\n  option("readOnly", false, function(cm, val) {\n    if (val == "nocursor") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n      if (!val) resetInput(cm, true);\n    }\n  });\n  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm, true);}, true);\n  option("dragDrop", true);\n\n  option("cursorBlinkRate", 530);\n  option("cursorScrollMargin", 0);\n  option("cursorHeight", 1);\n  option("workTime", 100);\n  option("workDelay", 100);\n  option("flattenSpans", true, resetModeState, true);\n  option("addModeClass", false, resetModeState, true);\n  option("pollInterval", 100);\n  option("undoDepth", 40, function(cm, val){cm.doc.history.undoDepth = val;});\n  option("historyEventDelay", 500);\n  option("viewportMargin", 10, function(cm){cm.refresh();}, true);\n  option("maxHighlightLength", 10000, resetModeState, true);\n  option("crudeMeasuringFrom", 10000);\n  option("moveInputWithCursor", true, function(cm, val) {\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n  });\n\n  option("tabindex", null, function(cm, val) {\n    cm.display.input.tabIndex = val || "";\n  });\n  option("autofocus", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode("application/xml");\n    }\n    if (typeof spec == "string") return {name: spec};\n    else return spec || {name: "null"};\n  };\n\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, "text/plain");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  CodeMirror.defineMode("null", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME("text/plain", "null");\n\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // UTILITIES\n\n  CodeMirror.isWordChar = isWordChar;\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch)\n        cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");\n      else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");\n    },\n    deleteLine: function(cm) {\n      var l = cm.getCursor().line;\n      cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");\n    },\n    delLineLeft: function(cm) {\n      var cur = cm.getCursor();\n      cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n    },\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor(), start = lineStart(cm, cur.line);\n      var line = cm.getLineHandle(start.line);\n      var order = getOrder(line);\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));\n      } else cm.extendSelection(start);\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n    },\n    goLineRight: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), "div").top + 5;\n      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div"));\n    },\n    goLineLeft: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), "div").top + 5;\n      cm.extendSelection(cm.coordsChar({left: 0, top: top}, "div"));\n    },\n    goLineUp: function(cm) {cm.moveV(-1, "line");},\n    goLineDown: function(cm) {cm.moveV(1, "line");},\n    goPageUp: function(cm) {cm.moveV(-1, "page");},\n    goPageDown: function(cm) {cm.moveV(1, "page");},\n    goCharLeft: function(cm) {cm.moveH(-1, "char");},\n    goCharRight: function(cm) {cm.moveH(1, "char");},\n    goColumnLeft: function(cm) {cm.moveH(-1, "column");},\n    goColumnRight: function(cm) {cm.moveH(1, "column");},\n    goWordLeft: function(cm) {cm.moveH(-1, "word");},\n    goGroupRight: function(cm) {cm.moveH(1, "group");},\n    goGroupLeft: function(cm) {cm.moveH(-1, "group");},\n    goWordRight: function(cm) {cm.moveH(1, "word");},\n    delCharBefore: function(cm) {cm.deleteH(-1, "char");},\n    delCharAfter: function(cm) {cm.deleteH(1, "char");},\n    delWordBefore: function(cm) {cm.deleteH(-1, "word");},\n    delWordAfter: function(cm) {cm.deleteH(1, "word");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},\n    delGroupAfter: function(cm) {cm.deleteH(1, "group");},\n    indentAuto: function(cm) {cm.indentSelection("smart");},\n    indentMore: function(cm) {cm.indentSelection("add");},\n    indentLess: function(cm) {cm.indentSelection("subtract");},\n    insertTab: function(cm) {\n      cm.replaceSelection("\\t", "end", "+input");\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection("add");\n      else cm.replaceSelection("\\t", "end", "+input");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n    },\n    newlineAndIndent: function(cm) {\n      operation(cm, function() {\n        cm.replaceSelection("\\n", "end", "+input");\n        cm.indentLine(cm.getCursor().line, null, true);\n      })();\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",\n    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",\n    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",\n    "Tab": "defaultTab", "Shift-Tab": "indentAuto",\n    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",\n    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",\n    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",\n    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",\n    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",\n    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",\n    fallthrough: "basic"\n  };\n  keyMap.macDefault = {\n    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",\n    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",\n    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",\n    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",\n    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",\n    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",\n    fallthrough: ["basic", "emacsy"]\n  };\n  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",\n    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",\n    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",\n    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"\n  };\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == "string") return keyMap[val];\n    else return val;\n  }\n\n  function lookupKey(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return "stop";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return "stop";\n\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != "[object Array]")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done != "stop";\n    }\n  }\n  function isModifierKey(event) {\n    var name = keyNames[event.keyCode];\n    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";\n  }\n  function keyName(event, noShift) {\n    if (opera && event.keyCode == 34 && event["char"]) return false;\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = "Alt-" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;\n    if (!noShift && event.shiftKey) name = "Shift-" + name;\n    return name;\n  }\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.keyName = keyName;\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = document.body;\n      // doc.activeElement occasionally throws on IE\n      try { hasFocus = document.activeElement; } catch(e) {}\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute("autofocus") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, "submit", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    textarea.style.display = "none";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = "";\n      if (textarea.form) {\n        off(textarea.form, "submit", save);\n        if (typeof textarea.form.submit == "function")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  }\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == "string") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == "string") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n  CodeMirror.StringStream = StringStream;\n\n  // TEXTMARKERS\n\n  function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  }\n  CodeMirror.TextMarker = TextMarker;\n  eventMixin(TextMarker);\n\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, "clear")) {\n      var found = this.find();\n      if (found) signalLater(this, "clear", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.to != null) max = lineNo(line);\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from != null)\n        min = lineNo(line);\n      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm);\n    }\n    if (withOp) endOperation(cm);\n  };\n\n  TextMarker.prototype.find = function(bothSides) {\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null || span.to != null) {\n        var found = lineNo(line);\n        if (span.from != null) from = Pos(found, span.from);\n        if (span.to != null) to = Pos(found, span.to);\n      }\n    }\n    if (this.type == "bookmark" && !bothSides) return from;\n    return from && {from: from, to: to};\n  };\n\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(), cm = this.doc.cm;\n    if (!pos || !cm) return;\n    if (this.type != "bookmark") pos = pos.from;\n    var line = getLine(this.doc, pos.line);\n    clearCachedMeasurement(cm, line);\n    if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {\n      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {\n        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);\n        break;\n      }\n      runInOp(cm, function() {\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;\n      });\n    }\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  var nextMarkerId = 0;\n\n  function markText(doc, from, to, options, type) {\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type);\n    if (options) copyObj(options, marker);\n    if (posLess(to, from) || posEq(from, to) && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      marker.collapsed = true;\n      marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");\n      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error("Inserting collapsed marker partially overlapping an existing one");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addToHistory(doc, {from: from, to: to, origin: "markText"},\n                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)\n        updateMaxLine = true;\n      var span = {from: null, to: null, marker: marker};\n      if (curLine == from.line) span.from = from.ch;\n      if (curLine == to.line) span.to = to.ch;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, span);\n      ++curLine;\n    });\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      if (marker.atomic) reCheckSelection(cm);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0, me = this; i < markers.length; ++i) {\n      markers[i].parent = this;\n      on(markers[i], "clear", function(){me.clear();});\n    }\n  }\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, "clear");\n  };\n  SharedTextMarker.prototype.find = function() {\n    return this.primary.find();\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.replacedWith;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.replacedWith = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  // TEXTMARKER SPANS\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({from: span.from,\n                                to: endsAfter ? null : span.to,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n                                to: span.to == null ? null : span.to - endCh,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find();\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;\n        var newParts = [j, 1];\n        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))\n          newParts.push({from: p.from, to: m.from});\n        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(true);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||\n          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)\n        return true;\n    }\n  }\n\n  function visualLine(doc, line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(doc, merged.find().from.line);\n    return line;\n  }\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.replacedWith) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find().to, endLine = getLine(doc, end.line);\n      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // LINE WIDGETS\n\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.cm = cm;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n  function widgetOperation(f) {\n    return function() {\n      var withOp = !this.cm.curOp;\n      if (withOp) startOperation(this.cm);\n      try {var result = f.apply(this, arguments);}\n      finally {if (withOp) endOperation(this.cm);}\n      return result;\n    };\n  }\n  LineWidget.prototype.clear = widgetOperation(function() {\n    var ws = this.line.widgets, no = lineNo(this.line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) this.line.widgets = null;\n    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;\n    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));\n    if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);\n    regChange(this.cm, no, no + 1);\n  });\n  LineWidget.prototype.changed = widgetOperation(function() {\n    var oldH = this.height;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(this.line, this.line.height + diff);\n    var no = lineNo(this.line);\n    regChange(this.cm, no, no + 1);\n  });\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)\n      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm, handle, function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {\n        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, 0, widget.height);\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Run the given mode's parser over a line, update the styles\n  // array, which contains alternating fragments of text and CSS\n  // classes.\n  function runMode(cm, text, mode, state, f, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    if (text == "" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = mode.token(stream, state);\n      }\n      if (cm.options.addModeClass) {\n        var mName = CodeMirror.innerMode(mode, state).mode.name;\n        if (mName) style = "m-" + (style ? mName + " " + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        if (curStart < stream.start) f(stream.start, curStyle);\n        curStart = stream.start; curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen];\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = cur ? cur + " " + style : style;\n          }\n        }\n      });\n    }\n\n    return st;\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen)\n      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == "" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n      mode.token(stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, builder) {\n    if (!style) return null;\n    for (;;) {\n      var lineClass = style.match(/(?:^|\\s)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? "bgClass" : "textClass";\n      if (builder[prop] == null)\n        builder[prop] = lineClass[2];\n      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(builder[prop]))\n        builder[prop] += " " + lineClass[2];\n    }\n    var cache = builder.cm.options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = "cm-" + style.replace(/ +/g, " cm-"));\n  }\n\n  function buildLineContent(cm, realLine, measure, copyWidgets) {\n    var merged, line = realLine, empty = true;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(cm.doc, merged.find().from.line);\n\n    var builder = {pre: elt("pre"), col: 0, pos: 0,\n                   measure: null, measuredSomething: false, cm: cm,\n                   copyWidgets: copyWidgets};\n\n    do {\n      if (line.text) empty = false;\n      builder.measure = line == realLine && measure;\n      builder.pos = 0;\n      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n      if ((old_ie || webkit) && cm.getOption("lineWrapping"))\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      var next = insertLineContent(line, builder, getLineStyles(cm, line));\n      if (measure && line == realLine && !builder.measuredSomething) {\n        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n        builder.measuredSomething = true;\n      }\n      if (next) line = getLine(cm.doc, next.to.line);\n    } while (next);\n\n    if (measure && !builder.measuredSomething && !measure[0])\n      measure[0] = builder.pre.appendChild(empty ? elt("span", "\\u00a0") : zeroWidthElement(cm.display.measure));\n    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))\n      builder.pre.appendChild(document.createTextNode("\\u00a0"));\n\n    var order;\n    // Work around problem with the reported dimensions of single-char\n    // direction spans on IE (issue #1129). See also the comment in\n    // cursorCoords.\n    if (measure && ie && (order = getOrder(line))) {\n      var l = order.length - 1;\n      if (order[l].from == order[l].to) --l;\n      var last = order[l], prev = order[l - 1];\n      if (last.from + 1 == last.to && prev && last.level < prev.level) {\n        var span = measure[builder.pos - 1];\n        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),\n                                               span.nextSibling);\n      }\n    }\n\n    var textClass = builder.textClass ? builder.textClass + " " + (realLine.textClass || "") : realLine.textClass;\n    if (textClass) builder.pre.className = textClass;\n\n    signal(cm, "renderLine", cm, realLine, builder.pre);\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt("span", "\\u2022", "cm-invalidchar");\n    token.title = "\\\\u" + ch.charCodeAt(0).toString(16);\n    return token;\n  }\n\n  function buildToken(builder, text, style, startStyle, endStyle, title) {\n    if (!text) return;\n    var special = builder.cm.options.specialChars;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n          builder.col += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == "\\t") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));\n          builder.col += tabWidth;\n        } else {\n          var token = builder.cm.options.specialCharPlaceholder(m[0]);\n          content.appendChild(token);\n          builder.col += 1;\n        }\n      }\n    }\n    if (style || startStyle || endStyle || builder.measure) {\n      var fullStyle = style || "";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt("span", [content], fullStyle);\n      if (title) token.title = title;\n      return builder.pre.appendChild(token);\n    }\n    builder.pre.appendChild(content);\n  }\n\n  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n    var wrapping = builder.cm.options.lineWrapping;\n    for (var i = 0; i < text.length; ++i) {\n      var start = i == 0, to = i + 1;\n      while (to < text.length && isExtendingChar(text.charAt(to))) ++to;\n      var ch = text.slice(i, to);\n      i = to - 1;\n      if (i && wrapping && spanAffectsWrapping(text, i))\n        builder.pre.appendChild(elt("wbr"));\n      var old = builder.measure[builder.pos];\n      var span = builder.measure[builder.pos] =\n        buildToken(builder, ch, style,\n                   start && startStyle, i == text.length - 1 && endStyle);\n      if (old) span.leftSide = old.leftSide || old;\n      // In IE single-space nodes wrap differently than spaces\n      // embedded in larger text nodes, except when set to\n      // white-space: normal (issue #1268).\n      if (old_ie && wrapping && ch == " " && i && !/\\s/.test(text.charAt(i - 1)) &&\n          i < text.length - 1 && !/\\s/.test(text.charAt(i + 1)))\n        span.style.whiteSpace = "normal";\n      builder.pos += ch.length;\n    }\n    if (text.length) builder.measuredSomething = true;\n  }\n\n  function buildTokenSplitSpaces(inner) {\n    function split(old) {\n      var out = " ";\n      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\\u00a0";\n      out += " ";\n      return out;\n    }\n    return function(builder, text, style, startStyle, endStyle, title) {\n      return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.replacedWith;\n    if (widget) {\n      if (builder.copyWidgets) widget = widget.cloneNode(true);\n      builder.pre.appendChild(widget);\n      if (builder.measure) {\n        if (size) {\n          builder.measure[builder.pos] = widget;\n        } else {\n          var elt = zeroWidthElement(builder.cm.display.measure);\n          if (marker.type == "bookmark" && !marker.insertLeft)\n            builder.measure[builder.pos] = builder.pre.appendChild(elt);\n          else if (builder.measure[builder.pos])\n            return;\n          else\n            builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);\n        }\n        builder.measuredSomething = true;\n      }\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = "", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = "";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }\n            if (m.className) spanStyle += " " + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == "bookmark" && sp.from == pos && m.replacedWith) foundBookmarks.push(m);\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return collapsed.marker.find();\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = "";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, "change", line, change);\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // First adjust the line structure\n    if (from.ch == 0 && to.ch == 0 && lastText == "" &&\n        (!doc.cm || doc.cm.options.wholeLineUpdateBefore)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)\n          added.push(new Line(text[i], spansFor(i), estimateHeight));\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, "change", doc, change);\n    setSelection(doc, selAfter.anchor, selAfter.head, null, true);\n  }\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, "delete");\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.history = makeHistory();\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n\n    if (typeof text == "string") text = splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || "\\n");\n    },\n    setValue: function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: splitLines(code), origin: "setValue"},\n                 {head: top, anchor: top}, true);\n    },\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || "\\n");\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n    setLine: function(line, text) {\n      if (isLine(this, line))\n        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));\n    },\n    removeLine: function(line) {\n      if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));\n      else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));\n    },\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == "number") line = getLine(this, line);\n      return visualLine(this, line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var sel = this.sel, pos;\n      if (start == null || start == "head") pos = sel.head;\n      else if (start == "anchor") pos = sel.anchor;\n      else if (start == "end" || start === false) pos = sel.to;\n      else pos = sel.from;\n      return copyPos(pos);\n    },\n    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},\n\n    setCursor: docOperation(function(line, ch, extend) {\n      var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);\n      if (extend) extendSelection(this, pos);\n      else setSelection(this, pos, pos);\n    }),\n    setSelection: docOperation(function(anchor, head, bias) {\n      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);\n    }),\n    extendSelection: docOperation(function(from, to, bias) {\n      extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);\n    }),\n\n    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},\n    replaceSelection: function(code, collapse, origin) {\n      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || "around");\n    },\n    undo: docOperation(function() {makeChangeFromHistory(this, "undo");}),\n    redo: docOperation(function() {makeChangeFromHistory(this, "redo");}),\n\n    setExtending: function(val) {this.sel.extend = val;},\n\n    historySize: function() {\n      var hist = this.history;\n      return {undo: hist.done.length, redo: hist.undone.length};\n    },\n    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = makeHistory(this.history.maxGeneration);\n      hist.done = histData.done.slice(0);\n      hist.undone = histData.undone.slice(0);\n    },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, "bookmark");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,\n                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = makeHistory();\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;}\n  });\n\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // The Doc methods that should be available on CodeMirror instances\n  var dontDelegate = "iter insert remove copy getEditor".split(" ");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error("This document is already in use.");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) computeMaxLength(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  function getLine(chunk, n) {\n    n -= chunk.first;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n  function heightAtLine(cm, lineObj) {\n    lineObj = visualLine(cm.doc, lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function makeHistory(startGen) {\n    return {\n      // Arrays of history events. Doing something adds an event to\n      // done and clears undo. Undoing moves events from done to\n      // undone, redoing moves them in the other direction.\n      done: [], undone: [], undoDepth: Infinity,\n      // Used to track when changes can be merged into a single undo\n      // event\n      lastTime: 0, lastOp: null, lastOrigin: null,\n      // Used by the isClean() method\n      generation: startGen || 1, maxGeneration: startGen || 1\n    };\n  }\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change["spans_" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  function historyChangeFromChange(doc, change) {\n    var from = { line: change.from.line, ch: change.from.ch };\n    var histChange = {from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  function addToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur = lst(hist.done);\n\n    if (cur &&\n        (hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == "*"))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;\n    } else {\n      // Can not be merged, start a new event.\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation,\n             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,\n             anchorAfter: selAfter.anchor, headAfter: selAfter.head};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth)\n        hist.done.shift();\n    }\n    hist.generation = ++hist.maxGeneration;\n    hist.lastTime = time;\n    hist.lastOp = opId;\n    hist.lastOrigin = change.origin;\n  }\n\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  function getOldSpans(doc, change) {\n    var found = change["spans_" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i], changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,\n                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSel(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }\n        if (to < cur.from.line) {\n          cur.from.line += diff;\n          cur.to.line += diff;\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!sub.copied) {\n        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);\n        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);\n        sub.copied = true;\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      } else {\n        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);\n        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT OPERATORS\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  function on(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent("on" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent("on" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  }\n\n  var delayedCallbacks, delayedCallbackDepth = 0;\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    if (!delayedCallbacks) {\n      ++delayedCallbackDepth;\n      delayedCallbacks = [];\n      setTimeout(fireDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      delayedCallbacks.push(bnd(arr[i]));\n  }\n\n  function signalDOMEvent(cm, e, override) {\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function fireDelayed() {\n    --delayedCallbackDepth;\n    var delayed = delayedCallbacks;\n    delayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;\n\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {\n      if (string.charAt(i) == "\\t") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n  CodeMirror.countColumn = countColumn;\n\n  var spaceStrs = [""];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + " ");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else {\n      // Suppress mysterious IE10 errors\n      try { node.select(); }\n      catch(_e) {}\n    }\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  function createObj(base, props) {\n    function Obj() {}\n    Obj.prototype = base;\n    var inst = new Obj();\n    if (props) copyObj(props, inst);\n    return inst;\n  }\n\n  function copyObj(obj, target) {\n    if (!target) target = {};\n    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n    return target;\n  }\n\n  function emptyArray(size) {\n    for (var a = [], i = 0; i < size; ++i) a.push(undefined);\n    return a;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch > "\\x80" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == "string") setTextContent(e, content);\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = "";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  function getRect(node) {\n    return node.getBoundingClientRect();\n  }\n  CodeMirror.replaceGetRect = function(f) { getRect = f; };\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return "draggable" in div || "dragDrop" in div;\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of tests matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  function spanAffectsWrapping() { return false; }\n  if (gecko) // Only for "$'"\n    spanAffectsWrapping = function(str, i) {\n      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;\n    };\n  else if (safari && !/Version\\/([6-9]|\\d\\d)\\b/.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      return /\\-[^ \\-?]|\\?[^ !\\'\\"\\),.\\-\\/:;\\?\\]\\}]/.test(str.slice(i - 1, i + 1));\n    };\n  else if (webkit && /Chrome\\/(?:29|[3-9]\\d|\\d\\d\\d)\\./.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      var code = str.charCodeAt(i - 1);\n      return code >= 8208 && code <= 8212;\n    };\n  else if (webkit)\n    spanAffectsWrapping = function(str, i) {\n      if (i > 1 && str.charCodeAt(i - 1) == 45) {\n        if (/\\w/.test(str.charAt(i - 2)) && /[^\\-?\\.]/.test(str.charAt(i))) return true;\n        if (i > 2 && /[\\d\\.,]/.test(str.charAt(i - 2)) && /[\\d\\.,]/.test(str.charAt(i))) return false;\n      }\n      return /[~!#%&*)=+}\\]\\\\|\\"\\.>,:;][({[<]|-[^\\-?\\.\\u2010-\\u201f\\u2026]|\\?[\\w~`@#$%\\^&*(_=+{[|><]|\\u2026[\\w~`@#$%\\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));\n    };\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt("span", "\\u200b");\n      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n    }\n    if (zwspSupported) return elt("span", "\\u200b");\n    else return elt("span", "\\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");\n  }\n\n  // See if "".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf("\\n", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);\n      var rt = line.indexOf("\\r");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints("StartToEnd", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt("div");\n    if ("oncopy" in e) return true;\n    e.setAttribute("oncopy", "return;");\n    return typeof e.oncopy == 'function';\n  })();\n\n  // KEY NAMING\n\n  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",\n                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",\n                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",\n                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",\n                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\\\",\n                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",\n                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, "ltr");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, "ltr");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(cm.doc, line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line;\n    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))\n      lineN = merged.find().to.line;\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN, ch);\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is somewhat involved. It is needed in order to move\n  // 'visually' through bi-directional text -- i.e., pressing left\n  // should make the cursor go left, even when in RTL text. The\n  // tricky part is the 'jumps', where RTL and LTR text touch each\n  // other. This often requires the cursor offset to move more than\n  // one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";\n    function charType(code) {\n      if (code <= 0xff) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return "R";\n      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);\n      else if (0x700 <= code && code <= 0x8ac) return "r";\n      else return "L";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = "L";\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == "m") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == "1" && cur == "r") types[i] = "n";\n        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";\n        else if (type == "," && prev == types[i+1] &&\n                 (prev == "1" || prev == "n")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == ",") types[i] = "N";\n        else if (type == "%") {\n          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}\n          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == "L" && type == "1") types[i] = "L";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == "L";\n          var after = (end < len ? types[end] : outerType) == "L";\n          var replace = before || after ? "L" : "R";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push({from: start, to: i, level: 0});\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != "L"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, {from: nstart, to: j, level: 2});\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift({from: 0, to: m[0].length, level: 0});\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push({from: len - m[0].length, to: len, level: 0});\n      }\n      if (order[0].level != lst(order).level)\n        order.push({from: len, to: len, level: order[0].level});\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = "3.21.0";\n\n  return CodeMirror;\n})();\n\n\n\n\n\n\n\n\nCodeMirror.defineMode("sql", function(config, parserConfig) {\n  "use strict";\n\n  var client         = parserConfig.client || {},\n      atoms          = parserConfig.atoms || {"false": true, "true": true, "null": true},\n      builtin        = parserConfig.builtin || {},\n      keywords       = parserConfig.keywords || {},\n      operatorChars  = parserConfig.operatorChars || /^[*+\\-%<>!=&|~^]/,\n      support        = parserConfig.support || {},\n      hooks          = parserConfig.hooks || {},\n      dateSQL        = parserConfig.dateSQL || {"date" : true, "time" : true, "timestamp" : true};\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n\n    // call hooks from the mime type\n    if (hooks[ch]) {\n      var result = hooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n\n    if (support.hexNumber == true &&\n      ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/))\n      || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {\n      // hex\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html\n      return "number";\n    } else if (support.binaryNumber == true &&\n      (((ch == "b" || ch == "B") && stream.match(/^'[01]+'/))\n      || (ch == "0" && stream.match(/^b[01]+/)))) {\n      // bitstring\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html\n      return "number";\n    } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {\n      // numbers\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html\n          stream.match(/^[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/);\n      support.decimallessFloat == true && stream.eat('.');\n      return "number";\n    } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {\n      // placeholders\n      return "variable-3";\n    } else if (ch == "'" || (ch == '"' && support.doubleQuote)) {\n      // strings\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html\n      state.tokenize = tokenLiteral(ch);\n      return state.tokenize(stream, state);\n    } else if ((((support.nCharCast == true && (ch == "n" || ch == "N"))\n        || (support.charsetCast == true && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)))\n        && (stream.peek() == "'" || stream.peek() == '"'))) {\n      // charset casting: _utf8'str', N'str', n'str'\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html\n      return "keyword";\n    } else if (/^[\\(\\),\\;\\[\\]]/.test(ch)) {\n      // no highlightning\n      return null;\n    } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {\n      // 1-line comment\n      stream.skipToEnd();\n      return "comment";\n    } else if ((support.commentHash && ch == "#")\n        || (ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" ")))) {\n      // 1-line comments\n      // ref: https://kb.askmonty.org/en/comment-syntax/\n      stream.skipToEnd();\n      return "comment";\n    } else if (ch == "/" && stream.eat("*")) {\n      // multi-line comments\n      // ref: https://kb.askmonty.org/en/comment-syntax/\n      state.tokenize = tokenComment;\n      return state.tokenize(stream, state);\n    } else if (ch == ".") {\n      // .1 for 0.1\n      if (support.zerolessFloat == true && stream.match(/^(?:\\d+(?:e[+-]?\\d+)?)/i)) {\n        return "number";\n      }\n      // .table_name (ODBC)\n      // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html\n      if (support.ODBCdotTable == true && stream.match(/^[a-zA-Z_]+/)) {\n        return "variable-2";\n      }\n    } else if (operatorChars.test(ch)) {\n      // operators\n      stream.eatWhile(operatorChars);\n      return null;\n    } else if (ch == '{' &&\n        (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {\n      // dates (weird ODBC syntax)\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html\n      return "number";\n    } else {\n      stream.eatWhile(/^[_\\w\\d]/);\n      var word = stream.current().toLowerCase();\n      // dates (standard SQL syntax)\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html\n      if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))\n        return "number";\n      if (atoms.hasOwnProperty(word)) return "atom";\n      if (builtin.hasOwnProperty(word)) return "builtin";\n      if (keywords.hasOwnProperty(word)) return "keyword";\n      if (client.hasOwnProperty(word)) return "string-2";\n      return null;\n    }\n  }\n\n  // 'string', with char specified in quote escaped by '\\'\n  function tokenLiteral(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      return "string";\n    };\n  }\n  function tokenComment(stream, state) {\n    while (true) {\n      if (stream.skipTo("*")) {\n        stream.next();\n        if (stream.eat("/")) {\n          state.tokenize = tokenBase;\n          break;\n        }\n      } else {\n        stream.skipToEnd();\n        break;\n      }\n    }\n    return "comment";\n  }\n\n  function pushContext(stream, state, type) {\n    state.context = {\n      prev: state.context,\n      indent: stream.indentation(),\n      col: stream.column(),\n      type: type\n    };\n  }\n\n  function popContext(state) {\n    state.indent = state.context.indent;\n    state.context = state.context.prev;\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: tokenBase, context: null};\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (state.context && state.context.align == null)\n          state.context.align = false;\n      }\n      if (stream.eatSpace()) return null;\n\n      var style = state.tokenize(stream, state);\n      if (style == "comment") return style;\n\n      if (state.context && state.context.align == null)\n        state.context.align = true;\n\n      var tok = stream.current();\n      if (tok == "(")\n        pushContext(stream, state, ")");\n      else if (tok == "[")\n        pushContext(stream, state, "]");\n      else if (state.context && state.context.type == tok)\n        popContext(state);\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context;\n      if (!cx) return 0;\n      var closing = textAfter.charAt(0) == cx.type;\n      if (cx.align) return cx.col + (closing ? 0 : 1);\n      else return cx.indent + (closing ? 0 : config.indentUnit);\n    },\n\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : null\n  };\n});\n\n(function() {\n  "use strict";\n\n  // `identifier`\n  function hookIdentifier(stream) {\n    // MySQL/MariaDB identifiers\n    // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html\n    var ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == "`" && !stream.eat("`")) return "variable-2";\n    }\n    return null;\n  }\n\n  // variable token\n  function hookVar(stream) {\n    // variables\n    // @@prefix.varName @varName\n    // varName can be quoted with ` or ' or "\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html\n    if (stream.eat("@")) {\n      stream.match(/^session\\./);\n      stream.match(/^local\\./);\n      stream.match(/^global\\./);\n    }\n\n    if (stream.eat("'")) {\n      stream.match(/^.*'/);\n      return "variable-2";\n    } else if (stream.eat('"')) {\n      stream.match(/^.*"/);\n      return "variable-2";\n    } else if (stream.eat("`")) {\n      stream.match(/^.*`/);\n      return "variable-2";\n    } else if (stream.match(/^[0-9a-zA-Z$\\.\\_]+/)) {\n      return "variable-2";\n    }\n    return null;\n  };\n\n  // short client keyword token\n  function hookClient(stream) {\n    // \\N means NULL\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html\n    if (stream.eat("N")) {\n        return "atom";\n    }\n    // \\g, etc\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html\n    return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;\n  }\n\n  // these keywords are used by all SQL dialects (however, a mode can still overwrite it)\n  var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from having in insert into is join like not on or order select set table union update values where ";\n\n  // turn a space-separated list into an array\n  function set(str) {\n    var obj = {}, words = str.split(" ");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  // A generic SQL Mode. It's not a standard, it just try to support what is generally supported\n  CodeMirror.defineMIME("text/x-sql", {\n    name: "sql",\n    keywords: set(sqlKeywords + "begin"),\n    builtin: set("bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")\n  });\n\n  CodeMirror.defineMIME("text/x-mssql", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered"),\n    builtin: set("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=]/,\n    dateSQL: set("date datetimeoffset datetime2 smalldatetime datetime time"),\n    hooks: {\n      "@":   hookVar\n    }\n  });\n\n  CodeMirror.defineMIME("text/x-mysql", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group groupby_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),\n    builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=&|^]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),\n    hooks: {\n      "@":   hookVar,\n      "`":   hookIdentifier,\n      "\\\\":  hookClient\n    }\n  });\n\n  CodeMirror.defineMIME("text/x-mariadb", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),\n    builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=&|^]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),\n    hooks: {\n      "@":   hookVar,\n      "`":   hookIdentifier,\n      "\\\\":  hookClient\n    }\n  });\n\n  // the query language used by Apache Cassandra is called CQL, but this mime type\n  // is called Cassandra to avoid confusion with Contextual Query Language\n  CodeMirror.defineMIME("text/x-cassandra", {\n    name: "sql",\n    client: { },\n    keywords: set("use select from using consistency where limit first reversed first and in insert into values using consistency ttl update set delete truncate begin batch apply create keyspace with columnfamily primary key index on drop alter type add any one quorum all local_quorum each_quorum"),\n    builtin: set("ascii bigint blob boolean counter decimal double float int text timestamp uuid varchar varint"),\n    atoms: set("false true"),\n    operatorChars: /^[<>=]/,\n    dateSQL: { },\n    support: set("commentSlashSlash decimallessFloat"),\n    hooks: { }\n  });\n\n  // this is based on Peter Raganitsch's 'plsql' mode\n  CodeMirror.defineMIME("text/x-plsql", {\n    name:       "sql",\n    client:     set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),\n    keywords:   set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),\n    builtin:    set("abs acos add_months ascii asin atan atan2 average bfile bfilename bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least lenght lenghtb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid upper user userenv varchar varchar2 variance varying vsize xml"),\n    operatorChars: /^[*+\\-%<>!=~]/,\n    dateSQL:    set("date time timestamp"),\n    support:    set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")\n  });\n}());\n\n/*\n  How Properties of Mime Types are used by SQL Mode\n  =================================================\n\n  keywords:\n    A list of keywords you want to be highlighted.\n  functions:\n    A list of function names you want to be highlighted.\n  builtin:\n    A list of builtin types you want to be highlighted (if you want types to be of class "builtin" instead of "keyword").\n  operatorChars:\n    All characters that must be handled as operators.\n  client:\n    Commands parsed and executed by the client (not the server).\n  support:\n    A list of supported syntaxes which are not common, but are supported by more than 1 DBMS.\n    * ODBCdotTable: .tableName\n    * zerolessFloat: .1\n    * doubleQuote\n    * nCharCast: N'string'\n    * charsetCast: _utf8'string'\n    * commentHash: use # char for comments\n    * commentSlashSlash: use // for comments\n    * commentSpaceRequired: require a space after -- for comments\n  atoms:\n    Keywords that must be highlighted as atoms,. Some DBMS's support more atoms than others:\n    UNKNOWN, INFINITY, UNDERFLOW, NaN...\n  dateSQL:\n    Used for date/time SQL standard syntax, because not all DBMS's support same temporal types.\n*/\n\n\n\n\n\n\n\n\n// TODO actually recognize syntax of TypeScript constructs\n\nCodeMirror.defineMode("javascript", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonMode = parserConfig.json;\n  var isTS = parserConfig.typescript;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: "keyword"};}\n    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");\n    var operator = kw("operator"), atom = {type: "atom", style: "atom"};\n\n    var jsKeywords = {\n      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,\n      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,\n      "var": kw("var"), "const": kw("var"), "let": kw("var"),\n      "function": kw("function"), "catch": kw("catch"),\n      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),\n      "in": operator, "typeof": operator, "instanceof": operator,\n      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,\n      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),\n      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: "variable", style: "variable-3"};\n      var tsKeywords = {\n        // object-like things\n        "interface": kw("interface"),\n        "extends": kw("extends"),\n        "constructor": kw("constructor"),\n\n        // scope modifiers\n        "public": kw("public"),\n        "private": kw("private"),\n        "protected": kw("protected"),\n        "static": kw("static"),\n\n        // types\n        "string": type, "number": type, "bool": type, "any": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == "/" && !inSet) return;\n        if (next == "[") inSet = true;\n        else if (inSet && next == "]") inSet = false;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '"' || ch == "'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "." && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret("number", "number");\n    } else if (ch == "." && stream.match("..")) {\n      return ret("spread", "meta");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == "=" && stream.eat(">")) {\n      return ret("=>", "operator");\n    } else if (ch == "0" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret("number", "number");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret("number", "number");\n    } else if (ch == "/") {\n      if (stream.eat("*")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat("/")) {\n        stream.skipToEnd();\n        return ret("comment", "comment");\n      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||\n               state.lastType == "sof" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla\n        return ret("regexp", "string-2");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret("operator", "operator", stream.current());\n      }\n    } else if (ch == "`") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == "#") {\n      stream.skipToEnd();\n      return ret("error", "error");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret("operator", "operator", stream.current());\n    } else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :\n                     ret("variable", "variable", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == "\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == "/" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ret("comment", "comment");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n    return ret("quasi", "string-2", stream.current());\n  }\n\n  var brackets = "([{}])";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf("=>", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (/[$\\w]/.test(ch)) {\n        sawSomething = true;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty("align"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == "variable" && inScope(state, content)) return "variable-2";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = "def";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: "this", next: {name: "arguments"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == "stat") indent = state.lexical.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == ")")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function(type) {\n      if (type == wanted) return cont();\n      else if (wanted == ";") return pass();\n      else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type, value) {\n    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);\n    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);\n    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);\n    if (type == "{") return cont(pushlex("}"), block, poplex);\n    if (type == ";") return cont();\n    if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);\n    if (type == "function") return cont(functiondef);\n    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);\n    if (type == "variable") return cont(pushlex("stat"), maybelabel);\n    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),\n                                      block, poplex, poplex);\n    if (type == "case") return cont(expression, expect(":"));\n    if (type == "default") return cont(expect(":"));\n    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),\n                                     statement, poplex, popcontext);\n    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);\n    if (type == "class") return cont(pushlex("form"), className, objlit, poplex);\n    if (type == "export") return cont(pushlex("form"), afterExport, poplex);\n    if (type == "import") return cont(pushlex("form"), afterImport, poplex);\n    return pass(pushlex("stat"), expression, expect(";"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);\n      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == "function") return cont(functiondef);\n    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);\n    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);\n    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);\n    if (type == "{") return contCommasep(objprop, "}", null, maybeop);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == ",") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == "operator") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == "?") return cont(expression, expect(":"), expr);\n      return cont(expr);\n    }\n    if (type == "quasi") { cx.cc.push(me); return quasi(value); }\n    if (type == ";") return;\n    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);\n    if (type == ".") return cont(property, me);\n    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);\n  }\n  function quasi(value) {\n    if (value.slice(value.length - 2) != "${") return cont();\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == "}") {\n      cx.marked = "string-2";\n      cx.state.tokenize = tokenQuasi;\n      return cont();\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == "{") return pass(statement);\n    return pass(expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == "{") return pass(statement);\n    return pass(expressionNoComma);\n  }\n  function maybelabel(type) {\n    if (type == ":") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(";"), poplex);\n  }\n  function property(type) {\n    if (type == "variable") {cx.marked = "property"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == "variable") {\n      cx.marked = "property";\n      if (value == "get" || value == "set") return cont(getterSetter);\n    } else if (type == "number" || type == "string") {\n      cx.marked = type + " property";\n    } else if (type == "[") {\n      return cont(expression, expect("]"), afterprop);\n    }\n    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);\n  }\n  function getterSetter(type) {\n    if (type != "variable") return pass(afterprop);\n    cx.marked = "property";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == ":") return cont(expressionNoComma);\n    if (type == "(") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == ",") {\n        var lex = cx.state.lexical;\n        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == "}") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == ":") return cont(typedef);\n  }\n  function typedef(type) {\n    if (type == "variable"){cx.marked = "variable-3"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == "variable") { register(value); return cont(); }\n    if (type == "[") return contCommasep(pattern, "]");\n    if (type == "{") return contCommasep(proppattern, "}");\n  }\n  function proppattern(type, value) {\n    if (type == "variable" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == "variable") cx.marked = "property";\n    return cont(expect(":"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == "=") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == ",") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);\n  }\n  function forspec1(type) {\n    if (type == "var") return cont(vardef, expect(";"), forspec2);\n    if (type == ";") return cont(forspec2);\n    if (type == "variable") return cont(formaybeinof);\n    return pass(expression, expect(";"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == ";") return cont(forspec3);\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }\n    return pass(expression, expect(";"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != ")") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}\n    if (type == "variable") {register(value); return cont(functiondef);}\n    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == "spread") return cont(funarg);\n    return pass(pattern, maybetype);\n  }\n  function className(type, value) {\n    if (type == "variable") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(_type, value) {\n    if (value == "extends") return cont(expression);\n  }\n  function objlit(type) {\n    if (type == "{") return contCommasep(objprop, "}");\n  }\n  function afterModule(type, value) {\n    if (type == "string") return cont(statement);\n    if (type == "variable") { register(value); return cont(maybeFrom); }\n  }\n  function afterExport(_type, value) {\n    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }\n    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == "string") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == "{") return contCommasep(importSpec, "}");\n    if (type == "variable") register(value);\n    return cont();\n  }\n  function maybeFrom(_type, value) {\n    if (value == "from") { cx.marked = "keyword"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == "]") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == "for") return pass(comprehension, expect("]"));\n    if (type == ",") return cont(commasep(expressionNoComma, "]"));\n    return pass(commasep(expressionNoComma, "]"));\n  }\n  function comprehension(type) {\n    if (type == "for") return cont(forspec, comprehension);\n    if (type == "if") return cont(expression, comprehension);\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: "sof",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty("align"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == "comment") return style;\n      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;\n      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);\n      else if (type == "form" && firstChar == "{") return lexical.indented;\n      else if (type == "form") return lexical.indented + indentUnit;\n      else if (type == "stat")\n        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);\n      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: ":{}",\n    blockCommentStart: jsonMode ? null : "/*",\n    blockCommentEnd: jsonMode ? null : "*/",\n    lineComment: jsonMode ? null : "//",\n    fold: "brace",\n\n    helperType: jsonMode ? "json" : "javascript",\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.defineMIME("text/javascript", "javascript");\nCodeMirror.defineMIME("text/ecmascript", "javascript");\nCodeMirror.defineMIME("application/javascript", "javascript");\nCodeMirror.defineMIME("application/ecmascript", "javascript");\nCodeMirror.defineMIME("application/json", {name: "javascript", json: true});\nCodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});\nCodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });\nCodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });\n\n\n\n\n\n\n        \n        \n        \nCodeMirror.defineMode("xml", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;\n  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag || true;\n\n  var Kludges = parserConfig.htmlMode ? {\n    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                      'track': true, 'wbr': true},\n    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                       'th': true, 'tr': true},\n    contextGrabbers: {\n      'dd': {'dd': true, 'dt': true},\n      'dt': {'dd': true, 'dt': true},\n      'li': {'li': true},\n      'option': {'option': true, 'optgroup': true},\n      'optgroup': {'optgroup': true},\n      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n      'rp': {'rp': true, 'rt': true},\n      'rt': {'rp': true, 'rt': true},\n      'tbody': {'tbody': true, 'tfoot': true},\n      'td': {'td': true, 'th': true},\n      'tfoot': {'tbody': true},\n      'th': {'td': true, 'th': true},\n      'thead': {'tbody': true, 'tfoot': true},\n      'tr': {'tr': true}\n    },\n    doNotIndent: {"pre": true},\n    allowUnquoted: true,\n    allowMissing: true\n  } : {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false\n  };\n  var alignCDATA = parserConfig.alignCDATA;\n\n  // Return variables for tokenizers\n  var tagName, type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == "<") {\n      if (stream.eat("!")) {\n        if (stream.eat("[")) {\n          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));\n          else return null;\n        } else if (stream.match("--")) {\n          return chain(inBlock("comment", "-->"));\n        } else if (stream.match("DOCTYPE", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat("?")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock("meta", "?>");\n        return "meta";\n      } else {\n        var isClose = stream.eat("/");\n        tagName = "";\n        var c;\n        while ((c = stream.eat(/[^\\s\\u00a0=<>\\"\\'\\/?]/))) tagName += c;\n        if (!tagName) return "tag error";\n        type = isClose ? "closeTag" : "openTag";\n        state.tokenize = inTag;\n        return "tag";\n      }\n    } else if (ch == "&") {\n      var ok;\n      if (stream.eat("#")) {\n        if (stream.eat("x")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(";");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(";");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(";");\n      }\n      return ok ? "atom" : "error";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == ">" || (ch == "/" && stream.eat(">"))) {\n      state.tokenize = inText;\n      type = ch == ">" ? "endTag" : "selfcloseTag";\n      return "tag";\n    } else if (ch == "=") {\n      type = "equals";\n      return null;\n    } else if (ch == "<") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + " error" : "error";\n    } else if (/[\\'\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.eatWhile(/[^\\s\\u00a0=<>\\"\\']/);\n      return "word";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return "string";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == "<") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == ">") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return "meta";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName.toLowerCase();\n      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == "openTag") {\n      state.tagName = tagName;\n      state.tagStart = stream.column();\n      return attrState;\n    } else if (type == "closeTag") {\n      var err = false;\n      if (state.context) {\n        if (state.context.tagName != tagName) {\n          if (Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName.toLowerCase()))\n            popContext(state);\n          err = !state.context || state.context.tagName != tagName;\n        }\n      } else {\n        err = true;\n      }\n      if (err) setStyle = "error";\n      return err ? closeStateErr : closeState;\n    } else {\n      return baseState;\n    }\n  }\n  function closeState(type, _stream, state) {\n    if (type != "endTag") {\n      setStyle = "error";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = "error";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == "word") {\n      setStyle = "attribute";\n      return attrEqState;\n    } else if (type == "endTag" || type == "selfcloseTag") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == "selfcloseTag" ||\n          Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) {\n        maybePopContext(state, tagName.toLowerCase());\n      } else {\n        maybePopContext(state, tagName.toLowerCase());\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = "error";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == "equals") return attrValueState;\n    if (!Kludges.allowMissing) setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return attrState;}\n    setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: inText,\n              state: baseState,\n              indented: 0,\n              tagName: null, tagStart: null,\n              context: null};\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      tagName = type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != "comment") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == "error" ? style + " error" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        return state.stringStartCol + 1;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (multilineTagIndentPastTag)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * multilineTagIndentFactor;\n      }\n      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      if (context && /^<\\//.test(textAfter))\n        context = context.prev;\n      while (context && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return 0;\n    },\n\n    electricChars: "/",\n    blockCommentStart: "<!--",\n    blockCommentEnd: "-->",\n\n    configuration: parserConfig.htmlMode ? "html" : "xml",\n    helperType: parserConfig.htmlMode ? "html" : "xml"\n  };\n});\n\nCodeMirror.defineMIME("text/xml", "xml");\nCodeMirror.defineMIME("application/xml", "xml");\nif (!CodeMirror.mimeModes.hasOwnProperty("text/html"))\n  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});        \n        \n        \n        \n        \n        \n        \n\n\n\n// HTMLMIXED\n\nCodeMirror.defineMode("htmlmixed", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});\n  var cssMode = CodeMirror.getMode(config, "css");\n\n  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;\n  scriptTypes.push({matches: /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i,\n                    mode: CodeMirror.getMode(config, "javascript")});\n  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {\n    var conf = scriptTypesConf[i];\n    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});\n  }\n  scriptTypes.push({matches: /./,\n                    mode: CodeMirror.getMode(config, "text/plain")});\n\n  function html(stream, state) {\n    var tagName = state.htmlState.tagName;\n    var style = htmlMode.token(stream, state.htmlState);\n    if (tagName == "script" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      // Script block: mode to change to depends on type attribute\n      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\\btype\\s*=\\s*("[^"]+"|'[^']+'|\\S+)[^<]*$/i);\n      scriptType = scriptType ? scriptType[1] : "";\n      if (scriptType && /[\\"\\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);\n      for (var i = 0; i < scriptTypes.length; ++i) {\n        var tp = scriptTypes[i];\n        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {\n          if (tp.mode) {\n            state.token = script;\n            state.localMode = tp.mode;\n            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));\n          }\n          break;\n        }\n      }\n    } else if (tagName == "style" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      state.token = css;\n      state.localMode = cssMode;\n      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur[0]);\n    }\n    return style;\n  }\n  function script(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       state.localMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localMode: null, localState: null, htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.localMode, state.localState);\n      return {token: state.token, localMode: state.localMode, localState: local,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.localMode || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.localMode.indent)\n        return state.localMode.indent(state.localState, textAfter);\n      else\n        return CodeMirror.Pass;\n    },\n\n    electricChars: "/{}:",\n\n    innerMode: function(state) {\n      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n    }\n  };\n}, "xml", "javascript", "css");\n\nCodeMirror.defineMIME("text/html", "htmlmixed");\n\n\n\n\n\n\n/* 3.21 version, which hash a bug\nCodeMirror.defineMode("htmlmixed", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});\n  var cssMode = CodeMirror.getMode(config, "css");\n\n  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;\n  scriptTypes.push({matches: /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i,\n                    mode: CodeMirror.getMode(config, "javascript")});\n  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {\n    var conf = scriptTypesConf[i];\n    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});\n  }\n  scriptTypes.push({matches: /./,\n                    mode: CodeMirror.getMode(config, "text/plain")});\n\n  function html(stream, state) {\n    var tagName = state.htmlState.tagName;\n    var style = htmlMode.token(stream, state.htmlState);\n    if (tagName == "script" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      // Script block: mode to change to depends on type attribute\n      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\\btype\\s*=\\s*("[^"]+"|'[^']+'|\\S+)[^<]*$/i);\n      scriptType = scriptType ? scriptType[1] : "";\n      if (scriptType && /[\\"\\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);\n      for (var i = 0; i < scriptTypes.length; ++i) {\n        var tp = scriptTypes[i];\n        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {\n          if (tp.mode) {\n            state.token = script;\n            state.localMode = tp.mode;\n            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));\n          }\n          break;\n        }\n      }\n    } else if (tagName == "style" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      state.token = css;\n      state.localMode = cssMode;\n      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n  function script(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       state.localMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localMode: null, localState: null, htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.localMode, state.localState);\n      return {token: state.token, localMode: state.localMode, localState: local,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.localMode || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.localMode.indent)\n        return state.localMode.indent(state.localState, textAfter);\n      else\n        return CodeMirror.Pass;\n    },\n\n    innerMode: function(state) {\n      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n    }\n  };\n}, "xml", "javascript", "css");\n\nCodeMirror.defineMIME("text/html", "htmlmixed");\n\n*/\n\n\n\n\n\nCodeMirror.defineMode("css", function(config, parserConfig) {\n  "use strict";\n\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      allowNested = parserConfig.allowNested;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == "@") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("def", stream.current());\n    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {\n      return ret(null, "compare");\n    } else if (ch == "\\"" || ch == "'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "#") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("atom", "hash");\n    } else if (ch == "!") {\n      stream.match(/^\\s*\\w*/);\n      return ret("keyword", "important");\n    } else if (/\\d/.test(ch) || ch == "." && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret("number", "unit");\n    } else if (ch === "-") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret("number", "unit");\n      } else if (stream.match(/^[^-]+-/)) {\n        return ret("meta", "meta");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, "select-op");\n    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret("qualifier", "qualifier");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (ch == "u" && stream.match("rl(")) {\n      stream.backUp(1);\n      state.tokenize = tokenParenthesized;\n      return ret("property", "word");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("property", "word");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == ")") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      if (ch == quote || !escaped && quote != ")") state.tokenize = null;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\"\\']/, false))\n      state.tokenize = tokenString(")");\n    else\n      state.tokenize = null;\n    return ret(null, "(");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type) {\n    state.context = new Context(type, stream.indentation() + indentUnit, state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = "atom";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = "keyword";\n    else\n      override = "variable";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == "{") {\n      return pushContext(state, stream, "block");\n    } else if (type == "}" && state.context.prev) {\n      return popContext(state);\n    } else if (type == "@media") {\n      return pushContext(state, stream, "media");\n    } else if (type == "@font-face") {\n      return "font_face_before";\n    } else if (type && type.charAt(0) == "@") {\n      return pushContext(state, stream, "at");\n    } else if (type == "hash") {\n      override = "builtin";\n    } else if (type == "word") {\n      override = "tag";\n    } else if (type == "variable-definition") {\n      return "maybeprop";\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    } else if (type == ":") {\n      return "pseudo";\n    } else if (allowNested && type == "(") {\n      return pushContext(state, stream, "params");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == "word") {\n      if (propertyKeywords.hasOwnProperty(stream.current().toLowerCase())) {\n        override = "property";\n        return "maybeprop";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:/, false) ? "property" : "tag";\n        return "block";\n      } else {\n        override += " error";\n        return "maybeprop";\n      }\n    } else if (type == "meta") {\n      return "block";\n    } else if (!allowNested && (type == "hash" || type == "qualifier")) {\n      override = "error";\n      return "block";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == ":") return pushContext(state, stream, "prop");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");\n    if (type == "}" || type == "{") return popAndPass(type, stream, state);\n    if (type == "(") return pushContext(state, stream, "parens");\n\n    if (type == "hash" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {\n      override += " error";\n    } else if (type == "word") {\n      wordAsValue(stream);\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    }\n    return "prop";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") { override = "property"; return "maybeprop"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == ")") return popContext(state);\n    return "parens";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == "word") {\n      override = "variable-3";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.media = function(type, stream, state) {\n    if (type == "(") return pushContext(state, stream, "media_parens");\n    if (type == "}") return popAndPass(type, stream, state);\n    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");\n\n    if (type == "word") {\n      var word = stream.current().toLowerCase();\n      if (word == "only" || word == "not" || word == "and")\n        override = "keyword";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = "attribute";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = "property";\n      else\n        override = "error";\n    }\n    return state.context.type;\n  };\n\n  states.media_parens = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);\n    return states.media(type, stream, state);\n  };\n\n  states.font_face_before = function(type, stream, state) {\n    if (type == "{")\n      return pushContext(state, stream, "font_face");\n    return pass(type, stream, state);\n  };\n\n  states.font_face = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") {\n      if (!fontProperties.hasOwnProperty(stream.current().toLowerCase()))\n        override = "error";\n      else\n        override = "property";\n      return "maybeprop";\n    }\n    return "font_face";\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") override = "tag";\n    else if (type == "hash") override = "builtin";\n    return "at";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "{" || type == ";") return popAndPass(type, stream, state);\n    if (type != "variable") override = "error";\n    return "interpolation";\n  };\n\n  states.params = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") wordAsValue(stream);\n    return "params";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: "top",\n              context: new Context("top", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == "object") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.prev &&\n          (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "font_face") ||\n           ch == ")" && (cx.type == "parens" || cx.type == "params" || cx.type == "media_parens") ||\n           ch == "{" && (cx.type == "at" || cx.type == "media"))) {\n        indent = cx.indent - indentUnit;\n        cx = cx.prev;\n      }\n      return indent;\n    },\n\n    electricChars: "}",\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    fold: "brace"\n  };\n});\n\n(function() {\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i]] = true;\n    }\n    return keys;\n  }\n\n  var mediaTypes_ = [\n    "all", "aural", "braille", "handheld", "print", "projection", "screen",\n    "tty", "tv", "embossed"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    "width", "min-width", "max-width", "height", "min-height", "max-height",\n    "device-width", "min-device-width", "max-device-width", "device-height",\n    "min-device-height", "max-device-height", "aspect-ratio",\n    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",\n    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",\n    "max-color", "color-index", "min-color-index", "max-color-index",\n    "monochrome", "min-monochrome", "max-monochrome", "resolution",\n    "min-resolution", "max-resolution", "scan", "grid"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var propertyKeywords_ = [\n    "align-content", "align-items", "align-self", "alignment-adjust",\n    "alignment-baseline", "anchor-point", "animation", "animation-delay",\n    "animation-direction", "animation-duration", "animation-iteration-count",\n    "animation-name", "animation-play-state", "animation-timing-function",\n    "appearance", "azimuth", "backface-visibility", "background",\n    "background-attachment", "background-clip", "background-color",\n    "background-image", "background-origin", "background-position",\n    "background-repeat", "background-size", "baseline-shift", "binding",\n    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",\n    "bookmark-target", "border", "border-bottom", "border-bottom-color",\n    "border-bottom-left-radius", "border-bottom-right-radius",\n    "border-bottom-style", "border-bottom-width", "border-collapse",\n    "border-color", "border-image", "border-image-outset",\n    "border-image-repeat", "border-image-slice", "border-image-source",\n    "border-image-width", "border-left", "border-left-color",\n    "border-left-style", "border-left-width", "border-radius", "border-right",\n    "border-right-color", "border-right-style", "border-right-width",\n    "border-spacing", "border-style", "border-top", "border-top-color",\n    "border-top-left-radius", "border-top-right-radius", "border-top-style",\n    "border-top-width", "border-width", "bottom", "box-decoration-break",\n    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",\n    "caption-side", "clear", "clip", "color", "color-profile", "column-count",\n    "column-fill", "column-gap", "column-rule", "column-rule-color",\n    "column-rule-style", "column-rule-width", "column-span", "column-width",\n    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",\n    "cue-after", "cue-before", "cursor", "direction", "display",\n    "dominant-baseline", "drop-initial-after-adjust",\n    "drop-initial-after-align", "drop-initial-before-adjust",\n    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",\n    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",\n    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",\n    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",\n    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",\n    "font-stretch", "font-style", "font-synthesis", "font-variant",\n    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",\n    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",\n    "font-weight", "grid-cell", "grid-column", "grid-column-align",\n    "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",\n    "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",\n    "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",\n    "icon", "image-orientation", "image-rendering", "image-resolution",\n    "inline-box-align", "justify-content", "left", "letter-spacing",\n    "line-break", "line-height", "line-stacking", "line-stacking-ruby",\n    "line-stacking-shift", "line-stacking-strategy", "list-style",\n    "list-style-image", "list-style-position", "list-style-type", "margin",\n    "margin-bottom", "margin-left", "margin-right", "margin-top",\n    "marker-offset", "marks", "marquee-direction", "marquee-loop",\n    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",\n    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",\n    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",\n    "outline-color", "outline-offset", "outline-style", "outline-width",\n    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",\n    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",\n    "page", "page-break-after", "page-break-before", "page-break-inside",\n    "page-policy", "pause", "pause-after", "pause-before", "perspective",\n    "perspective-origin", "pitch", "pitch-range", "play-during", "position",\n    "presentation-level", "punctuation-trim", "quotes", "region-break-after",\n    "region-break-before", "region-break-inside", "region-fragment",\n    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",\n    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",\n    "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size",\n    "speak", "speak-as", "speak-header",\n    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",\n    "tab-size", "table-layout", "target", "target-name", "target-new",\n    "target-position", "text-align", "text-align-last", "text-decoration",\n    "text-decoration-color", "text-decoration-line", "text-decoration-skip",\n    "text-decoration-style", "text-emphasis", "text-emphasis-color",\n    "text-emphasis-position", "text-emphasis-style", "text-height",\n    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",\n    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",\n    "text-wrap", "top", "transform", "transform-origin", "transform-style",\n    "transition", "transition-delay", "transition-duration",\n    "transition-property", "transition-timing-function", "unicode-bidi",\n    "vertical-align", "visibility", "voice-balance", "voice-duration",\n    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",\n    "voice-volume", "volume", "white-space", "widows", "width", "word-break",\n    "word-spacing", "word-wrap", "z-index", "zoom",\n    // SVG-specific\n    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",\n    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",\n    "color-interpolation", "color-interpolation-filters", "color-profile",\n    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",\n    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",\n    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",\n    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",\n    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",\n    "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var colorKeywords_ = [\n    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",\n    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",\n    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",\n    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",\n    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",\n    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",\n    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",\n    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",\n    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",\n    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",\n    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",\n    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",\n    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",\n    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",\n    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",\n    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",\n    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",\n    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",\n    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",\n    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",\n    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",\n    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",\n    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",\n    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",\n    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",\n    "whitesmoke", "yellow", "yellowgreen"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    "above", "absolute", "activeborder", "activecaption", "afar",\n    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",\n    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",\n    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page",\n    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",\n    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",\n    "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel",\n    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",\n    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",\n    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",\n    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",\n    "col-resize", "collapse", "column", "compact", "condensed", "contain", "content",\n    "content-box", "context-menu", "continuous", "copy", "cover", "crop",\n    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",\n    "decimal-leading-zero", "default", "default-button", "destination-atop",\n    "destination-in", "destination-out", "destination-over", "devanagari",\n    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",\n    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",\n    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",\n    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",\n    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",\n    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",\n    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",\n    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",\n    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",\n    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",\n    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",\n    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",\n    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",\n    "help", "hidden", "hide", "higher", "highlight", "highlighttext",\n    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",\n    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",\n    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",\n    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",\n    "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer",\n    "landscape", "lao", "large", "larger", "left", "level", "lighter",\n    "line-through", "linear", "lines", "list-item", "listbox", "listitem",\n    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",\n    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",\n    "lower-roman", "lowercase", "ltr", "malayalam", "match",\n    "media-controls-background", "media-current-time-display",\n    "media-fullscreen-button", "media-mute-button", "media-play-button",\n    "media-return-to-realtime-button", "media-rewind-button",\n    "media-seek-back-button", "media-seek-forward-button", "media-slider",\n    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",\n    "media-volume-slider-container", "media-volume-sliderthumb", "medium",\n    "menu", "menulist", "menulist-button", "menulist-text",\n    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",\n    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",\n    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",\n    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",\n    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",\n    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",\n    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",\n    "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer",\n    "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",\n    "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region",\n    "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",\n    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",\n    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",\n    "searchfield-cancel-button", "searchfield-decoration",\n    "searchfield-results-button", "searchfield-results-decoration",\n    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",\n    "single", "skip-white-space", "slide", "slider-horizontal",\n    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",\n    "small", "small-caps", "small-caption", "smaller", "solid", "somali",\n    "source-atop", "source-in", "source-out", "source-over", "space", "square",\n    "square-button", "start", "static", "status-bar", "stretch", "stroke",\n    "sub", "subpixel-antialiased", "super", "sw-resize", "table",\n    "table-caption", "table-cell", "table-column", "table-column-group",\n    "table-footer-group", "table-header-group", "table-row", "table-row-group",\n    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",\n    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",\n    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",\n    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",\n    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",\n    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",\n    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",\n    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",\n    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",\n    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",\n    "xx-large", "xx-small"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var fontProperties_ = [\n    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",\n    "font-stretch", "font-weight", "font-style"\n  ], fontProperties = keySet(fontProperties_);\n\n  var allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);\n  CodeMirror.registerHelper("hintWords", "css", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == "/") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ["comment", "comment"];\n  }\n\n  function tokenSGMLComment(stream, state) {\n    if (stream.skipTo("-->")) {\n      stream.match("-->");\n      state.tokenize = null;\n    } else {\n      stream.skipToEnd();\n    }\n    return ["comment", "comment"];\n  }\n\n  CodeMirror.defineMIME("text/css", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    tokenHooks: {\n      "<": function(stream, state) {\n        if (!stream.match("!--")) return false;\n        state.tokenize = tokenSGMLComment;\n        return tokenSGMLComment(stream, state);\n      },\n      "/": function(stream, state) {\n        if (!stream.eat("*")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: "css"\n  });\n\n  CodeMirror.defineMIME("text/x-scss", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      ":": function(stream) {\n        if (stream.match(/\\s*{/))\n          return [null, "{"];\n        return false;\n      },\n      "$": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "#": function(stream) {\n        if (!stream.eat("{")) return false;\n        return [null, "interpolation"];\n      }\n    },\n    name: "css",\n    helperType: "scss"\n  });\n\n  CodeMirror.defineMIME("text/x-less", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      "@": function(stream) {\n        if (stream.match(/^(charset|document|font-face|import|keyframes|media|namespace|page|supports)\\b/, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "&": function() {\n        return ["atom", "atom"];\n      }\n    },\n    name: "css",\n    helperType: "less"\n  });\n})();\n\n\n\n\n\n\n\nCodeMirror.defineMode("sass", function(config) {\n  var tokenRegexp = function(words){\n    return new RegExp("^" + words.join("|"));\n  };\n\n  var keywords = ["true", "false", "null", "auto"];\n  var keywordsRegexp = new RegExp("^" + keywords.join("|"));\n\n  var operators = ["\\\\(", "\\\\)", "=", ">", "<", "==", ">=", "<=", "\\\\+", "-", "\\\\!=", "/", "\\\\*", "%", "and", "or", "not"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[\\w\\-]+/;\n\n  var urlTokens = function(stream, state){\n    var ch = stream.peek();\n\n    if (ch === ")"){\n      stream.next();\n      state.tokenizer = tokenBase;\n      return "operator";\n    }else if (ch === "("){\n      stream.next();\n      stream.eatSpace();\n\n      return "operator";\n    }else if (ch === "'" || ch === '"'){\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return "string";\n    }else{\n      state.tokenizer = buildStringTokenizer(")", false);\n      return "string";\n    }\n  };\n  var multilineComment = function(stream, state) {\n    if (stream.skipTo("*/")){\n      stream.next();\n      stream.next();\n      state.tokenizer = tokenBase;\n    }else {\n      stream.next();\n    }\n\n    return "comment";\n  };\n\n  var buildStringTokenizer = function(quote, greedy){\n    if(greedy == null){ greedy = true; }\n\n    function stringTokenizer(stream, state){\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== "\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== "\\\\"));\n\n      /*\n      console.log("previousChar: " + previousChar);\n      console.log("nextChar: " + nextChar);\n      console.log("peekChar: " + peekChar);\n      console.log("ending: " + endingString);\n      */\n\n      if (endingString){\n        if (nextChar !== quote && greedy) { stream.next(); }\n        state.tokenizer = tokenBase;\n        return "string";\n      }else if (nextChar === "#" && peekChar === "{"){\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return "operator";\n      }else {\n        return "string";\n      }\n    }\n\n    return stringTokenizer;\n  };\n\n  var buildInterpolationTokenizer = function(currentTokenizer){\n    return function(stream, state){\n      if (stream.peek() === "}"){\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return "operator";\n      }else{\n        return tokenBase(stream, state);\n      }\n    };\n  };\n\n  var indent = function(state){\n    if (state.indentCount == 0){\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  };\n\n  var dedent = function(state){\n    if (state.scopes.length == 1) { return; }\n\n    state.scopes.shift();\n  };\n\n  var tokenBase = function(stream, state) {\n    var ch = stream.peek();\n\n    // Single line Comment\n    if (stream.match('//')) {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Multiline Comment\n    if (stream.match('/*')){\n      state.tokenizer = multilineComment;\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match('#{')){\n    state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return "operator";\n    }\n\n    if (ch === "."){\n      stream.next();\n\n      // Match class selectors\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "atom";\n      }else if (stream.peek() === "#"){\n        indent(state);\n        return "atom";\n      }else{\n        return "operator";\n      }\n    }\n\n    if (ch === "#"){\n      stream.next();\n\n      // Hex numbers\n      if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n        return "number";\n      }\n\n      // ID selectors\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "atom";\n      }\n\n      if (stream.peek() === "#"){\n        indent(state);\n        return "atom";\n      }\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/)){\n      return "number";\n    }\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/)){\n      return "unit";\n    }\n\n    if (stream.match(keywordsRegexp)){\n      return "keyword";\n    }\n\n    if (stream.match(/^url/) && stream.peek() === "("){\n      state.tokenizer = urlTokens;\n      return "atom";\n    }\n\n    // Variables\n    if (ch === "$"){\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n\n      if (stream.peek() === ":"){\n        stream.next();\n        return "variable-2";\n      }else{\n        return "variable-3";\n      }\n    }\n\n    if (ch === "!"){\n      stream.next();\n\n      if (stream.match(/^[\\w]+/)){\n        return "keyword";\n      }\n\n      return "operator";\n    }\n\n    if (ch === "="){\n      stream.next();\n\n      // Match shortcut mixin definition\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "meta";\n      }else {\n        return "operator";\n      }\n    }\n\n    if (ch === "+"){\n      stream.next();\n\n      // Match shortcut mixin definition\n      if (stream.match(/^[\\w-]+/)){\n        return "variable-3";\n      }else {\n        return "operator";\n      }\n    }\n\n    // Indent Directives\n    if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)){\n      indent(state);\n      return "meta";\n    }\n\n    // Other Directives\n    if (ch === "@"){\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      return "meta";\n    }\n\n    // Strings\n    if (ch === '"' || ch === "'"){\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return "string";\n    }\n\n    // Pseudo element selectors\n    if (ch == ':' && stream.match(pseudoElementsRegexp)){\n      return "keyword";\n    }\n\n    // atoms\n    if (stream.eatWhile(/[\\w-&]/)){\n      // matches a property definition\n      if (stream.peek() === ":" && !stream.match(pseudoElementsRegexp, false))\n        return "property";\n      else\n        return "atom";\n    }\n\n    if (stream.match(opRegexp)){\n      return "operator";\n    }\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  };\n\n  var tokenLexer = function(stream, state) {\n    if (stream.sol()){\n      state.indentCount = 0;\n    }\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === "@return"){\n      dedent(state);\n    }\n\n    if (style === "atom"){\n      indent(state);\n    }\n\n    if (style !== null){\n      var startOfToken = stream.pos - current.length;\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++){\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent){\n          newScopes.push(scope);\n        }\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  };\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: 'sass'}],\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    }\n  };\n});\n\nCodeMirror.defineMIME("text/x-sass", "sass");\n\n\n\n\n\n\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\nCodeMirror.defineMode("coffeescript", function(conf) {\n  var ERRORCLASS = "error";\n\n  function wordRegexp(words) {\n    return new RegExp("^((" + words.join(")|(") + "))\\\\b");\n  }\n\n  var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?)/;\n  var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n  var properties = /^(@|this\\.)[_A-Za-z$][_A-Za-z$0-9]*/;\n\n  var wordOperators = wordRegexp(["and", "or", "not",\n                                  "is", "isnt", "in",\n                                  "instanceof", "typeof"]);\n  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",\n                        "switch", "try", "catch", "finally", "class"];\n  var commonKeywords = ["break", "by", "continue", "debugger", "delete",\n                        "do", "in", "of", "new", "return", "then",\n                        "this", "throw", "when", "until"];\n\n  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n  indentKeywords = wordRegexp(indentKeywords);\n\n\n  var stringPrefixes = /^('{3}|\\"{3}|['\\"])/;\n  var regexPrefixes = /^(\\/{3}|\\/)/;\n  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];\n  var constants = wordRegexp(commonConstants);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    // Handle scope changes\n    if (stream.sol()) {\n      if (state.scope.align === null) state.scope.align = false;\n      var scopeOffset = state.scope.offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset && state.scope.type == "coffee") {\n          return "indent";\n        } else if (lineOffset < scopeOffset) {\n          return "dedent";\n        }\n        return null;\n      } else {\n        if (scopeOffset > 0) {\n          dedent(stream, state);\n        }\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle docco title comment (single line)\n    if (stream.match("####")) {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Handle multi line comments\n    if (stream.match("###")) {\n      state.tokenize = longComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Single line comment\n    if (ch === "#") {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Handle number literals\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\d+\\.\\d*/)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\.\\d+/)) {\n        floatLiteral = true;\n      }\n\n      if (floatLiteral) {\n        // prevent from getting extra . on 1..\n        if (stream.peek() == "."){\n          stream.backUp(1);\n        }\n        return "number";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^-?0x[0-9a-f]+/i)) {\n        intLiteral = true;\n      }\n      // Decimal\n      if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^-?0(?![\\dx])/i)) {\n        intLiteral = true;\n      }\n      if (intLiteral) {\n        return "number";\n      }\n    }\n\n    // Handle strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenFactory(stream.current(), false, "string");\n      return state.tokenize(stream, state);\n    }\n    // Handle regex literals\n    if (stream.match(regexPrefixes)) {\n      if (stream.current() != "/" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n        state.tokenize = tokenFactory(stream.current(), true, "string-2");\n        return state.tokenize(stream, state);\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n    // Handle operators and delimiters\n    if (stream.match(operators) || stream.match(wordOperators)) {\n      return "operator";\n    }\n    if (stream.match(delimiters)) {\n      return "punctuation";\n    }\n\n    if (stream.match(constants)) {\n      return "atom";\n    }\n\n    if (stream.match(keywords)) {\n      return "keyword";\n    }\n\n    if (stream.match(identifiers)) {\n      return "variable";\n    }\n\n    if (stream.match(properties)) {\n      return "property";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function tokenFactory(delimiter, singleline, outclass) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'"\\/\\\\]/);\n        if (stream.eat("\\\\")) {\n          stream.next();\n          if (singleline && stream.eol()) {\n            return outclass;\n          }\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          return outclass;\n        } else {\n          stream.eat(/['"\\/]/);\n        }\n      }\n      if (singleline) {\n        if (conf.mode.singleLineStringErrors) {\n          outclass = ERRORCLASS;\n        } else {\n          state.tokenize = tokenBase;\n        }\n      }\n      return outclass;\n    };\n  }\n\n  function longComment(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^#]/);\n      if (stream.match("###")) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.eatWhile("#");\n    }\n    return "comment";\n  }\n\n  function indent(stream, state, type) {\n    type = type || "coffee";\n    var offset = 0, align = false, alignOffset = null;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (scope.type === "coffee") {\n        offset = scope.offset + conf.indentUnit;\n        break;\n      }\n    }\n    if (type !== "coffee") {\n      align = null;\n      alignOffset = stream.column() + stream.current().length;\n    } else if (state.scope.align) {\n      state.scope.align = false;\n    }\n    state.scope = {\n      offset: offset,\n      type: type,\n      prev: state.scope,\n      align: align,\n      alignOffset: alignOffset\n    };\n  }\n\n  function dedent(stream, state) {\n    if (!state.scope.prev) return;\n    if (state.scope.type === "coffee") {\n      var _indent = stream.indentation();\n      var matched = false;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (_indent === scope.offset) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return true;\n      }\n      while (state.scope.prev && state.scope.offset !== _indent) {\n        state.scope = state.scope.prev;\n      }\n      return false;\n    } else {\n      state.scope = state.scope.prev;\n      return false;\n    }\n  }\n\n  function tokenLexer(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle "." connected identifiers\n    if (current === ".") {\n      style = state.tokenize(stream, state);\n      current = stream.current();\n      if (/^\\.[\\w$]+$/.test(current)) {\n        return "variable";\n      } else {\n        return ERRORCLASS;\n      }\n    }\n\n    // Handle scope changes.\n    if (current === "return") {\n      state.dedent += 1;\n    }\n    if (((current === "->" || current === "=>") &&\n         !state.lambda &&\n         !stream.peek())\n        || style === "indent") {\n      indent(stream, state);\n    }\n    var delimiter_index = "[({".indexOf(current);\n    if (delimiter_index !== -1) {\n      indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));\n    }\n    if (indentKeywords.exec(current)){\n      indent(stream, state);\n    }\n    if (current == "then"){\n      dedent(stream, state);\n    }\n\n\n    if (style === "dedent") {\n      if (dedent(stream, state)) {\n        return ERRORCLASS;\n      }\n    }\n    delimiter_index = "])}".indexOf(current);\n    if (delimiter_index !== -1) {\n      while (state.scope.type == "coffee" && state.scope.prev)\n        state.scope = state.scope.prev;\n      if (state.scope.type == current)\n        state.scope = state.scope.prev;\n    }\n    if (state.dedent > 0 && stream.eol() && state.scope.type == "coffee") {\n      if (state.scope.prev) state.scope = state.scope.prev;\n      state.dedent -= 1;\n    }\n\n    return style;\n  }\n\n  var external = {\n    startState: function(basecolumn) {\n      return {\n        tokenize: tokenBase,\n        scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},\n        lastToken: null,\n        lambda: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var fillAlign = state.scope.align === null && state.scope;\n      if (fillAlign && stream.sol()) fillAlign.align = false;\n\n      var style = tokenLexer(stream, state);\n      if (fillAlign && style && style != "comment") fillAlign.align = true;\n\n      state.lastToken = {style:style, content: stream.current()};\n\n      if (stream.eol() && stream.lambda) {\n        state.lambda = false;\n      }\n\n      return style;\n    },\n\n    indent: function(state, text) {\n      if (state.tokenize != tokenBase) return 0;\n      var scope = state.scope;\n      var closer = text && "])}".indexOf(text.charAt(0)) > -1;\n      if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;\n      var closes = closer && scope.type === text.charAt(0);\n      if (scope.align)\n        return scope.alignOffset - (closes ? 1 : 0);\n      else\n        return (closes ? scope.prev : scope).offset;\n    },\n\n    lineComment: "#",\n    fold: "indent"\n  };\n  return external;\n});\n\nCodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
\\x82788b36dada0f70a2814be2924ab5c0d009a39fd021590b2c3910bb71bd329f	// CodeMirror is the only global var we claim\nwindow.CodeMirror = (function() {\n  "use strict";\n\n  // BROWSER SNIFFING\n\n  // Crude, but necessary to handle a number of hard-to-feature-detect\n  // bugs and behavior differences.\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\n  // IE11 currently doesn't count as 'ie', since it has almost none of\n  // the same bugs as earlier versions. Use ie_gt10 to handle\n  // incompatibilities in that version.\n  var old_ie = /MSIE \\d/.test(navigator.userAgent);\n  var ie_lt8 = old_ie && (document.documentMode == null || document.documentMode < 8);\n  var ie_lt9 = old_ie && (document.documentMode == null || document.documentMode < 9);\n  var ie_gt10 = /Trident\\/([7-9]|\\d{2,})\\./.test(navigator.userAgent);\n  var ie = old_ie || ie_gt10;\n  var webkit = /WebKit\\//.test(navigator.userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\n  var chrome = /Chrome\\//.test(navigator.userAgent);\n  var opera = /Opera\\//.test(navigator.userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var khtml = /KHTML\\//.test(navigator.userAgent);\n  var mac_geLion = /Mac OS X 1\\d\\D([7-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\n  var phantom = /PhantomJS/.test(navigator.userAgent);\n\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\n  var mac = ios || /Mac/.test(navigator.platform);\n  var windows = /win/i.test(navigator.platform);\n\n  var opera_version = opera && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (opera_version) opera_version = Number(opera_version[1]);\n  if (opera_version && opera_version >= 15) { opera = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || opera && (opera_version == null || opera_version < 12.11));\n  var captureMiddleClick = gecko || (old_ie && !ie_lt9);\n\n  // Optimize some code when these features are not used\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  // CONSTRUCTOR\n\n  function CodeMirror(place, options) {\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\n\n    this.options = options = options || {};\n    // Determine effective options based on given values and defaults.\n    for (var opt in defaults) if (!options.hasOwnProperty(opt) && defaults.hasOwnProperty(opt))\n      options[opt] = defaults[opt];\n    setGuttersForLineNumbers(options);\n\n    var docStart = typeof options.value == "string" ? 0 : options.value.first;\n    var display = this.display = makeDisplay(place, docStart);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    if (options.autofocus && !mobile) focusInput(this);\n\n    this.state = {keyMaps: [],\n                  overlays: [],\n                  modeGen: 0,\n                  overwrite: false, focused: false,\n                  suppressEdits: false,\n                  pasteIncoming: false, cutIncoming: false,\n                  draggingText: false,\n                  highlight: new Delayed()};\n\n    themeChanged(this);\n    if (options.lineWrapping)\n      this.display.wrapper.className += " CodeMirror-wrap";\n\n    var doc = options.value;\n    if (typeof doc == "string") doc = new Doc(options.value, options.mode);\n    operation(this, attachDoc)(this, doc);\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (old_ie) setTimeout(bind(resetInput, this, true), 20);\n\n    registerEventHandlers(this);\n    // IE throws unspecified error in certain cases, when\n    // trying to access activeElement before onload\n    var hasFocus; try { hasFocus = (document.activeElement == display.input); } catch(e) { }\n    if (hasFocus || (options.autofocus && !mobile)) setTimeout(bind(onFocus, this), 20);\n    else onBlur(this);\n\n    operation(this, function() {\n      for (var opt in optionHandlers)\n        if (optionHandlers.propertyIsEnumerable(opt))\n          optionHandlers[opt](this, options[opt], Init);\n      for (var i = 0; i < initHooks.length; ++i) initHooks[i](this);\n    })();\n  }\n\n  // DISPLAY CONSTRUCTOR\n\n  function makeDisplay(place, docStart) {\n    var d = {};\n\n    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none; font-size: 4px;");\n    if (webkit) input.style.width = "1000px";\n    else input.setAttribute("wrap", "off");\n    // if border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) input.style.border = "1px solid black";\n    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");\n\n    // Wraps and hides input textarea\n    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");\n    // The actual fake scrollbars.\n    d.scrollbarH = elt("div", [elt("div", null, null, "height: 1px")], "CodeMirror-hscrollbar");\n    d.scrollbarV = elt("div", [elt("div", null, null, "width: 1px")], "CodeMirror-vscrollbar");\n    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");\n    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");\n    // DIVs containing the selection and the actual code\n    d.lineDiv = elt("div", null, "CodeMirror-code");\n    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");\n    // Blinky cursor, and element used to ensure cursor fits at the end of a line\n    d.cursor = elt("div", "\\u00a0", "CodeMirror-cursor");\n    // Secondary cursor, shown when on a 'jump' in bi-directional text\n    d.otherCursor = elt("div", "\\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor");\n    // Used to measure text size\n    d.measure = elt("div", null, "CodeMirror-measure");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = elt("div", [d.measure, d.selectionDiv, d.lineDiv, d.cursor, d.otherCursor],\n                         null, "position: relative; outline: none");\n    // Moved around its parent to cover visible view\n    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");\n    // Set to the height of the text, causes scrolling\n    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");\n    // D is needed because behavior of elts with overflow: auto and padding is inconsistent across browsers\n    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");\n    // Will contain the gutters, if any\n    d.gutters = elt("div", null, "CodeMirror-gutters");\n    d.lineGutter = null;\n    // Provides scrolling\n    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");\n    d.scroller.setAttribute("tabIndex", "-1");\n    // The element in which the editor lives.\n    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,\n                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");\n    // Work around IE7 z-index bug\n    if (ie_lt8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (place.appendChild) place.appendChild(d.wrapper); else place(d.wrapper);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari\n    if (ios) input.style.width = "0px";\n    if (!webkit) d.scroller.draggable = true;\n    // Needed to handle Tab key in KHTML\n    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    else if (ie_lt8) d.scrollbarH.style.minWidth = d.scrollbarV.style.minWidth = "18px";\n\n    // Current visible range (may be bigger than the view window).\n    d.viewOffset = d.lastSizeC = 0;\n    d.showingFrom = d.showingTo = docStart;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // See readInput and resetInput\n    d.prevInput = "";\n    // Set to true when a non-horizontal-scrolling widget is added. As\n    // an optimization, widget aligning is skipped when d is false.\n    d.alignWidgets = false;\n    // Flag that indicates whether we currently expect input to appear\n    // (after some event like 'keypress' or 'input') and are polling\n    // intensively.\n    d.pollingFast = false;\n    // Self-resetting timeout for the poller\n    d.poll = new Delayed();\n\n    d.cachedCharWidth = d.cachedTextHeight = null;\n    d.measureLineCache = [];\n    d.measureLineCachePos = 0;\n\n    // Tracks when resetInput has punted to just putting a short\n    // string instead of the (large) selection.\n    d.inaccurateSelection = false;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    return d;\n  }\n\n  // STATE UPDATES\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function(line) {\n      if (line.stateAfter) line.stateAfter = null;\n      if (line.styles) line.styles = null;\n    });\n    cm.doc.frontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) regChange(cm);\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      cm.display.wrapper.className += " CodeMirror-wrap";\n      cm.display.sizer.style.minWidth = "";\n    } else {\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-wrap", "");\n      computeMaxLength(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function(){updateScrollbars(cm);}, 100);\n  }\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function(line) {\n      if (lineIsHidden(cm.doc, line))\n        return 0;\n      else if (wrapping)\n        return (Math.ceil(line.text.length / perLine) || 1) * th;\n      else\n        return th;\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function(line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\n    });\n  }\n\n  function keyMapChanged(cm) {\n    var map = keyMap[cm.options.keyMap], style = map.style;\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, "") +\n      (style ? " cm-keymap-" + style : "");\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");\n    clearCaches(cm);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    setTimeout(function(){alignHorizontally(cm);}, 20);\n  }\n\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    for (var i = 0; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));\n      if (gutterClass == "CodeMirror-linenumbers") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";\n      }\n    }\n    gutters.style.display = i ? "" : "none";\n  }\n\n  function lineLength(doc, line) {\n    if (line.height == 0) return 0;\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find();\n      cur = getLine(doc, found.from.line);\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found = merged.find();\n      len -= cur.text.length - found.from.ch;\n      cur = getLine(doc, found.to.line);\n      len += cur.text.length - found.to.ch;\n    }\n    return len;\n  }\n\n  function computeMaxLength(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(doc, d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function(line) {\n      var len = lineLength(doc, line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // Make sure the gutters options contains the element\n  // "CodeMirror-linenumbers" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, "CodeMirror-linenumbers");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // SCROLLBARS\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content. Optionally force a scrollTop.\n  function updateScrollbars(cm) {\n    var d = cm.display, docHeight = cm.doc.height;\n    var totalHeight = docHeight + paddingVert(d);\n    d.sizer.style.minHeight = d.heightForcer.style.top = totalHeight + "px";\n    d.gutters.style.height = Math.max(totalHeight, d.scroller.clientHeight - scrollerCutOff) + "px";\n    var scrollHeight = Math.max(totalHeight, d.scroller.scrollHeight);\n    var needsH = d.scroller.scrollWidth > (d.scroller.clientWidth + 1);\n    var needsV = scrollHeight > (d.scroller.clientHeight + 1);\n    if (needsV) {\n      d.scrollbarV.style.display = "block";\n      d.scrollbarV.style.bottom = needsH ? scrollbarWidth(d.measure) + "px" : "0";\n      d.scrollbarV.firstChild.style.height =\n        (scrollHeight - d.scroller.clientHeight + d.scrollbarV.clientHeight) + "px";\n    } else {\n      d.scrollbarV.style.display = "";\n      d.scrollbarV.firstChild.style.height = "0";\n    }\n    if (needsH) {\n      d.scrollbarH.style.display = "block";\n      d.scrollbarH.style.right = needsV ? scrollbarWidth(d.measure) + "px" : "0";\n      d.scrollbarH.firstChild.style.width =\n        (d.scroller.scrollWidth - d.scroller.clientWidth + d.scrollbarH.clientWidth) + "px";\n    } else {\n      d.scrollbarH.style.display = "";\n      d.scrollbarH.firstChild.style.width = "0";\n    }\n    if (needsH && needsV) {\n      d.scrollbarFiller.style.display = "block";\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = scrollbarWidth(d.measure) + "px";\n    } else d.scrollbarFiller.style.display = "";\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = "block";\n      d.gutterFiller.style.height = scrollbarWidth(d.measure) + "px";\n      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";\n    } else d.gutterFiller.style.display = "";\n\n    if (mac_geLion && scrollbarWidth(d.measure) === 0) {\n      d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = mac_geMountainLion ? "18px" : "12px";\n      d.scrollbarV.style.pointerEvents = d.scrollbarH.style.pointerEvents = "none";\n    }\n  }\n\n  function visibleLines(display, doc, viewPort) {\n    var top = display.scroller.scrollTop, height = display.wrapper.clientHeight;\n    if (typeof viewPort == "number") top = viewPort;\n    else if (viewPort) {top = viewPort.top; height = viewPort.bottom - viewPort.top;}\n    top = Math.floor(top - paddingTop(display));\n    var bottom = Math.ceil(top + height);\n    return {from: lineAtHeight(doc, top), to: lineAtHeight(doc, bottom)};\n  }\n\n  // LINE NUMBERS\n\n  function alignHorizontally(cm) {\n    var display = cm.display;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, l = comp + "px";\n    for (var n = display.lineDiv.firstChild; n; n = n.nextSibling) if (n.alignable) {\n      for (var i = 0, a = n.alignable; i < a.length; ++i) a[i].style.left = l;\n    }\n    if (cm.options.fixedGutter)\n      display.gutters.style.left = (comp + gutterW) + "px";\n  }\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) return false;\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt("div", [elt("div", last)],\n                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = "";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + "px";\n      return true;\n    }\n    return false;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  }\n  function compensateForHScroll(display) {\n    return getRect(display.scroller).left - getRect(display.sizer).left;\n  }\n\n  // DISPLAY DRAWING\n\n  function updateDisplay(cm, changes, viewPort, forced) {\n    var oldFrom = cm.display.showingFrom, oldTo = cm.display.showingTo, updated;\n    var visible = visibleLines(cm.display, cm.doc, viewPort);\n    for (var first = true;; first = false) {\n      var oldWidth = cm.display.scroller.clientWidth;\n      if (!updateDisplayInner(cm, changes, visible, forced)) break;\n      updated = true;\n      changes = [];\n      updateSelection(cm);\n      updateScrollbars(cm);\n      if (first && cm.options.lineWrapping && oldWidth != cm.display.scroller.clientWidth) {\n        forced = true;\n        continue;\n      }\n      forced = false;\n\n      // Clip forced viewport to actual scrollable area\n      if (viewPort)\n        viewPort = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight,\n                            typeof viewPort == "number" ? viewPort : viewPort.top);\n      visible = visibleLines(cm.display, cm.doc, viewPort);\n      if (visible.from >= cm.display.showingFrom && visible.to <= cm.display.showingTo)\n        break;\n    }\n\n    if (updated) {\n      signalLater(cm, "update", cm);\n      if (cm.display.showingFrom != oldFrom || cm.display.showingTo != oldTo)\n        signalLater(cm, "viewportChange", cm, cm.display.showingFrom, cm.display.showingTo);\n    }\n    return updated;\n  }\n\n  // Uses a set of changes plus the current scroll position to\n  // determine which DOM updates have to be made, and makes the\n  // updates.\n  function updateDisplayInner(cm, changes, visible, forced) {\n    var display = cm.display, doc = cm.doc;\n    if (!display.wrapper.offsetWidth) {\n      display.showingFrom = display.showingTo = doc.first;\n      display.viewOffset = 0;\n      return;\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!forced && changes.length == 0 &&\n        visible.from > display.showingFrom && visible.to < display.showingTo)\n      return;\n\n    if (maybeUpdateLineNumberWidth(cm))\n      changes = [{from: doc.first, to: doc.first + doc.size}];\n    var gutterW = display.sizer.style.marginLeft = display.gutters.offsetWidth + "px";\n    display.scrollbarH.style.left = cm.options.fixedGutter ? gutterW : "0";\n\n    // Used to determine which lines need their line numbers updated\n    var positionsChangedFrom = Infinity;\n    if (cm.options.lineNumbers)\n      for (var i = 0; i < changes.length; ++i)\n        if (changes[i].diff && changes[i].from < positionsChangedFrom) { positionsChangedFrom = changes[i].from; }\n\n    var end = doc.first + doc.size;\n    var from = Math.max(visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, visible.to + cm.options.viewportMargin);\n    if (display.showingFrom < from && from - display.showingFrom < 20) from = Math.max(doc.first, display.showingFrom);\n    if (display.showingTo > to && display.showingTo - to < 20) to = Math.min(end, display.showingTo);\n    if (sawCollapsedSpans) {\n      from = lineNo(visualLine(doc, getLine(doc, from)));\n      while (to < end && lineIsHidden(doc, getLine(doc, to))) ++to;\n    }\n\n    // Create a range of theoretically intact lines, and punch holes\n    // in that using the change info.\n    var intact = [{from: Math.max(display.showingFrom, doc.first),\n                   to: Math.min(display.showingTo, end)}];\n    if (intact[0].from >= intact[0].to) intact = [];\n    else intact = computeIntact(intact, changes);\n    // When merged lines are present, we might have to reduce the\n    // intact ranges because changes in continued fragments of the\n    // intact lines do require the lines to be redrawn.\n    if (sawCollapsedSpans)\n      for (var i = 0; i < intact.length; ++i) {\n        var range = intact[i], merged;\n        while (merged = collapsedSpanAtEnd(getLine(doc, range.to - 1))) {\n          var newTo = merged.find().from.line;\n          if (newTo > range.from) range.to = newTo;\n          else { intact.splice(i--, 1); break; }\n        }\n      }\n\n    // Clip off the parts that won't be visible\n    var intactLines = 0;\n    for (var i = 0; i < intact.length; ++i) {\n      var range = intact[i];\n      if (range.from < from) range.from = from;\n      if (range.to > to) range.to = to;\n      if (range.from >= range.to) intact.splice(i--, 1);\n      else intactLines += range.to - range.from;\n    }\n    if (!forced && intactLines == to - from && from == display.showingFrom && to == display.showingTo) {\n      updateViewOffset(cm);\n      return;\n    }\n    intact.sort(function(a, b) {return a.from - b.from;});\n\n    // Avoid crashing on IE's "unspecified error" when in iframes\n    try {\n      var focused = document.activeElement;\n    } catch(e) {}\n    if (intactLines < (to - from) * .7) display.lineDiv.style.display = "none";\n    patchDisplay(cm, from, to, intact, positionsChangedFrom);\n    display.lineDiv.style.display = "";\n    if (focused && document.activeElement != focused && focused.offsetHeight) focused.focus();\n\n    var different = from != display.showingFrom || to != display.showingTo ||\n      display.lastSizeC != display.wrapper.clientHeight;\n    // This is just a bogus formula that detects when the editor is\n    // resized or the font size changes.\n    if (different) {\n      display.lastSizeC = display.wrapper.clientHeight;\n      startWorker(cm, 400);\n    }\n    display.showingFrom = from; display.showingTo = to;\n\n    display.gutters.style.height = "";\n    updateHeightsInViewport(cm);\n    updateViewOffset(cm);\n\n    return true;\n  }\n\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var node = display.lineDiv.firstChild, height; node; node = node.nextSibling) if (node.lineObj) {\n      if (ie_lt8) {\n        var bot = node.offsetTop + node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = getRect(node);\n        height = box.bottom - box.top;\n      }\n      var diff = node.lineObj.height - height;\n      if (height < 2) height = textHeight(display);\n      if (diff > .001 || diff < -.001) {\n        updateLineHeight(node.lineObj, height);\n        var widgets = node.lineObj.widgets;\n        if (widgets) for (var i = 0; i < widgets.length; ++i)\n          widgets[i].height = widgets[i].node.offsetHeight;\n      }\n    }\n  }\n\n  function updateViewOffset(cm) {\n    var off = cm.display.viewOffset = heightAtLine(cm, getLine(cm.doc, cm.display.showingFrom));\n    // Position the mover div to align with the current virtual scroll position\n    cm.display.mover.style.top = off + "px";\n  }\n\n  function computeIntact(intact, changes) {\n    for (var i = 0, l = changes.length || 0; i < l; ++i) {\n      var change = changes[i], intact2 = [], diff = change.diff || 0;\n      for (var j = 0, l2 = intact.length; j < l2; ++j) {\n        var range = intact[j];\n        if (change.to <= range.from && change.diff) {\n          intact2.push({from: range.from + diff, to: range.to + diff});\n        } else if (change.to <= range.from || change.from >= range.to) {\n          intact2.push(range);\n        } else {\n          if (change.from > range.from)\n            intact2.push({from: range.from, to: change.from});\n          if (change.to < range.to)\n            intact2.push({from: change.to + diff, to: range.to + diff});\n        }\n      }\n      intact = intact2;\n    }\n    return intact;\n  }\n\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft;\n      width[cm.options.gutters[i]] = n.offsetWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth};\n  }\n\n  function patchDisplay(cm, from, to, intact, updateNumbersFrom) {\n    var dims = getDimensions(cm);\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    if (!intact.length && (!webkit || !cm.display.currentWheelTarget))\n      removeChildren(display.lineDiv);\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = "none";\n        node.lineObj = null;\n      } else {\n        node.parentNode.removeChild(node);\n      }\n      return next;\n    }\n\n    var nextIntact = intact.shift(), lineN = from;\n    cm.doc.iter(from, to, function(line) {\n      if (nextIntact && nextIntact.to == lineN) nextIntact = intact.shift();\n      if (lineIsHidden(cm.doc, line)) {\n        if (line.height != 0) updateLineHeight(line, 0);\n        if (line.widgets && cur && cur.previousSibling) for (var i = 0; i < line.widgets.length; ++i) {\n          var w = line.widgets[i];\n          if (w.showIfHidden) {\n            var prev = cur.previousSibling;\n            if (/pre/i.test(prev.nodeName)) {\n              var wrap = elt("div", null, null, "position: relative");\n              prev.parentNode.replaceChild(wrap, prev);\n              wrap.appendChild(prev);\n              prev = wrap;\n            }\n            var wnode = prev.appendChild(elt("div", [w.node], "CodeMirror-linewidget"));\n            if (!w.handleMouseEvents) wnode.ignoreEvents = true;\n            positionLineWidget(w, wnode, prev, dims);\n          }\n        }\n      } else if (nextIntact && nextIntact.from <= lineN && nextIntact.to > lineN) {\n        // This line is intact. Skip to the actual node. Update its\n        // line number if needed.\n        while (cur.lineObj != line) cur = rm(cur);\n        if (lineNumbers && updateNumbersFrom <= lineN && cur.lineNumber)\n          setTextContent(cur.lineNumber, lineNumberFor(cm.options, lineN));\n        cur = cur.nextSibling;\n      } else {\n        // For lines with widgets, make an attempt to find and reuse\n        // the existing element, so that widgets aren't needlessly\n        // removed and re-inserted into the dom\n        if (line.widgets) for (var j = 0, search = cur, reuse; search && j < 20; ++j, search = search.nextSibling)\n          if (search.lineObj == line && /div/i.test(search.nodeName)) { reuse = search; break; }\n        // This line needs to be generated.\n        var lineNode = buildLineElement(cm, line, lineN, dims, reuse);\n        if (lineNode != reuse) {\n          container.insertBefore(lineNode, cur);\n        } else {\n          while (cur != reuse) cur = rm(cur);\n          cur = cur.nextSibling;\n        }\n\n        lineNode.lineObj = line;\n      }\n      ++lineN;\n    });\n    while (cur) cur = rm(cur);\n  }\n\n  function buildLineElement(cm, line, lineNo, dims, reuse) {\n    var built = buildLineContent(cm, line), lineElement = built.pre;\n    var markers = line.gutterMarkers, display = cm.display, wrap;\n\n    var bgClass = built.bgClass ? built.bgClass + " " + (line.bgClass || "") : line.bgClass;\n    if (!cm.options.lineNumbers && !markers && !bgClass && !line.wrapClass && !line.widgets)\n      return lineElement;\n\n    // Lines with gutter elements, widgets or a background class need\n    // to be wrapped again, and have the extra elements added to the\n    // wrapper div\n\n    if (reuse) {\n      reuse.alignable = null;\n      var isOk = true, widgetsSeen = 0, insertBefore = null;\n      for (var n = reuse.firstChild, next; n; n = next) {\n        next = n.nextSibling;\n        if (!/\\bCodeMirror-linewidget\\b/.test(n.className)) {\n          reuse.removeChild(n);\n        } else {\n          for (var i = 0; i < line.widgets.length; ++i) {\n            var widget = line.widgets[i];\n            if (widget.node == n.firstChild) {\n              if (!widget.above && !insertBefore) insertBefore = n;\n              positionLineWidget(widget, n, reuse, dims);\n              ++widgetsSeen;\n              break;\n            }\n          }\n          if (i == line.widgets.length) { isOk = false; break; }\n        }\n      }\n      reuse.insertBefore(lineElement, insertBefore);\n      if (isOk && widgetsSeen == line.widgets.length) {\n        wrap = reuse;\n        reuse.className = line.wrapClass || "";\n      }\n    }\n    if (!wrap) {\n      wrap = elt("div", null, line.wrapClass, "position: relative");\n      wrap.appendChild(lineElement);\n    }\n    // Kludge to make sure the styled element lies behind the selection (by z-index)\n    if (bgClass)\n      wrap.insertBefore(elt("div", null, bgClass + " CodeMirror-linebackground"), wrap.firstChild);\n    if (cm.options.lineNumbers || markers) {\n      var gutterWrap = wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +\n                                             (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),\n                                         lineElement);\n      if (cm.options.fixedGutter) (wrap.alignable || (wrap.alignable = [])).push(gutterWrap);\n      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))\n        wrap.lineNumber = gutterWrap.appendChild(\n          elt("div", lineNumberFor(cm.options, lineNo),\n              "CodeMirror-linenumber CodeMirror-gutter-elt",\n              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "\n              + display.lineNumInnerWidth + "px"));\n      if (markers)\n        for (var k = 0; k < cm.options.gutters.length; ++k) {\n          var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n          if (found)\n            gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +\n                                       dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));\n        }\n    }\n    if (ie_lt8) wrap.style.zIndex = 2;\n    if (line.widgets && wrap != reuse) for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\n      positionLineWidget(widget, node, wrap, dims);\n      if (widget.above)\n        wrap.insertBefore(node, cm.options.lineNumbers && line.height != 0 ? gutterWrap : lineElement);\n      else\n        wrap.appendChild(node);\n      signalLater(widget, "redraw");\n    }\n    return wrap;\n  }\n\n  function positionLineWidget(widget, node, wrap, dims) {\n    if (widget.noHScroll) {\n      (wrap.alignable || (wrap.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + "px";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + "px";\n      }\n      node.style.width = width + "px";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = "relative";\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";\n    }\n  }\n\n  // SELECTION / CURSOR\n\n  function updateSelection(cm) {\n    var display = cm.display;\n    var collapsed = posEq(cm.doc.sel.from, cm.doc.sel.to);\n    if (collapsed || cm.options.showCursorWhenSelecting)\n      updateSelectionCursor(cm);\n    else\n      display.cursor.style.display = display.otherCursor.style.display = "none";\n    if (!collapsed)\n      updateSelectionRange(cm);\n    else\n      display.selectionDiv.style.display = "none";\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, cm.doc.sel.head, "div");\n      var wrapOff = getRect(display.wrapper), lineOff = getRect(display.lineDiv);\n      display.inputDiv.style.top = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                                        headPos.top + lineOff.top - wrapOff.top)) + "px";\n      display.inputDiv.style.left = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                                         headPos.left + lineOff.left - wrapOff.left)) + "px";\n    }\n  }\n\n  // No selection, plain cursor\n  function updateSelectionCursor(cm) {\n    var display = cm.display, pos = cursorCoords(cm, cm.doc.sel.head, "div");\n    display.cursor.style.left = pos.left + "px";\n    display.cursor.style.top = pos.top + "px";\n    display.cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";\n    display.cursor.style.display = "";\n\n    if (pos.other) {\n      display.otherCursor.style.display = "";\n      display.otherCursor.style.left = pos.other.left + "px";\n      display.otherCursor.style.top = pos.other.top + "px";\n      display.otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";\n    } else { display.otherCursor.style.display = "none"; }\n  }\n\n  // Highlight selection\n  function updateSelectionRange(cm) {\n    var display = cm.display, doc = cm.doc, sel = cm.doc.sel;\n    var fragment = document.createDocumentFragment();\n    var clientWidth = display.lineSpace.offsetWidth, pl = paddingLeft(cm.display);\n\n    function add(left, top, width, bottom) {\n      if (top < 0) top = 0;\n      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +\n                               "px; top: " + top + "px; width: " + (width == null ? clientWidth - left : width) +\n                               "px; height: " + (bottom - top) + "px"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);\n      }\n\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\n        var leftPos = coords(from, "left"), rightPos, left, right;\n        if (from == to) {\n          rightPos = leftPos;\n          left = right = leftPos.left;\n        } else {\n          rightPos = coords(to - 1, "right");\n          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\n          left = leftPos.left;\n          right = rightPos.right;\n        }\n        if (fromArg == null && from == 0) left = pl;\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\n          add(left, leftPos.top, null, leftPos.bottom);\n          left = pl;\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\n        }\n        if (toArg == null && to == lineLen) right = clientWidth;\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\n          start = leftPos;\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\n          end = rightPos;\n        if (left < pl + 1) left = pl;\n        add(left, rightPos.top, right - left, rightPos.bottom);\n      });\n      return {start: start, end: end};\n    }\n\n    if (sel.from.line == sel.to.line) {\n      drawForLine(sel.from.line, sel.from.ch, sel.to.ch);\n    } else {\n      var fromLine = getLine(doc, sel.from.line), toLine = getLine(doc, sel.to.line);\n      var singleVLine = visualLine(doc, fromLine) == visualLine(doc, toLine);\n      var leftEnd = drawForLine(sel.from.line, sel.from.ch, singleVLine ? fromLine.text.length : null).end;\n      var rightStart = drawForLine(sel.to.line, singleVLine ? 0 : null, sel.to.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(pl, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        add(pl, leftEnd.bottom, null, rightStart.top);\n    }\n\n    removeChildrenAndAdd(display.selectionDiv, fragment);\n    display.selectionDiv.style.display = "";\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) return;\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursor.style.visibility = display.otherCursor.style.visibility = "";\n    if (cm.options.cursorBlinkRate > 0)\n      display.blinker = setInterval(function() {\n        display.cursor.style.visibility = display.otherCursor.style.visibility = (on = !on) ? "" : "hidden";\n      }, cm.options.cursorBlinkRate);\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.showingTo)\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\n    if (doc.frontier >= cm.display.showingTo) return;\n    var end = +new Date + cm.options.workTime;\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\n    var changed = [], prevChange;\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.showingTo + 500), function(line) {\n      if (doc.frontier >= cm.display.showingFrom) { // Visible\n        var oldStyles = line.styles;\n        line.styles = highlightLine(cm, line, state, true);\n        var ischange = !oldStyles || oldStyles.length != line.styles.length;\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\n        if (ischange) {\n          if (prevChange && prevChange.end == doc.frontier) prevChange.end++;\n          else changed.push(prevChange = {start: doc.frontier, end: doc.frontier + 1});\n        }\n        line.stateAfter = copyState(doc.mode, state);\n      } else {\n        processLine(cm, line.text, state);\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\n      }\n      ++doc.frontier;\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    if (changed.length)\n      operation(cm, function() {\n        for (var i = 0; i < changed.length; ++i)\n          regChange(this, changed[i].start, changed[i].end);\n      })();\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) return doc.first;\n      var line = getLine(doc, search - 1);\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline;\n  }\n\n  function getStateBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) return true;\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\n    if (!state) state = startState(doc.mode);\n    else state = copyState(doc.mode, state);\n    doc.iter(pos, n, function(line) {\n      processLine(cm, line.text, state);\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.showingFrom && pos < display.showingTo;\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\n      ++pos;\n    });\n    if (precise) doc.frontier = pos;\n    return state;\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\n  function paddingLeft(display) {\n    var e = removeChildrenAndAdd(display.measure, elt("pre", null, null, "text-align: left")).appendChild(elt("span", "x"));\n    return e.offsetLeft;\n  }\n\n  function measureChar(cm, line, ch, data, bias) {\n    var dir = -1;\n    data = data || measureLine(cm, line);\n    if (data.crude) {\n      var left = data.left + ch * data.width;\n      return {left: left, right: left + data.width, top: data.top, bottom: data.bottom};\n    }\n\n    for (var pos = ch;; pos += dir) {\n      var r = data[pos];\n      if (r) break;\n      if (dir < 0 && pos == 0) dir = 1;\n    }\n    bias = pos > ch ? "left" : pos < ch ? "right" : bias;\n    if (bias == "left" && r.leftSide) r = r.leftSide;\n    else if (bias == "right" && r.rightSide) r = r.rightSide;\n    return {left: pos < ch ? r.right : r.left,\n            right: pos > ch ? r.left : r.right,\n            top: r.top,\n            bottom: r.bottom};\n  }\n\n  function findCachedMeasurement(cm, line) {\n    var cache = cm.display.measureLineCache;\n    for (var i = 0; i < cache.length; ++i) {\n      var memo = cache[i];\n      if (memo.text == line.text && memo.markedSpans == line.markedSpans &&\n          cm.display.scroller.clientWidth == memo.width &&\n          memo.classes == line.textClass + "|" + line.wrapClass)\n        return memo;\n    }\n  }\n\n  function clearCachedMeasurement(cm, line) {\n    var exists = findCachedMeasurement(cm, line);\n    if (exists) exists.text = exists.measure = exists.markedSpans = null;\n  }\n\n  function measureLine(cm, line) {\n    // First look in the cache\n    var cached = findCachedMeasurement(cm, line);\n    if (cached) return cached.measure;\n\n    // Failing that, recompute and store result in cache\n    var measure = measureLineInner(cm, line);\n    var cache = cm.display.measureLineCache;\n    var memo = {text: line.text, width: cm.display.scroller.clientWidth,\n                markedSpans: line.markedSpans, measure: measure,\n                classes: line.textClass + "|" + line.wrapClass};\n    if (cache.length == 16) cache[++cm.display.measureLineCachePos % 16] = memo;\n    else cache.push(memo);\n    return measure;\n  }\n\n  function measureLineInner(cm, line) {\n    if (!cm.options.lineWrapping && line.text.length >= cm.options.crudeMeasuringFrom)\n      return crudelyMeasureLine(cm, line);\n\n    var display = cm.display, measure = emptyArray(line.text.length);\n    var pre = buildLineContent(cm, line, measure, true).pre;\n\n    // IE does not cache element positions of inline elements between\n    // calls to getBoundingClientRect. This makes the loop below,\n    // which gathers the positions of all the characters on the line,\n    // do an amount of layout work quadratic to the number of\n    // characters. When line wrapping is off, we try to improve things\n    // by first subdividing the line into a bunch of inline blocks, so\n    // that IE can reuse most of the layout information from caches\n    // for those blocks. This does interfere with line wrapping, so it\n    // doesn't work when wrapping is on, but in that case the\n    // situation is slightly better, since IE does cache line-wrapping\n    // information and only recomputes per-line.\n    if (old_ie && !ie_lt8 && !cm.options.lineWrapping && pre.childNodes.length > 100) {\n      var fragment = document.createDocumentFragment();\n      var chunk = 10, n = pre.childNodes.length;\n      for (var i = 0, chunks = Math.ceil(n / chunk); i < chunks; ++i) {\n        var wrap = elt("div", null, null, "display: inline-block");\n        for (var j = 0; j < chunk && n; ++j) {\n          wrap.appendChild(pre.firstChild);\n          --n;\n        }\n        fragment.appendChild(wrap);\n      }\n      pre.appendChild(fragment);\n    }\n\n    removeChildrenAndAdd(display.measure, pre);\n\n    var outer = getRect(display.lineDiv);\n    var vranges = [], data = emptyArray(line.text.length), maxBot = pre.offsetHeight;\n    // Work around an IE7/8 bug where it will sometimes have randomly\n    // replaced our pre with a clone at this point.\n    if (ie_lt9 && display.measure.first != pre)\n      removeChildrenAndAdd(display.measure, pre);\n\n    function measureRect(rect) {\n      var top = rect.top - outer.top, bot = rect.bottom - outer.top;\n      if (bot > maxBot) bot = maxBot;\n      if (top < 0) top = 0;\n      for (var i = vranges.length - 2; i >= 0; i -= 2) {\n        var rtop = vranges[i], rbot = vranges[i+1];\n        if (rtop > bot || rbot < top) continue;\n        if (rtop <= top && rbot >= bot ||\n            top <= rtop && bot >= rbot ||\n            Math.min(bot, rbot) - Math.max(top, rtop) >= (bot - top) >> 1) {\n          vranges[i] = Math.min(top, rtop);\n          vranges[i+1] = Math.max(bot, rbot);\n          break;\n        }\n      }\n      if (i < 0) { i = vranges.length; vranges.push(top, bot); }\n      return {left: rect.left - outer.left,\n              right: rect.right - outer.left,\n              top: i, bottom: null};\n    }\n    function finishRect(rect) {\n      rect.bottom = vranges[rect.top+1];\n      rect.top = vranges[rect.top];\n    }\n\n    for (var i = 0, cur; i < measure.length; ++i) if (cur = measure[i]) {\n      var node = cur, rect = null;\n      // A widget might wrap, needs special care\n      if (/\\bCodeMirror-widget\\b/.test(cur.className) && cur.getClientRects) {\n        if (cur.firstChild.nodeType == 1) node = cur.firstChild;\n        var rects = node.getClientRects();\n        if (rects.length > 1) {\n          rect = data[i] = measureRect(rects[0]);\n          rect.rightSide = measureRect(rects[rects.length - 1]);\n        }\n      }\n      if (!rect) rect = data[i] = measureRect(getRect(node));\n      if (cur.measureRight) rect.right = getRect(cur.measureRight).left - outer.left;\n      if (cur.leftSide) rect.leftSide = measureRect(getRect(cur.leftSide));\n    }\n    removeChildren(cm.display.measure);\n    for (var i = 0, cur; i < data.length; ++i) if (cur = data[i]) {\n      finishRect(cur);\n      if (cur.leftSide) finishRect(cur.leftSide);\n      if (cur.rightSide) finishRect(cur.rightSide);\n    }\n    return data;\n  }\n\n  function crudelyMeasureLine(cm, line) {\n    var copy = new Line(line.text.slice(0, 100), null);\n    if (line.textClass) copy.textClass = line.textClass;\n    var measure = measureLineInner(cm, copy);\n    var left = measureChar(cm, copy, 0, measure, "left");\n    var right = measureChar(cm, copy, 99, measure, "right");\n    return {crude: true, top: left.top, left: left.left, bottom: left.bottom, width: (right.right - left.left) / 100};\n  }\n\n  function measureLineWidth(cm, line) {\n    var hasBadSpan = false;\n    if (line.markedSpans) for (var i = 0; i < line.markedSpans; ++i) {\n      var sp = line.markedSpans[i];\n      if (sp.collapsed && (sp.to == null || sp.to == line.text.length)) hasBadSpan = true;\n    }\n    var cached = !hasBadSpan && findCachedMeasurement(cm, line);\n    if (cached || line.text.length >= cm.options.crudeMeasuringFrom)\n      return measureChar(cm, line, line.text.length, cached && cached.measure, "right").right;\n\n    var pre = buildLineContent(cm, line, null, true).pre;\n    var end = pre.appendChild(zeroWidthElement(cm.display.measure));\n    removeChildrenAndAdd(cm.display.measure, pre);\n    return getRect(end).right - getRect(cm.display.lineDiv).left;\n  }\n\n  function clearCaches(cm) {\n    cm.display.measureLineCache.length = cm.display.measureLineCachePos = 0;\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = null;\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\n\n  // Context is one of "line", "div" (display.lineDiv), "local"/null (editor), or "page"\n  function intoCoordSystem(cm, lineObj, rect, context) {\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\n      var size = widgetHeight(lineObj.widgets[i]);\n      rect.top += size; rect.bottom += size;\n    }\n    if (context == "line") return rect;\n    if (!context) context = "local";\n    var yOff = heightAtLine(cm, lineObj);\n    if (context == "local") yOff += paddingTop(cm.display);\n    else yOff -= cm.display.viewOffset;\n    if (context == "page" || context == "window") {\n      var lOff = getRect(cm.display.lineSpace);\n      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect;\n  }\n\n  // Context may be "window", "page", "div", or "local"/null\n  // Result is in "div" coords\n  function fromCoordSystem(cm, coords, context) {\n    if (context == "div") return coords;\n    var left = coords.left, top = coords.top;\n    // First move into "page" coordinate system\n    if (context == "page") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == "local" || !context) {\n      var localBox = getRect(cm.display.sizer);\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = getRect(cm.display.lineSpace);\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, null, bias), context);\n  }\n\n  function cursorCoords(cm, pos, context, lineObj, measurement) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!measurement) measurement = measureLine(cm, lineObj);\n    function get(ch, right) {\n      var m = measureChar(cm, lineObj, ch, measurement, right ? "right" : "left");\n      if (right) m.left = m.right; else m.right = m.left;\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n    function getBidi(ch, partPos) {\n      var part = order[partPos], right = part.level % 2;\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\n        part = order[--partPos];\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\n        right = true;\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\n        part = order[++partPos];\n        ch = bidiLeft(part) - part.level % 2;\n        right = false;\n      }\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\n      return get(ch, right);\n    }\n    var order = getOrder(lineObj), ch = pos.ch;\n    if (!order) return get(ch);\n    var partPos = getBidiPartAt(order, ch);\n    var val = getBidi(ch, partPos);\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\n    return val;\n  }\n\n  function PosWithInfo(line, ch, outside, xRel) {\n    var pos = new Pos(line, ch);\n    pos.xRel = xRel;\n    if (outside) pos.outside = true;\n    return pos;\n  }\n\n  // Coords must be lineSpace-local\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\n    var lineNo = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineNo > last)\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\n    if (x < 0) x = 0;\n\n    for (;;) {\n      var lineObj = getLine(doc, lineNo);\n      var found = coordsCharInner(cm, lineObj, lineNo, x, y);\n      var merged = collapsedSpanAtEnd(lineObj);\n      var mergedPos = merged && merged.find();\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\n        lineNo = mergedPos.to.line;\n      else\n        return found;\n    }\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    var innerOff = y - heightAtLine(cm, lineObj);\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\n    var measurement = measureLine(cm, lineObj);\n\n    function getX(ch) {\n      var sp = cursorCoords(cm, Pos(lineNo, ch), "line",\n                            lineObj, measurement);\n      wrongLine = true;\n      if (innerOff > sp.bottom) return sp.left - adjust;\n      else if (innerOff < sp.top) return sp.left + adjust;\n      else wrongLine = false;\n      return sp.left;\n    }\n\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\n\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\n    // Do a binary search between these bounds.\n    for (;;) {\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\n        var xDiff = x - (ch == from ? fromX : toX);\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\n                              xDiff < 0 ? -1 : xDiff ? 1 : 0);\n        return pos;\n      }\n      var step = Math.ceil(dist / 2), middle = from + step;\n      if (bidi) {\n        middle = from;\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\n      }\n      var middleX = getX(middle);\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\n    }\n  }\n\n  var measureText;\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\n    if (measureText == null) {\n      measureText = elt("pre");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode("x"));\n        measureText.appendChild(elt("br"));\n      }\n      measureText.appendChild(document.createTextNode("x"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) display.cachedTextHeight = height;\n    removeChildren(display.measure);\n    return height || 1;\n  }\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\n    var anchor = elt("span", "x");\n    var pre = elt("pre", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var width = anchor.offsetWidth;\n    if (width > 2) display.cachedCharWidth = width;\n    return width || 10;\n  }\n\n  // OPERATIONS\n\n  // Operations are used to wrap changes in such a way that each\n  // change won't have to update the cursor and display (which would\n  // be awkward, slow, and error-prone), but instead updates are\n  // batched and then all combined and executed at once.\n\n  var nextOpId = 0;\n  function startOperation(cm) {\n    cm.curOp = {\n      // An array of ranges of lines that have to be updated. See\n      // updateDisplay.\n      changes: [],\n      forceUpdate: false,\n      updateInput: null,\n      userSelChange: null,\n      textChanged: null,\n      selectionChanged: false,\n      cursorActivity: false,\n      updateMaxLine: false,\n      updateScrollPos: false,\n      id: ++nextOpId\n    };\n    if (!delayedCallbackDepth++) delayedCallbacks = [];\n  }\n\n  function endOperation(cm) {\n    var op = cm.curOp, doc = cm.doc, display = cm.display;\n    cm.curOp = null;\n\n    if (op.updateMaxLine) computeMaxLength(cm);\n    if (display.maxLineChanged && !cm.options.lineWrapping && display.maxLine) {\n      var width = measureLineWidth(cm, display.maxLine);\n      display.sizer.style.minWidth = Math.max(0, width + 3 + scrollerCutOff) + "px";\n      display.maxLineChanged = false;\n      var maxScrollLeft = Math.max(0, display.sizer.offsetLeft + display.sizer.offsetWidth - display.scroller.clientWidth);\n      if (maxScrollLeft < doc.scrollLeft && !op.updateScrollPos)\n        setScrollLeft(cm, Math.min(display.scroller.scrollLeft, maxScrollLeft), true);\n    }\n    var newScrollPos, updated;\n    if (op.updateScrollPos) {\n      newScrollPos = op.updateScrollPos;\n    } else if (op.selectionChanged && display.scroller.clientHeight) { // don't rescroll if not visible\n      var coords = cursorCoords(cm, doc.sel.head);\n      newScrollPos = calculateScrollPos(cm, coords.left, coords.top, coords.left, coords.bottom);\n    }\n    if (op.changes.length || op.forceUpdate || newScrollPos && newScrollPos.scrollTop != null) {\n      updated = updateDisplay(cm, op.changes, newScrollPos && newScrollPos.scrollTop, op.forceUpdate);\n      if (cm.display.scroller.offsetHeight) cm.doc.scrollTop = cm.display.scroller.scrollTop;\n    }\n    if (!updated && op.selectionChanged) updateSelection(cm);\n    if (op.updateScrollPos) {\n      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, newScrollPos.scrollTop));\n      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, newScrollPos.scrollLeft));\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\n      alignHorizontally(cm);\n      if (op.scrollToPos)\n        scrollPosIntoView(cm, clipPos(cm.doc, op.scrollToPos.from),\n                          clipPos(cm.doc, op.scrollToPos.to), op.scrollToPos.margin);\n    } else if (newScrollPos) {\n      scrollCursorIntoView(cm);\n    }\n    if (op.selectionChanged) restartBlink(cm);\n\n    if (cm.state.focused && op.updateInput)\n      resetInput(cm, op.userSelChange);\n\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\n      if (!hidden[i].lines.length) signal(hidden[i], "hide");\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\n      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");\n\n    var delayed;\n    if (!--delayedCallbackDepth) {\n      delayed = delayedCallbacks;\n      delayedCallbacks = null;\n    }\n    if (op.textChanged)\n      signal(cm, "change", cm, op.textChanged);\n    if (op.cursorActivity) signal(cm, "cursorActivity", cm);\n    if (delayed) for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm1, f) {\n    return function() {\n      var cm = cm1 || this, withOp = !cm.curOp;\n      if (withOp) startOperation(cm);\n      try { var result = f.apply(cm, arguments); }\n      finally { if (withOp) endOperation(cm); }\n      return result;\n    };\n  }\n  function docOperation(f) {\n    return function() {\n      var withOp = this.cm && !this.cm.curOp, result;\n      if (withOp) startOperation(this.cm);\n      try { result = f.apply(this, arguments); }\n      finally { if (withOp) endOperation(this.cm); }\n      return result;\n    };\n  }\n  function runInOp(cm, f) {\n    var withOp = !cm.curOp, result;\n    if (withOp) startOperation(cm);\n    try { result = f(); }\n    finally { if (withOp) endOperation(cm); }\n    return result;\n  }\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) from = cm.doc.first;\n    if (to == null) to = cm.doc.first + cm.doc.size;\n    cm.curOp.changes.push({from: from, to: to, diff: lendiff});\n  }\n\n  // INPUT HANDLING\n\n  function slowPoll(cm) {\n    if (cm.display.pollingFast) return;\n    cm.display.poll.set(cm.options.pollInterval, function() {\n      readInput(cm);\n      if (cm.state.focused) slowPoll(cm);\n    });\n  }\n\n  function fastPoll(cm) {\n    var missed = false;\n    cm.display.pollingFast = true;\n    function p() {\n      var changed = readInput(cm);\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\n      else {cm.display.pollingFast = false; slowPoll(cm);}\n    }\n    cm.display.poll.set(20, p);\n  }\n\n  // prevInput is a hack to work with IME. If we reset the textarea\n  // on every change, that breaks IME. So we look for changes\n  // compared to the previous content instead. (Modern browsers have\n  // events that indicate IME taking place, but these are not widely\n  // supported or compatible enough yet to rely on.)\n  function readInput(cm) {\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc, sel = doc.sel;\n    if (!cm.state.focused || hasSelection(input) || isReadOnly(cm) || cm.options.disableInput) return false;\n    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\n      input.value = input.value.substring(0, input.value.length - 1);\n      cm.state.fakedLastChar = false;\n    }\n    var text = input.value;\n    if (text == prevInput && posEq(sel.from, sel.to)) return false;\n    if (ie && !ie_lt9 && cm.display.inputHasSelection === text) {\n      resetInput(cm, true);\n      return false;\n    }\n\n    var withOp = !cm.curOp;\n    if (withOp) startOperation(cm);\n    sel.shift = false;\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\n    var from = sel.from, to = sel.to;\n    var inserted = text.slice(same);\n    if (same < prevInput.length)\n      from = Pos(from.line, from.ch - (prevInput.length - same));\n    else if (cm.state.overwrite && posEq(from, to) && !cm.state.pasteIncoming)\n      to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + inserted.length));\n\n    var updateInput = cm.curOp.updateInput;\n    var changeEvent = {from: from, to: to, text: splitLines(inserted),\n                       origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};\n    makeChange(cm.doc, changeEvent, "end");\n    cm.curOp.updateInput = updateInput;\n    signalLater(cm, "inputRead", cm, changeEvent);\n    if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\n        cm.options.smartIndent && sel.head.ch < 100) {\n      var electric = cm.getModeAt(sel.head).electricChars;\n      if (electric) for (var i = 0; i < electric.length; i++)\n        if (inserted.indexOf(electric.charAt(i)) > -1) {\n          indentLine(cm, sel.head.line, "smart");\n          break;\n        }\n    }\n\n    if (text.length > 1000 || text.indexOf("\\n") > -1) input.value = cm.display.prevInput = "";\n    else cm.display.prevInput = text;\n    if (withOp) endOperation(cm);\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\n    return true;\n  }\n\n  function resetInput(cm, user) {\n    var minimal, selected, doc = cm.doc;\n    if (!posEq(doc.sel.from, doc.sel.to)) {\n      cm.display.prevInput = "";\n      minimal = hasCopyEvent &&\n        (doc.sel.to.line - doc.sel.from.line > 100 || (selected = cm.getSelection()).length > 1000);\n      var content = minimal ? "-" : selected || cm.getSelection();\n      cm.display.input.value = content;\n      if (cm.state.focused) selectInput(cm.display.input);\n      if (ie && !ie_lt9) cm.display.inputHasSelection = content;\n    } else if (user) {\n      cm.display.prevInput = cm.display.input.value = "";\n      if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    }\n    cm.display.inaccurateSelection = minimal;\n  }\n\n  function focusInput(cm) {\n    if (cm.options.readOnly != "nocursor" && (!mobile || document.activeElement != cm.display.input))\n      cm.display.input.focus();\n  }\n\n  function isReadOnly(cm) {\n    return cm.options.readOnly || cm.doc.cantEdit;\n  }\n\n  // EVENT HANDLERS\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, "mousedown", operation(cm, onMouseDown));\n    if (old_ie)\n      on(d.scroller, "dblclick", operation(cm, function(e) {\n        if (signalDOMEvent(cm, e)) return;\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\n        e_preventDefault(e);\n        var word = findWordAt(getLine(cm.doc, pos.line).text, pos);\n        extendSelection(cm.doc, word.from, word.to);\n      }));\n    else\n      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\n    on(d.lineSpace, "selectstart", function(e) {\n      if (!eventInWidget(d, e)) e_preventDefault(e);\n    });\n    // Gecko browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for Gecko.\n    if (!captureMiddleClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});\n\n    on(d.scroller, "scroll", function() {\n      if (d.scroller.clientHeight) {\n        setScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, "scroll", cm);\n      }\n    });\n    on(d.scrollbarV, "scroll", function() {\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\n    });\n    on(d.scrollbarH, "scroll", function() {\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\n    });\n\n    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});\n    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});\n\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\n    on(d.scrollbarH, "mousedown", reFocus);\n    on(d.scrollbarV, "mousedown", reFocus);\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    var resizeTimer;\n    function onResize() {\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\n        resizeTimer = null;\n        // Might be a text scaling operation, clear size caches.\n        d.cachedCharWidth = d.cachedTextHeight = knownScrollbarWidth = null;\n        clearCaches(cm);\n        runInOp(cm, bind(regChange, cm));\n      }, 100);\n    }\n    on(window, "resize", onResize);\n    // Above handler holds on to the editor and its data structures.\n    // Here we poll to unregister it when the editor is no longer in\n    // the document, so that it can be garbage-collected.\n    function unregister() {\n      for (var p = d.wrapper.parentNode; p && p != document.body; p = p.parentNode) {}\n      if (p) setTimeout(unregister, 5000);\n      else off(window, "resize", onResize);\n    }\n    setTimeout(unregister, 5000);\n\n    on(d.input, "keyup", operation(cm, function(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n      if (e.keyCode == 16) cm.doc.sel.shift = false;\n    }));\n    on(d.input, "input", function() {\n      if (ie && !ie_lt9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\n      fastPoll(cm);\n    });\n    on(d.input, "keydown", operation(cm, onKeyDown));\n    on(d.input, "keypress", operation(cm, onKeyPress));\n    on(d.input, "focus", bind(onFocus, cm));\n    on(d.input, "blur", bind(onBlur, cm));\n\n    function drag_(e) {\n      if (signalDOMEvent(cm, e) || cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))) return;\n      e_stop(e);\n    }\n    if (cm.options.dragDrop) {\n      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});\n      on(d.scroller, "dragenter", drag_);\n      on(d.scroller, "dragover", drag_);\n      on(d.scroller, "drop", operation(cm, onDrop));\n    }\n    on(d.scroller, "paste", function(e) {\n      if (eventInWidget(d, e)) return;\n      focusInput(cm);\n      fastPoll(cm);\n    });\n    on(d.input, "paste", function() {\n      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\n      // Add a char to the end of textarea before paste occur so that\n      // selection doesn't span to the end of textarea.\n      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\n        var start = d.input.selectionStart, end = d.input.selectionEnd;\n        d.input.value += "$";\n        d.input.selectionStart = start;\n        d.input.selectionEnd = end;\n        cm.state.fakedLastChar = true;\n      }\n      cm.state.pasteIncoming = true;\n      fastPoll(cm);\n    });\n\n    function prepareCopy(e) {\n      if (d.inaccurateSelection) {\n        d.prevInput = "";\n        d.inaccurateSelection = false;\n        d.input.value = cm.getSelection();\n        selectInput(d.input);\n      }\n      if (e.type == "cut") cm.state.cutIncoming = true;\n    }\n    on(d.input, "cut", prepareCopy);\n    on(d.input, "copy", prepareCopy);\n\n    // Needed to handle Tab key in KHTML\n    if (khtml) on(d.sizer, "mouseup", function() {\n      if (document.activeElement == d.input) d.input.blur();\n      focusInput(cm);\n    });\n  }\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\n    }\n  }\n\n  function posFromMouse(cm, e, liberal) {\n    var display = cm.display;\n    if (!liberal) {\n      var target = e_target(e);\n      if (target == display.scrollbarH || target == display.scrollbarH.firstChild ||\n          target == display.scrollbarV || target == display.scrollbarV.firstChild ||\n          target == display.scrollbarFiller || target == display.gutterFiller) return null;\n    }\n    var x, y, space = getRect(display.lineSpace);\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX; y = e.clientY; } catch (e) { return null; }\n    return coordsChar(cm, x - space.left, y - space.top);\n  }\n\n  var lastClick, lastDoubleClick;\n  function onMouseDown(e) {\n    if (signalDOMEvent(this, e)) return;\n    var cm = this, display = cm.display, doc = cm.doc, sel = doc.sel;\n    sel.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        display.scroller.draggable = false;\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\n      }\n      return;\n    }\n    if (clickInGutter(cm, e)) return;\n    var start = posFromMouse(cm, e);\n\n    switch (e_button(e)) {\n    case 3:\n      if (captureMiddleClick) onContextMenu.call(cm, cm, e);\n      return;\n    case 2:\n      if (webkit) cm.state.lastMiddleDown = +new Date;\n      if (start) extendSelection(cm.doc, start);\n      setTimeout(bind(focusInput, cm), 20);\n      e_preventDefault(e);\n      return;\n    }\n    // For button 1, if it was clicked inside the editor\n    // (posFromMouse returning non-null), we have to adjust the\n    // selection.\n    if (!start) {if (e_target(e) == display.scroller) e_preventDefault(e); return;}\n\n    if (!cm.state.focused) onFocus(cm);\n\n    var now = +new Date, type = "single";\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && posEq(lastDoubleClick.pos, start)) {\n      type = "triple";\n      e_preventDefault(e);\n      setTimeout(bind(focusInput, cm), 20);\n      selectLine(cm, start.line);\n    } else if (lastClick && lastClick.time > now - 400 && posEq(lastClick.pos, start)) {\n      type = "double";\n      lastDoubleClick = {time: now, pos: start};\n      e_preventDefault(e);\n      var word = findWordAt(getLine(doc, start.line).text, start);\n      extendSelection(cm.doc, word.from, word.to);\n    } else { lastClick = {time: now, pos: start}; }\n\n    var last = start;\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) && !posEq(sel.from, sel.to) &&\n        !posLess(start, sel.from) && !posLess(sel.to, start) && type == "single") {\n      var dragEnd = operation(cm, function(e2) {\n        if (webkit) display.scroller.draggable = false;\n        cm.state.draggingText = false;\n        off(document, "mouseup", dragEnd);\n        off(display.scroller, "drop", dragEnd);\n        if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\n          e_preventDefault(e2);\n          extendSelection(cm.doc, start);\n          focusInput(cm);\n          // Work around unexplainable focus problem in IE9 (#2127)\n          if (old_ie && !ie_lt9)\n            setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\n        }\n      });\n      // Let the drag handler handle this.\n      if (webkit) display.scroller.draggable = true;\n      cm.state.draggingText = dragEnd;\n      // IE's approach to draggable\n      if (display.scroller.dragDrop) display.scroller.dragDrop();\n      on(document, "mouseup", dragEnd);\n      on(display.scroller, "drop", dragEnd);\n      return;\n    }\n    e_preventDefault(e);\n    if (type == "single") extendSelection(cm.doc, clipPos(doc, start));\n\n    var startstart = sel.from, startend = sel.to, lastPos = start;\n\n    function doSelect(cur) {\n      if (posEq(lastPos, cur)) return;\n      lastPos = cur;\n\n      if (type == "single") {\n        extendSelection(cm.doc, clipPos(doc, start), cur);\n        return;\n      }\n\n      startstart = clipPos(doc, startstart);\n      startend = clipPos(doc, startend);\n      if (type == "double") {\n        var word = findWordAt(getLine(doc, cur.line).text, cur);\n        if (posLess(cur, startstart)) extendSelection(cm.doc, word.from, startend);\n        else extendSelection(cm.doc, startstart, word.to);\n      } else if (type == "triple") {\n        if (posLess(cur, startstart)) extendSelection(cm.doc, startend, clipPos(doc, Pos(cur.line, 0)));\n        else extendSelection(cm.doc, startstart, clipPos(doc, Pos(cur.line + 1, 0)));\n      }\n    }\n\n    var editorSize = getRect(display.wrapper);\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true);\n      if (!cur) return;\n      if (!posEq(cur, last)) {\n        if (!cm.state.focused) onFocus(cm);\n        last = cur;\n        doSelect(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) setTimeout(operation(cm, function() {\n          if (counter != curCount) return;\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50);\n      }\n    }\n\n    function done(e) {\n      counter = Infinity;\n      e_preventDefault(e);\n      focusInput(cm);\n      off(document, "mousemove", move);\n      off(document, "mouseup", up);\n    }\n\n    var move = operation(cm, function(e) {\n      if (!old_ie && !e_button(e)) done(e);\n      else extend(e);\n    });\n    var up = operation(cm, done);\n    on(document, "mousemove", move);\n    on(document, "mouseup", up);\n  }\n\n  function gutterEvent(cm, e, type, prevent, signalfn) {\n    try { var mX = e.clientX, mY = e.clientY; }\n    catch(e) { return false; }\n    if (mX >= Math.floor(getRect(cm.display.gutters).right)) return false;\n    if (prevent) e_preventDefault(e);\n\n    var display = cm.display;\n    var lineBox = getRect(display.lineDiv);\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && getRect(g).right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signalfn(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, "gutterContextMenu")) return false;\n    return gutterEvent(cm, e, "gutterContextMenu", false, signal);\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, "gutterClick", true, signalLater);\n  }\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e) || (cm.options.onDragEvent && cm.options.onDragEvent(cm, addStop(e))))\n      return;\n    e_preventDefault(e);\n    if (ie) lastDrop = +new Date;\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || isReadOnly(cm)) return;\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function(file, i) {\n        var reader = new FileReader;\n        reader.onload = function() {\n          text[i] = reader.result;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            makeChange(cm.doc, {from: pos, to: pos, text: splitLines(text.join("\\n")), origin: "paste"}, "around");\n          }\n        };\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\n    } else {\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && !(posLess(pos, cm.doc.sel.from) || posLess(cm.doc.sel.to, pos))) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(bind(focusInput, cm), 20);\n        return;\n      }\n      try {\n        var text = e.dataTransfer.getData("Text");\n        if (text) {\n          var curFrom = cm.doc.sel.from, curTo = cm.doc.sel.to;\n          setSelection(cm.doc, pos, pos);\n          if (cm.state.draggingText) replaceRange(cm.doc, "", curFrom, curTo, "paste");\n          cm.replaceSelection(text, null, "paste");\n          focusInput(cm);\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\n\n    var txt = cm.getSelection();\n    e.dataTransfer.setData("Text", txt);\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");\n      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\n      if (opera) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (opera) img.parentNode.removeChild(img);\n    }\n  }\n\n  function setScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\n    cm.doc.scrollTop = val;\n    if (!gecko) updateDisplay(cm, [], val);\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\n    if (gecko) updateDisplay(cm, []);\n    startWorker(cm, 100);\n  }\n  function setScrollLeft(cm, val, isScroller) {\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (old_ie) wheelPixelsPerUnit = -.53;\n  else if (gecko) wheelPixelsPerUnit = 15;\n  else if (chrome) wheelPixelsPerUnit = -.7;\n  else if (safari) wheelPixelsPerUnit = -1/3;\n\n  function onScrollWheel(cm, e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\n    else if (dy == null) dy = e.wheelDelta;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      for (var cur = e.target; cur != scroll; cur = cur.parentNode) {\n        if (cur.lineObj) {\n          cm.display.currentWheelTarget = cur;\n          break;\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !opera && wheelPixelsPerUnit != null) {\n      if (dy)\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\n      e_preventDefault(e);\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return;\n    }\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\n      updateDisplay(cm, [], {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function() {\n          if (display.wheelStartX == null) return;\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) return;\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == "string") {\n      bound = commands[bound];\n      if (!bound) return false;\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\n    var doc = cm.doc, prevShift = doc.sel.shift, done = false;\n    try {\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\n      if (dropShift) doc.sel.shift = false;\n      done = bound(cm) != Pass;\n    } finally {\n      doc.sel.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done;\n  }\n\n  function allKeyMaps(cm) {\n    var maps = cm.state.keyMaps.slice(0);\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\n    maps.push(cm.options.keyMap);\n    return maps;\n  }\n\n  var maybeTransition;\n  function handleKeyBinding(cm, e) {\n    // Handle auto keymap transitions\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\n    clearTimeout(maybeTransition);\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\n      if (getKeyMap(cm.options.keyMap) == startMap) {\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\n        keyMapChanged(cm);\n      }\n    }, 50);\n\n    var name = keyName(e, true), handled = false;\n    if (!name) return false;\n    var keymaps = allKeyMaps(cm);\n\n    if (e.shiftKey) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\n             || lookupKey(name, keymaps, function(b) {\n                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)\n                    return doHandleBinding(cm, b);\n                });\n    } else {\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\n    }\n\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      if (ie_lt9) { e.oldKeyCode = e.keyCode; e.keyCode = 0; }\n      signalLater(cm, "keyHandled", cm, name, e);\n    }\n    return handled;\n  }\n\n  function handleCharBinding(cm, e, ch) {\n    var handled = lookupKey("'" + ch + "'", allKeyMaps(cm),\n                            function(b) { return doHandleBinding(cm, b, true); });\n    if (handled) {\n      e_preventDefault(e);\n      restartBlink(cm);\n      signalLater(cm, "keyHandled", cm, "'" + ch + "'", e);\n    }\n    return handled;\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    if (!cm.state.focused) onFocus(cm);\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    if (old_ie && e.keyCode == 27) e.returnValue = false;\n    var code = e.keyCode;\n    // IE does strange things with escape.\n    cm.doc.sel.shift = code == 16 || e.shiftKey;\n    // First give onKeyEvent option a chance to handle this.\n    var handled = handleKeyBinding(cm, e);\n    if (opera) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        cm.replaceSelection("");\n    }\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (signalDOMEvent(cm, e) || cm.options.onKeyEvent && cm.options.onKeyEvent(cm, addStop(e))) return;\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (opera && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\n    if (((opera && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    if (handleCharBinding(cm, e, ch)) return;\n    if (ie && !ie_lt9) cm.display.inputHasSelection = null;\n    fastPoll(cm);\n  }\n\n  function onFocus(cm) {\n    if (cm.options.readOnly == "nocursor") return;\n    if (!cm.state.focused) {\n      signal(cm, "focus", cm);\n      cm.state.focused = true;\n      if (cm.display.wrapper.className.search(/\\bCodeMirror-focused\\b/) == -1)\n        cm.display.wrapper.className += " CodeMirror-focused";\n      if (!cm.curOp) {\n        resetInput(cm, true);\n        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\n      }\n    }\n    slowPoll(cm);\n    restartBlink(cm);\n  }\n  function onBlur(cm) {\n    if (cm.state.focused) {\n      signal(cm, "blur", cm);\n      cm.state.focused = false;\n      cm.display.wrapper.className = cm.display.wrapper.className.replace(" CodeMirror-focused", "");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function() {if (!cm.state.focused) cm.doc.sel.shift = false;}, 150);\n  }\n\n  var detectingSelectAll;\n  function onContextMenu(cm, e) {\n    if (signalDOMEvent(cm, e, "contextmenu")) return;\n    var display = cm.display, sel = cm.doc.sel;\n    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\n\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || opera) return; // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && (posEq(sel.from, sel.to) || posLess(pos, sel.from) || !posLess(pos, sel.to)))\n      operation(cm, setSelection)(cm.doc, pos, pos);\n\n    var oldCSS = display.input.style.cssText;\n    display.inputDiv.style.position = "absolute";\n    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +\n      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: transparent; outline: none;" +\n      "border-width: 0; outline: none; overflow: hidden; opacity: .05; -ms-opacity: .05; filter: alpha(opacity=5);";\n    focusInput(cm);\n    resetInput(cm, true);\n    // Adds "Select all" to context menu in FF\n    if (posEq(sel.from, sel.to)) display.input.value = display.prevInput = " ";\n\n    function prepareSelectAllHack() {\n      if (display.input.selectionStart != null) {\n        var extval = display.input.value = "\\u200b" + (posEq(sel.from, sel.to) ? "" : display.input.value);\n        display.prevInput = "\\u200b";\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\n      }\n    }\n    function rehide() {\n      display.inputDiv.style.position = "relative";\n      display.input.style.cssText = oldCSS;\n      if (ie_lt9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\n      slowPoll(cm);\n\n      // Try to detect the user choosing select-all\n      if (display.input.selectionStart != null) {\n        if (!old_ie || ie_lt9) prepareSelectAllHack();\n        clearTimeout(detectingSelectAll);\n        var i = 0, poll = function(){\n          if (display.prevInput == "\\u200b" && display.input.selectionStart == 0)\n            operation(cm, commands.selectAll)(cm);\n          else if (i++ < 10) detectingSelectAll = setTimeout(poll, 500);\n          else resetInput(cm);\n        };\n        detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (old_ie && !ie_lt9) prepareSelectAllHack();\n    if (captureMiddleClick) {\n      e_stop(e);\n      var mouseup = function() {\n        off(window, "mouseup", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, "mouseup", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  }\n\n  // UPDATING\n\n  var changeEnd = CodeMirror.changeEnd = function(change) {\n    if (!change.text) return change.to;\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  };\n\n  // Make sure a position will be valid after the given change.\n  function clipPostChange(doc, change, pos) {\n    if (!posLess(change.from, pos)) return clipPos(doc, pos);\n    var diff = (change.text.length - 1) - (change.to.line - change.from.line);\n    if (pos.line > change.to.line + diff) {\n      var preLine = pos.line - diff, lastLine = doc.first + doc.size - 1;\n      if (preLine > lastLine) return Pos(lastLine, getLine(doc, lastLine).text.length);\n      return clipToLen(pos, getLine(doc, preLine).text.length);\n    }\n    if (pos.line == change.to.line + diff)\n      return clipToLen(pos, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0) +\n                       getLine(doc, change.to.line).text.length - change.to.ch);\n    var inside = pos.line - change.from.line;\n    return clipToLen(pos, change.text[inside].length + (inside ? 0 : change.from.ch));\n  }\n\n  // Hint can be null|"end"|"start"|"around"|{anchor,head}\n  function computeSelAfterChange(doc, change, hint) {\n    if (hint && typeof hint == "object") // Assumed to be {anchor, head} object\n      return {anchor: clipPostChange(doc, change, hint.anchor),\n              head: clipPostChange(doc, change, hint.head)};\n\n    if (hint == "start") return {anchor: change.from, head: change.from};\n\n    var end = changeEnd(change);\n    if (hint == "around") return {anchor: change.from, head: end};\n    if (hint == "end") return {anchor: end, head: end};\n\n    // hint is null, leave the selection alone as much as possible\n    var adjustPos = function(pos) {\n      if (posLess(pos, change.from)) return pos;\n      if (!posLess(change.to, pos)) return end;\n\n      var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n      if (pos.line == change.to.line) ch += end.ch - change.to.ch;\n      return Pos(line, ch);\n    };\n    return {anchor: adjustPos(doc.sel.anchor), head: adjustPos(doc.sel.head)};\n  }\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function() { this.canceled = true; }\n    };\n    if (update) obj.update = function(from, to, text, origin) {\n      if (from) this.from = clipPos(doc, from);\n      if (to) this.to = clipPos(doc, to);\n      if (text) this.text = text;\n      if (origin !== undefined) this.origin = origin;\n    };\n    signal(doc, "beforeChange", doc, obj);\n    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);\n\n    if (obj.canceled) return null;\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\n  }\n\n  // Replace the range from from to to by the strings in replacement.\n  // change is a {from, to, text [, origin]} object\n  function makeChange(doc, change, selUpdate, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, selUpdate, ignoreReadOnly);\n      if (doc.cm.state.suppressEdits) return;\n    }\n\n    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {\n      change = filterChange(doc, change, true);\n      if (!change) return;\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 1; --i)\n        makeChangeNoReadonly(doc, {from: split[i].from, to: split[i].to, text: [""]});\n      if (split.length)\n        makeChangeNoReadonly(doc, {from: split[0].from, to: split[0].to, text: change.text}, selUpdate);\n    } else {\n      makeChangeNoReadonly(doc, change, selUpdate);\n    }\n  }\n\n  function makeChangeNoReadonly(doc, change, selUpdate) {\n    if (change.text.length == 1 && change.text[0] == "" && posEq(change.from, change.to)) return;\n    var selAfter = computeSelAfterChange(doc, change, selUpdate);\n    addToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function(doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  function makeChangeFromHistory(doc, type) {\n    if (doc.cm && doc.cm.state.suppressEdits) return;\n\n    var hist = doc.history;\n    var event = (type == "undo" ? hist.done : hist.undone).pop();\n    if (!event) return;\n\n    var anti = {changes: [], anchorBefore: event.anchorAfter, headBefore: event.headAfter,\n                anchorAfter: event.anchorBefore, headAfter: event.headBefore,\n                generation: hist.generation};\n    (type == "undo" ? hist.undone : hist.done).push(anti);\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");\n\n    for (var i = event.changes.length - 1; i >= 0; --i) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        (type == "undo" ? hist.done : hist.undone).length = 0;\n        return;\n      }\n\n      anti.changes.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change, null)\n                    : {anchor: event.anchorBefore, head: event.headBefore};\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      var rebased = [];\n\n      linkedDocs(doc, function(doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    }\n  }\n\n  function shiftDoc(doc, distance) {\n    function shiftPos(pos) {return Pos(pos.line + distance, pos.ch);}\n    doc.first += distance;\n    if (doc.cm) regChange(doc.cm, doc.first, doc.first, distance);\n    doc.sel.head = shiftPos(doc.sel.head); doc.sel.anchor = shiftPos(doc.sel.anchor);\n    doc.sel.from = shiftPos(doc.sel.from); doc.sel.to = shiftPos(doc.sel.to);\n  }\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n    if (change.from.line > doc.lastLine()) return;\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change, null);\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans, selAfter);\n    else updateDoc(doc, change, spans, selAfter);\n  }\n\n  function makeChangeSingleDocInEditor(cm, change, spans, selAfter) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(doc, getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (!posLess(doc.sel.head, change.from) && !posLess(change.to, doc.sel.head))\n      cm.curOp.cursorActivity = true;\n\n    updateDoc(doc, change, spans, selAfter, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\n        var len = lineLength(doc, line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\n    }\n\n    // Adjust frontier, schedule worker\n    doc.frontier = Math.min(doc.frontier, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    regChange(cm, from.line, to.line + 1, lendiff);\n\n    if (hasHandler(cm, "change")) {\n      var changeObj = {from: from, to: to,\n                       text: change.text,\n                       removed: change.removed,\n                       origin: change.origin};\n      if (cm.curOp.textChanged) {\n        for (var cur = cm.curOp.textChanged; cur.next; cur = cur.next) {}\n        cur.next = changeObj;\n      } else cm.curOp.textChanged = changeObj;\n    }\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    if (!to) to = from;\n    if (posLess(to, from)) { var tmp = to; to = from; from = tmp; }\n    if (typeof code == "string") code = splitLines(code);\n    makeChange(doc, {from: from, to: to, text: code, origin: origin}, null);\n  }\n\n  // POSITION OBJECT\n\n  function Pos(line, ch) {\n    if (!(this instanceof Pos)) return new Pos(line, ch);\n    this.line = line; this.ch = ch;\n  }\n  CodeMirror.Pos = Pos;\n\n  function posEq(a, b) {return a.line == b.line && a.ch == b.ch;}\n  function posLess(a, b) {return a.line < b.line || (a.line == b.line && a.ch < b.ch);}\n  function cmp(a, b) {return a.line - b.line || a.ch - b.ch;}\n  function copyPos(x) {return Pos(x.line, x.ch);}\n\n  // SELECTION\n\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) return Pos(doc.first, 0);\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\n    else if (ch < 0) return Pos(pos.line, 0);\n    else return pos;\n  }\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\n\n  // If shift is held, this will move the selection anchor. Otherwise,\n  // it'll set the whole selection.\n  function extendSelection(doc, pos, other, bias) {\n    if (doc.sel.shift || doc.sel.extend) {\n      var anchor = doc.sel.anchor;\n      if (other) {\n        var posBefore = posLess(pos, anchor);\n        if (posBefore != posLess(other, anchor)) {\n          anchor = pos;\n          pos = other;\n        } else if (posBefore != posLess(pos, other)) {\n          pos = other;\n        }\n      }\n      setSelection(doc, anchor, pos, bias);\n    } else {\n      setSelection(doc, pos, other || pos, bias);\n    }\n    if (doc.cm) doc.cm.curOp.userSelChange = true;\n  }\n\n  function filterSelectionChange(doc, anchor, head) {\n    var obj = {anchor: anchor, head: head};\n    signal(doc, "beforeSelectionChange", doc, obj);\n    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);\n    obj.anchor = clipPos(doc, obj.anchor); obj.head = clipPos(doc, obj.head);\n    return obj;\n  }\n\n  // Update the selection. Last two args are only used by\n  // updateDoc, since they have to be expressed in the line\n  // numbers before the update.\n  function setSelection(doc, anchor, head, bias, checkAtomic) {\n    if (!checkAtomic && hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {\n      var filtered = filterSelectionChange(doc, anchor, head);\n      head = filtered.head;\n      anchor = filtered.anchor;\n    }\n\n    var sel = doc.sel;\n    sel.goalColumn = null;\n    if (bias == null) bias = posLess(head, sel.head) ? -1 : 1;\n    // Skip over atomic spans.\n    if (checkAtomic || !posEq(anchor, sel.anchor))\n      anchor = skipAtomic(doc, anchor, bias, checkAtomic != "push");\n    if (checkAtomic || !posEq(head, sel.head))\n      head = skipAtomic(doc, head, bias, checkAtomic != "push");\n\n    if (posEq(sel.anchor, anchor) && posEq(sel.head, head)) return;\n\n    sel.anchor = anchor; sel.head = head;\n    var inv = posLess(head, anchor);\n    sel.from = inv ? head : anchor;\n    sel.to = inv ? anchor : head;\n\n    if (doc.cm)\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged =\n        doc.cm.curOp.cursorActivity = true;\n\n    signalLater(doc, "cursorActivity", doc);\n  }\n\n  function reCheckSelection(cm) {\n    setSelection(cm.doc, cm.doc.sel.from, cm.doc.sel.to, null, "push");\n  }\n\n  function skipAtomic(doc, pos, bias, mayClear) {\n    var flipped = false, curPos = pos;\n    var dir = bias || 1;\n    doc.cantEdit = false;\n    search: for (;;) {\n      var line = getLine(doc, curPos.line);\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var sp = line.markedSpans[i], m = sp.marker;\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\n            if (mayClear) {\n              signal(m, "beforeCursorEnter");\n              if (m.explicitlyCleared) {\n                if (!line.markedSpans) break;\n                else {--i; continue;}\n              }\n            }\n            if (!m.atomic) continue;\n            var newPos = m.find()[dir < 0 ? "from" : "to"];\n            if (posEq(newPos, curPos)) {\n              newPos.ch += dir;\n              if (newPos.ch < 0) {\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\n                else newPos = null;\n              } else if (newPos.ch > line.text.length) {\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\n                else newPos = null;\n              }\n              if (!newPos) {\n                if (flipped) {\n                  // Driven in a corner -- no valid cursor position found at all\n                  // -- try again *with* clearing, if we didn't already\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\n                  doc.cantEdit = true;\n                  return Pos(doc.first, 0);\n                }\n                flipped = true; newPos = pos; dir = -dir;\n              }\n            }\n            curPos = newPos;\n            continue search;\n          }\n        }\n      }\n      return curPos;\n    }\n  }\n\n  // SCROLLING\n\n  function scrollCursorIntoView(cm) {\n    var coords = scrollPosIntoView(cm, cm.doc.sel.head, null, cm.options.cursorScrollMargin);\n    if (!cm.state.focused) return;\n    var display = cm.display, box = getRect(display.sizer), doScroll = null;\n    if (coords.top + box.top < 0) doScroll = true;\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt("div", "\\u200b", null, "position: absolute; top: " +\n                           (coords.top - display.viewOffset) + "px; height: " +\n                           (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +\n                           coords.left + "px; width: 2px;");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) margin = 0;\n    for (;;) {\n      var changed = false, coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\n                                         Math.min(coords.top, endCoords.top) - margin,\n                                         Math.max(coords.left, endCoords.left),\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        setScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\n      }\n      if (!changed) return coords;\n    }\n  }\n\n  function scrollIntoView(cm, x1, y1, x2, y2) {\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\n  }\n\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (y1 < 0) y1 = 0;\n    var screen = display.scroller.clientHeight - scrollerCutOff, screentop = display.scroller.scrollTop, result = {};\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\n    if (y1 < screentop) {\n      result.scrollTop = atTop ? 0 : y1;\n    } else if (y2 > screentop + screen) {\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\n      if (newTop != screentop) result.scrollTop = newTop;\n    }\n\n    var screenw = display.scroller.clientWidth - scrollerCutOff, screenleft = display.scroller.scrollLeft;\n    x1 += display.gutters.offsetWidth; x2 += display.gutters.offsetWidth;\n    var gutterw = display.gutters.offsetWidth;\n    var atLeft = x1 < gutterw + 10;\n    if (x1 < screenleft + gutterw || atLeft) {\n      if (atLeft) x1 = 0;\n      result.scrollLeft = Math.max(0, x1 - 10 - gutterw);\n    } else if (x2 > screenw + screenleft - 3) {\n      result.scrollLeft = x2 + 10 - screenw;\n    }\n    return result;\n  }\n\n  function updateScrollPos(cm, left, top) {\n    cm.curOp.updateScrollPos = {scrollLeft: left == null ? cm.doc.scrollLeft : left,\n                                scrollTop: top == null ? cm.doc.scrollTop : top};\n  }\n\n  function addToScrollPos(cm, left, top) {\n    var pos = cm.curOp.updateScrollPos || (cm.curOp.updateScrollPos = {scrollLeft: cm.doc.scrollLeft, scrollTop: cm.doc.scrollTop});\n    var scroll = cm.display.scroller;\n    pos.scrollTop = Math.max(0, Math.min(scroll.scrollHeight - scroll.clientHeight, pos.scrollTop + top));\n    pos.scrollLeft = Math.max(0, Math.min(scroll.scrollWidth - scroll.clientWidth, pos.scrollLeft + left));\n  }\n\n  // API UTILITIES\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc;\n    if (how == null) how = "add";\n    if (how == "smart") {\n      if (!cm.doc.mode.indent) how = "prev";\n      else var state = getStateBefore(cm, n);\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = "not";\n    } else if (how == "smart") {\n      indentation = cm.doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass) {\n        if (!aggressive) return;\n        how = "prev";\n      }\n    }\n    if (how == "prev") {\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\n      else indentation = 0;\n    } else if (how == "add") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == "subtract") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == "number") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = "", pos = 0;\n    if (cm.options.indentWithTabs)\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\\t";}\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\n\n    if (indentString != curSpaceString)\n      replaceRange(cm.doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");\n    else if (doc.sel.head.line == n && doc.sel.head.ch < curSpaceString.length)\n      setSelection(doc, Pos(n, curSpaceString.length), Pos(n, curSpaceString.length), 1);\n    line.stateAfter = null;\n  }\n\n  function changeLine(cm, handle, op) {\n    var no = handle, line = handle, doc = cm.doc;\n    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));\n    else no = lineNo(handle);\n    if (no == null) return null;\n    if (op(line, no)) regChange(cm, no, no + 1);\n    else return null;\n    return line;\n  }\n\n  function findPosH(doc, pos, dir, unit, visually) {\n    var line = pos.line, ch = pos.ch, origDir = dir;\n    var lineObj = getLine(doc, line);\n    var possible = true;\n    function findNextLine() {\n      var l = line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\n      line = l;\n      return lineObj = getLine(doc, l);\n    }\n    function moveOnce(boundToLine) {\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\n          else ch = dir < 0 ? lineObj.text.length : 0;\n        } else return (possible = false);\n      } else ch = next;\n      return true;\n    }\n\n    if (unit == "char") moveOnce();\n    else if (unit == "column") moveOnce(true);\n    else if (unit == "word" || unit == "group") {\n      var sawType = null, group = unit == "group";\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) break;\n        var cur = lineObj.text.charAt(ch) || "\\n";\n        var type = isWordChar(cur) ? "w"\n          : !group ? null\n          : /\\s/.test(cur) ? null\n          : "p";\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce();}\n          break;\n        }\n        if (type) sawType = type;\n        if (dir > 0 && !moveOnce(!first)) break;\n      }\n    }\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\n    if (!possible) result.hitSide = true;\n    return result;\n  }\n\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == "page") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\n    } else if (unit == "line") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    for (;;) {\n      var target = coordsChar(cm, x, y);\n      if (!target.outside) break;\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\n      y += dir * 5;\n    }\n    return target;\n  }\n\n  function findWordAt(line, pos) {\n    var start = pos.ch, end = pos.ch;\n    if (line) {\n      if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\n      var startChar = line.charAt(start);\n      var check = isWordChar(startChar) ? isWordChar\n        : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\n        : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\n      while (start > 0 && check(line.charAt(start - 1))) --start;\n      while (end < line.length && check(line.charAt(end))) ++end;\n    }\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end)};\n  }\n\n  function selectLine(cm, line) {\n    extendSelection(cm.doc, Pos(line, 0), clipPos(cm.doc, Pos(line + 1, 0)));\n  }\n\n  // PROTOTYPE\n\n  // The publicly visible API. Note that operation(null, f) means\n  // 'wrap f in an operation, performed on its `this` parameter'\n\n  CodeMirror.prototype = {\n    constructor: CodeMirror,\n    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\n\n    setOption: function(option, value) {\n      var options = this.options, old = options[option];\n      if (options[option] == value && option != "mode") return;\n      options[option] = value;\n      if (optionHandlers.hasOwnProperty(option))\n        operation(this, optionHandlers[option])(this, value, old);\n    },\n\n    getOption: function(option) {return this.options[option];},\n    getDoc: function() {return this.doc;},\n\n    addKeyMap: function(map, bottom) {\n      this.state.keyMaps[bottom ? "push" : "unshift"](map);\n    },\n    removeKeyMap: function(map) {\n      var maps = this.state.keyMaps;\n      for (var i = 0; i < maps.length; ++i)\n        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {\n          maps.splice(i, 1);\n          return true;\n        }\n    },\n\n    addOverlay: operation(null, function(spec, options) {\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n      if (mode.startState) throw new Error("Overlays may not be stateful.");\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\n      this.state.modeGen++;\n      regChange(this);\n    }),\n    removeOverlay: operation(null, function(spec) {\n      var overlays = this.state.overlays;\n      for (var i = 0; i < overlays.length; ++i) {\n        var cur = overlays[i].modeSpec;\n        if (cur == spec || typeof spec == "string" && cur.name == spec) {\n          overlays.splice(i, 1);\n          this.state.modeGen++;\n          regChange(this);\n          return;\n        }\n      }\n    }),\n\n    indentLine: operation(null, function(n, dir, aggressive) {\n      if (typeof dir != "string" && typeof dir != "number") {\n        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";\n        else dir = dir ? "add" : "subtract";\n      }\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\n    }),\n    indentSelection: operation(null, function(how) {\n      var sel = this.doc.sel;\n      if (posEq(sel.from, sel.to)) return indentLine(this, sel.from.line, how, true);\n      var e = sel.to.line - (sel.to.ch ? 0 : 1);\n      for (var i = sel.from.line; i <= e; ++i) indentLine(this, i, how);\n    }),\n\n    // Fetch the parser token for a given character. Useful for hacks\n    // that want to inspect the mode state (say, for completion).\n    getTokenAt: function(pos, precise) {\n      var doc = this.doc;\n      pos = clipPos(doc, pos);\n      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\n      var line = getLine(doc, pos.line);\n      var stream = new StringStream(line.text, this.options.tabSize);\n      while (stream.pos < pos.ch && !stream.eol()) {\n        stream.start = stream.pos;\n        var style = mode.token(stream, state);\n      }\n      return {start: stream.start,\n              end: stream.pos,\n              string: stream.current(),\n              className: style || null, // Deprecated, use 'type' instead\n              type: style || null,\n              state: state};\n    },\n\n    getTokenTypeAt: function(pos) {\n      pos = clipPos(this.doc, pos);\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n      if (ch == 0) return styles[2];\n      for (;;) {\n        var mid = (before + after) >> 1;\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\n        else return styles[mid * 2 + 2];\n      }\n    },\n\n    getModeAt: function(pos) {\n      var mode = this.doc.mode;\n      if (!mode.innerMode) return mode;\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n    },\n\n    getHelper: function(pos, type) {\n      return this.getHelpers(pos, type)[0];\n    },\n\n    getHelpers: function(pos, type) {\n      var found = [];\n      if (!helpers.hasOwnProperty(type)) return helpers;\n      var help = helpers[type], mode = this.getModeAt(pos);\n      if (typeof mode[type] == "string") {\n        if (help[mode[type]]) found.push(help[mode[type]]);\n      } else if (mode[type]) {\n        for (var i = 0; i < mode[type].length; i++) {\n          var val = help[mode[type][i]];\n          if (val) found.push(val);\n        }\n      } else if (mode.helperType && help[mode.helperType]) {\n        found.push(help[mode.helperType]);\n      } else if (help[mode.name]) {\n        found.push(help[mode.name]);\n      }\n      for (var i = 0; i < help._global.length; i++) {\n        var cur = help._global[i];\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\n          found.push(cur.val);\n      }\n      return found;\n    },\n\n    getStateAfter: function(line, precise) {\n      var doc = this.doc;\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n      return getStateBefore(this, line + 1, precise);\n    },\n\n    cursorCoords: function(start, mode) {\n      var pos, sel = this.doc.sel;\n      if (start == null) pos = sel.head;\n      else if (typeof start == "object") pos = clipPos(this.doc, start);\n      else pos = start ? sel.from : sel.to;\n      return cursorCoords(this, pos, mode || "page");\n    },\n\n    charCoords: function(pos, mode) {\n      return charCoords(this, clipPos(this.doc, pos), mode || "page");\n    },\n\n    coordsChar: function(coords, mode) {\n      coords = fromCoordSystem(this, coords, mode || "page");\n      return coordsChar(this, coords.left, coords.top);\n    },\n\n    lineAtHeight: function(height, mode) {\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\n    },\n    heightAtLine: function(line, mode) {\n      var end = false, last = this.doc.first + this.doc.size - 1;\n      if (line < this.doc.first) line = this.doc.first;\n      else if (line > last) { line = last; end = true; }\n      var lineObj = getLine(this.doc, line);\n      return intoCoordSystem(this, getLine(this.doc, line), {top: 0, left: 0}, mode || "page").top +\n        (end ? lineObj.height : 0);\n    },\n\n    defaultTextHeight: function() { return textHeight(this.display); },\n    defaultCharWidth: function() { return charWidth(this.display); },\n\n    setGutterMarker: operation(null, function(line, gutterID, value) {\n      return changeLine(this, line, function(line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\n        return true;\n      });\n    }),\n\n    clearGutter: operation(null, function(gutterID) {\n      var cm = this, doc = cm.doc, i = doc.first;\n      doc.iter(function(line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          line.gutterMarkers[gutterID] = null;\n          regChange(cm, i, i + 1);\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\n        }\n        ++i;\n      });\n    }),\n\n    addLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\n        if (!line[prop]) line[prop] = cls;\n        else if (new RegExp("(?:^|\\\\s)" + cls + "(?:$|\\\\s)").test(line[prop])) return false;\n        else line[prop] += " " + cls;\n        return true;\n      });\n    }),\n\n    removeLineClass: operation(null, function(handle, where, cls) {\n      return changeLine(this, handle, function(line) {\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\n        var cur = line[prop];\n        if (!cur) return false;\n        else if (cls == null) line[prop] = null;\n        else {\n          var found = cur.match(new RegExp("(?:^|\\\\s+)" + cls + "(?:$|\\\\s+)"));\n          if (!found) return false;\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;\n        }\n        return true;\n      });\n    }),\n\n    addLineWidget: operation(null, function(handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    lineInfo: function(line) {\n      if (typeof line == "number") {\n        if (!isLine(this.doc, line)) return null;\n        var n = line;\n        line = getLine(this.doc, line);\n        if (!line) return null;\n      } else {\n        var n = lineNo(line);\n        if (n == null) return null;\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets};\n    },\n\n    getViewport: function() { return {from: this.display.showingFrom, to: this.display.showingTo};},\n\n    addWidget: function(pos, node, scroll, vert, horiz) {\n      var display = this.display;\n      pos = cursorCoords(this, clipPos(this.doc, pos));\n      var top = pos.bottom, left = pos.left;\n      node.style.position = "absolute";\n      display.sizer.appendChild(node);\n      if (vert == "over") {\n        top = pos.top;\n      } else if (vert == "above" || vert == "near") {\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\n        if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n          top = pos.top - node.offsetHeight;\n        else if (pos.bottom + node.offsetHeight <= vspace)\n          top = pos.bottom;\n        if (left + node.offsetWidth > hspace)\n          left = hspace - node.offsetWidth;\n      }\n      node.style.top = top + "px";\n      node.style.left = node.style.right = "";\n      if (horiz == "right") {\n        left = display.sizer.clientWidth - node.offsetWidth;\n        node.style.right = "0px";\n      } else {\n        if (horiz == "left") left = 0;\n        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n        node.style.left = left + "px";\n      }\n      if (scroll)\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\n    },\n\n    triggerOnKeyDown: operation(null, onKeyDown),\n\n    execCommand: function(cmd) {\n      if (commands.hasOwnProperty(cmd))\n        return commands[cmd](this);\n    },\n\n    findPosH: function(from, amount, unit, visually) {\n      var dir = 1;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        cur = findPosH(this.doc, cur, dir, unit, visually);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, pos;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to))\n        pos = findPosH(this.doc, sel.head, dir, unit, this.options.rtlMoveVisually);\n      else\n        pos = dir < 0 ? sel.from : sel.to;\n      extendSelection(this.doc, pos, pos, dir);\n    }),\n\n    deleteH: operation(null, function(dir, unit) {\n      var sel = this.doc.sel;\n      if (!posEq(sel.from, sel.to)) replaceRange(this.doc, "", sel.from, sel.to, "+delete");\n      else replaceRange(this.doc, "", sel.from, findPosH(this.doc, sel.head, dir, unit, false), "+delete");\n      this.curOp.userSelChange = true;\n    }),\n\n    findPosV: function(from, amount, unit, goalColumn) {\n      var dir = 1, x = goalColumn;\n      if (amount < 0) { dir = -1; amount = -amount; }\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\n        var coords = cursorCoords(this, cur, "div");\n        if (x == null) x = coords.left;\n        else coords.left = x;\n        cur = findPosV(this, coords, dir, unit);\n        if (cur.hitSide) break;\n      }\n      return cur;\n    },\n\n    moveV: operation(null, function(dir, unit) {\n      var sel = this.doc.sel, target, goal;\n      if (sel.shift || sel.extend || posEq(sel.from, sel.to)) {\n        var pos = cursorCoords(this, sel.head, "div");\n        if (sel.goalColumn != null) pos.left = sel.goalColumn;\n        target = findPosV(this, pos, dir, unit);\n        if (unit == "page") addToScrollPos(this, 0, charCoords(this, target, "div").top - pos.top);\n        goal = pos.left;\n      } else {\n        target = dir < 0 ? sel.from : sel.to;\n      }\n      extendSelection(this.doc, target, target, dir);\n      if (goal != null) sel.goalColumn = goal;\n    }),\n\n    toggleOverwrite: function(value) {\n      if (value != null && value == this.state.overwrite) return;\n      if (this.state.overwrite = !this.state.overwrite)\n        this.display.cursor.className += " CodeMirror-overwrite";\n      else\n        this.display.cursor.className = this.display.cursor.className.replace(" CodeMirror-overwrite", "");\n    },\n    hasFocus: function() { return this.state.focused; },\n\n    scrollTo: operation(null, function(x, y) {\n      updateScrollPos(this, x, y);\n    }),\n    getScrollInfo: function() {\n      var scroller = this.display.scroller, co = scrollerCutOff;\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\n    },\n\n    scrollIntoView: operation(null, function(range, margin) {\n      if (range == null) range = {from: this.doc.sel.head, to: null};\n      else if (typeof range == "number") range = {from: Pos(range, 0), to: null};\n      else if (range.from == null) range = {from: range, to: null};\n      if (!range.to) range.to = range.from;\n      if (!margin) margin = 0;\n\n      var coords = range;\n      if (range.from.line != null) {\n        this.curOp.scrollToPos = {from: range.from, to: range.to, margin: margin};\n        coords = {from: cursorCoords(this, range.from),\n                  to: cursorCoords(this, range.to)};\n      }\n      var sPos = calculateScrollPos(this, Math.min(coords.from.left, coords.to.left),\n                                    Math.min(coords.from.top, coords.to.top) - margin,\n                                    Math.max(coords.from.right, coords.to.right),\n                                    Math.max(coords.from.bottom, coords.to.bottom) + margin);\n      updateScrollPos(this, sPos.scrollLeft, sPos.scrollTop);\n    }),\n\n    setSize: operation(null, function(width, height) {\n      function interpret(val) {\n        return typeof val == "number" || /^\\d+$/.test(String(val)) ? val + "px" : val;\n      }\n      if (width != null) this.display.wrapper.style.width = interpret(width);\n      if (height != null) this.display.wrapper.style.height = interpret(height);\n      if (this.options.lineWrapping)\n        this.display.measureLineCache.length = this.display.measureLineCachePos = 0;\n      this.curOp.forceUpdate = true;\n    }),\n\n    operation: function(f){return runInOp(this, f);},\n\n    refresh: operation(null, function() {\n      var badHeight = this.display.cachedTextHeight == null;\n      clearCaches(this);\n      updateScrollPos(this, this.doc.scrollLeft, this.doc.scrollTop);\n      regChange(this);\n      if (badHeight) estimateLineHeights(this);\n    }),\n\n    swapDoc: operation(null, function(doc) {\n      var old = this.doc;\n      old.cm = null;\n      attachDoc(this, doc);\n      clearCaches(this);\n      resetInput(this, true);\n      updateScrollPos(this, doc.scrollLeft, doc.scrollTop);\n      signalLater(this, "swapDoc", this, old);\n      return old;\n    }),\n\n    getInputField: function(){return this.display.input;},\n    getWrapperElement: function(){return this.display.wrapper;},\n    getScrollerElement: function(){return this.display.scroller;},\n    getGutterElement: function(){return this.display.gutters;}\n  };\n  eventMixin(CodeMirror);\n\n  // OPTION DEFAULTS\n\n  var optionHandlers = CodeMirror.optionHandlers = {};\n\n  // The default configuration options.\n  var defaults = CodeMirror.defaults = {};\n\n  function option(name, deflt, handle, notOnInit) {\n    CodeMirror.defaults[name] = deflt;\n    if (handle) optionHandlers[name] =\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\n  }\n\n  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};\n\n  // These two are, on init, called from the constructor because they\n  // have to be initialized before the editor can start at all.\n  option("value", "", function(cm, val) {\n    cm.setValue(val);\n  }, true);\n  option("mode", null, function(cm, val) {\n    cm.doc.modeOption = val;\n    loadMode(cm);\n  }, true);\n\n  option("indentUnit", 2, loadMode, true);\n  option("indentWithTabs", false);\n  option("smartIndent", true);\n  option("tabSize", 4, function(cm) {\n    resetModeState(cm);\n    clearCaches(cm);\n    regChange(cm);\n  }, true);\n  option("specialChars", /[\\t\\u0000-\\u0019\\u00ad\\u200b\\u2028\\u2029\\ufeff]/g, function(cm, val) {\n    cm.options.specialChars = new RegExp(val.source + (val.test("\\t") ? "" : "|\\t"), "g");\n    cm.refresh();\n  }, true);\n  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\n  option("electricChars", true);\n  option("rtlMoveVisually", !windows);\n  option("wholeLineUpdateBefore", true);\n\n  option("theme", "default", function(cm) {\n    themeChanged(cm);\n    guttersChanged(cm);\n  }, true);\n  option("keyMap", "default", keyMapChanged);\n  option("extraKeys", null);\n\n  option("onKeyEvent", null);\n  option("onDragEvent", null);\n\n  option("lineWrapping", false, wrappingChanged, true);\n  option("gutters", [], function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option("fixedGutter", true, function(cm, val) {\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";\n    cm.refresh();\n  }, true);\n  option("coverGutterNextToScrollbar", false, updateScrollbars, true);\n  option("lineNumbers", false, function(cm) {\n    setGuttersForLineNumbers(cm.options);\n    guttersChanged(cm);\n  }, true);\n  option("firstLineNumber", 1, guttersChanged, true);\n  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);\n  option("showCursorWhenSelecting", false, updateSelection, true);\n\n  option("resetSelectionOnContextMenu", true);\n\n  option("readOnly", false, function(cm, val) {\n    if (val == "nocursor") {\n      onBlur(cm);\n      cm.display.input.blur();\n      cm.display.disabled = true;\n    } else {\n      cm.display.disabled = false;\n      if (!val) resetInput(cm, true);\n    }\n  });\n  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm, true);}, true);\n  option("dragDrop", true);\n\n  option("cursorBlinkRate", 530);\n  option("cursorScrollMargin", 0);\n  option("cursorHeight", 1);\n  option("workTime", 100);\n  option("workDelay", 100);\n  option("flattenSpans", true, resetModeState, true);\n  option("addModeClass", false, resetModeState, true);\n  option("pollInterval", 100);\n  option("undoDepth", 40, function(cm, val){cm.doc.history.undoDepth = val;});\n  option("historyEventDelay", 500);\n  option("viewportMargin", 10, function(cm){cm.refresh();}, true);\n  option("maxHighlightLength", 10000, resetModeState, true);\n  option("crudeMeasuringFrom", 10000);\n  option("moveInputWithCursor", true, function(cm, val) {\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\n  });\n\n  option("tabindex", null, function(cm, val) {\n    cm.display.input.tabIndex = val || "";\n  });\n  option("autofocus", null);\n\n  // MODE DEFINITION AND QUERYING\n\n  // Known modes, by name and by MIME\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\n\n  CodeMirror.defineMode = function(name, mode) {\n    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;\n    if (arguments.length > 2) {\n      mode.dependencies = [];\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\n    }\n    modes[name] = mode;\n  };\n\n  CodeMirror.defineMIME = function(mime, spec) {\n    mimeModes[mime] = spec;\n  };\n\n  CodeMirror.resolveMode = function(spec) {\n    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return CodeMirror.resolveMode("application/xml");\n    }\n    if (typeof spec == "string") return {name: spec};\n    else return spec || {name: "null"};\n  };\n\n  CodeMirror.getMode = function(options, spec) {\n    var spec = CodeMirror.resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) return CodeMirror.getMode(options, "text/plain");\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) continue;\n        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) modeObj.helperType = spec.helperType;\n    if (spec.modeProps) for (var prop in spec.modeProps)\n      modeObj[prop] = spec.modeProps[prop];\n\n    return modeObj;\n  };\n\n  CodeMirror.defineMode("null", function() {\n    return {token: function(stream) {stream.skipToEnd();}};\n  });\n  CodeMirror.defineMIME("text/plain", "null");\n\n  var modeExtensions = CodeMirror.modeExtensions = {};\n  CodeMirror.extendMode = function(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  };\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function(name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function(name, func) {\n    Doc.prototype[name] = func;\n  };\n  CodeMirror.defineOption = option;\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\n\n  var helpers = CodeMirror.helpers = {};\n  CodeMirror.registerHelper = function(type, name, value) {\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\n    helpers[type][name] = value;\n  };\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n    CodeMirror.registerHelper(type, name, value);\n    helpers[type]._global.push({pred: predicate, val: value});\n  };\n\n  // UTILITIES\n\n  CodeMirror.isWordChar = isWordChar;\n\n  // MODE STATE HANDLING\n\n  // Utility functions for working with state. Exported because modes\n  // sometimes need to do this.\n  function copyState(mode, state) {\n    if (state === true) return state;\n    if (mode.copyState) return mode.copyState(state);\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) val = val.concat([]);\n      nstate[n] = val;\n    }\n    return nstate;\n  }\n  CodeMirror.copyState = copyState;\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  }\n  CodeMirror.startState = startState;\n\n  CodeMirror.innerMode = function(mode, state) {\n    while (mode.innerMode) {\n      var info = mode.innerMode(state);\n      if (!info || info.mode == mode) break;\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state};\n  };\n\n  // STANDARD COMMANDS\n\n  var commands = CodeMirror.commands = {\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()));},\n    killLine: function(cm) {\n      var from = cm.getCursor(true), to = cm.getCursor(false), sel = !posEq(from, to);\n      if (!sel && cm.getLine(from.line).length == from.ch)\n        cm.replaceRange("", from, Pos(from.line + 1, 0), "+delete");\n      else cm.replaceRange("", from, sel ? to : Pos(from.line), "+delete");\n    },\n    deleteLine: function(cm) {\n      var l = cm.getCursor().line;\n      cm.replaceRange("", Pos(l, 0), Pos(l), "+delete");\n    },\n    delLineLeft: function(cm) {\n      var cur = cm.getCursor();\n      cm.replaceRange("", Pos(cur.line, 0), cur, "+delete");\n    },\n    undo: function(cm) {cm.undo();},\n    redo: function(cm) {cm.redo();},\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\n    goLineStart: function(cm) {\n      cm.extendSelection(lineStart(cm, cm.getCursor().line));\n    },\n    goLineStartSmart: function(cm) {\n      var cur = cm.getCursor(), start = lineStart(cm, cur.line);\n      var line = cm.getLineHandle(start.line);\n      var order = getOrder(line);\n      if (!order || order[0].level == 0) {\n        var firstNonWS = Math.max(0, line.text.search(/\\S/));\n        var inWS = cur.line == start.line && cur.ch <= firstNonWS && cur.ch;\n        cm.extendSelection(Pos(start.line, inWS ? 0 : firstNonWS));\n      } else cm.extendSelection(start);\n    },\n    goLineEnd: function(cm) {\n      cm.extendSelection(lineEnd(cm, cm.getCursor().line));\n    },\n    goLineRight: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), "div").top + 5;\n      cm.extendSelection(cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div"));\n    },\n    goLineLeft: function(cm) {\n      var top = cm.charCoords(cm.getCursor(), "div").top + 5;\n      cm.extendSelection(cm.coordsChar({left: 0, top: top}, "div"));\n    },\n    goLineUp: function(cm) {cm.moveV(-1, "line");},\n    goLineDown: function(cm) {cm.moveV(1, "line");},\n    goPageUp: function(cm) {cm.moveV(-1, "page");},\n    goPageDown: function(cm) {cm.moveV(1, "page");},\n    goCharLeft: function(cm) {cm.moveH(-1, "char");},\n    goCharRight: function(cm) {cm.moveH(1, "char");},\n    goColumnLeft: function(cm) {cm.moveH(-1, "column");},\n    goColumnRight: function(cm) {cm.moveH(1, "column");},\n    goWordLeft: function(cm) {cm.moveH(-1, "word");},\n    goGroupRight: function(cm) {cm.moveH(1, "group");},\n    goGroupLeft: function(cm) {cm.moveH(-1, "group");},\n    goWordRight: function(cm) {cm.moveH(1, "word");},\n    delCharBefore: function(cm) {cm.deleteH(-1, "char");},\n    delCharAfter: function(cm) {cm.deleteH(1, "char");},\n    delWordBefore: function(cm) {cm.deleteH(-1, "word");},\n    delWordAfter: function(cm) {cm.deleteH(1, "word");},\n    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},\n    delGroupAfter: function(cm) {cm.deleteH(1, "group");},\n    indentAuto: function(cm) {cm.indentSelection("smart");},\n    indentMore: function(cm) {cm.indentSelection("add");},\n    indentLess: function(cm) {cm.indentSelection("subtract");},\n    insertTab: function(cm) {\n      cm.replaceSelection("\\t", "end", "+input");\n    },\n    defaultTab: function(cm) {\n      if (cm.somethingSelected()) cm.indentSelection("add");\n      else cm.replaceSelection("\\t", "end", "+input");\n    },\n    transposeChars: function(cm) {\n      var cur = cm.getCursor(), line = cm.getLine(cur.line);\n      if (cur.ch > 0 && cur.ch < line.length - 1)\n        cm.replaceRange(line.charAt(cur.ch) + line.charAt(cur.ch - 1),\n                        Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\n    },\n    newlineAndIndent: function(cm) {\n      operation(cm, function() {\n        cm.replaceSelection("\\n", "end", "+input");\n        cm.indentLine(cm.getCursor().line, null, true);\n      })();\n    },\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\n  };\n\n  // STANDARD KEYMAPS\n\n  var keyMap = CodeMirror.keyMap = {};\n  keyMap.basic = {\n    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",\n    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",\n    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",\n    "Tab": "defaultTab", "Shift-Tab": "indentAuto",\n    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. Unknown commands are simply ignored.\n  keyMap.pcDefault = {\n    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",\n    "Ctrl-Home": "goDocStart", "Alt-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",\n    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",\n    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",\n    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",\n    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",\n    fallthrough: "basic"\n  };\n  keyMap.macDefault = {\n    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",\n    "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",\n    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineStart", "Cmd-Right": "goLineEnd", "Alt-Backspace": "delGroupBefore",\n    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",\n    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",\n    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delLineLeft",\n    fallthrough: ["basic", "emacsy"]\n  };\n  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n  keyMap.emacsy = {\n    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",\n    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",\n    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",\n    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"\n  };\n\n  // KEYMAP DISPATCH\n\n  function getKeyMap(val) {\n    if (typeof val == "string") return keyMap[val];\n    else return val;\n  }\n\n  function lookupKey(name, maps, handle) {\n    function lookup(map) {\n      map = getKeyMap(map);\n      var found = map[name];\n      if (found === false) return "stop";\n      if (found != null && handle(found)) return true;\n      if (map.nofallthrough) return "stop";\n\n      var fallthrough = map.fallthrough;\n      if (fallthrough == null) return false;\n      if (Object.prototype.toString.call(fallthrough) != "[object Array]")\n        return lookup(fallthrough);\n      for (var i = 0, e = fallthrough.length; i < e; ++i) {\n        var done = lookup(fallthrough[i]);\n        if (done) return done;\n      }\n      return false;\n    }\n\n    for (var i = 0; i < maps.length; ++i) {\n      var done = lookup(maps[i]);\n      if (done) return done != "stop";\n    }\n  }\n  function isModifierKey(event) {\n    var name = keyNames[event.keyCode];\n    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";\n  }\n  function keyName(event, noShift) {\n    if (opera && event.keyCode == 34 && event["char"]) return false;\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) return false;\n    if (event.altKey) name = "Alt-" + name;\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;\n    if (!noShift && event.shiftKey) name = "Shift-" + name;\n    return name;\n  }\n  CodeMirror.lookupKey = lookupKey;\n  CodeMirror.isModifierKey = isModifierKey;\n  CodeMirror.keyName = keyName;\n\n  // FROMTEXTAREA\n\n  CodeMirror.fromTextArea = function(textarea, options) {\n    if (!options) options = {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabindex)\n      options.tabindex = textarea.tabindex;\n    if (!options.placeholder && textarea.placeholder)\n      options.placeholder = textarea.placeholder;\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = document.body;\n      // doc.activeElement occasionally throws on IE\n      try { hasFocus = document.activeElement; } catch(e) {}\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute("autofocus") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n    if (textarea.form) {\n      on(textarea.form, "submit", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form, realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function() {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    textarea.style.display = "none";\n    var cm = CodeMirror(function(node) {\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    cm.save = save;\n    cm.getTextArea = function() { return textarea; };\n    cm.toTextArea = function() {\n      save();\n      textarea.parentNode.removeChild(cm.getWrapperElement());\n      textarea.style.display = "";\n      if (textarea.form) {\n        off(textarea.form, "submit", save);\n        if (typeof textarea.form.submit == "function")\n          textarea.form.submit = realSubmit;\n      }\n    };\n    return cm;\n  };\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  // The character stream used by a mode's parser.\n  function StringStream(string, tabSize) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n  }\n\n  StringStream.prototype = {\n    eol: function() {return this.pos >= this.string.length;},\n    sol: function() {return this.pos == this.lineStart;},\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\n    next: function() {\n      if (this.pos < this.string.length)\n        return this.string.charAt(this.pos++);\n    },\n    eat: function(match) {\n      var ch = this.string.charAt(this.pos);\n      if (typeof match == "string") var ok = ch == match;\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\n      if (ok) {++this.pos; return ch;}\n    },\n    eatWhile: function(match) {\n      var start = this.pos;\n      while (this.eat(match)){}\n      return this.pos > start;\n    },\n    eatSpace: function() {\n      var start = this.pos;\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n      return this.pos > start;\n    },\n    skipToEnd: function() {this.pos = this.string.length;},\n    skipTo: function(ch) {\n      var found = this.string.indexOf(ch, this.pos);\n      if (found > -1) {this.pos = found; return true;}\n    },\n    backUp: function(n) {this.pos -= n;},\n    column: function() {\n      if (this.lastColumnPos < this.start) {\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n        this.lastColumnPos = this.start;\n      }\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    indentation: function() {\n      return countColumn(this.string, null, this.tabSize) -\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n    },\n    match: function(pattern, consume, caseInsensitive) {\n      if (typeof pattern == "string") {\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\n        var substr = this.string.substr(this.pos, pattern.length);\n        if (cased(substr) == cased(pattern)) {\n          if (consume !== false) this.pos += pattern.length;\n          return true;\n        }\n      } else {\n        var match = this.string.slice(this.pos).match(pattern);\n        if (match && match.index > 0) return null;\n        if (match && consume !== false) this.pos += match[0].length;\n        return match;\n      }\n    },\n    current: function(){return this.string.slice(this.start, this.pos);},\n    hideFirstChars: function(n, inner) {\n      this.lineStart += n;\n      try { return inner(); }\n      finally { this.lineStart -= n; }\n    }\n  };\n  CodeMirror.StringStream = StringStream;\n\n  // TEXTMARKERS\n\n  function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n  }\n  CodeMirror.TextMarker = TextMarker;\n  eventMixin(TextMarker);\n\n  TextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) startOperation(cm);\n    if (hasHandler(this, "clear")) {\n      var found = this.find();\n      if (found) signalLater(this, "clear", found.from, found.to);\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.to != null) max = lineNo(line);\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from != null)\n        min = lineNo(line);\n      else if (this.collapsed && !lineIsHidden(this.doc, line) && cm)\n        updateLineHeight(line, textHeight(cm.display));\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\n      var visual = visualLine(cm.doc, this.lines[i]), len = lineLength(cm.doc, visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    }\n\n    if (min != null && cm) regChange(cm, min, max + 1);\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) reCheckSelection(cm);\n    }\n    if (withOp) endOperation(cm);\n  };\n\n  TextMarker.prototype.find = function(bothSides) {\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n      if (span.from != null || span.to != null) {\n        var found = lineNo(line);\n        if (span.from != null) from = Pos(found, span.from);\n        if (span.to != null) to = Pos(found, span.to);\n      }\n    }\n    if (this.type == "bookmark" && !bothSides) return from;\n    return from && {from: from, to: to};\n  };\n\n  TextMarker.prototype.changed = function() {\n    var pos = this.find(), cm = this.doc.cm;\n    if (!pos || !cm) return;\n    if (this.type != "bookmark") pos = pos.from;\n    var line = getLine(this.doc, pos.line);\n    clearCachedMeasurement(cm, line);\n    if (pos.line >= cm.display.showingFrom && pos.line < cm.display.showingTo) {\n      for (var node = cm.display.lineDiv.firstChild; node; node = node.nextSibling) if (node.lineObj == line) {\n        if (node.offsetHeight != line.height) updateLineHeight(line, node.offsetHeight);\n        break;\n      }\n      runInOp(cm, function() {\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = cm.curOp.updateMaxLine = true;\n      });\n    }\n  };\n\n  TextMarker.prototype.attachLine = function(line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n    }\n    this.lines.push(line);\n  };\n  TextMarker.prototype.detachLine = function(line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  var nextMarkerId = 0;\n\n  function markText(doc, from, to, options, type) {\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\n\n    var marker = new TextMarker(doc, type);\n    if (options) copyObj(options, marker);\n    if (posLess(to, from) || posEq(from, to) && marker.clearWhenEmpty !== false)\n      return marker;\n    if (marker.replacedWith) {\n      marker.collapsed = true;\n      marker.replacedWith = elt("span", [marker.replacedWith], "CodeMirror-widget");\n      if (!options.handleMouseEvents) marker.replacedWith.ignoreEvents = true;\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        throw new Error("Inserting collapsed marker partially overlapping an existing one");\n      sawCollapsedSpans = true;\n    }\n\n    if (marker.addToHistory)\n      addToHistory(doc, {from: from, to: to, origin: "markText"},\n                   {head: doc.sel.head, anchor: doc.sel.anchor}, NaN);\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function(line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(doc, line) == cm.display.maxLine)\n        updateMaxLine = true;\n      var span = {from: null, to: null, marker: marker};\n      if (curLine == from.line) span.from = from.ch;\n      if (curLine == to.line) span.to = to.ch;\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\n      addMarkedSpan(line, span);\n      ++curLine;\n    });\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\n    });\n\n    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });\n\n    if (marker.readOnly) {\n      sawReadOnlySpans = true;\n      if (doc.history.done.length || doc.history.undone.length)\n        doc.clearHistory();\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\n      if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.collapsed)\n        regChange(cm, from.line, to.line + 1);\n      if (marker.atomic) reCheckSelection(cm);\n    }\n    return marker;\n  }\n\n  // SHARED TEXTMARKERS\n\n  function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0, me = this; i < markers.length; ++i) {\n      markers[i].parent = this;\n      on(markers[i], "clear", function(){me.clear();});\n    }\n  }\n  CodeMirror.SharedTextMarker = SharedTextMarker;\n  eventMixin(SharedTextMarker);\n\n  SharedTextMarker.prototype.clear = function() {\n    if (this.explicitlyCleared) return;\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      this.markers[i].clear();\n    signalLater(this, "clear");\n  };\n  SharedTextMarker.prototype.find = function() {\n    return this.primary.find();\n  };\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.replacedWith;\n    linkedDocs(doc, function(doc) {\n      if (widget) options.replacedWith = widget.cloneNode(true);\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        if (doc.linked[i].isParent) return;\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  // TEXTMARKER SPANS\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) return span;\n    }\n  }\n  function removeMarkedSpan(spans, span) {\n    for (var r, i = 0; i < spans.length; ++i)\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\n    return r;\n  }\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n        (nw || (nw = [])).push({from: span.from,\n                                to: endsAfter ? null : span.to,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n        (nw || (nw = [])).push({from: startsBefore ? null : span.from - endCh,\n                                to: span.to == null ? null : span.to - endCh,\n                                marker: marker});\n      }\n    }\n    return nw;\n  }\n\n  function stretchSpansOverChange(doc, change) {\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) return null;\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = posEq(change.from, change.to);\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) span.to = startCh;\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i = 0; i < last.length; ++i) {\n        var span = last[i];\n        if (span.to != null) span.to += offset;\n        if (span.from == null) {\n          var found = getMarkedSpanFor(first, span.marker);\n          if (!found) {\n            span.from = offset;\n            if (sameLine) (first || (first = [])).push(span);\n          }\n        } else {\n          span.from += offset;\n          if (sameLine) (first || (first = [])).push(span);\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) first = clearEmptySpans(first);\n    if (last && last != first) last = clearEmptySpans(last);\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        for (var i = 0; i < first.length; ++i)\n          if (first[i].to == null)\n            (gapMarkers || (gapMarkers = [])).push({from: null, to: null, marker: first[i].marker});\n      for (var i = 0; i < gap; ++i)\n        newMarkers.push(gapMarkers);\n      newMarkers.push(last);\n    }\n    return newMarkers;\n  }\n\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        spans.splice(i--, 1);\n    }\n    if (!spans.length) return null;\n    return spans;\n  }\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) return stretched;\n    if (!stretched) return old;\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            if (oldCur[k].marker == span.marker) continue spans;\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old;\n  }\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function(line) {\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          (markers || (markers = [])).push(mark);\n      }\n    });\n    if (!markers) return null;\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find();\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (posLess(p.to, m.from) || posLess(m.to, p.from)) continue;\n        var newParts = [j, 1];\n        if (posLess(p.from, m.from) || !mk.inclusiveLeft && posEq(p.from, m.from))\n          newParts.push({from: p.from, to: m.from});\n        if (posLess(m.to, p.to) || !mk.inclusiveRight && posEq(p.to, m.to))\n          newParts.push({from: m.to, to: p.to});\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 1;\n      }\n    }\n    return parts;\n  }\n\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\n\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) return lenDiff;\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) return -fromCmp;\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) return toCmp;\n    return b.id - a.id;\n  }\n\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        found = sp.marker;\n    }\n    return found;\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\n\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      var found = sp.marker.find(true);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\n      if (fromCmp <= 0 && (cmp(found.to, from) || extraRight(sp.marker) - extraLeft(marker)) > 0 ||\n          fromCmp >= 0 && (cmp(found.from, to) || extraLeft(sp.marker) - extraRight(marker)) < 0)\n        return true;\n    }\n  }\n\n  function visualLine(doc, line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(doc, merged.find().from.line);\n    return line;\n  }\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) continue;\n      if (sp.from == null) return true;\n      if (sp.marker.replacedWith) continue;\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        return true;\n    }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find().to, endLine = getLine(doc, end.line);\n      return lineIsHiddenInner(doc, endLine, getMarkedSpanFor(endLine.markedSpans, span.marker));\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      return true;\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.replacedWith && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) return true;\n    }\n  }\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.detachLine(line);\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) return;\n    for (var i = 0; i < spans.length; ++i)\n      spans[i].marker.attachLine(line);\n    line.markedSpans = spans;\n  }\n\n  // LINE WIDGETS\n\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\n      this[opt] = options[opt];\n    this.cm = cm;\n    this.node = node;\n  };\n  eventMixin(LineWidget);\n  function widgetOperation(f) {\n    return function() {\n      var withOp = !this.cm.curOp;\n      if (withOp) startOperation(this.cm);\n      try {var result = f.apply(this, arguments);}\n      finally {if (withOp) endOperation(this.cm);}\n      return result;\n    };\n  }\n  LineWidget.prototype.clear = widgetOperation(function() {\n    var ws = this.line.widgets, no = lineNo(this.line);\n    if (no == null || !ws) return;\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\n    if (!ws.length) this.line.widgets = null;\n    var aboveVisible = heightAtLine(this.cm, this.line) < this.cm.doc.scrollTop;\n    updateLineHeight(this.line, Math.max(0, this.line.height - widgetHeight(this)));\n    if (aboveVisible) addToScrollPos(this.cm, 0, -this.height);\n    regChange(this.cm, no, no + 1);\n  });\n  LineWidget.prototype.changed = widgetOperation(function() {\n    var oldH = this.height;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) return;\n    updateLineHeight(this.line, this.line.height + diff);\n    var no = lineNo(this.line);\n    regChange(this.cm, no, no + 1);\n  });\n\n  function widgetHeight(widget) {\n    if (widget.height != null) return widget.height;\n    if (!widget.node.parentNode || widget.node.parentNode.nodeType != 1)\n      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, "position: relative"));\n    return widget.height = widget.node.offsetHeight;\n  }\n\n  function addLineWidget(cm, handle, node, options) {\n    var widget = new LineWidget(cm, node, options);\n    if (widget.noHScroll) cm.display.alignWidgets = true;\n    changeLine(cm, handle, function(line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) widgets.push(widget);\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\n      widget.line = line;\n      if (!lineIsHidden(cm.doc, line) || widget.showIfHidden) {\n        var aboveVisible = heightAtLine(cm, line) < cm.doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) addToScrollPos(cm, 0, widget.height);\n      }\n      return true;\n    });\n    return widget;\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n  eventMixin(Line);\n  Line.prototype.lineNo = function() { return lineNo(this); };\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) line.stateAfter = null;\n    if (line.styles) line.styles = null;\n    if (line.order != null) line.order = null;\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\n  }\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Run the given mode's parser over a line, update the styles\n  // array, which contains alternating fragments of text and CSS\n  // classes.\n  function runMode(cm, text, mode, state, f, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize), style;\n    if (text == "" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = mode.token(stream, state);\n      }\n      if (cm.options.addModeClass) {\n        var mName = CodeMirror.innerMode(mode, state).mode.name;\n        if (mName) style = "m-" + (style ? mName + " " + style : mName);\n      }\n      if (!flattenSpans || curStyle != style) {\n        if (curStart < stream.start) f(stream.start, curStyle);\n        curStart = stream.start; curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\n      var pos = Math.min(stream.pos, curStart + 50000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  function highlightLine(cm, line, state, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen];\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\n      st.push(end, style);\n    }, forceToEnd);\n\n    // Run overlays, adjust style array.\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            st.splice(i, 1, end, st[i+1], i_end);\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) return;\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = cur ? cur + " " + style : style;\n          }\n        }\n      });\n    }\n\n    return st;\n  }\n\n  function getLineStyles(cm, line) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen)\n      line.styles = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\n    return line.styles;\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array.\n  function processLine(cm, text, state, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize);\n    stream.start = stream.pos = startAt || 0;\n    if (text == "" && mode.blankLine) mode.blankLine(state);\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\n      mode.token(stream, state);\n      stream.start = stream.pos;\n    }\n  }\n\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, builder) {\n    if (!style) return null;\n    for (;;) {\n      var lineClass = style.match(/(?:^|\\s)line-(background-)?(\\S+)/);\n      if (!lineClass) break;\n      style = style.slice(0, lineClass.index) + style.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? "bgClass" : "textClass";\n      if (builder[prop] == null)\n        builder[prop] = lineClass[2];\n      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(builder[prop]))\n        builder[prop] += " " + lineClass[2];\n    }\n    var cache = builder.cm.options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = "cm-" + style.replace(/ +/g, " cm-"));\n  }\n\n  function buildLineContent(cm, realLine, measure, copyWidgets) {\n    var merged, line = realLine, empty = true;\n    while (merged = collapsedSpanAtStart(line))\n      line = getLine(cm.doc, merged.find().from.line);\n\n    var builder = {pre: elt("pre"), col: 0, pos: 0,\n                   measure: null, measuredSomething: false, cm: cm,\n                   copyWidgets: copyWidgets};\n\n    do {\n      if (line.text) empty = false;\n      builder.measure = line == realLine && measure;\n      builder.pos = 0;\n      builder.addToken = builder.measure ? buildTokenMeasure : buildToken;\n      if ((old_ie || webkit) && cm.getOption("lineWrapping"))\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\n      var next = insertLineContent(line, builder, getLineStyles(cm, line));\n      if (measure && line == realLine && !builder.measuredSomething) {\n        measure[0] = builder.pre.appendChild(zeroWidthElement(cm.display.measure));\n        builder.measuredSomething = true;\n      }\n      if (next) line = getLine(cm.doc, next.to.line);\n    } while (next);\n\n    if (measure && !builder.measuredSomething && !measure[0])\n      measure[0] = builder.pre.appendChild(empty ? elt("span", "\\u00a0") : zeroWidthElement(cm.display.measure));\n    if (!builder.pre.firstChild && !lineIsHidden(cm.doc, realLine))\n      builder.pre.appendChild(document.createTextNode("\\u00a0"));\n\n    var order;\n    // Work around problem with the reported dimensions of single-char\n    // direction spans on IE (issue #1129). See also the comment in\n    // cursorCoords.\n    if (measure && ie && (order = getOrder(line))) {\n      var l = order.length - 1;\n      if (order[l].from == order[l].to) --l;\n      var last = order[l], prev = order[l - 1];\n      if (last.from + 1 == last.to && prev && last.level < prev.level) {\n        var span = measure[builder.pos - 1];\n        if (span) span.parentNode.insertBefore(span.measureRight = zeroWidthElement(cm.display.measure),\n                                               span.nextSibling);\n      }\n    }\n\n    var textClass = builder.textClass ? builder.textClass + " " + (realLine.textClass || "") : realLine.textClass;\n    if (textClass) builder.pre.className = textClass;\n\n    signal(cm, "renderLine", cm, realLine, builder.pre);\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt("span", "\\u2022", "cm-invalidchar");\n    token.title = "\\\\u" + ch.charCodeAt(0).toString(16);\n    return token;\n  }\n\n  function buildToken(builder, text, style, startStyle, endStyle, title) {\n    if (!text) return;\n    var special = builder.cm.options.specialChars;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      var content = document.createTextNode(text);\n    } else {\n      var content = document.createDocumentFragment(), pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          content.appendChild(document.createTextNode(text.slice(pos, pos + skipped)));\n          builder.col += skipped;\n        }\n        if (!m) break;\n        pos += skipped + 1;\n        if (m[0] == "\\t") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));\n          builder.col += tabWidth;\n        } else {\n          var token = builder.cm.options.specialCharPlaceholder(m[0]);\n          content.appendChild(token);\n          builder.col += 1;\n        }\n      }\n    }\n    if (style || startStyle || endStyle || builder.measure) {\n      var fullStyle = style || "";\n      if (startStyle) fullStyle += startStyle;\n      if (endStyle) fullStyle += endStyle;\n      var token = elt("span", [content], fullStyle);\n      if (title) token.title = title;\n      return builder.pre.appendChild(token);\n    }\n    builder.pre.appendChild(content);\n  }\n\n  function buildTokenMeasure(builder, text, style, startStyle, endStyle) {\n    var wrapping = builder.cm.options.lineWrapping;\n    for (var i = 0; i < text.length; ++i) {\n      var start = i == 0, to = i + 1;\n      while (to < text.length && isExtendingChar(text.charAt(to))) ++to;\n      var ch = text.slice(i, to);\n      i = to - 1;\n      if (i && wrapping && spanAffectsWrapping(text, i))\n        builder.pre.appendChild(elt("wbr"));\n      var old = builder.measure[builder.pos];\n      var span = builder.measure[builder.pos] =\n        buildToken(builder, ch, style,\n                   start && startStyle, i == text.length - 1 && endStyle);\n      if (old) span.leftSide = old.leftSide || old;\n      // In IE single-space nodes wrap differently than spaces\n      // embedded in larger text nodes, except when set to\n      // white-space: normal (issue #1268).\n      if (old_ie && wrapping && ch == " " && i && !/\\s/.test(text.charAt(i - 1)) &&\n          i < text.length - 1 && !/\\s/.test(text.charAt(i + 1)))\n        span.style.whiteSpace = "normal";\n      builder.pos += ch.length;\n    }\n    if (text.length) builder.measuredSomething = true;\n  }\n\n  function buildTokenSplitSpaces(inner) {\n    function split(old) {\n      var out = " ";\n      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\\u00a0";\n      out += " ";\n      return out;\n    }\n    return function(builder, text, style, startStyle, endStyle, title) {\n      return inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.replacedWith;\n    if (widget) {\n      if (builder.copyWidgets) widget = widget.cloneNode(true);\n      builder.pre.appendChild(widget);\n      if (builder.measure) {\n        if (size) {\n          builder.measure[builder.pos] = widget;\n        } else {\n          var elt = zeroWidthElement(builder.cm.display.measure);\n          if (marker.type == "bookmark" && !marker.insertLeft)\n            builder.measure[builder.pos] = builder.pre.appendChild(elt);\n          else if (builder.measure[builder.pos])\n            return;\n          else\n            builder.measure[builder.pos] = builder.pre.insertBefore(elt, widget);\n        }\n        builder.measuredSomething = true;\n      }\n    }\n    builder.pos += size;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i = 1; i < styles.length; i+=2)\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder));\n      return;\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = "", style;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = title = "";\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [];\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }\n            if (m.className) spanStyle += " " + m.className;\n            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;\n            if (m.title && !title) title = m.title;\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              collapsed = sp;\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n          if (m.type == "bookmark" && sp.from == pos && m.replacedWith) foundBookmarks.push(m);\n        }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) return collapsed.marker.find();\n        }\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\n      }\n      if (pos >= len) break;\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\n          pos = end;\n          spanStartStyle = "";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder);\n      }\n    }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  function updateDoc(doc, change, markedSpans, selAfter, estimateHeight) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, "change", line, change);\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // First adjust the line structure\n    if (from.ch == 0 && to.ch == 0 && lastText == "" &&\n        (!doc.cm || doc.cm.options.wholeLineUpdateBefore)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      for (var i = 0, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) doc.remove(from.line, nlines);\n      if (added.length) doc.insert(from.line, added);\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        for (var added = [], i = 1, e = text.length - 1; i < e; ++i)\n          added.push(new Line(text[i], spansFor(i), estimateHeight));\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      for (var i = 1, e = text.length - 1, added = []; i < e; ++i)\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\n      doc.insert(from.line + 1, added);\n    }\n\n    signalLater(doc, "change", doc, change);\n    setSelection(doc, selAfter.anchor, selAfter.head, null, true);\n  }\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    for (var i = 0, e = lines.length, height = 0; i < e; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length; },\n    removeInner: function(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, "delete");\n      }\n      this.lines.splice(at, n);\n    },\n    collapse: function(lines) {\n      lines.splice.apply(lines, [lines.length, 0].concat(this.lines));\n    },\n    insertInner: function(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0, e = lines.length; i < e; ++i) lines[i].parent = this;\n    },\n    iterN: function(at, n, op) {\n      for (var e = at + n; at < e; ++at)\n        if (op(this.lines[at])) return true;\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0, e = children.length; i < e; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size; },\n    removeInner: function(at, n) {\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n      if (this.size - n < 25) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function(lines) {\n      for (var i = 0, e = this.children.length; i < e; ++i) this.children[i].collapse(lines);\n    },\n    insertInner: function(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            while (child.lines.length > 50) {\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\n              var newleaf = new LeafChunk(spilled);\n              child.height -= newleaf.height;\n              this.children.splice(i + 1, 0, newleaf);\n              newleaf.parent = this;\n            }\n            this.maybeSpill();\n          }\n          break;\n        }\n        at -= sz;\n      }\n    },\n    maybeSpill: function() {\n      if (this.children.length <= 10) return;\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n      me.parent.maybeSpill();\n    },\n    iterN: function(at, n, op) {\n      for (var i = 0, e = this.children.length; i < e; ++i) {\n        var child = this.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) return true;\n          if ((n -= used) == 0) break;\n          at = 0;\n        } else at -= sz;\n      }\n    }\n  };\n\n  var nextDocId = 0;\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\n    if (firstLine == null) firstLine = 0;\n\n    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.history = makeHistory();\n    this.cleanGeneration = 1;\n    this.frontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = {from: start, to: start, head: start, anchor: start, shift: false, extend: false, goalColumn: null};\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n\n    if (typeof text == "string") text = splitLines(text);\n    updateDoc(this, {from: start, to: start, text: text}, null, {head: start, anchor: start});\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    iter: function(from, to, op) {\n      if (op) this.iterN(from - this.first, to - from, op);\n      else this.iterN(this.first, this.first + this.size, from);\n    },\n\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0, e = lines.length; i < e; ++i) height += lines[i].height;\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || "\\n");\n    },\n    setValue: function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: splitLines(code), origin: "setValue"},\n                 {head: top, anchor: top}, true);\n    },\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) return lines;\n      return lines.join(lineSep || "\\n");\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\n    setLine: function(line, text) {\n      if (isLine(this, line))\n        replaceRange(this, text, Pos(line, 0), clipPos(this, Pos(line)));\n    },\n    removeLine: function(line) {\n      if (line) replaceRange(this, "", clipPos(this, Pos(line - 1)), clipPos(this, Pos(line)));\n      else replaceRange(this, "", Pos(0, 0), clipPos(this, Pos(1, 0)));\n    },\n\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\n    getLineNumber: function(line) {return lineNo(line);},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == "number") line = getLine(this, line);\n      return visualLine(this, line);\n    },\n\n    lineCount: function() {return this.size;},\n    firstLine: function() {return this.first;},\n    lastLine: function() {return this.first + this.size - 1;},\n\n    clipPos: function(pos) {return clipPos(this, pos);},\n\n    getCursor: function(start) {\n      var sel = this.sel, pos;\n      if (start == null || start == "head") pos = sel.head;\n      else if (start == "anchor") pos = sel.anchor;\n      else if (start == "end" || start === false) pos = sel.to;\n      else pos = sel.from;\n      return copyPos(pos);\n    },\n    somethingSelected: function() {return !posEq(this.sel.head, this.sel.anchor);},\n\n    setCursor: docOperation(function(line, ch, extend) {\n      var pos = clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line);\n      if (extend) extendSelection(this, pos);\n      else setSelection(this, pos, pos);\n    }),\n    setSelection: docOperation(function(anchor, head, bias) {\n      setSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), bias);\n    }),\n    extendSelection: docOperation(function(from, to, bias) {\n      extendSelection(this, clipPos(this, from), to && clipPos(this, to), bias);\n    }),\n\n    getSelection: function(lineSep) {return this.getRange(this.sel.from, this.sel.to, lineSep);},\n    replaceSelection: function(code, collapse, origin) {\n      makeChange(this, {from: this.sel.from, to: this.sel.to, text: splitLines(code), origin: origin}, collapse || "around");\n    },\n    undo: docOperation(function() {makeChangeFromHistory(this, "undo");}),\n    redo: docOperation(function() {makeChangeFromHistory(this, "redo");}),\n\n    setExtending: function(val) {this.sel.extend = val;},\n\n    historySize: function() {\n      var hist = this.history;\n      return {undo: hist.done.length, redo: hist.undone.length};\n    },\n    clearHistory: function() {this.history = makeHistory(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        this.history.lastOp = this.history.lastOrigin = null;\n      return this.history.generation;\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)};\n    },\n    setHistory: function(histData) {\n      var hist = this.history = makeHistory(this.history.maxGeneration);\n      hist.done = histData.done.slice(0);\n      hist.undone = histData.undone.slice(0);\n    },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, "bookmark");\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          markers.push(span.marker.parent || span.marker);\n      }\n      return markers;\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function(line) {\n        var sps = line.markedSpans;\n        if (sps) for (var i = 0; i < sps.length; ++i)\n          if (sps[i].from != null) markers.push(sps[i].marker);\n      });\n      return markers;\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo = this.first;\n      this.iter(function(line) {\n        var sz = line.text.length + 1;\n        if (sz > off) { ch = off; return true; }\n        off -= sz;\n        ++lineNo;\n      });\n      return clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) return 0;\n      this.iter(this.first, coords.line, function (line) {\n        index += line.text.length + 1;\n      });\n      return index;\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = {from: this.sel.from, to: this.sel.to, head: this.sel.head, anchor: this.sel.anchor,\n                 shift: this.sel.shift, extend: false, goalColumn: this.sel.goalColumn};\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc;\n    },\n\n    linkedDoc: function(options) {\n      if (!options) options = {};\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) from = options.from;\n      if (options.to != null && options.to < to) to = options.to;\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\n      if (options.sharedHist) copy.history = this.history;\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      return copy;\n    },\n    unlinkDoc: function(other) {\n      if (other instanceof CodeMirror) other = other.doc;\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\n        var link = this.linked[i];\n        if (link.doc != other) continue;\n        this.linked.splice(i, 1);\n        other.unlinkDoc(this);\n        break;\n      }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\n        other.history = makeHistory();\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode;},\n    getEditor: function() {return this.cm;}\n  });\n\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // The Doc methods that should be available on CodeMirror instances\n  var dontDelegate = "iter insert remove copy getEditor".split(" ");\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments);};\n    })(Doc.prototype[prop]);\n\n  eventMixin(Doc);\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) continue;\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) continue;\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      }\n    }\n    propagate(doc, null, true);\n  }\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) throw new Error("This document is already in use.");\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    if (!cm.options.lineWrapping) computeMaxLength(cm);\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  // LINE UTILITIES\n\n  function getLine(chunk, n) {\n    n -= chunk.first;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break; }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n];\n  }\n\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function(line) {\n      var text = line.text;\n      if (n == end.line) text = text.slice(0, end.ch);\n      if (n == start.line) text = text.slice(start.ch);\n      out.push(text);\n      ++n;\n    });\n    return out;\n  }\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function(line) { out.push(line.text); });\n    return out;\n  }\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    for (var n = line; n; n = n.parent) n.height += diff;\n  }\n\n  function lineNo(line) {\n    if (line.parent == null) return null;\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) break;\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first;\n  }\n\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i = 0, e = chunk.children.length; i < e; ++i) {\n        var child = chunk.children[i], ch = child.height;\n        if (h < ch) { chunk = child; continue outer; }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n;\n    } while (!chunk.lines);\n    for (var i = 0, e = chunk.lines.length; i < e; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) break;\n      h -= lh;\n    }\n    return n + i;\n  }\n\n  function heightAtLine(cm, lineObj) {\n    lineObj = visualLine(cm.doc, lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) break;\n      else h += line.height;\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i = 0; i < p.children.length; ++i) {\n        var cur = p.children[i];\n        if (cur == chunk) break;\n        else h += cur.height;\n      }\n    }\n    return h;\n  }\n\n  function getOrder(line) {\n    var order = line.order;\n    if (order == null) order = line.order = bidiOrdering(line.text);\n    return order;\n  }\n\n  // HISTORY\n\n  function makeHistory(startGen) {\n    return {\n      // Arrays of history events. Doing something adds an event to\n      // done and clears undo. Undoing moves events from done to\n      // undone, redoing moves them in the other direction.\n      done: [], undone: [], undoDepth: Infinity,\n      // Used to track when changes can be merged into a single undo\n      // event\n      lastTime: 0, lastOp: null, lastOrigin: null,\n      // Used by the isClean() method\n      generation: startGen || 1, maxGeneration: startGen || 1\n    };\n  }\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change["spans_" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\n      if (line.markedSpans)\n        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;\n      ++n;\n    });\n  }\n\n  function historyChangeFromChange(doc, change) {\n    var from = { line: change.from.line, ch: change.from.ch };\n    var histChange = {from: from, to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\n    return histChange;\n  }\n\n  function addToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur = lst(hist.done);\n\n    if (cur &&\n        (hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastTime > time - doc.cm.options.historyEventDelay) ||\n          change.origin.charAt(0) == "*"))) {\n      // Merge this change into the last event\n      var last = lst(cur.changes);\n      if (posEq(change.from, change.to) && posEq(change.from, last.to)) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n      cur.anchorAfter = selAfter.anchor; cur.headAfter = selAfter.head;\n    } else {\n      // Can not be merged, start a new event.\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation,\n             anchorBefore: doc.sel.anchor, headBefore: doc.sel.head,\n             anchorAfter: selAfter.anchor, headAfter: selAfter.head};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth)\n        hist.done.shift();\n    }\n    hist.generation = ++hist.maxGeneration;\n    hist.lastTime = time;\n    hist.lastOp = opId;\n    hist.lastOrigin = change.origin;\n  }\n\n  function removeClearedSpans(spans) {\n    if (!spans) return null;\n    for (var i = 0, out; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\n      else if (out) out.push(spans[i]);\n    }\n    return !out ? spans : out.length ? out : null;\n  }\n\n  function getOldSpans(doc, change) {\n    var found = change["spans_" + doc.id];\n    if (!found) return null;\n    for (var i = 0, nw = []; i < change.text.length; ++i)\n      nw.push(removeClearedSpans(found[i]));\n    return nw;\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup) {\n    for (var i = 0, copy = []; i < events.length; ++i) {\n      var event = events[i], changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges, anchorBefore: event.anchorBefore, headBefore: event.headBefore,\n                 anchorAfter: event.anchorAfter, headAfter: event.headAfter});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m;\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        }\n      }\n    }\n    return copy;\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSel(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      for (var j = 0; j < sub.changes.length; ++j) {\n        var cur = sub.changes[j];\n        if (!sub.copied) { cur.from = copyPos(cur.from); cur.to = copyPos(cur.to); }\n        if (to < cur.from.line) {\n          cur.from.line += diff;\n          cur.to.line += diff;\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n      if (!sub.copied) {\n        sub.anchorBefore = copyPos(sub.anchorBefore); sub.headBefore = copyPos(sub.headBefore);\n        sub.anchorAfter = copyPos(sub.anchorAfter); sub.readAfter = copyPos(sub.headAfter);\n        sub.copied = true;\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      } else {\n        rebaseHistSel(sub.anchorBefore); rebaseHistSel(sub.headBefore);\n        rebaseHistSel(sub.anchorAfter); rebaseHistSel(sub.headAfter);\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // EVENT OPERATORS\n\n  function stopMethod() {e_stop(this);}\n  // Ensure an event has a stop method.\n  function addStop(event) {\n    if (!event.stop) event.stop = stopMethod;\n    return event;\n  }\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) e.preventDefault();\n    else e.returnValue = false;\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) e.stopPropagation();\n    else e.cancelBubble = true;\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n  CodeMirror.e_stop = e_stop;\n  CodeMirror.e_preventDefault = e_preventDefault;\n  CodeMirror.e_stopPropagation = e_stopPropagation;\n\n  function e_target(e) {return e.target || e.srcElement;}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) b = 1;\n      else if (e.button & 2) b = 3;\n      else if (e.button & 4) b = 2;\n    }\n    if (mac && e.ctrlKey && b == 1) b = 3;\n    return b;\n  }\n\n  // EVENT HANDLING\n\n  function on(emitter, type, f) {\n    if (emitter.addEventListener)\n      emitter.addEventListener(type, f, false);\n    else if (emitter.attachEvent)\n      emitter.attachEvent("on" + type, f);\n    else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      var arr = map[type] || (map[type] = []);\n      arr.push(f);\n    }\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener)\n      emitter.removeEventListener(type, f, false);\n    else if (emitter.detachEvent)\n      emitter.detachEvent("on" + type, f);\n    else {\n      var arr = emitter._handlers && emitter._handlers[type];\n      if (!arr) return;\n      for (var i = 0; i < arr.length; ++i)\n        if (arr[i] == f) { arr.splice(i, 1); break; }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\n  }\n\n  var delayedCallbacks, delayedCallbackDepth = 0;\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    if (!arr) return;\n    var args = Array.prototype.slice.call(arguments, 2);\n    if (!delayedCallbacks) {\n      ++delayedCallbackDepth;\n      delayedCallbacks = [];\n      setTimeout(fireDelayed, 0);\n    }\n    function bnd(f) {return function(){f.apply(null, args);};};\n    for (var i = 0; i < arr.length; ++i)\n      delayedCallbacks.push(bnd(arr[i]));\n  }\n\n  function signalDOMEvent(cm, e, override) {\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function fireDelayed() {\n    --delayedCallbackDepth;\n    var delayed = delayedCallbacks;\n    delayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\n  }\n\n  function hasHandler(emitter, type) {\n    var arr = emitter._handlers && emitter._handlers[type];\n    return arr && arr.length > 0;\n  }\n\n  CodeMirror.on = on; CodeMirror.off = off; CodeMirror.signal = signal;\n\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // MISC UTILITIES\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerCutOff = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};\n\n  function Delayed() {this.id = null;}\n  Delayed.prototype = {set: function(ms, f) {clearTimeout(this.id); this.id = setTimeout(f, ms);}};\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) end = string.length;\n    }\n    for (var i = startIndex || 0, n = startValue || 0; i < end; ++i) {\n      if (string.charAt(i) == "\\t") n += tabSize - (n % tabSize);\n      else ++n;\n    }\n    return n;\n  }\n  CodeMirror.countColumn = countColumn;\n\n  var spaceStrs = [""];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      spaceStrs.push(lst(spaceStrs) + " ");\n    return spaceStrs[n];\n  }\n\n  function lst(arr) { return arr[arr.length-1]; }\n\n  function selectInput(node) {\n    if (ios) { // Mobile Safari apparently has a bug where select() is broken.\n      node.selectionStart = 0;\n      node.selectionEnd = node.value.length;\n    } else {\n      // Suppress mysterious IE10 errors\n      try { node.select(); }\n      catch(_e) {}\n    }\n  }\n\n  function indexOf(collection, elt) {\n    if (collection.indexOf) return collection.indexOf(elt);\n    for (var i = 0, e = collection.length; i < e; ++i)\n      if (collection[i] == elt) return i;\n    return -1;\n  }\n\n  function createObj(base, props) {\n    function Obj() {}\n    Obj.prototype = base;\n    var inst = new Obj();\n    if (props) copyObj(props, inst);\n    return inst;\n  }\n\n  function copyObj(obj, target) {\n    if (!target) target = {};\n    for (var prop in obj) if (obj.hasOwnProperty(prop)) target[prop] = obj[prop];\n    return target;\n  }\n\n  function emptyArray(size) {\n    for (var a = [], i = 0; i < size; ++i) a.push(undefined);\n    return a;\n  }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args);};\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordChar(ch) {\n    return /\\w/.test(ch) || ch > "\\x80" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\n    return true;\n  }\n\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\n\n  // DOM UTILITIES\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) e.className = className;\n    if (style) e.style.cssText = style;\n    if (typeof content == "string") setTextContent(e, content);\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\n    return e;\n  }\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      e.removeChild(e.firstChild);\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function setTextContent(e, str) {\n    if (ie_lt9) {\n      e.innerHTML = "";\n      e.appendChild(document.createTextNode(str));\n    } else e.textContent = str;\n  }\n\n  function getRect(node) {\n    return node.getBoundingClientRect();\n  }\n  CodeMirror.replaceGetRect = function(f) { getRect = f; };\n\n  // FEATURE DETECTION\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie_lt9) return false;\n    var div = elt('div');\n    return "draggable" in div || "dragDrop" in div;\n  }();\n\n  // For a reason I have yet to figure out, some browsers disallow\n  // word wrapping between certain characters *only* if a new inline\n  // element is started between them. This makes it hard to reliably\n  // measure the position of things, since that requires inserting an\n  // extra span. This terribly fragile set of tests matches the\n  // character combinations that suffer from this phenomenon on the\n  // various browsers.\n  function spanAffectsWrapping() { return false; }\n  if (gecko) // Only for "$'"\n    spanAffectsWrapping = function(str, i) {\n      return str.charCodeAt(i - 1) == 36 && str.charCodeAt(i) == 39;\n    };\n  else if (safari && !/Version\\/([6-9]|\\d\\d)\\b/.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      return /\\-[^ \\-?]|\\?[^ !\\'\\"\\),.\\-\\/:;\\?\\]\\}]/.test(str.slice(i - 1, i + 1));\n    };\n  else if (webkit && /Chrome\\/(?:29|[3-9]\\d|\\d\\d\\d)\\./.test(navigator.userAgent))\n    spanAffectsWrapping = function(str, i) {\n      var code = str.charCodeAt(i - 1);\n      return code >= 8208 && code <= 8212;\n    };\n  else if (webkit)\n    spanAffectsWrapping = function(str, i) {\n      if (i > 1 && str.charCodeAt(i - 1) == 45) {\n        if (/\\w/.test(str.charAt(i - 2)) && /[^\\-?\\.]/.test(str.charAt(i))) return true;\n        if (i > 2 && /[\\d\\.,]/.test(str.charAt(i - 2)) && /[\\d\\.,]/.test(str.charAt(i))) return false;\n      }\n      return /[~!#%&*)=+}\\]\\\\|\\"\\.>,:;][({[<]|-[^\\-?\\.\\u2010-\\u201f\\u2026]|\\?[\\w~`@#$%\\^&*(_=+{[|><]|\\u2026[\\w~`@#$%\\^&*(_=+{[><]/.test(str.slice(i - 1, i + 1));\n    };\n\n  var knownScrollbarWidth;\n  function scrollbarWidth(measure) {\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\n    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");\n    removeChildrenAndAdd(measure, test);\n    if (test.offsetWidth)\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\n    return knownScrollbarWidth || 0;\n  }\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt("span", "\\u200b");\n      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));\n      if (measure.firstChild.offsetHeight != 0)\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !ie_lt8;\n    }\n    if (zwspSupported) return elt("span", "\\u200b");\n    else return elt("span", "\\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");\n  }\n\n  // See if "".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLines = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf("\\n", pos);\n      if (nl == -1) nl = string.length;\n      var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);\n      var rt = line.indexOf("\\r");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result;\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\n  CodeMirror.splitLines = splitLines;\n\n  var hasSelection = window.getSelection ? function(te) {\n    try { return te.selectionStart != te.selectionEnd; }\n    catch(e) { return false; }\n  } : function(te) {\n    try {var range = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range || range.parentElement() != te) return false;\n    return range.compareEndPoints("StartToEnd", range) != 0;\n  };\n\n  var hasCopyEvent = (function() {\n    var e = elt("div");\n    if ("oncopy" in e) return true;\n    e.setAttribute("oncopy", "return;");\n    return typeof e.oncopy == 'function';\n  })();\n\n  // KEY NAMING\n\n  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",\n                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",\n                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",\n                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",\n                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\\\",\n                  221: "]", 222: "'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",\n                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};\n  CodeMirror.keyNames = keyNames;\n  (function() {\n    // Number keys\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\n    // Alphabetic keys\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\n    // Function keys\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;\n  })();\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) return f(from, to, "ltr");\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");\n        found = true;\n      }\n    }\n    if (!found) f(from, to, "ltr");\n  }\n\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\n\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\n  function lineRight(line) {\n    var order = getOrder(line);\n    if (!order) return line.text.length;\n    return bidiRight(lst(order));\n  }\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(cm.doc, line);\n    if (visual != line) lineN = lineNo(visual);\n    var order = getOrder(visual);\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\n    return Pos(lineN, ch);\n  }\n  function lineEnd(cm, lineN) {\n    var merged, line;\n    while (merged = collapsedSpanAtEnd(line = getLine(cm.doc, lineN)))\n      lineN = merged.find().to.line;\n    var order = getOrder(line);\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\n    return Pos(lineN, ch);\n  }\n\n  function compareBidiLevel(order, a, b) {\n    var linedir = order[0].level;\n    if (a == linedir) return true;\n    if (b == linedir) return false;\n    return a < b;\n  }\n  var bidiOther;\n  function getBidiPartAt(order, pos) {\n    bidiOther = null;\n    for (var i = 0, found; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < pos && cur.to > pos) return i;\n      if ((cur.from == pos || cur.to == pos)) {\n        if (found == null) {\n          found = i;\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\n          if (cur.from != cur.to) bidiOther = found;\n          return i;\n        } else {\n          if (cur.from != cur.to) bidiOther = i;\n          return found;\n        }\n      }\n    }\n    return found;\n  }\n\n  function moveInLine(line, pos, dir, byUnit) {\n    if (!byUnit) return pos + dir;\n    do pos += dir;\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\n    return pos;\n  }\n\n  // This is somewhat involved. It is needed in order to move\n  // 'visually' through bi-directional text -- i.e., pressing left\n  // should make the cursor go left, even when in RTL text. The\n  // tricky part is the 'jumps', where RTL and LTR text touch each\n  // other. This often requires the cursor offset to move more than\n  // one unit, in order to visually move one unit.\n  function moveVisually(line, start, dir, byUnit) {\n    var bidi = getOrder(line);\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\n\n    for (;;) {\n      if (target > part.from && target < part.to) return target;\n      if (target == part.from || target == part.to) {\n        if (getBidiPartAt(bidi, target) == pos) return target;\n        part = bidi[pos += dir];\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\n      } else {\n        part = bidi[pos += dir];\n        if (!part) return null;\n        if ((dir > 0) == part.level % 2)\n          target = moveInLine(line, part.to, -1, byUnit);\n        else\n          target = moveInLine(line, part.from, 1, byUnit);\n      }\n    }\n  }\n\n  function moveLogically(line, start, dir, byUnit) {\n    var target = start + dir;\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLL";\n    // Character types for codepoints 0x600 to 0x6ff\n    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmmrrrrrrrrrrrrrrrrrr";\n    function charType(code) {\n      if (code <= 0xff) return lowTypes.charAt(code);\n      else if (0x590 <= code && code <= 0x5f4) return "R";\n      else if (0x600 <= code && code <= 0x6ff) return arabicTypes.charAt(code - 0x600);\n      else if (0x700 <= code && code <= 0x8ac) return "r";\n      else return "L";\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n    // Browsers seem to always treat the boundaries of block elements as being L.\n    var outerType = "L";\n\n    return function(str) {\n      if (!bidiRE.test(str)) return false;\n      var len = str.length, types = [];\n      for (var i = 0, type; i < len; ++i)\n        types.push(type = charType(str.charCodeAt(i)));\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i = 0, prev = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == "m") types[i] = prev;\n        else prev = type;\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (type == "1" && cur == "r") types[i] = "n";\n        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\n        var type = types[i];\n        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";\n        else if (type == "," && prev == types[i+1] &&\n                 (prev == "1" || prev == "n")) types[i] = prev;\n        prev = type;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i = 0; i < len; ++i) {\n        var type = types[i];\n        if (type == ",") types[i] = "N";\n        else if (type == "%") {\n          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}\n          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i = 0, cur = outerType; i < len; ++i) {\n        var type = types[i];\n        if (cur == "L" && type == "1") types[i] = "L";\n        else if (isStrong.test(type)) cur = type;\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i = 0; i < len; ++i) {\n        if (isNeutral.test(types[i])) {\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\n          var before = (i ? types[i-1] : outerType) == "L";\n          var after = (end < len ? types[end] : outerType) == "L";\n          var replace = before || after ? "L" : "R";\n          for (var j = i; j < end; ++j) types[j] = replace;\n          i = end - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i = 0; i < len;) {\n        if (countsAsLeft.test(types[i])) {\n          var start = i;\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\n          order.push({from: start, to: i, level: 0});\n        } else {\n          var pos = i, at = order.length;\n          for (++i; i < len && types[i] != "L"; ++i) {}\n          for (var j = pos; j < i;) {\n            if (countsAsNum.test(types[j])) {\n              if (pos < j) order.splice(at, 0, {from: pos, to: j, level: 1});\n              var nstart = j;\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\n              order.splice(at, 0, {from: nstart, to: j, level: 2});\n              pos = j;\n            } else ++j;\n          }\n          if (pos < i) order.splice(at, 0, {from: pos, to: i, level: 1});\n        }\n      }\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n        order[0].from = m[0].length;\n        order.unshift({from: 0, to: m[0].length, level: 0});\n      }\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n        lst(order).to -= m[0].length;\n        order.push({from: len - m[0].length, to: len, level: 0});\n      }\n      if (order[0].level != lst(order).level)\n        order.push({from: len, to: len, level: order[0].level});\n\n      return order;\n    };\n  })();\n\n  // THE END\n\n  CodeMirror.version = "3.21.0";\n\n  return CodeMirror;\n})();\n\n\n\n\n\n\n\n\nCodeMirror.defineMode("sql", function(config, parserConfig) {\n  "use strict";\n\n  var client         = parserConfig.client || {},\n      atoms          = parserConfig.atoms || {"false": true, "true": true, "null": true},\n      builtin        = parserConfig.builtin || {},\n      keywords       = parserConfig.keywords || {},\n      operatorChars  = parserConfig.operatorChars || /^[*+\\-%<>!=&|~^]/,\n      support        = parserConfig.support || {},\n      hooks          = parserConfig.hooks || {},\n      dateSQL        = parserConfig.dateSQL || {"date" : true, "time" : true, "timestamp" : true};\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n\n    // call hooks from the mime type\n    if (hooks[ch]) {\n      var result = hooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n\n    if (support.hexNumber == true &&\n      ((ch == "0" && stream.match(/^[xX][0-9a-fA-F]+/))\n      || (ch == "x" || ch == "X") && stream.match(/^'[0-9a-fA-F]+'/))) {\n      // hex\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/hexadecimal-literals.html\n      return "number";\n    } else if (support.binaryNumber == true &&\n      (((ch == "b" || ch == "B") && stream.match(/^'[01]+'/))\n      || (ch == "0" && stream.match(/^b[01]+/)))) {\n      // bitstring\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/bit-field-literals.html\n      return "number";\n    } else if (ch.charCodeAt(0) > 47 && ch.charCodeAt(0) < 58) {\n      // numbers\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/number-literals.html\n          stream.match(/^[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?/);\n      support.decimallessFloat == true && stream.eat('.');\n      return "number";\n    } else if (ch == "?" && (stream.eatSpace() || stream.eol() || stream.eat(";"))) {\n      // placeholders\n      return "variable-3";\n    } else if (ch == "'" || (ch == '"' && support.doubleQuote)) {\n      // strings\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html\n      state.tokenize = tokenLiteral(ch);\n      return state.tokenize(stream, state);\n    } else if ((((support.nCharCast == true && (ch == "n" || ch == "N"))\n        || (support.charsetCast == true && ch == "_" && stream.match(/[a-z][a-z0-9]*/i)))\n        && (stream.peek() == "'" || stream.peek() == '"'))) {\n      // charset casting: _utf8'str', N'str', n'str'\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/string-literals.html\n      return "keyword";\n    } else if (/^[\\(\\),\\;\\[\\]]/.test(ch)) {\n      // no highlightning\n      return null;\n    } else if (support.commentSlashSlash && ch == "/" && stream.eat("/")) {\n      // 1-line comment\n      stream.skipToEnd();\n      return "comment";\n    } else if ((support.commentHash && ch == "#")\n        || (ch == "-" && stream.eat("-") && (!support.commentSpaceRequired || stream.eat(" ")))) {\n      // 1-line comments\n      // ref: https://kb.askmonty.org/en/comment-syntax/\n      stream.skipToEnd();\n      return "comment";\n    } else if (ch == "/" && stream.eat("*")) {\n      // multi-line comments\n      // ref: https://kb.askmonty.org/en/comment-syntax/\n      state.tokenize = tokenComment;\n      return state.tokenize(stream, state);\n    } else if (ch == ".") {\n      // .1 for 0.1\n      if (support.zerolessFloat == true && stream.match(/^(?:\\d+(?:e[+-]?\\d+)?)/i)) {\n        return "number";\n      }\n      // .table_name (ODBC)\n      // // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html\n      if (support.ODBCdotTable == true && stream.match(/^[a-zA-Z_]+/)) {\n        return "variable-2";\n      }\n    } else if (operatorChars.test(ch)) {\n      // operators\n      stream.eatWhile(operatorChars);\n      return null;\n    } else if (ch == '{' &&\n        (stream.match(/^( )*(d|D|t|T|ts|TS)( )*'[^']*'( )*}/) || stream.match(/^( )*(d|D|t|T|ts|TS)( )*"[^"]*"( )*}/))) {\n      // dates (weird ODBC syntax)\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html\n      return "number";\n    } else {\n      stream.eatWhile(/^[_\\w\\d]/);\n      var word = stream.current().toLowerCase();\n      // dates (standard SQL syntax)\n      // ref: http://dev.mysql.com/doc/refman/5.5/en/date-and-time-literals.html\n      if (dateSQL.hasOwnProperty(word) && (stream.match(/^( )+'[^']*'/) || stream.match(/^( )+"[^"]*"/)))\n        return "number";\n      if (atoms.hasOwnProperty(word)) return "atom";\n      if (builtin.hasOwnProperty(word)) return "builtin";\n      if (keywords.hasOwnProperty(word)) return "keyword";\n      if (client.hasOwnProperty(word)) return "string-2";\n      return null;\n    }\n  }\n\n  // 'string', with char specified in quote escaped by '\\'\n  function tokenLiteral(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          state.tokenize = tokenBase;\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      return "string";\n    };\n  }\n  function tokenComment(stream, state) {\n    while (true) {\n      if (stream.skipTo("*")) {\n        stream.next();\n        if (stream.eat("/")) {\n          state.tokenize = tokenBase;\n          break;\n        }\n      } else {\n        stream.skipToEnd();\n        break;\n      }\n    }\n    return "comment";\n  }\n\n  function pushContext(stream, state, type) {\n    state.context = {\n      prev: state.context,\n      indent: stream.indentation(),\n      col: stream.column(),\n      type: type\n    };\n  }\n\n  function popContext(state) {\n    state.indent = state.context.indent;\n    state.context = state.context.prev;\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: tokenBase, context: null};\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (state.context && state.context.align == null)\n          state.context.align = false;\n      }\n      if (stream.eatSpace()) return null;\n\n      var style = state.tokenize(stream, state);\n      if (style == "comment") return style;\n\n      if (state.context && state.context.align == null)\n        state.context.align = true;\n\n      var tok = stream.current();\n      if (tok == "(")\n        pushContext(stream, state, ")");\n      else if (tok == "[")\n        pushContext(stream, state, "]");\n      else if (state.context && state.context.type == tok)\n        popContext(state);\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context;\n      if (!cx) return 0;\n      var closing = textAfter.charAt(0) == cx.type;\n      if (cx.align) return cx.col + (closing ? 0 : 1);\n      else return cx.indent + (closing ? 0 : config.indentUnit);\n    },\n\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    lineComment: support.commentSlashSlash ? "//" : support.commentHash ? "#" : null\n  };\n});\n\n(function() {\n  "use strict";\n\n  // `identifier`\n  function hookIdentifier(stream) {\n    // MySQL/MariaDB identifiers\n    // ref: http://dev.mysql.com/doc/refman/5.6/en/identifier-qualifiers.html\n    var ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == "`" && !stream.eat("`")) return "variable-2";\n    }\n    return null;\n  }\n\n  // variable token\n  function hookVar(stream) {\n    // variables\n    // @@prefix.varName @varName\n    // varName can be quoted with ` or ' or "\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/user-variables.html\n    if (stream.eat("@")) {\n      stream.match(/^session\\./);\n      stream.match(/^local\\./);\n      stream.match(/^global\\./);\n    }\n\n    if (stream.eat("'")) {\n      stream.match(/^.*'/);\n      return "variable-2";\n    } else if (stream.eat('"')) {\n      stream.match(/^.*"/);\n      return "variable-2";\n    } else if (stream.eat("`")) {\n      stream.match(/^.*`/);\n      return "variable-2";\n    } else if (stream.match(/^[0-9a-zA-Z$\\.\\_]+/)) {\n      return "variable-2";\n    }\n    return null;\n  };\n\n  // short client keyword token\n  function hookClient(stream) {\n    // \\N means NULL\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/null-values.html\n    if (stream.eat("N")) {\n        return "atom";\n    }\n    // \\g, etc\n    // ref: http://dev.mysql.com/doc/refman/5.5/en/mysql-commands.html\n    return stream.match(/^[a-zA-Z.#!?]/) ? "variable-2" : null;\n  }\n\n  // these keywords are used by all SQL dialects (however, a mode can still overwrite it)\n  var sqlKeywords = "alter and as asc between by count create delete desc distinct drop from having in insert into is join like not on or order select set table union update values where ";\n\n  // turn a space-separated list into an array\n  function set(str) {\n    var obj = {}, words = str.split(" ");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  // A generic SQL Mode. It's not a standard, it just try to support what is generally supported\n  CodeMirror.defineMIME("text/x-sql", {\n    name: "sql",\n    keywords: set(sqlKeywords + "begin"),\n    builtin: set("bool boolean bit blob enum long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision real date datetime year unsigned signed decimal numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable doubleQuote binaryNumber hexNumber")\n  });\n\n  CodeMirror.defineMIME("text/x-mssql", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "begin trigger proc view index for add constraint key primary foreign collate clustered nonclustered"),\n    builtin: set("bigint numeric bit smallint decimal smallmoney int tinyint money float real char varchar text nchar nvarchar ntext binary varbinary image cursor timestamp hierarchyid uniqueidentifier sql_variant xml table "),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=]/,\n    dateSQL: set("date datetimeoffset datetime2 smalldatetime datetime time"),\n    hooks: {\n      "@":   hookVar\n    }\n  });\n\n  CodeMirror.defineMIME("text/x-mysql", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "accessible action add after algorithm all analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general get global grant grants group groupby_concat handler hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show signal slave slow smallint snapshot soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),\n    builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=&|^]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),\n    hooks: {\n      "@":   hookVar,\n      "`":   hookIdentifier,\n      "\\\\":  hookClient\n    }\n  });\n\n  CodeMirror.defineMIME("text/x-mariadb", {\n    name: "sql",\n    client: set("charset clear connect edit ego exit go help nopager notee nowarning pager print prompt quit rehash source status system tee"),\n    keywords: set(sqlKeywords + "accessible action add after algorithm all always analyze asensitive at authors auto_increment autocommit avg avg_row_length before binary binlog both btree cache call cascade cascaded case catalog_name chain change changed character check checkpoint checksum class_origin client_statistics close coalesce code collate collation collations column columns comment commit committed completion concurrent condition connection consistent constraint contains continue contributors convert cross current current_date current_time current_timestamp current_user cursor data database databases day_hour day_microsecond day_minute day_second deallocate dec declare default delay_key_write delayed delimiter des_key_file describe deterministic dev_pop dev_samp deviance diagnostics directory disable discard distinctrow div dual dumpfile each elseif enable enclosed end ends engine engines enum errors escape escaped even event events every execute exists exit explain extended fast fetch field fields first flush for force foreign found_rows full fulltext function general generated get global grant grants group groupby_concat handler hard hash help high_priority hosts hour_microsecond hour_minute hour_second if ignore ignore_server_ids import index index_statistics infile inner innodb inout insensitive insert_method install interval invoker isolation iterate key keys kill language last leading leave left level limit linear lines list load local localtime localtimestamp lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters match max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modifies modify mutex mysql_errno natural next no no_write_to_binlog offline offset one online open optimize option optionally out outer outfile pack_keys parser partition partitions password persistent phase plugin plugins prepare preserve prev primary privileges procedure processlist profile profiles purge query quick range read read_write reads real rebuild recover references regexp relaylog release remove rename reorganize repair repeatable replace require resignal restrict resume return returns revoke right rlike rollback rollup row row_format rtree savepoint schedule schema schema_name schemas second_microsecond security sensitive separator serializable server session share show shutdown signal slave slow smallint snapshot soft soname spatial specific sql sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result sqlexception sqlstate sqlwarning ssl start starting starts status std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace temporary terminated to trailing transaction trigger triggers truncate uncommitted undo uninstall unique unlock upgrade usage use use_frm user user_resources user_statistics using utc_date utc_time utc_timestamp value variables varying view views virtual warnings when while with work write xa xor year_month zerofill begin do then else loop repeat"),\n    builtin: set("bool boolean bit blob decimal double float long longblob longtext medium mediumblob mediumint mediumtext time timestamp tinyblob tinyint tinytext text bigint int int1 int2 int3 int4 int8 integer float float4 float8 double char varbinary varchar varcharacter precision date datetime year unsigned signed numeric"),\n    atoms: set("false true null unknown"),\n    operatorChars: /^[*+\\-%<>!=&|^]/,\n    dateSQL: set("date time timestamp"),\n    support: set("ODBCdotTable decimallessFloat zerolessFloat binaryNumber hexNumber doubleQuote nCharCast charsetCast commentHash commentSpaceRequired"),\n    hooks: {\n      "@":   hookVar,\n      "`":   hookIdentifier,\n      "\\\\":  hookClient\n    }\n  });\n\n  // the query language used by Apache Cassandra is called CQL, but this mime type\n  // is called Cassandra to avoid confusion with Contextual Query Language\n  CodeMirror.defineMIME("text/x-cassandra", {\n    name: "sql",\n    client: { },\n    keywords: set("use select from using consistency where limit first reversed first and in insert into values using consistency ttl update set delete truncate begin batch apply create keyspace with columnfamily primary key index on drop alter type add any one quorum all local_quorum each_quorum"),\n    builtin: set("ascii bigint blob boolean counter decimal double float int text timestamp uuid varchar varint"),\n    atoms: set("false true"),\n    operatorChars: /^[<>=]/,\n    dateSQL: { },\n    support: set("commentSlashSlash decimallessFloat"),\n    hooks: { }\n  });\n\n  // this is based on Peter Raganitsch's 'plsql' mode\n  CodeMirror.defineMIME("text/x-plsql", {\n    name:       "sql",\n    client:     set("appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define describe echo editfile embedded escape exec execute feedback flagger flush heading headsep instance linesize lno loboffset logsource long longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar release repfooter repheader serveroutput shiftinout show showmode size spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout time timing trimout trimspool ttitle underline verify version wrap"),\n    keywords:   set("abort accept access add all alter and any array arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body boolean by case cast char char_base check close cluster clusters colauth column comment commit compress connect connected constant constraint crash create current currval cursor data_base database date dba deallocate debugoff debugon decimal declare default definition delay delete desc digits dispose distinct do drop else elsif enable end entry escape exception exception_init exchange exclusive exists exit external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging long loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base object of off offline on online only open option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw read rebuild record ref references refresh release rename replace resource restrict return returning reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate session set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work"),\n    builtin:    set("abs acos add_months ascii asin atan atan2 average bfile bfilename bit blob ceil character chartorowid chr clob concat convert cos cosh count dec decode deref dual dump dup_val_on_index empty error exp false float floor found glb greatest hextoraw initcap instr instrb int integer isopen last_day least lenght lenghtb ln lower lpad ltrim lub make_ref max min mlslabel mod months_between natural naturaln nchar nclob new_time next_day nextval nls_charset_decl_len nls_charset_id nls_charset_name nls_initcap nls_lower nls_sort nls_upper nlssort no_data_found notfound null number numeric nvarchar2 nvl others power rawtohex real reftohex round rowcount rowidtochar rowtype rpad rtrim sign signtype sin sinh smallint soundex sqlcode sqlerrm sqrt stddev string substr substrb sum sysdate tan tanh to_char text to_date to_label to_multi_byte to_number to_single_byte translate true trunc uid upper user userenv varchar varchar2 variance varying vsize xml"),\n    operatorChars: /^[*+\\-%<>!=~]/,\n    dateSQL:    set("date time timestamp"),\n    support:    set("doubleQuote nCharCast zerolessFloat binaryNumber hexNumber")\n  });\n}());\n\n/*\n  How Properties of Mime Types are used by SQL Mode\n  =================================================\n\n  keywords:\n    A list of keywords you want to be highlighted.\n  functions:\n    A list of function names you want to be highlighted.\n  builtin:\n    A list of builtin types you want to be highlighted (if you want types to be of class "builtin" instead of "keyword").\n  operatorChars:\n    All characters that must be handled as operators.\n  client:\n    Commands parsed and executed by the client (not the server).\n  support:\n    A list of supported syntaxes which are not common, but are supported by more than 1 DBMS.\n    * ODBCdotTable: .tableName\n    * zerolessFloat: .1\n    * doubleQuote\n    * nCharCast: N'string'\n    * charsetCast: _utf8'string'\n    * commentHash: use # char for comments\n    * commentSlashSlash: use // for comments\n    * commentSpaceRequired: require a space after -- for comments\n  atoms:\n    Keywords that must be highlighted as atoms,. Some DBMS's support more atoms than others:\n    UNKNOWN, INFINITY, UNDERFLOW, NaN...\n  dateSQL:\n    Used for date/time SQL standard syntax, because not all DBMS's support same temporal types.\n*/\n\n\n\n\n\n\n\n\n// TODO actually recognize syntax of TypeScript constructs\n\nCodeMirror.defineMode("javascript", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonMode = parserConfig.json;\n  var isTS = parserConfig.typescript;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: "keyword"};}\n    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c");\n    var operator = kw("operator"), atom = {type: "atom", style: "atom"};\n\n    var jsKeywords = {\n      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,\n      "return": C, "break": C, "continue": C, "new": C, "delete": C, "throw": C, "debugger": C,\n      "var": kw("var"), "const": kw("var"), "let": kw("var"),\n      "function": kw("function"), "catch": kw("catch"),\n      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),\n      "in": operator, "typeof": operator, "instanceof": operator,\n      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,\n      "this": kw("this"), "module": kw("module"), "class": kw("class"), "super": kw("atom"),\n      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C\n    };\n\n    // Extend the 'normal' keywords with the TypeScript language extensions\n    if (isTS) {\n      var type = {type: "variable", style: "variable-3"};\n      var tsKeywords = {\n        // object-like things\n        "interface": kw("interface"),\n        "extends": kw("extends"),\n        "constructor": kw("constructor"),\n\n        // scope modifiers\n        "public": kw("public"),\n        "private": kw("private"),\n        "protected": kw("protected"),\n        "static": kw("static"),\n\n        // types\n        "string": type, "number": type, "bool": type, "any": type\n      };\n\n      for (var attr in tsKeywords) {\n        jsKeywords[attr] = tsKeywords[attr];\n      }\n    }\n\n    return jsKeywords;\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^]/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == "/" && !inSet) return;\n        if (next == "[") inSet = true;\n        else if (inSet && next == "]") inSet = false;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '"' || ch == "'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "." && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret("number", "number");\n    } else if (ch == "." && stream.match("..")) {\n      return ret("spread", "meta");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == "=" && stream.eat(">")) {\n      return ret("=>", "operator");\n    } else if (ch == "0" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret("number", "number");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/);\n      return ret("number", "number");\n    } else if (ch == "/") {\n      if (stream.eat("*")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat("/")) {\n        stream.skipToEnd();\n        return ret("comment", "comment");\n      } else if (state.lastType == "operator" || state.lastType == "keyword c" ||\n               state.lastType == "sof" || /^[\\[{}\\(,;:]$/.test(state.lastType)) {\n        readRegexp(stream);\n        stream.eatWhile(/[gimy]/); // 'y' is "sticky" option in Mozilla\n        return ret("regexp", "string-2");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret("operator", "operator", stream.current());\n      }\n    } else if (ch == "`") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == "#") {\n      stream.skipToEnd();\n      return ret("error", "error");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret("operator", "operator", stream.current());\n    } else {\n      stream.eatWhile(/[\\w\\$_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.lastType != ".") ? ret(known.type, known.style, word) :\n                     ret("variable", "variable", word);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == "\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == "/" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ret("comment", "comment");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == "\\\\";\n    }\n    return ret("quasi", "string-2", stream.current());\n  }\n\n  var brackets = "([{}])";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf("=>", stream.start);\n    if (arrow < 0) return;\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) break;\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (/[$\\w]/.test(ch)) {\n        sawSomething = true;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty("align"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == "variable" && inScope(state, content)) return "variable-2";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function register(varname) {\n    function inList(list) {\n      for (var v = list; v; v = v.next)\n        if (v.name == varname) return true;\n      return false;\n    }\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = "def";\n      if (inList(state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else {\n      if (inList(state.globalVars)) return;\n      if (parserConfig.globalVars)\n        state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: "this", next: {name: "arguments"}};\n  function pushcontext() {\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n    cx.state.localVars = defaultVars;\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == "stat") indent = state.lexical.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == ")")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    return function(type) {\n      if (type == wanted) return cont();\n      else if (wanted == ";") return pass();\n      else return cont(arguments.callee);\n    };\n  }\n\n  function statement(type, value) {\n    if (type == "var") return cont(pushlex("vardef", value.length), vardef, expect(";"), poplex);\n    if (type == "keyword a") return cont(pushlex("form"), expression, statement, poplex);\n    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);\n    if (type == "{") return cont(pushlex("}"), block, poplex);\n    if (type == ";") return cont();\n    if (type == "if") return cont(pushlex("form"), expression, statement, poplex, maybeelse);\n    if (type == "function") return cont(functiondef);\n    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);\n    if (type == "variable") return cont(pushlex("stat"), maybelabel);\n    if (type == "switch") return cont(pushlex("form"), expression, pushlex("}", "switch"), expect("{"),\n                                      block, poplex, poplex);\n    if (type == "case") return cont(expression, expect(":"));\n    if (type == "default") return cont(expect(":"));\n    if (type == "catch") return cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"),\n                                     statement, poplex, popcontext);\n    if (type == "module") return cont(pushlex("form"), pushcontext, afterModule, popcontext, poplex);\n    if (type == "class") return cont(pushlex("form"), className, objlit, poplex);\n    if (type == "export") return cont(pushlex("form"), afterExport, poplex);\n    if (type == "import") return cont(pushlex("form"), afterImport, poplex);\n    return pass(pushlex("stat"), expression, expect(";"), poplex);\n  }\n  function expression(type) {\n    return expressionInner(type, false);\n  }\n  function expressionNoComma(type) {\n    return expressionInner(type, true);\n  }\n  function expressionInner(type, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(pattern, ")"), poplex, expect("=>"), body, popcontext);\n      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == "function") return cont(functiondef);\n    if (type == "keyword c") return cont(noComma ? maybeexpressionNoComma : maybeexpression);\n    if (type == "(") return cont(pushlex(")"), maybeexpression, comprehension, expect(")"), poplex, maybeop);\n    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);\n    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);\n    if (type == "{") return contCommasep(objprop, "}", null, maybeop);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n  function maybeexpressionNoComma(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expressionNoComma);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == ",") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (value == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == "operator") {\n      if (/\\+\\+|--/.test(value)) return cont(me);\n      if (value == "?") return cont(expression, expect(":"), expr);\n      return cont(expr);\n    }\n    if (type == "quasi") { cx.cc.push(me); return quasi(value); }\n    if (type == ";") return;\n    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);\n    if (type == ".") return cont(property, me);\n    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);\n  }\n  function quasi(value) {\n    if (value.slice(value.length - 2) != "${") return cont();\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == "}") {\n      cx.marked = "string-2";\n      cx.state.tokenize = tokenQuasi;\n      return cont();\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == "{") return pass(statement);\n    return pass(expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    if (type == "{") return pass(statement);\n    return pass(expressionNoComma);\n  }\n  function maybelabel(type) {\n    if (type == ":") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(";"), poplex);\n  }\n  function property(type) {\n    if (type == "variable") {cx.marked = "property"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == "variable") {\n      cx.marked = "property";\n      if (value == "get" || value == "set") return cont(getterSetter);\n    } else if (type == "number" || type == "string") {\n      cx.marked = type + " property";\n    } else if (type == "[") {\n      return cont(expression, expect("]"), afterprop);\n    }\n    if (atomicTypes.hasOwnProperty(type)) return cont(afterprop);\n  }\n  function getterSetter(type) {\n    if (type != "variable") return pass(afterprop);\n    cx.marked = "property";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == ":") return cont(expressionNoComma);\n    if (type == "(") return pass(functiondef);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == ",") {\n        var lex = cx.state.lexical;\n        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;\n        return cont(what, proceed);\n      }\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == "}") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type) {\n    if (isTS && type == ":") return cont(typedef);\n  }\n  function typedef(type) {\n    if (type == "variable"){cx.marked = "variable-3"; return cont();}\n  }\n  function vardef() {\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (type == "variable") { register(value); return cont(); }\n    if (type == "[") return contCommasep(pattern, "]");\n    if (type == "{") return contCommasep(proppattern, "}");\n  }\n  function proppattern(type, value) {\n    if (type == "variable" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == "variable") cx.marked = "property";\n    return cont(expect(":"), pattern, maybeAssign);\n  }\n  function maybeAssign(_type, value) {\n    if (value == "=") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == ",") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == "keyword b" && value == "else") return cont(pushlex("form"), statement, poplex);\n  }\n  function forspec(type) {\n    if (type == "(") return cont(pushlex(")"), forspec1, expect(")"), poplex);\n  }\n  function forspec1(type) {\n    if (type == "var") return cont(vardef, expect(";"), forspec2);\n    if (type == ";") return cont(forspec2);\n    if (type == "variable") return cont(formaybeinof);\n    return pass(expression, expect(";"), forspec2);\n  }\n  function formaybeinof(_type, value) {\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }\n    return cont(maybeoperatorComma, forspec2);\n  }\n  function forspec2(type, value) {\n    if (type == ";") return cont(forspec3);\n    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression); }\n    return pass(expression, expect(";"), forspec3);\n  }\n  function forspec3(type) {\n    if (type != ")") cont(expression);\n  }\n  function functiondef(type, value) {\n    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}\n    if (type == "variable") {register(value); return cont(functiondef);}\n    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, statement, popcontext);\n  }\n  function funarg(type) {\n    if (type == "spread") return cont(funarg);\n    return pass(pattern, maybetype);\n  }\n  function className(type, value) {\n    if (type == "variable") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(_type, value) {\n    if (value == "extends") return cont(expression);\n  }\n  function objlit(type) {\n    if (type == "{") return contCommasep(objprop, "}");\n  }\n  function afterModule(type, value) {\n    if (type == "string") return cont(statement);\n    if (type == "variable") { register(value); return cont(maybeFrom); }\n  }\n  function afterExport(_type, value) {\n    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }\n    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }\n    return pass(statement);\n  }\n  function afterImport(type) {\n    if (type == "string") return cont();\n    return pass(importSpec, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == "{") return contCommasep(importSpec, "}");\n    if (type == "variable") register(value);\n    return cont();\n  }\n  function maybeFrom(_type, value) {\n    if (value == "from") { cx.marked = "keyword"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == "]") return cont();\n    return pass(expressionNoComma, maybeArrayComprehension);\n  }\n  function maybeArrayComprehension(type) {\n    if (type == "for") return pass(comprehension, expect("]"));\n    if (type == ",") return cont(commasep(expressionNoComma, "]"));\n    return pass(commasep(expressionNoComma, "]"));\n  }\n  function comprehension(type) {\n    if (type == "for") return cont(forspec, comprehension);\n    if (type == "if") return cont(expression, comprehension);\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: "sof",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars) state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty("align"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == "comment") return style;\n      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      if (lexical.type == "stat" && firstChar == "}") lexical = lexical.prev;\n      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info + 1 : 0);\n      else if (type == "form" && firstChar == "{") return lexical.indented;\n      else if (type == "form") return lexical.indented + indentUnit;\n      else if (type == "stat")\n        return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? statementIndent || indentUnit : 0);\n      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: ":{}",\n    blockCommentStart: jsonMode ? null : "/*",\n    blockCommentEnd: jsonMode ? null : "*/",\n    lineComment: jsonMode ? null : "//",\n    fold: "brace",\n\n    helperType: jsonMode ? "json" : "javascript",\n    jsonMode: jsonMode\n  };\n});\n\nCodeMirror.defineMIME("text/javascript", "javascript");\nCodeMirror.defineMIME("text/ecmascript", "javascript");\nCodeMirror.defineMIME("application/javascript", "javascript");\nCodeMirror.defineMIME("application/ecmascript", "javascript");\nCodeMirror.defineMIME("application/json", {name: "javascript", json: true});\nCodeMirror.defineMIME("application/x-json", {name: "javascript", json: true});\nCodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });\nCodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });\n\n\n\n\n\n\n        \n        \n        \nCodeMirror.defineMode("xml", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var multilineTagIndentFactor = parserConfig.multilineTagIndentFactor || 1;\n  var multilineTagIndentPastTag = parserConfig.multilineTagIndentPastTag || true;\n\n  var Kludges = parserConfig.htmlMode ? {\n    autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,\n                      'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,\n                      'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,\n                      'track': true, 'wbr': true},\n    implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,\n                       'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,\n                       'th': true, 'tr': true},\n    contextGrabbers: {\n      'dd': {'dd': true, 'dt': true},\n      'dt': {'dd': true, 'dt': true},\n      'li': {'li': true},\n      'option': {'option': true, 'optgroup': true},\n      'optgroup': {'optgroup': true},\n      'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,\n            'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,\n            'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,\n            'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,\n            'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},\n      'rp': {'rp': true, 'rt': true},\n      'rt': {'rp': true, 'rt': true},\n      'tbody': {'tbody': true, 'tfoot': true},\n      'td': {'td': true, 'th': true},\n      'tfoot': {'tbody': true},\n      'th': {'td': true, 'th': true},\n      'thead': {'tbody': true, 'tfoot': true},\n      'tr': {'tr': true}\n    },\n    doNotIndent: {"pre": true},\n    allowUnquoted: true,\n    allowMissing: true\n  } : {\n    autoSelfClosers: {},\n    implicitlyClosed: {},\n    contextGrabbers: {},\n    doNotIndent: {},\n    allowUnquoted: false,\n    allowMissing: false\n  };\n  var alignCDATA = parserConfig.alignCDATA;\n\n  // Return variables for tokenizers\n  var tagName, type, setStyle;\n\n  function inText(stream, state) {\n    function chain(parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    var ch = stream.next();\n    if (ch == "<") {\n      if (stream.eat("!")) {\n        if (stream.eat("[")) {\n          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));\n          else return null;\n        } else if (stream.match("--")) {\n          return chain(inBlock("comment", "-->"));\n        } else if (stream.match("DOCTYPE", true, true)) {\n          stream.eatWhile(/[\\w\\._\\-]/);\n          return chain(doctype(1));\n        } else {\n          return null;\n        }\n      } else if (stream.eat("?")) {\n        stream.eatWhile(/[\\w\\._\\-]/);\n        state.tokenize = inBlock("meta", "?>");\n        return "meta";\n      } else {\n        var isClose = stream.eat("/");\n        tagName = "";\n        var c;\n        while ((c = stream.eat(/[^\\s\\u00a0=<>\\"\\'\\/?]/))) tagName += c;\n        if (!tagName) return "tag error";\n        type = isClose ? "closeTag" : "openTag";\n        state.tokenize = inTag;\n        return "tag";\n      }\n    } else if (ch == "&") {\n      var ok;\n      if (stream.eat("#")) {\n        if (stream.eat("x")) {\n          ok = stream.eatWhile(/[a-fA-F\\d]/) && stream.eat(";");\n        } else {\n          ok = stream.eatWhile(/[\\d]/) && stream.eat(";");\n        }\n      } else {\n        ok = stream.eatWhile(/[\\w\\.\\-:]/) && stream.eat(";");\n      }\n      return ok ? "atom" : "error";\n    } else {\n      stream.eatWhile(/[^&<]/);\n      return null;\n    }\n  }\n\n  function inTag(stream, state) {\n    var ch = stream.next();\n    if (ch == ">" || (ch == "/" && stream.eat(">"))) {\n      state.tokenize = inText;\n      type = ch == ">" ? "endTag" : "selfcloseTag";\n      return "tag";\n    } else if (ch == "=") {\n      type = "equals";\n      return null;\n    } else if (ch == "<") {\n      state.tokenize = inText;\n      state.state = baseState;\n      state.tagName = state.tagStart = null;\n      var next = state.tokenize(stream, state);\n      return next ? next + " error" : "error";\n    } else if (/[\\'\\"]/.test(ch)) {\n      state.tokenize = inAttribute(ch);\n      state.stringStartCol = stream.column();\n      return state.tokenize(stream, state);\n    } else {\n      stream.eatWhile(/[^\\s\\u00a0=<>\\"\\']/);\n      return "word";\n    }\n  }\n\n  function inAttribute(quote) {\n    var closure = function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.next() == quote) {\n          state.tokenize = inTag;\n          break;\n        }\n      }\n      return "string";\n    };\n    closure.isInAttribute = true;\n    return closure;\n  }\n\n  function inBlock(style, terminator) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        if (stream.match(terminator)) {\n          state.tokenize = inText;\n          break;\n        }\n        stream.next();\n      }\n      return style;\n    };\n  }\n  function doctype(depth) {\n    return function(stream, state) {\n      var ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == "<") {\n          state.tokenize = doctype(depth + 1);\n          return state.tokenize(stream, state);\n        } else if (ch == ">") {\n          if (depth == 1) {\n            state.tokenize = inText;\n            break;\n          } else {\n            state.tokenize = doctype(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n      return "meta";\n    };\n  }\n\n  function Context(state, tagName, startOfLine) {\n    this.prev = state.context;\n    this.tagName = tagName;\n    this.indent = state.indented;\n    this.startOfLine = startOfLine;\n    if (Kludges.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))\n      this.noIndent = true;\n  }\n  function popContext(state) {\n    if (state.context) state.context = state.context.prev;\n  }\n  function maybePopContext(state, nextTagName) {\n    var parentTagName;\n    while (true) {\n      if (!state.context) {\n        return;\n      }\n      parentTagName = state.context.tagName.toLowerCase();\n      if (!Kludges.contextGrabbers.hasOwnProperty(parentTagName) ||\n          !Kludges.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {\n        return;\n      }\n      popContext(state);\n    }\n  }\n\n  function baseState(type, stream, state) {\n    if (type == "openTag") {\n      state.tagName = tagName;\n      state.tagStart = stream.column();\n      return attrState;\n    } else if (type == "closeTag") {\n      var err = false;\n      if (state.context) {\n        if (state.context.tagName != tagName) {\n          if (Kludges.implicitlyClosed.hasOwnProperty(state.context.tagName.toLowerCase()))\n            popContext(state);\n          err = !state.context || state.context.tagName != tagName;\n        }\n      } else {\n        err = true;\n      }\n      if (err) setStyle = "error";\n      return err ? closeStateErr : closeState;\n    } else {\n      return baseState;\n    }\n  }\n  function closeState(type, _stream, state) {\n    if (type != "endTag") {\n      setStyle = "error";\n      return closeState;\n    }\n    popContext(state);\n    return baseState;\n  }\n  function closeStateErr(type, stream, state) {\n    setStyle = "error";\n    return closeState(type, stream, state);\n  }\n\n  function attrState(type, _stream, state) {\n    if (type == "word") {\n      setStyle = "attribute";\n      return attrEqState;\n    } else if (type == "endTag" || type == "selfcloseTag") {\n      var tagName = state.tagName, tagStart = state.tagStart;\n      state.tagName = state.tagStart = null;\n      if (type == "selfcloseTag" ||\n          Kludges.autoSelfClosers.hasOwnProperty(tagName.toLowerCase())) {\n        maybePopContext(state, tagName.toLowerCase());\n      } else {\n        maybePopContext(state, tagName.toLowerCase());\n        state.context = new Context(state, tagName, tagStart == state.indented);\n      }\n      return baseState;\n    }\n    setStyle = "error";\n    return attrState;\n  }\n  function attrEqState(type, stream, state) {\n    if (type == "equals") return attrValueState;\n    if (!Kludges.allowMissing) setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrValueState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    if (type == "word" && Kludges.allowUnquoted) {setStyle = "string"; return attrState;}\n    setStyle = "error";\n    return attrState(type, stream, state);\n  }\n  function attrContinuedState(type, stream, state) {\n    if (type == "string") return attrContinuedState;\n    return attrState(type, stream, state);\n  }\n\n  return {\n    startState: function() {\n      return {tokenize: inText,\n              state: baseState,\n              indented: 0,\n              tagName: null, tagStart: null,\n              context: null};\n    },\n\n    token: function(stream, state) {\n      if (!state.tagName && stream.sol())\n        state.indented = stream.indentation();\n\n      if (stream.eatSpace()) return null;\n      tagName = type = null;\n      var style = state.tokenize(stream, state);\n      if ((style || type) && style != "comment") {\n        setStyle = null;\n        state.state = state.state(type || style, stream, state);\n        if (setStyle)\n          style = setStyle == "error" ? style + " error" : setStyle;\n      }\n      return style;\n    },\n\n    indent: function(state, textAfter, fullLine) {\n      var context = state.context;\n      // Indent multi-line strings (e.g. css).\n      if (state.tokenize.isInAttribute) {\n        return state.stringStartCol + 1;\n      }\n      if (context && context.noIndent) return CodeMirror.Pass;\n      if (state.tokenize != inTag && state.tokenize != inText)\n        return fullLine ? fullLine.match(/^(\\s*)/)[0].length : 0;\n      // Indent the starts of attribute names.\n      if (state.tagName) {\n        if (multilineTagIndentPastTag)\n          return state.tagStart + state.tagName.length + 2;\n        else\n          return state.tagStart + indentUnit * multilineTagIndentFactor;\n      }\n      if (alignCDATA && /<!\\[CDATA\\[/.test(textAfter)) return 0;\n      if (context && /^<\\//.test(textAfter))\n        context = context.prev;\n      while (context && !context.startOfLine)\n        context = context.prev;\n      if (context) return context.indent + indentUnit;\n      else return 0;\n    },\n\n    electricChars: "/",\n    blockCommentStart: "<!--",\n    blockCommentEnd: "-->",\n\n    configuration: parserConfig.htmlMode ? "html" : "xml",\n    helperType: parserConfig.htmlMode ? "html" : "xml"\n  };\n});\n\nCodeMirror.defineMIME("text/xml", "xml");\nCodeMirror.defineMIME("application/xml", "xml");\nif (!CodeMirror.mimeModes.hasOwnProperty("text/html"))\n  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});        \n        \n        \n        \n        \n        \n        \n\n\n\n// HTMLMIXED\n\nCodeMirror.defineMode("htmlmixed", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});\n  var cssMode = CodeMirror.getMode(config, "css");\n\n  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;\n  scriptTypes.push({matches: /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i,\n                    mode: CodeMirror.getMode(config, "javascript")});\n  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {\n    var conf = scriptTypesConf[i];\n    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});\n  }\n  scriptTypes.push({matches: /./,\n                    mode: CodeMirror.getMode(config, "text/plain")});\n\n  function html(stream, state) {\n    var tagName = state.htmlState.tagName;\n    var style = htmlMode.token(stream, state.htmlState);\n    if (tagName == "script" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      // Script block: mode to change to depends on type attribute\n      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\\btype\\s*=\\s*("[^"]+"|'[^']+'|\\S+)[^<]*$/i);\n      scriptType = scriptType ? scriptType[1] : "";\n      if (scriptType && /[\\"\\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);\n      for (var i = 0; i < scriptTypes.length; ++i) {\n        var tp = scriptTypes[i];\n        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {\n          if (tp.mode) {\n            state.token = script;\n            state.localMode = tp.mode;\n            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));\n          }\n          break;\n        }\n      }\n    } else if (tagName == "style" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      state.token = css;\n      state.localMode = cssMode;\n      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur[0]);\n    }\n    return style;\n  }\n  function script(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       state.localMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localMode: null, localState: null, htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.localMode, state.localState);\n      return {token: state.token, localMode: state.localMode, localState: local,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.localMode || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.localMode.indent)\n        return state.localMode.indent(state.localState, textAfter);\n      else\n        return CodeMirror.Pass;\n    },\n\n    electricChars: "/{}:",\n\n    innerMode: function(state) {\n      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n    }\n  };\n}, "xml", "javascript", "css");\n\nCodeMirror.defineMIME("text/html", "htmlmixed");\n\n\n\n\n\n\n/* 3.21 version, which hash a bug\nCodeMirror.defineMode("htmlmixed", function(config, parserConfig) {\n  var htmlMode = CodeMirror.getMode(config, {name: "xml", htmlMode: true});\n  var cssMode = CodeMirror.getMode(config, "css");\n\n  var scriptTypes = [], scriptTypesConf = parserConfig && parserConfig.scriptTypes;\n  scriptTypes.push({matches: /^(?:text|application)\\/(?:x-)?(?:java|ecma)script$|^$/i,\n                    mode: CodeMirror.getMode(config, "javascript")});\n  if (scriptTypesConf) for (var i = 0; i < scriptTypesConf.length; ++i) {\n    var conf = scriptTypesConf[i];\n    scriptTypes.push({matches: conf.matches, mode: conf.mode && CodeMirror.getMode(config, conf.mode)});\n  }\n  scriptTypes.push({matches: /./,\n                    mode: CodeMirror.getMode(config, "text/plain")});\n\n  function html(stream, state) {\n    var tagName = state.htmlState.tagName;\n    var style = htmlMode.token(stream, state.htmlState);\n    if (tagName == "script" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      // Script block: mode to change to depends on type attribute\n      var scriptType = stream.string.slice(Math.max(0, stream.pos - 100), stream.pos).match(/\\btype\\s*=\\s*("[^"]+"|'[^']+'|\\S+)[^<]*$/i);\n      scriptType = scriptType ? scriptType[1] : "";\n      if (scriptType && /[\\"\\']/.test(scriptType.charAt(0))) scriptType = scriptType.slice(1, scriptType.length - 1);\n      for (var i = 0; i < scriptTypes.length; ++i) {\n        var tp = scriptTypes[i];\n        if (typeof tp.matches == "string" ? scriptType == tp.matches : tp.matches.test(scriptType)) {\n          if (tp.mode) {\n            state.token = script;\n            state.localMode = tp.mode;\n            state.localState = tp.mode.startState && tp.mode.startState(htmlMode.indent(state.htmlState, ""));\n          }\n          break;\n        }\n      }\n    } else if (tagName == "style" && /\\btag\\b/.test(style) && stream.current() == ">") {\n      state.token = css;\n      state.localMode = cssMode;\n      state.localState = cssMode.startState(htmlMode.indent(state.htmlState, ""));\n    }\n    return style;\n  }\n  function maybeBackup(stream, pat, style) {\n    var cur = stream.current();\n    var close = cur.search(pat), m;\n    if (close > -1) stream.backUp(cur.length - close);\n    else if (m = cur.match(/<\\/?$/)) {\n      stream.backUp(cur.length);\n      if (!stream.match(pat, false)) stream.match(cur);\n    }\n    return style;\n  }\n  function script(stream, state) {\n    if (stream.match(/^<\\/\\s*script\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*script\\s*>/,\n                       state.localMode.token(stream, state.localState));\n  }\n  function css(stream, state) {\n    if (stream.match(/^<\\/\\s*style\\s*>/i, false)) {\n      state.token = html;\n      state.localState = state.localMode = null;\n      return html(stream, state);\n    }\n    return maybeBackup(stream, /<\\/\\s*style\\s*>/,\n                       cssMode.token(stream, state.localState));\n  }\n\n  return {\n    startState: function() {\n      var state = htmlMode.startState();\n      return {token: html, localMode: null, localState: null, htmlState: state};\n    },\n\n    copyState: function(state) {\n      if (state.localState)\n        var local = CodeMirror.copyState(state.localMode, state.localState);\n      return {token: state.token, localMode: state.localMode, localState: local,\n              htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};\n    },\n\n    token: function(stream, state) {\n      return state.token(stream, state);\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.localMode || /^\\s*<\\//.test(textAfter))\n        return htmlMode.indent(state.htmlState, textAfter);\n      else if (state.localMode.indent)\n        return state.localMode.indent(state.localState, textAfter);\n      else\n        return CodeMirror.Pass;\n    },\n\n    innerMode: function(state) {\n      return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};\n    }\n  };\n}, "xml", "javascript", "css");\n\nCodeMirror.defineMIME("text/html", "htmlmixed");\n\n*/\n\n\n\n\n\nCodeMirror.defineMode("css", function(config, parserConfig) {\n  "use strict";\n\n  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");\n\n  var indentUnit = config.indentUnit,\n      tokenHooks = parserConfig.tokenHooks,\n      mediaTypes = parserConfig.mediaTypes || {},\n      mediaFeatures = parserConfig.mediaFeatures || {},\n      propertyKeywords = parserConfig.propertyKeywords || {},\n      colorKeywords = parserConfig.colorKeywords || {},\n      valueKeywords = parserConfig.valueKeywords || {},\n      fontProperties = parserConfig.fontProperties || {},\n      allowNested = parserConfig.allowNested;\n\n  var type, override;\n  function ret(style, tp) { type = tp; return style; }\n\n  // Tokenizers\n\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (tokenHooks[ch]) {\n      var result = tokenHooks[ch](stream, state);\n      if (result !== false) return result;\n    }\n    if (ch == "@") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("def", stream.current());\n    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {\n      return ret(null, "compare");\n    } else if (ch == "\\"" || ch == "'") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == "#") {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("atom", "hash");\n    } else if (ch == "!") {\n      stream.match(/^\\s*\\w*/);\n      return ret("keyword", "important");\n    } else if (/\\d/.test(ch) || ch == "." && stream.eat(/\\d/)) {\n      stream.eatWhile(/[\\w.%]/);\n      return ret("number", "unit");\n    } else if (ch === "-") {\n      if (/[\\d.]/.test(stream.peek())) {\n        stream.eatWhile(/[\\w.%]/);\n        return ret("number", "unit");\n      } else if (stream.match(/^[^-]+-/)) {\n        return ret("meta", "meta");\n      }\n    } else if (/[,+>*\\/]/.test(ch)) {\n      return ret(null, "select-op");\n    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {\n      return ret("qualifier", "qualifier");\n    } else if (/[:;{}\\[\\]\\(\\)]/.test(ch)) {\n      return ret(null, ch);\n    } else if (ch == "u" && stream.match("rl(")) {\n      stream.backUp(1);\n      state.tokenize = tokenParenthesized;\n      return ret("property", "word");\n    } else if (/[\\w\\\\\\-]/.test(ch)) {\n      stream.eatWhile(/[\\w\\\\\\-]/);\n      return ret("property", "word");\n    } else {\n      return ret(null, null);\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, ch;\n      while ((ch = stream.next()) != null) {\n        if (ch == quote && !escaped) {\n          if (quote == ")") stream.backUp(1);\n          break;\n        }\n        escaped = !escaped && ch == "\\\\";\n      }\n      if (ch == quote || !escaped && quote != ")") state.tokenize = null;\n      return ret("string", "string");\n    };\n  }\n\n  function tokenParenthesized(stream, state) {\n    stream.next(); // Must be '('\n    if (!stream.match(/\\s*[\\"\\']/, false))\n      state.tokenize = tokenString(")");\n    else\n      state.tokenize = null;\n    return ret(null, "(");\n  }\n\n  // Context management\n\n  function Context(type, indent, prev) {\n    this.type = type;\n    this.indent = indent;\n    this.prev = prev;\n  }\n\n  function pushContext(state, stream, type) {\n    state.context = new Context(type, stream.indentation() + indentUnit, state.context);\n    return type;\n  }\n\n  function popContext(state) {\n    state.context = state.context.prev;\n    return state.context.type;\n  }\n\n  function pass(type, stream, state) {\n    return states[state.context.type](type, stream, state);\n  }\n  function popAndPass(type, stream, state, n) {\n    for (var i = n || 1; i > 0; i--)\n      state.context = state.context.prev;\n    return pass(type, stream, state);\n  }\n\n  // Parser\n\n  function wordAsValue(stream) {\n    var word = stream.current().toLowerCase();\n    if (valueKeywords.hasOwnProperty(word))\n      override = "atom";\n    else if (colorKeywords.hasOwnProperty(word))\n      override = "keyword";\n    else\n      override = "variable";\n  }\n\n  var states = {};\n\n  states.top = function(type, stream, state) {\n    if (type == "{") {\n      return pushContext(state, stream, "block");\n    } else if (type == "}" && state.context.prev) {\n      return popContext(state);\n    } else if (type == "@media") {\n      return pushContext(state, stream, "media");\n    } else if (type == "@font-face") {\n      return "font_face_before";\n    } else if (type && type.charAt(0) == "@") {\n      return pushContext(state, stream, "at");\n    } else if (type == "hash") {\n      override = "builtin";\n    } else if (type == "word") {\n      override = "tag";\n    } else if (type == "variable-definition") {\n      return "maybeprop";\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    } else if (type == ":") {\n      return "pseudo";\n    } else if (allowNested && type == "(") {\n      return pushContext(state, stream, "params");\n    }\n    return state.context.type;\n  };\n\n  states.block = function(type, stream, state) {\n    if (type == "word") {\n      if (propertyKeywords.hasOwnProperty(stream.current().toLowerCase())) {\n        override = "property";\n        return "maybeprop";\n      } else if (allowNested) {\n        override = stream.match(/^\\s*:/, false) ? "property" : "tag";\n        return "block";\n      } else {\n        override += " error";\n        return "maybeprop";\n      }\n    } else if (type == "meta") {\n      return "block";\n    } else if (!allowNested && (type == "hash" || type == "qualifier")) {\n      override = "error";\n      return "block";\n    } else {\n      return states.top(type, stream, state);\n    }\n  };\n\n  states.maybeprop = function(type, stream, state) {\n    if (type == ":") return pushContext(state, stream, "prop");\n    return pass(type, stream, state);\n  };\n\n  states.prop = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");\n    if (type == "}" || type == "{") return popAndPass(type, stream, state);\n    if (type == "(") return pushContext(state, stream, "parens");\n\n    if (type == "hash" && !/^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/.test(stream.current())) {\n      override += " error";\n    } else if (type == "word") {\n      wordAsValue(stream);\n    } else if (type == "interpolation") {\n      return pushContext(state, stream, "interpolation");\n    }\n    return "prop";\n  };\n\n  states.propBlock = function(type, _stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") { override = "property"; return "maybeprop"; }\n    return state.context.type;\n  };\n\n  states.parens = function(type, stream, state) {\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == ")") return popContext(state);\n    return "parens";\n  };\n\n  states.pseudo = function(type, stream, state) {\n    if (type == "word") {\n      override = "variable-3";\n      return state.context.type;\n    }\n    return pass(type, stream, state);\n  };\n\n  states.media = function(type, stream, state) {\n    if (type == "(") return pushContext(state, stream, "media_parens");\n    if (type == "}") return popAndPass(type, stream, state);\n    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");\n\n    if (type == "word") {\n      var word = stream.current().toLowerCase();\n      if (word == "only" || word == "not" || word == "and")\n        override = "keyword";\n      else if (mediaTypes.hasOwnProperty(word))\n        override = "attribute";\n      else if (mediaFeatures.hasOwnProperty(word))\n        override = "property";\n      else\n        override = "error";\n    }\n    return state.context.type;\n  };\n\n  states.media_parens = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);\n    return states.media(type, stream, state);\n  };\n\n  states.font_face_before = function(type, stream, state) {\n    if (type == "{")\n      return pushContext(state, stream, "font_face");\n    return pass(type, stream, state);\n  };\n\n  states.font_face = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "word") {\n      if (!fontProperties.hasOwnProperty(stream.current().toLowerCase()))\n        override = "error";\n      else\n        override = "property";\n      return "maybeprop";\n    }\n    return "font_face";\n  };\n\n  states.at = function(type, stream, state) {\n    if (type == ";") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") override = "tag";\n    else if (type == "hash") override = "builtin";\n    return "at";\n  };\n\n  states.interpolation = function(type, stream, state) {\n    if (type == "}") return popContext(state);\n    if (type == "{" || type == ";") return popAndPass(type, stream, state);\n    if (type != "variable") override = "error";\n    return "interpolation";\n  };\n\n  states.params = function(type, stream, state) {\n    if (type == ")") return popContext(state);\n    if (type == "{" || type == "}") return popAndPass(type, stream, state);\n    if (type == "word") wordAsValue(stream);\n    return "params";\n  };\n\n  return {\n    startState: function(base) {\n      return {tokenize: null,\n              state: "top",\n              context: new Context("top", base || 0, null)};\n    },\n\n    token: function(stream, state) {\n      if (!state.tokenize && stream.eatSpace()) return null;\n      var style = (state.tokenize || tokenBase)(stream, state);\n      if (style && typeof style == "object") {\n        type = style[1];\n        style = style[0];\n      }\n      override = style;\n      state.state = states[state.state](type, stream, state);\n      return override;\n    },\n\n    indent: function(state, textAfter) {\n      var cx = state.context, ch = textAfter && textAfter.charAt(0);\n      var indent = cx.indent;\n      if (cx.prev &&\n          (ch == "}" && (cx.type == "block" || cx.type == "top" || cx.type == "interpolation" || cx.type == "font_face") ||\n           ch == ")" && (cx.type == "parens" || cx.type == "params" || cx.type == "media_parens") ||\n           ch == "{" && (cx.type == "at" || cx.type == "media"))) {\n        indent = cx.indent - indentUnit;\n        cx = cx.prev;\n      }\n      return indent;\n    },\n\n    electricChars: "}",\n    blockCommentStart: "/*",\n    blockCommentEnd: "*/",\n    fold: "brace"\n  };\n});\n\n(function() {\n  function keySet(array) {\n    var keys = {};\n    for (var i = 0; i < array.length; ++i) {\n      keys[array[i]] = true;\n    }\n    return keys;\n  }\n\n  var mediaTypes_ = [\n    "all", "aural", "braille", "handheld", "print", "projection", "screen",\n    "tty", "tv", "embossed"\n  ], mediaTypes = keySet(mediaTypes_);\n\n  var mediaFeatures_ = [\n    "width", "min-width", "max-width", "height", "min-height", "max-height",\n    "device-width", "min-device-width", "max-device-width", "device-height",\n    "min-device-height", "max-device-height", "aspect-ratio",\n    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",\n    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",\n    "max-color", "color-index", "min-color-index", "max-color-index",\n    "monochrome", "min-monochrome", "max-monochrome", "resolution",\n    "min-resolution", "max-resolution", "scan", "grid"\n  ], mediaFeatures = keySet(mediaFeatures_);\n\n  var propertyKeywords_ = [\n    "align-content", "align-items", "align-self", "alignment-adjust",\n    "alignment-baseline", "anchor-point", "animation", "animation-delay",\n    "animation-direction", "animation-duration", "animation-iteration-count",\n    "animation-name", "animation-play-state", "animation-timing-function",\n    "appearance", "azimuth", "backface-visibility", "background",\n    "background-attachment", "background-clip", "background-color",\n    "background-image", "background-origin", "background-position",\n    "background-repeat", "background-size", "baseline-shift", "binding",\n    "bleed", "bookmark-label", "bookmark-level", "bookmark-state",\n    "bookmark-target", "border", "border-bottom", "border-bottom-color",\n    "border-bottom-left-radius", "border-bottom-right-radius",\n    "border-bottom-style", "border-bottom-width", "border-collapse",\n    "border-color", "border-image", "border-image-outset",\n    "border-image-repeat", "border-image-slice", "border-image-source",\n    "border-image-width", "border-left", "border-left-color",\n    "border-left-style", "border-left-width", "border-radius", "border-right",\n    "border-right-color", "border-right-style", "border-right-width",\n    "border-spacing", "border-style", "border-top", "border-top-color",\n    "border-top-left-radius", "border-top-right-radius", "border-top-style",\n    "border-top-width", "border-width", "bottom", "box-decoration-break",\n    "box-shadow", "box-sizing", "break-after", "break-before", "break-inside",\n    "caption-side", "clear", "clip", "color", "color-profile", "column-count",\n    "column-fill", "column-gap", "column-rule", "column-rule-color",\n    "column-rule-style", "column-rule-width", "column-span", "column-width",\n    "columns", "content", "counter-increment", "counter-reset", "crop", "cue",\n    "cue-after", "cue-before", "cursor", "direction", "display",\n    "dominant-baseline", "drop-initial-after-adjust",\n    "drop-initial-after-align", "drop-initial-before-adjust",\n    "drop-initial-before-align", "drop-initial-size", "drop-initial-value",\n    "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis",\n    "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap",\n    "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings",\n    "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust",\n    "font-stretch", "font-style", "font-synthesis", "font-variant",\n    "font-variant-alternates", "font-variant-caps", "font-variant-east-asian",\n    "font-variant-ligatures", "font-variant-numeric", "font-variant-position",\n    "font-weight", "grid-cell", "grid-column", "grid-column-align",\n    "grid-column-sizing", "grid-column-span", "grid-columns", "grid-flow",\n    "grid-row", "grid-row-align", "grid-row-sizing", "grid-row-span",\n    "grid-rows", "grid-template", "hanging-punctuation", "height", "hyphens",\n    "icon", "image-orientation", "image-rendering", "image-resolution",\n    "inline-box-align", "justify-content", "left", "letter-spacing",\n    "line-break", "line-height", "line-stacking", "line-stacking-ruby",\n    "line-stacking-shift", "line-stacking-strategy", "list-style",\n    "list-style-image", "list-style-position", "list-style-type", "margin",\n    "margin-bottom", "margin-left", "margin-right", "margin-top",\n    "marker-offset", "marks", "marquee-direction", "marquee-loop",\n    "marquee-play-count", "marquee-speed", "marquee-style", "max-height",\n    "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index",\n    "nav-left", "nav-right", "nav-up", "opacity", "order", "orphans", "outline",\n    "outline-color", "outline-offset", "outline-style", "outline-width",\n    "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y",\n    "padding", "padding-bottom", "padding-left", "padding-right", "padding-top",\n    "page", "page-break-after", "page-break-before", "page-break-inside",\n    "page-policy", "pause", "pause-after", "pause-before", "perspective",\n    "perspective-origin", "pitch", "pitch-range", "play-during", "position",\n    "presentation-level", "punctuation-trim", "quotes", "region-break-after",\n    "region-break-before", "region-break-inside", "region-fragment",\n    "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness",\n    "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang",\n    "ruby-position", "ruby-span", "shape-inside", "shape-outside", "size",\n    "speak", "speak-as", "speak-header",\n    "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set",\n    "tab-size", "table-layout", "target", "target-name", "target-new",\n    "target-position", "text-align", "text-align-last", "text-decoration",\n    "text-decoration-color", "text-decoration-line", "text-decoration-skip",\n    "text-decoration-style", "text-emphasis", "text-emphasis-color",\n    "text-emphasis-position", "text-emphasis-style", "text-height",\n    "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow",\n    "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position",\n    "text-wrap", "top", "transform", "transform-origin", "transform-style",\n    "transition", "transition-delay", "transition-duration",\n    "transition-property", "transition-timing-function", "unicode-bidi",\n    "vertical-align", "visibility", "voice-balance", "voice-duration",\n    "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress",\n    "voice-volume", "volume", "white-space", "widows", "width", "word-break",\n    "word-spacing", "word-wrap", "z-index", "zoom",\n    // SVG-specific\n    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",\n    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",\n    "color-interpolation", "color-interpolation-filters", "color-profile",\n    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",\n    "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke",\n    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",\n    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",\n    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",\n    "glyph-orientation-vertical", "kerning", "text-anchor", "writing-mode"\n  ], propertyKeywords = keySet(propertyKeywords_);\n\n  var colorKeywords_ = [\n    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",\n    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",\n    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",\n    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",\n    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",\n    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",\n    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",\n    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",\n    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",\n    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",\n    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",\n    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",\n    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",\n    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",\n    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",\n    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",\n    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",\n    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",\n    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",\n    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",\n    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",\n    "purple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon",\n    "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",\n    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",\n    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",\n    "whitesmoke", "yellow", "yellowgreen"\n  ], colorKeywords = keySet(colorKeywords_);\n\n  var valueKeywords_ = [\n    "above", "absolute", "activeborder", "activecaption", "afar",\n    "after-white-space", "ahead", "alias", "all", "all-scroll", "alternate",\n    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",\n    "arabic-indic", "armenian", "asterisks", "auto", "avoid", "avoid-column", "avoid-page",\n    "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary",\n    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",\n    "both", "bottom", "break", "break-all", "break-word", "button", "button-bevel",\n    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "cambodian",\n    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",\n    "cell", "center", "checkbox", "circle", "cjk-earthly-branch",\n    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",\n    "col-resize", "collapse", "column", "compact", "condensed", "contain", "content",\n    "content-box", "context-menu", "continuous", "copy", "cover", "crop",\n    "cross", "crosshair", "currentcolor", "cursive", "dashed", "decimal",\n    "decimal-leading-zero", "default", "default-button", "destination-atop",\n    "destination-in", "destination-out", "destination-over", "devanagari",\n    "disc", "discard", "document", "dot-dash", "dot-dot-dash", "dotted",\n    "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",\n    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",\n    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",\n    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",\n    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",\n    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",\n    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",\n    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et",\n    "ethiopic-halehame-tig", "ew-resize", "expanded", "extra-condensed",\n    "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "footnotes",\n    "forwards", "from", "geometricPrecision", "georgian", "graytext", "groove",\n    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hebrew",\n    "help", "hidden", "hide", "higher", "highlight", "highlighttext",\n    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "icon", "ignore",\n    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",\n    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",\n    "inline-block", "inline-table", "inset", "inside", "intrinsic", "invert",\n    "italic", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer",\n    "landscape", "lao", "large", "larger", "left", "level", "lighter",\n    "line-through", "linear", "lines", "list-item", "listbox", "listitem",\n    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",\n    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",\n    "lower-roman", "lowercase", "ltr", "malayalam", "match",\n    "media-controls-background", "media-current-time-display",\n    "media-fullscreen-button", "media-mute-button", "media-play-button",\n    "media-return-to-realtime-button", "media-rewind-button",\n    "media-seek-back-button", "media-seek-forward-button", "media-slider",\n    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",\n    "media-volume-slider-container", "media-volume-sliderthumb", "medium",\n    "menu", "menulist", "menulist-button", "menulist-text",\n    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",\n    "mix", "mongolian", "monospace", "move", "multiple", "myanmar", "n-resize",\n    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",\n    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",\n    "ns-resize", "nw-resize", "nwse-resize", "oblique", "octal", "open-quote",\n    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",\n    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",\n    "painted", "page", "paused", "persian", "plus-darker", "plus-lighter", "pointer",\n    "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button",\n    "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region",\n    "relative", "repeat", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba",\n    "ridge", "right", "round", "row-resize", "rtl", "run-in", "running",\n    "s-resize", "sans-serif", "scroll", "scrollbar", "se-resize", "searchfield",\n    "searchfield-cancel-button", "searchfield-decoration",\n    "searchfield-results-button", "searchfield-results-decoration",\n    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",\n    "single", "skip-white-space", "slide", "slider-horizontal",\n    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",\n    "small", "small-caps", "small-caption", "smaller", "solid", "somali",\n    "source-atop", "source-in", "source-out", "source-over", "space", "square",\n    "square-button", "start", "static", "status-bar", "stretch", "stroke",\n    "sub", "subpixel-antialiased", "super", "sw-resize", "table",\n    "table-caption", "table-cell", "table-column", "table-column-group",\n    "table-footer-group", "table-header-group", "table-row", "table-row-group",\n    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",\n    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",\n    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",\n    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",\n    "transparent", "ultra-condensed", "ultra-expanded", "underline", "up",\n    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",\n    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",\n    "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted",\n    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",\n    "window", "windowframe", "windowtext", "x-large", "x-small", "xor",\n    "xx-large", "xx-small"\n  ], valueKeywords = keySet(valueKeywords_);\n\n  var fontProperties_ = [\n    "font-family", "src", "unicode-range", "font-variant", "font-feature-settings",\n    "font-stretch", "font-weight", "font-style"\n  ], fontProperties = keySet(fontProperties_);\n\n  var allWords = mediaTypes_.concat(mediaFeatures_).concat(propertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);\n  CodeMirror.registerHelper("hintWords", "css", allWords);\n\n  function tokenCComment(stream, state) {\n    var maybeEnd = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (maybeEnd && ch == "/") {\n        state.tokenize = null;\n        break;\n      }\n      maybeEnd = (ch == "*");\n    }\n    return ["comment", "comment"];\n  }\n\n  function tokenSGMLComment(stream, state) {\n    if (stream.skipTo("-->")) {\n      stream.match("-->");\n      state.tokenize = null;\n    } else {\n      stream.skipToEnd();\n    }\n    return ["comment", "comment"];\n  }\n\n  CodeMirror.defineMIME("text/css", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    tokenHooks: {\n      "<": function(stream, state) {\n        if (!stream.match("!--")) return false;\n        state.tokenize = tokenSGMLComment;\n        return tokenSGMLComment(stream, state);\n      },\n      "/": function(stream, state) {\n        if (!stream.eat("*")) return false;\n        state.tokenize = tokenCComment;\n        return tokenCComment(stream, state);\n      }\n    },\n    name: "css"\n  });\n\n  CodeMirror.defineMIME("text/x-scss", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      ":": function(stream) {\n        if (stream.match(/\\s*{/))\n          return [null, "{"];\n        return false;\n      },\n      "$": function(stream) {\n        stream.match(/^[\\w-]+/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "#": function(stream) {\n        if (!stream.eat("{")) return false;\n        return [null, "interpolation"];\n      }\n    },\n    name: "css",\n    helperType: "scss"\n  });\n\n  CodeMirror.defineMIME("text/x-less", {\n    mediaTypes: mediaTypes,\n    mediaFeatures: mediaFeatures,\n    propertyKeywords: propertyKeywords,\n    colorKeywords: colorKeywords,\n    valueKeywords: valueKeywords,\n    fontProperties: fontProperties,\n    allowNested: true,\n    tokenHooks: {\n      "/": function(stream, state) {\n        if (stream.eat("/")) {\n          stream.skipToEnd();\n          return ["comment", "comment"];\n        } else if (stream.eat("*")) {\n          state.tokenize = tokenCComment;\n          return tokenCComment(stream, state);\n        } else {\n          return ["operator", "operator"];\n        }\n      },\n      "@": function(stream) {\n        if (stream.match(/^(charset|document|font-face|import|keyframes|media|namespace|page|supports)\\b/, false)) return false;\n        stream.eatWhile(/[\\w\\\\\\-]/);\n        if (stream.match(/^\\s*:/, false))\n          return ["variable-2", "variable-definition"];\n        return ["variable-2", "variable"];\n      },\n      "&": function() {\n        return ["atom", "atom"];\n      }\n    },\n    name: "css",\n    helperType: "less"\n  });\n})();\n\n\n\n\n\n\n\nCodeMirror.defineMode("sass", function(config) {\n  var tokenRegexp = function(words){\n    return new RegExp("^" + words.join("|"));\n  };\n\n  var keywords = ["true", "false", "null", "auto"];\n  var keywordsRegexp = new RegExp("^" + keywords.join("|"));\n\n  var operators = ["\\\\(", "\\\\)", "=", ">", "<", "==", ">=", "<=", "\\\\+", "-", "\\\\!=", "/", "\\\\*", "%", "and", "or", "not"];\n  var opRegexp = tokenRegexp(operators);\n\n  var pseudoElementsRegexp = /^::?[\\w\\-]+/;\n\n  var urlTokens = function(stream, state){\n    var ch = stream.peek();\n\n    if (ch === ")"){\n      stream.next();\n      state.tokenizer = tokenBase;\n      return "operator";\n    }else if (ch === "("){\n      stream.next();\n      stream.eatSpace();\n\n      return "operator";\n    }else if (ch === "'" || ch === '"'){\n      state.tokenizer = buildStringTokenizer(stream.next());\n      return "string";\n    }else{\n      state.tokenizer = buildStringTokenizer(")", false);\n      return "string";\n    }\n  };\n  var multilineComment = function(stream, state) {\n    if (stream.skipTo("*/")){\n      stream.next();\n      stream.next();\n      state.tokenizer = tokenBase;\n    }else {\n      stream.next();\n    }\n\n    return "comment";\n  };\n\n  var buildStringTokenizer = function(quote, greedy){\n    if(greedy == null){ greedy = true; }\n\n    function stringTokenizer(stream, state){\n      var nextChar = stream.next();\n      var peekChar = stream.peek();\n      var previousChar = stream.string.charAt(stream.pos-2);\n\n      var endingString = ((nextChar !== "\\\\" && peekChar === quote) || (nextChar === quote && previousChar !== "\\\\"));\n\n      /*\n      console.log("previousChar: " + previousChar);\n      console.log("nextChar: " + nextChar);\n      console.log("peekChar: " + peekChar);\n      console.log("ending: " + endingString);\n      */\n\n      if (endingString){\n        if (nextChar !== quote && greedy) { stream.next(); }\n        state.tokenizer = tokenBase;\n        return "string";\n      }else if (nextChar === "#" && peekChar === "{"){\n        state.tokenizer = buildInterpolationTokenizer(stringTokenizer);\n        stream.next();\n        return "operator";\n      }else {\n        return "string";\n      }\n    }\n\n    return stringTokenizer;\n  };\n\n  var buildInterpolationTokenizer = function(currentTokenizer){\n    return function(stream, state){\n      if (stream.peek() === "}"){\n        stream.next();\n        state.tokenizer = currentTokenizer;\n        return "operator";\n      }else{\n        return tokenBase(stream, state);\n      }\n    };\n  };\n\n  var indent = function(state){\n    if (state.indentCount == 0){\n      state.indentCount++;\n      var lastScopeOffset = state.scopes[0].offset;\n      var currentOffset = lastScopeOffset + config.indentUnit;\n      state.scopes.unshift({ offset:currentOffset });\n    }\n  };\n\n  var dedent = function(state){\n    if (state.scopes.length == 1) { return; }\n\n    state.scopes.shift();\n  };\n\n  var tokenBase = function(stream, state) {\n    var ch = stream.peek();\n\n    // Single line Comment\n    if (stream.match('//')) {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Multiline Comment\n    if (stream.match('/*')){\n      state.tokenizer = multilineComment;\n      return state.tokenizer(stream, state);\n    }\n\n    // Interpolation\n    if (stream.match('#{')){\n    state.tokenizer = buildInterpolationTokenizer(tokenBase);\n      return "operator";\n    }\n\n    if (ch === "."){\n      stream.next();\n\n      // Match class selectors\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "atom";\n      }else if (stream.peek() === "#"){\n        indent(state);\n        return "atom";\n      }else{\n        return "operator";\n      }\n    }\n\n    if (ch === "#"){\n      stream.next();\n\n      // Hex numbers\n      if (stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/)){\n        return "number";\n      }\n\n      // ID selectors\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "atom";\n      }\n\n      if (stream.peek() === "#"){\n        indent(state);\n        return "atom";\n      }\n    }\n\n    // Numbers\n    if (stream.match(/^-?[0-9\\.]+/)){\n      return "number";\n    }\n\n    // Units\n    if (stream.match(/^(px|em|in)\\b/)){\n      return "unit";\n    }\n\n    if (stream.match(keywordsRegexp)){\n      return "keyword";\n    }\n\n    if (stream.match(/^url/) && stream.peek() === "("){\n      state.tokenizer = urlTokens;\n      return "atom";\n    }\n\n    // Variables\n    if (ch === "$"){\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n\n      if (stream.peek() === ":"){\n        stream.next();\n        return "variable-2";\n      }else{\n        return "variable-3";\n      }\n    }\n\n    if (ch === "!"){\n      stream.next();\n\n      if (stream.match(/^[\\w]+/)){\n        return "keyword";\n      }\n\n      return "operator";\n    }\n\n    if (ch === "="){\n      stream.next();\n\n      // Match shortcut mixin definition\n      if (stream.match(/^[\\w-]+/)){\n        indent(state);\n        return "meta";\n      }else {\n        return "operator";\n      }\n    }\n\n    if (ch === "+"){\n      stream.next();\n\n      // Match shortcut mixin definition\n      if (stream.match(/^[\\w-]+/)){\n        return "variable-3";\n      }else {\n        return "operator";\n      }\n    }\n\n    // Indent Directives\n    if (stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)){\n      indent(state);\n      return "meta";\n    }\n\n    // Other Directives\n    if (ch === "@"){\n      stream.next();\n      stream.eatWhile(/[\\w-]/);\n      return "meta";\n    }\n\n    // Strings\n    if (ch === '"' || ch === "'"){\n      stream.next();\n      state.tokenizer = buildStringTokenizer(ch);\n      return "string";\n    }\n\n    // Pseudo element selectors\n    if (ch == ':' && stream.match(pseudoElementsRegexp)){\n      return "keyword";\n    }\n\n    // atoms\n    if (stream.eatWhile(/[\\w-&]/)){\n      // matches a property definition\n      if (stream.peek() === ":" && !stream.match(pseudoElementsRegexp, false))\n        return "property";\n      else\n        return "atom";\n    }\n\n    if (stream.match(opRegexp)){\n      return "operator";\n    }\n\n    // If we haven't returned by now, we move 1 character\n    // and return an error\n    stream.next();\n    return null;\n  };\n\n  var tokenLexer = function(stream, state) {\n    if (stream.sol()){\n      state.indentCount = 0;\n    }\n    var style = state.tokenizer(stream, state);\n    var current = stream.current();\n\n    if (current === "@return"){\n      dedent(state);\n    }\n\n    if (style === "atom"){\n      indent(state);\n    }\n\n    if (style !== null){\n      var startOfToken = stream.pos - current.length;\n      var withCurrentIndent = startOfToken + (config.indentUnit * state.indentCount);\n\n      var newScopes = [];\n\n      for (var i = 0; i < state.scopes.length; i++){\n        var scope = state.scopes[i];\n\n        if (scope.offset <= withCurrentIndent){\n          newScopes.push(scope);\n        }\n      }\n\n      state.scopes = newScopes;\n    }\n\n\n    return style;\n  };\n\n  return {\n    startState: function() {\n      return {\n        tokenizer: tokenBase,\n        scopes: [{offset: 0, type: 'sass'}],\n        definedVars: [],\n        definedMixins: []\n      };\n    },\n    token: function(stream, state) {\n      var style = tokenLexer(stream, state);\n\n      state.lastToken = { style: style, content: stream.current() };\n\n      return style;\n    },\n\n    indent: function(state) {\n      return state.scopes[0].offset;\n    }\n  };\n});\n\nCodeMirror.defineMIME("text/x-sass", "sass");\n\n\n\n\n\n\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\nCodeMirror.defineMode("coffeescript", function(conf) {\n  var ERRORCLASS = "error";\n\n  function wordRegexp(words) {\n    return new RegExp("^((" + words.join(")|(") + "))\\\\b");\n  }\n\n  var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?)/;\n  var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n  var properties = /^(@|this\\.)[_A-Za-z$][_A-Za-z$0-9]*/;\n\n  var wordOperators = wordRegexp(["and", "or", "not",\n                                  "is", "isnt", "in",\n                                  "instanceof", "typeof"]);\n  var indentKeywords = ["for", "while", "loop", "if", "unless", "else",\n                        "switch", "try", "catch", "finally", "class"];\n  var commonKeywords = ["break", "by", "continue", "debugger", "delete",\n                        "do", "in", "of", "new", "return", "then",\n                        "this", "throw", "when", "until"];\n\n  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n  indentKeywords = wordRegexp(indentKeywords);\n\n\n  var stringPrefixes = /^('{3}|\\"{3}|['\\"])/;\n  var regexPrefixes = /^(\\/{3}|\\/)/;\n  var commonConstants = ["Infinity", "NaN", "undefined", "null", "true", "false", "on", "off", "yes", "no"];\n  var constants = wordRegexp(commonConstants);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    // Handle scope changes\n    if (stream.sol()) {\n      if (state.scope.align === null) state.scope.align = false;\n      var scopeOffset = state.scope.offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset && state.scope.type == "coffee") {\n          return "indent";\n        } else if (lineOffset < scopeOffset) {\n          return "dedent";\n        }\n        return null;\n      } else {\n        if (scopeOffset > 0) {\n          dedent(stream, state);\n        }\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle docco title comment (single line)\n    if (stream.match("####")) {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Handle multi line comments\n    if (stream.match("###")) {\n      state.tokenize = longComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Single line comment\n    if (ch === "#") {\n      stream.skipToEnd();\n      return "comment";\n    }\n\n    // Handle number literals\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\d+\\.\\d*/)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\.\\d+/)) {\n        floatLiteral = true;\n      }\n\n      if (floatLiteral) {\n        // prevent from getting extra . on 1..\n        if (stream.peek() == "."){\n          stream.backUp(1);\n        }\n        return "number";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^-?0x[0-9a-f]+/i)) {\n        intLiteral = true;\n      }\n      // Decimal\n      if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^-?0(?![\\dx])/i)) {\n        intLiteral = true;\n      }\n      if (intLiteral) {\n        return "number";\n      }\n    }\n\n    // Handle strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenFactory(stream.current(), false, "string");\n      return state.tokenize(stream, state);\n    }\n    // Handle regex literals\n    if (stream.match(regexPrefixes)) {\n      if (stream.current() != "/" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n        state.tokenize = tokenFactory(stream.current(), true, "string-2");\n        return state.tokenize(stream, state);\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n    // Handle operators and delimiters\n    if (stream.match(operators) || stream.match(wordOperators)) {\n      return "operator";\n    }\n    if (stream.match(delimiters)) {\n      return "punctuation";\n    }\n\n    if (stream.match(constants)) {\n      return "atom";\n    }\n\n    if (stream.match(keywords)) {\n      return "keyword";\n    }\n\n    if (stream.match(identifiers)) {\n      return "variable";\n    }\n\n    if (stream.match(properties)) {\n      return "property";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function tokenFactory(delimiter, singleline, outclass) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'"\\/\\\\]/);\n        if (stream.eat("\\\\")) {\n          stream.next();\n          if (singleline && stream.eol()) {\n            return outclass;\n          }\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          return outclass;\n        } else {\n          stream.eat(/['"\\/]/);\n        }\n      }\n      if (singleline) {\n        if (conf.mode.singleLineStringErrors) {\n          outclass = ERRORCLASS;\n        } else {\n          state.tokenize = tokenBase;\n        }\n      }\n      return outclass;\n    };\n  }\n\n  function longComment(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^#]/);\n      if (stream.match("###")) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.eatWhile("#");\n    }\n    return "comment";\n  }\n\n  function indent(stream, state, type) {\n    type = type || "coffee";\n    var offset = 0, align = false, alignOffset = null;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (scope.type === "coffee") {\n        offset = scope.offset + conf.indentUnit;\n        break;\n      }\n    }\n    if (type !== "coffee") {\n      align = null;\n      alignOffset = stream.column() + stream.current().length;\n    } else if (state.scope.align) {\n      state.scope.align = false;\n    }\n    state.scope = {\n      offset: offset,\n      type: type,\n      prev: state.scope,\n      align: align,\n      alignOffset: alignOffset\n    };\n  }\n\n  function dedent(stream, state) {\n    if (!state.scope.prev) return;\n    if (state.scope.type === "coffee") {\n      var _indent = stream.indentation();\n      var matched = false;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (_indent === scope.offset) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return true;\n      }\n      while (state.scope.prev && state.scope.offset !== _indent) {\n        state.scope = state.scope.prev;\n      }\n      return false;\n    } else {\n      state.scope = state.scope.prev;\n      return false;\n    }\n  }\n\n  function tokenLexer(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle "." connected identifiers\n    if (current === ".") {\n      style = state.tokenize(stream, state);\n      current = stream.current();\n      if (/^\\.[\\w$]+$/.test(current)) {\n        return "variable";\n      } else {\n        return ERRORCLASS;\n      }\n    }\n\n    // Handle scope changes.\n    if (current === "return") {\n      state.dedent += 1;\n    }\n    if (((current === "->" || current === "=>") &&\n         !state.lambda &&\n         !stream.peek())\n        || style === "indent") {\n      indent(stream, state);\n    }\n    var delimiter_index = "[({".indexOf(current);\n    if (delimiter_index !== -1) {\n      indent(stream, state, "])}".slice(delimiter_index, delimiter_index+1));\n    }\n    if (indentKeywords.exec(current)){\n      indent(stream, state);\n    }\n    if (current == "then"){\n      dedent(stream, state);\n    }\n\n\n    if (style === "dedent") {\n      if (dedent(stream, state)) {\n        return ERRORCLASS;\n      }\n    }\n    delimiter_index = "])}".indexOf(current);\n    if (delimiter_index !== -1) {\n      while (state.scope.type == "coffee" && state.scope.prev)\n        state.scope = state.scope.prev;\n      if (state.scope.type == current)\n        state.scope = state.scope.prev;\n    }\n    if (state.dedent > 0 && stream.eol() && state.scope.type == "coffee") {\n      if (state.scope.prev) state.scope = state.scope.prev;\n      state.dedent -= 1;\n    }\n\n    return style;\n  }\n\n  var external = {\n    startState: function(basecolumn) {\n      return {\n        tokenize: tokenBase,\n        scope: {offset:basecolumn || 0, type:"coffee", prev: null, align: false},\n        lastToken: null,\n        lambda: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var fillAlign = state.scope.align === null && state.scope;\n      if (fillAlign && stream.sol()) fillAlign.align = false;\n\n      var style = tokenLexer(stream, state);\n      if (fillAlign && style && style != "comment") fillAlign.align = true;\n\n      state.lastToken = {style:style, content: stream.current()};\n\n      if (stream.eol() && stream.lambda) {\n        state.lambda = false;\n      }\n\n      return style;\n    },\n\n    indent: function(state, text) {\n      if (state.tokenize != tokenBase) return 0;\n      var scope = state.scope;\n      var closer = text && "])}".indexOf(text.charAt(0)) > -1;\n      if (closer) while (scope.type == "coffee" && scope.prev) scope = scope.prev;\n      var closes = closer && scope.type === text.charAt(0);\n      if (scope.align)\n        return scope.alignOffset - (closes ? 1 : 0);\n      else\n        return (closes ? scope.prev : scope).offset;\n    },\n\n    lineComment: "#",\n    fold: "indent"\n  };\n  return external;\n});\n\nCodeMirror.defineMIME("text/x-coffeescript", "coffeescript");
\\x8280fe73c21bcf2b42a987c940e440be0c69bfdff40afe0988232e3468889dba	400e206e-77ed-4b12-9c09-168ee2fc812b
\\x8280fe73c21bcf2b42a987c940e440be0c69bfdff40afe0988232e3468889dba	400e206e-77ed-4b12-9c09-168ee2fc812b
\\x82b9f1a396e82eff677e73d5648b2a37ef2f8afc2085375714540e68f8c6ff54	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\nconsole.log('tab: my data is ', w.data('tab_id'));\nw.append(content);
\\x82b9f1a396e82eff677e73d5648b2a37ef2f8afc2085375714540e68f8c6ff54	var w = $("#"+id);\n\nw.data('tab_id', tab_id);\nconsole.log('tab: my data is ', w.data('tab_id'));\nw.append(content);
\\x82ba9aa995cfa1843ee31f2e83c584904d021085f0a86f43533ce7a4aa266018	ffc4d8c8-9a36-42a6-91af-41ae7a771bf0
\\x82ba9aa995cfa1843ee31f2e83c584904d021085f0a86f43533ce7a4aa266018	ffc4d8c8-9a36-42a6-91af-41ae7a771bf0
\\x83939a65527e92fe285304ea49eaec826d45c0a4f8ab74f613bba74a0c980ec7	var w = $("#"+id);\n/*\nTEST FKEY AUTOCOMPLETE\n\n\n\nvar from_column = 'new_row_widget_id';\n\nw.append('<p>Using column: ' + from_column + '</p>');\n\n\nendpoint.schema('semantics').table('relation').row().where({\n    row_detail_widget_id: '40cca2f6-7c35-4118-83db-031e04e4397a'\n}).result(function(row) {\n\n    w.append(widget('sem_fkey_autocomplete', { \n        from_row: row,\n        from_column: from_column,\n        to_relation: endpoint.schema('widget').table('widget'),\n        to_column: 'id',\n        label_function: function(to_row) {\n            return to_row.get('name')\n        },\n        order_by_function: function(rows) {\n            return rows.order_by({ column: 'name' });\n        },\n        new_enabled: true\n    }));\n\n});\n*/\n\nendpoint.schema('mickey').table('post').row().where({\n    name: 'words mickey says'\n}).result(function(row) {    \n    \n    w.append(widget('sem_fkey_one_to_many', { \n        from_row: row,\n        from_column: 'id',\n        to_relation: endpoint.schema('mickey').table('blah'),\n        to_column: 'post_id',\n        label_function: function(to_row) {\n            return to_row.get('name')\n        },\n        order_by_function: function(rows) {\n            return rows.order_by({ column: 'name' });\n        },\n        new_enabled: true\n    }));\n    \n});\n
\\x83939a65527e92fe285304ea49eaec826d45c0a4f8ab74f613bba74a0c980ec7	var w = $("#"+id);\n/*\nTEST FKEY AUTOCOMPLETE\n\n\n\nvar from_column = 'new_row_widget_id';\n\nw.append('<p>Using column: ' + from_column + '</p>');\n\n\nendpoint.schema('semantics').table('relation').row().where({\n    row_detail_widget_id: '40cca2f6-7c35-4118-83db-031e04e4397a'\n}).result(function(row) {\n\n    w.append(widget('sem_fkey_autocomplete', { \n        from_row: row,\n        from_column: from_column,\n        to_relation: endpoint.schema('widget').table('widget'),\n        to_column: 'id',\n        label_function: function(to_row) {\n            return to_row.get('name')\n        },\n        order_by_function: function(rows) {\n            return rows.order_by({ column: 'name' });\n        },\n        new_enabled: true\n    }));\n\n});\n*/\n\nendpoint.schema('mickey').table('post').row().where({\n    name: 'words mickey says'\n}).result(function(row) {    \n    \n    w.append(widget('sem_fkey_one_to_many', { \n        from_row: row,\n        from_column: 'id',\n        to_relation: endpoint.schema('mickey').table('blah'),\n        to_column: 'post_id',\n        label_function: function(to_row) {\n            return to_row.get('name')\n        },\n        order_by_function: function(rows) {\n            return rows.order_by({ column: 'name' });\n        },\n        new_enabled: true\n    }));\n    \n});\n
\\x8413503e76b8d9cfa3b2077a5726a0e74e099776088b20339ea267c4f8f6d3fe	<div id="{{= id }}" class="{{= name }}">\n    <div class='title'>{{= widget_name }}{{? properties.count > 1 }}(&times;{{=properties.count}}){{?}}</div>\n    <div class='children'>\n    </div>\n</div>
\\x8413503e76b8d9cfa3b2077a5726a0e74e099776088b20339ea267c4f8f6d3fe	<div id="{{= id }}" class="{{= name }}">\n    <div class='title'>{{= widget_name }}{{? properties.count > 1 }}(&times;{{=properties.count}}){{?}}</div>\n    <div class='children'>\n    </div>\n</div>
\\x8468ab5a3a5b263a8273b99620613c90845bdf9856f279416b7f8cb0141b2103	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        \n        <title>Aquameta</title>\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body>\n        <h1>Aquameta</h1>\n        <p>Huzzah!  If you can see this, it worked.</p>\n        <p>Here are some starting places:</p>\n        <ul>\n            <li><a href='/dev'>/dev</a> - Developer IDE</li>\n            <li><a href='/docs'>/docs</a> - Documentation (coming soon)</li>\n            <li><a href='/snake'>/snake</a> - Snake - a sample game</li>\n        </ul>\n            \n    </body>\n</html>\n\n
\\x85709a7c9fbc665e8c33637282c2287a0707d35140a467681175b7de3759e924	.{{= name }} {\n    margin: 0 auto;\n    padding: 1em;\n    text-align: left;\n    height: 100%;\n}\n\n.{{= name }} .hide {\n    display: none;\n}\n\n.{{= name }} > .loaded > .autocomplete {\n}\n\n.{{= name }} > .loaded > .results {\n\n    top: 0;\n    bottom:0;\n    left:0;\n    right:0;\n    \n    margin-top: 2.5em;\n    margin-bottom: 0.5em;\n    margin-right: 1em;\n    margin-left: 1em;\n\n    width: auto;\n    height: auto;\n    overflow-y: auto;\n    position: absolute;\n}\n\n.{{= name }} .autocomplete-suggestions {\n    width: 100% !important;\n}\n\n.{{= name }} .autocomplete-suggestion {\n    color: white;\n    font-size: 12px;\n    \n    margin: 0 auto;\n    padding: 3px;\n    \n    display: block;\n    width: 100%;\n}\n\n.{{= name }} .autocomplete-suggestion.autocomplete-selected {\n    background-color: #555;\n}
\\x85709a7c9fbc665e8c33637282c2287a0707d35140a467681175b7de3759e924	.{{= name }} {\n    margin: 0 auto;\n    padding: 1em;\n    text-align: left;\n    height: 100%;\n}\n\n.{{= name }} .hide {\n    display: none;\n}\n\n.{{= name }} > .loaded > .autocomplete {\n}\n\n.{{= name }} > .loaded > .results {\n\n    top: 0;\n    bottom:0;\n    left:0;\n    right:0;\n    \n    margin-top: 2.5em;\n    margin-bottom: 0.5em;\n    margin-right: 1em;\n    margin-left: 1em;\n\n    width: auto;\n    height: auto;\n    overflow-y: auto;\n    position: absolute;\n}\n\n.{{= name }} .autocomplete-suggestions {\n    width: 100% !important;\n}\n\n.{{= name }} .autocomplete-suggestion {\n    color: white;\n    font-size: 12px;\n    \n    margin: 0 auto;\n    padding: 3px;\n    \n    display: block;\n    width: 100%;\n}\n\n.{{= name }} .autocomplete-suggestion.autocomplete-selected {\n    background-color: #555;\n}
\\x86f19413ba11f8c4a658ed52098fba78ec0c64061bb1794dfe2f82197a227b00	.{{= name }} {\n    font-size: 80%;\n    position: fixed;\n    top: 4ex;\n    bottom: 2ex;\n    right: 0;\n    width: 20em;\n    border: 4px dashed blue;\n    margin-top: 3ex;\n\tbackground-color:rgba(0,0,0,0.95);\n    padding: .5ex .5em .5ex .5em;\n    z-index: 100;\n}
\\x86f19413ba11f8c4a658ed52098fba78ec0c64061bb1794dfe2f82197a227b00	.{{= name }} {\n    font-size: 80%;\n    position: fixed;\n    top: 4ex;\n    bottom: 2ex;\n    right: 0;\n    width: 20em;\n    border: 4px dashed blue;\n    margin-top: 3ex;\n\tbackground-color:rgba(0,0,0,0.95);\n    padding: .5ex .5em .5ex .5em;\n    z-index: 100;\n}
\\x885b6fff9801e7f7c4523f75b2c07f248b7cd9c9cb2375c8a64ba55812bb7e3a	var w = $("#"+id);\n\n\n/* SETUP */\nvar rel_name;\nvar relation = datum;\nif (!(datum instanceof AQ.Rowset)) {\n    datum = datum.rows()\n    .then(function(rows) {\n        rel_name = rows.relation.schema.name + '.' + rows.relation.name;\n        w.find('.title').text(rel_name);\n    });\n}\nelse {\n    rel_name = datum.relation.schema.name + '.' + datum.relation.name;\n    relation = datum.relation;\n    w.find('.title').text(rel_name);\n}\n\nwidget.sync(datum, w.find('> .list > ul'), function(row) {\n    return widget('semantics/list_item', row);\n});\n\n\n\n/* TRIGGERS */\nw.on('list_item_click', function(e, row, list_item) {\n    list_item.toggleClass('selected');\n    w.find('.header .continue').toggle(!!w.find('.header ~ * > .selected').length);\n});\n\nw.find('.divider').on('click', function() {\n    w.find('.list').toggleClass('collapsed');\n});\n\nw.find('.toggle_options').on('click', function() {\n    w.find('.arrow').toggleClass('up');\n    if (w.find('.arrow').hasClass('up')) {\n        w.find('.search').focus();\n    }\n});\n\nw.find('.new').on('click', function() {\n    w.append(\n        widget('core:modal', {\n            content: widget('semantics/new_row', relation)\n        })\n    );\n});\n\nw.find('.continue').on('click', function() {\n    var selected_items = w.find('.header ~ * > .selected').map(function() {\n        return $(this).data('row');\n    }).toArray();\n    w.trigger('list_view_select', [selected_items]);\n});\n\n\n\n/* SEARCH */\nfunction search(e) {\n    var list_items = w.find('li');\n    var val = $(this).val().trim();\n    if (val != '') {\n        \n        var matching_elements = $.grep(\n            list_items, \n            function(e, i) {\n                var re = new RegExp(val, 'i');\n\n                if (re.test($(e).html())) {\n                    return true;\n                }\n                return false;\n            });\n        \n        list_items.hide();\n        $(matching_elements).show();\n    }\n    else {\n        list_items.show();\n    }\n}\n/*\nvar debounced_search = debounce(search, 200, false);\nw.find('.search').on('keyup', debounced_search);\n*/\nw.find('.search').on('keyup', search);\n
\\x885b6fff9801e7f7c4523f75b2c07f248b7cd9c9cb2375c8a64ba55812bb7e3a	var w = $("#"+id);\n\n\n/* SETUP */\nvar rel_name;\nvar relation = datum;\nif (!(datum instanceof AQ.Rowset)) {\n    datum = datum.rows()\n    .then(function(rows) {\n        rel_name = rows.relation.schema.name + '.' + rows.relation.name;\n        w.find('.title').text(rel_name);\n    });\n}\nelse {\n    rel_name = datum.relation.schema.name + '.' + datum.relation.name;\n    relation = datum.relation;\n    w.find('.title').text(rel_name);\n}\n\nwidget.sync(datum, w.find('> .list > ul'), function(row) {\n    return widget('semantics/list_item', row);\n});\n\n\n\n/* TRIGGERS */\nw.on('list_item_click', function(e, row, list_item) {\n    list_item.toggleClass('selected');\n    w.find('.header .continue').toggle(!!w.find('.header ~ * > .selected').length);\n});\n\nw.find('.divider').on('click', function() {\n    w.find('.list').toggleClass('collapsed');\n});\n\nw.find('.toggle_options').on('click', function() {\n    w.find('.arrow').toggleClass('up');\n    if (w.find('.arrow').hasClass('up')) {\n        w.find('.search').focus();\n    }\n});\n\nw.find('.new').on('click', function() {\n    w.append(\n        widget('core:modal', {\n            content: widget('semantics/new_row', relation)\n        })\n    );\n});\n\nw.find('.continue').on('click', function() {\n    var selected_items = w.find('.header ~ * > .selected').map(function() {\n        return $(this).data('row');\n    }).toArray();\n    w.trigger('list_view_select', [selected_items]);\n});\n\n\n\n/* SEARCH */\nfunction search(e) {\n    var list_items = w.find('li');\n    var val = $(this).val().trim();\n    if (val != '') {\n        \n        var matching_elements = $.grep(\n            list_items, \n            function(e, i) {\n                var re = new RegExp(val, 'i');\n\n                if (re.test($(e).html())) {\n                    return true;\n                }\n                return false;\n            });\n        \n        list_items.hide();\n        $(matching_elements).show();\n    }\n    else {\n        list_items.show();\n    }\n}\n/*\nvar debounced_search = debounce(search, 200, false);\nw.find('.search').on('keyup', debounced_search);\n*/\nw.find('.search').on('keyup', search);\n
\\x88a33366edd8b3c97098db3e4c1cf07685ee98b2299dc9736701504ba1a2f438	layout_tabbed
\\x88a33366edd8b3c97098db3e4c1cf07685ee98b2299dc9736701504ba1a2f438	layout_tabbed
\\x897e67d3783bc8c4fc6e97f1f6e31ce42cbb3ce9b640f9bbfa56b30fb57af727	row_detail_meta_table
\\x897e67d3783bc8c4fc6e97f1f6e31ce42cbb3ce9b640f9bbfa56b30fb57af727	row_detail_meta_table
\\x8a1f29e7c944df2b834df2830681c0f09ec34e24699da8062cb34dd2887bd345	var w = $('#'+id);\n\nfunction display() {\n    var val = JSON.stringify(field.value);\n    \n    if (val == null) {\n        val = 'NULL';\n    }\n    \n    else if (val == '') {\n        val = '____';\n    }\n    \n    w.find('.display').html(val);\n    w.find('input').val(val);\n    \n    w.removeClass('saving')\n    .removeClass('editing')\n    .addClass('displaying');\n    \n    //w.find('.edit input').prop('disabled', false);\n}\ndisplay();\n\nfunction edit() {\n    w.removeClass('displaying')\n    .removeClass('saving')\n    .addClass('editing');\n    w.find('input').focus();\n}\n\n\nfunction save(saving_as_null) {\n    \n    w.removeClass('displaying')\n    .removeClass('editing')\n    .addClass('saving');\n    \n    //w.find('.edit input').prop('disabled', true);\n\n    var old_value = field.value;\n\n    // save\n    if (saving_as_null) {\n        field.set(null);\n    }\n    else {\n        field.set(w.find('input').val());\n    }\n    \n    field.update().then(function() {\n        w.trigger('status', ['Saved', 'success']);\n        w.trigger('form_field_save');\n        display();\n        \n    }).catch(function(error) {\n        field.set(old_value);\n        w.trigger('status', ['Failed save', 'fail']);\n        display();\n    });\n}\n\n\n// EVENT BINDINGS\nw.find('.save').on('click', save.bind(this, false));\nw.find('.save_as_null').on('click', save.bind(this, true));\nw.find('.display').on('click', edit);\nw.find('.cancel').on('click', display);\nw.find('input').on('keyup', function(e) {\n    if (e.keyCode == 27) {\n        display();\n    }\n    if (e.keyCode == 13) {\n        save(false);\n    }\n});\n
\\x8a1f29e7c944df2b834df2830681c0f09ec34e24699da8062cb34dd2887bd345	var w = $('#'+id);\n\nfunction display() {\n    var val = JSON.stringify(field.value);\n    \n    if (val == null) {\n        val = 'NULL';\n    }\n    \n    else if (val == '') {\n        val = '____';\n    }\n    \n    w.find('.display').html(val);\n    w.find('input').val(val);\n    \n    w.removeClass('saving')\n    .removeClass('editing')\n    .addClass('displaying');\n    \n    //w.find('.edit input').prop('disabled', false);\n}\ndisplay();\n\nfunction edit() {\n    w.removeClass('displaying')\n    .removeClass('saving')\n    .addClass('editing');\n    w.find('input').focus();\n}\n\n\nfunction save(saving_as_null) {\n    \n    w.removeClass('displaying')\n    .removeClass('editing')\n    .addClass('saving');\n    \n    //w.find('.edit input').prop('disabled', true);\n\n    var old_value = field.value;\n\n    // save\n    if (saving_as_null) {\n        field.set(null);\n    }\n    else {\n        field.set(w.find('input').val());\n    }\n    \n    field.update().then(function() {\n        w.trigger('status', ['Saved', 'success']);\n        w.trigger('form_field_save');\n        display();\n        \n    }).catch(function(error) {\n        field.set(old_value);\n        w.trigger('status', ['Failed save', 'fail']);\n        display();\n    });\n}\n\n\n// EVENT BINDINGS\nw.find('.save').on('click', save.bind(this, false));\nw.find('.save_as_null').on('click', save.bind(this, true));\nw.find('.display').on('click', edit);\nw.find('.cancel').on('click', display);\nw.find('input').on('keyup', function(e) {\n    if (e.keyCode == 27) {\n        display();\n    }\n    if (e.keyCode == 13) {\n        save(false);\n    }\n});\n
\\x8a5edab282632443219e051e4ade2d1d5bbc671c781051bf1437897cbdfea0f1	/
\\x8adcc0377c276eaa67ff1af64dd8f6ccf772fa668f0921a77005949c58073c96	2bc72050-e4fc-472a-ae7e-bee1f8869c85
\\x8adcc0377c276eaa67ff1af64dd8f6ccf772fa668f0921a77005949c58073c96	2bc72050-e4fc-472a-ae7e-bee1f8869c85
\\x8adcc0377c276eaa67ff1af64dd8f6ccf772fa668f0921a77005949c58073c96	2bc72050-e4fc-472a-ae7e-bee1f8869c85
\\x8adcc0377c276eaa67ff1af64dd8f6ccf772fa668f0921a77005949c58073c96	2bc72050-e4fc-472a-ae7e-bee1f8869c85
\\x8c400e7a853a662b835fd7efffd22c74b11734c897a05169e7b127061b7c0078	bundle_push_pull
\\x8c400e7a853a662b835fd7efffd22c74b11734c897a05169e7b127061b7c0078	bundle_push_pull
\\x8c44be9da009334637868fcdd1eb2eec1de5abee6b2fc5d9e5d1d22ae0d026b1	<div id="{{= id }}" class="{{= name }}">\n    <button class='new_row'>new row</button>\n    <button class='commit'>commit</button>\n    <button class='commit_log'>history</button>\n    <button class='push_pull'>&#8644;push/pull</button>\n    <button class='bundle_config'>&#9881;config</button>\n    \n    \n    \n    <div class='filters'>\n        <span class='tab all'>all</span>\n        <span class='tab changed'>changed</span>\n        <span class='tab head'>head</span>\n    </div>\n    <div class='bundle_contents'>\n    </div>\n</div>
\\x8c44be9da009334637868fcdd1eb2eec1de5abee6b2fc5d9e5d1d22ae0d026b1	<div id="{{= id }}" class="{{= name }}">\n    <button class='new_row'>new row</button>\n    <button class='commit'>commit</button>\n    <button class='commit_log'>history</button>\n    <button class='push_pull'>&#8644;push/pull</button>\n    <button class='bundle_config'>&#9881;config</button>\n    \n    \n    \n    <div class='filters'>\n        <span class='tab all'>all</span>\n        <span class='tab changed'>changed</span>\n        <span class='tab head'>head</span>\n    </div>\n    <div class='bundle_contents'>\n    </div>\n</div>
\\x8d2f9444c9f30d420222243bb2ef96ef29be8b28bde418b06f462f28f3492af1	bf6e6451-88c6-4642-b034-2c72a83ee6ec
\\x8d2f9444c9f30d420222243bb2ef96ef29be8b28bde418b06f462f28f3492af1	bf6e6451-88c6-4642-b034-2c72a83ee6ec
\\x8d34c2b7e40bbb2bbf5931944ddb32b26cc58ef4f1e7df63ac87a64863972296	6046e06d-28c5-4d25-ad3a-4470c2195323
\\x8d34c2b7e40bbb2bbf5931944ddb32b26cc58ef4f1e7df63ac87a64863972296	6046e06d-28c5-4d25-ad3a-4470c2195323
\\x8de79847a2b49948cb8847434202ba848fac61d4f234982bccd12e9475775d7b	var w = $("#"+id);\n\n// inputs:\n// relation {AQ.Relation}\n\n// this widget will insert uploaded file into the given 'relation'\n// the file data will be base64 encoded and set as the 'data' column (column type must be bytea)\n// the name of the file will be saved in the 'name' column\n\nw.find('.fileUpload').on('change', function () {\n    const reader = new FileReader()\n    const file = $(this).get(0).files[0]\n    reader.onload = event => {\n        const { name, size, type } = file\n        const dataURL = event.target.result\n        const data = dataURL.replace(/^data:.+;base64,/, '')\n        relation.insert({ name, data })\n        .then(result => {\n            console.log('file saved')\n        })\n        .catch(error => {\n            alert('file upload no worky\\n' + error)\n        })\n    }\n    reader.readAsDataURL(file)\n})
\\x8de79847a2b49948cb8847434202ba848fac61d4f234982bccd12e9475775d7b	var w = $("#"+id);\n\n// inputs:\n// relation {AQ.Relation}\n\n// this widget will insert uploaded file into the given 'relation'\n// the file data will be base64 encoded and set as the 'data' column (column type must be bytea)\n// the name of the file will be saved in the 'name' column\n\nw.find('.fileUpload').on('change', function () {\n    const reader = new FileReader()\n    const file = $(this).get(0).files[0]\n    reader.onload = event => {\n        const { name, size, type } = file\n        const dataURL = event.target.result\n        const data = dataURL.replace(/^data:.+;base64,/, '')\n        relation.insert({ name, data })\n        .then(result => {\n            console.log('file saved')\n        })\n        .catch(error => {\n            alert('file upload no worky\\n' + error)\n        })\n    }\n    reader.readAsDataURL(file)\n})
\\x8e54789afdb68c45fb948ae2e1b2470929186f8fc3f299d7fbf60d0b79410c56	573d40f7-be20-468a-8140-7d8c318b2e08
\\x8e54789afdb68c45fb948ae2e1b2470929186f8fc3f299d7fbf60d0b79410c56	573d40f7-be20-468a-8140-7d8c318b2e08
\\x91484a142e251b32d818e63cd51fa5df18ef7fb5c11e1983b37f7afb13b276b2	4ed34807-309b-47f0-a796-34850d9937e5
\\x91484a142e251b32d818e63cd51fa5df18ef7fb5c11e1983b37f7afb13b276b2	4ed34807-309b-47f0-a796-34850d9937e5
\\x922691d8151ff68081c9c944238ac26fb624e894b5bb516e9e1834fe9ed75096	5d9aa6c9-4e3d-4295-9ddc-f0506fef2e67
\\x922691d8151ff68081c9c944238ac26fb624e894b5bb516e9e1834fe9ed75096	5d9aa6c9-4e3d-4295-9ddc-f0506fef2e67
\\x9387a4e1685a399cf6a436428db2e244334a8c6137d129da749b68daabfda263	var w = $("#"+id);\n\n\nw.find('> .tabs').html(widget('layout_tabbed', {\n    tabs: {\n        'widgets': function () {\n            return widget('debugger3_widgets', { });\n        },\n        'data': function() {\n            return widget('debugger3_data', { });\n        },\n        'users': function() {\n            return widget('debugger3_users', { });\n        },\n    },\n    tab_colors: {\n        'widgets': 'blue',\n        'data': 'blue',\n        'machines-js': 'blue'\n    } \n}));\n
\\x9387a4e1685a399cf6a436428db2e244334a8c6137d129da749b68daabfda263	var w = $("#"+id);\n\n\nw.find('> .tabs').html(widget('layout_tabbed', {\n    tabs: {\n        'widgets': function () {\n            return widget('debugger3_widgets', { });\n        },\n        'data': function() {\n            return widget('debugger3_data', { });\n        },\n        'users': function() {\n            return widget('debugger3_users', { });\n        },\n    },\n    tab_colors: {\n        'widgets': 'blue',\n        'data': 'blue',\n        'machines-js': 'blue'\n    } \n}));\n
\\x938b99e3330802a9290b64452b1b303a7efa94dd8f5fc86b6c941cf0644ce220	/dev
\\x93dace93862993fb22d1ce8883d688e38c07dcc1baca8fbf58057db896e4afbd	<li id="{{= id }}" class="{{= name }}">\n    <span class='arrow'>&#10094;</span>\n    <span class='title'>{{= row.get('name') || row.get('id') }}</span>\n    <span class='empty hide'>Empty</span>\n    <div class='list'></div>\n</li>
\\x93dace93862993fb22d1ce8883d688e38c07dcc1baca8fbf58057db896e4afbd	<li id="{{= id }}" class="{{= name }}">\n    <span class='arrow'>&#10094;</span>\n    <span class='title'>{{= row.get('name') || row.get('id') }}</span>\n    <span class='empty hide'>Empty</span>\n    <div class='list'></div>\n</li>
\\x93e57604055f3df49366f29f59441ffb5019f4066514c0fbc12511e65f03d9e3	<tr id="{{= id }}" class="{{= name }}">\n    <td><nobr><span class='head_commit'>HEAD&#10148;</span></nobr></td>\n    <td>{{= commit.get("role_id") }}</td>\n    <td class='date'></td>\n    <td>{{= commit.get("message") }}</td>\n    <td><button class='checkout'>Check Out</button></td>\n</tr>
\\x93e57604055f3df49366f29f59441ffb5019f4066514c0fbc12511e65f03d9e3	<tr id="{{= id }}" class="{{= name }}">\n    <td><nobr><span class='head_commit'>HEAD&#10148;</span></nobr></td>\n    <td>{{= commit.get("role_id") }}</td>\n    <td class='date'></td>\n    <td>{{= commit.get("message") }}</td>\n    <td><button class='checkout'>Check Out</button></td>\n</tr>
\\x959d5aca9cacb643c42991fe095da5a617deb7ed94307f8c824b569aee03b30f	<select id="{{= id }}" class="{{= name }}">\n    <option>Select one.</option>\n</select>
\\x959d5aca9cacb643c42991fe095da5a617deb7ed94307f8c824b569aee03b30f	<select id="{{= id }}" class="{{= name }}">\n    <option>Select one.</option>\n</select>
\\x96084372d321eed34c83e03948899508d0fdd6464f4184849ede64d595ec606c	debugger3_widgets_tree
\\x96084372d321eed34c83e03948899508d0fdd6464f4184849ede64d595ec606c	debugger3_widgets_tree
\\x973efcb414361eaabee47639410952468f7c19728828be14abe45b8fe547f491	events:\nbinds to close_modal:  closes.\n\n\n\n
\\x973efcb414361eaabee47639410952468f7c19728828be14abe45b8fe547f491	events:\nbinds to close_modal:  closes.\n\n\n\n
\\x973efcb414361eaabee47639410952468f7c19728828be14abe45b8fe547f491	events:\nbinds to close_modal:  closes.\n\n\n\n
\\x973efcb414361eaabee47639410952468f7c19728828be14abe45b8fe547f491	events:\nbinds to close_modal:  closes.\n\n\n\n
\\x97aa140ff4c4017b8f45501de614dadc192738eea67f3aae8566ed1236e72c17	commit_dialog_staged_fields
\\x97aa140ff4c4017b8f45501de614dadc192738eea67f3aae8566ed1236e72c17	commit_dialog_staged_fields
\\x982221b639a143c8fca743755b932c9738fb383f5c4b3fb956f63622e22c9537	sem_fkey_one_to_many
\\x982221b639a143c8fca743755b932c9738fb383f5c4b3fb956f63622e22c9537	sem_fkey_one_to_many
\\x99af11672e664019bf7643badf53dd89462e108d1a0b97bcd1637f3c84944423	f94cba1e-dbf5-499b-9cf2-fe43ce8ab581
\\x99af11672e664019bf7643badf53dd89462e108d1a0b97bcd1637f3c84944423	f94cba1e-dbf5-499b-9cf2-fe43ce8ab581
\\x9a5ea6ccd4dc13823617991b0dda4e3070a1cfd6b7d773ea8809175c1ee118b3	/upload
\\x9a5ea6ccd4dc13823617991b0dda4e3070a1cfd6b7d773ea8809175c1ee118b3	/upload
\\x9b6277197bde3ae3d62cec10c7645f3369c648ff6ffe76d5802f2244df4b63b5	<div id="{{= id }}" class="{{= name }}">\n    <h1>commit!</h1>\n    \n    <h3>Changes</h3>\n        \n    <table border=1 class='changes'>\n        <tr><th>row</th><th>change</th><th>unstaged</th><th>staged</th></tr>\n    </table>\n\n    <!--\n    <h3>Untracked Rows</h3>\n    <p>These are changes to rows that have not yet been added to this commit.</p>\n    \n    <div class='untracked_rows'>\n        ...\n    </div>\n-->\n    \n    <p><button class='do_commit'>commit these changes</button></p>\n</div>
\\x9b6277197bde3ae3d62cec10c7645f3369c648ff6ffe76d5802f2244df4b63b5	<div id="{{= id }}" class="{{= name }}">\n    <h1>commit!</h1>\n    \n    <h3>Changes</h3>\n        \n    <table border=1 class='changes'>\n        <tr><th>row</th><th>change</th><th>unstaged</th><th>staged</th></tr>\n    </table>\n\n    <!--\n    <h3>Untracked Rows</h3>\n    <p>These are changes to rows that have not yet been added to this commit.</p>\n    \n    <div class='untracked_rows'>\n        ...\n    </div>\n-->\n    \n    <p><button class='do_commit'>commit these changes</button></p>\n</div>
\\x9c53f81bdbbf6e68e1f9cb1ade31210c3a6994ad6f0e890ca57ec25a10b1d760	bundle_config_dialog
\\x9c53f81bdbbf6e68e1f9cb1ade31210c3a6994ad6f0e890ca57ec25a10b1d760	bundle_config_dialog
\\x9e43cc6a827b137d2a2d7c9a2b4e9266b688a1455d9da164751c1a09cf5a42b2	c2e6b45c-d4eb-4134-b246-84c542718717
\\x9e43cc6a827b137d2a2d7c9a2b4e9266b688a1455d9da164751c1a09cf5a42b2	c2e6b45c-d4eb-4134-b246-84c542718717
\\x9e43cc6a827b137d2a2d7c9a2b4e9266b688a1455d9da164751c1a09cf5a42b2	c2e6b45c-d4eb-4134-b246-84c542718717
\\x9e43cc6a827b137d2a2d7c9a2b4e9266b688a1455d9da164751c1a09cf5a42b2	c2e6b45c-d4eb-4134-b246-84c542718717
\\x9edff668a3e7cd0e1c1b4e54c6d87a920d521869f5c764ebe75a339880b1da75	var w = $("#"+id);\n\n\n// changes\nbundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    /* first staged, then unstaged modified, then unstaged deleted */\n    order_by: [{\n        column: 'staged'\n    }, {\n        column: 'change_type'\n    }]\n}).then(function(changes) {\n    widget.sync(changes, w.find('.changes'), function(change) {\n        return widget('ide:commit_dialog_changed_row', { bundle: bundle, change: change });\n    });\n});\n\n// commit button handler\nw.find('button.do_commit').click(function() {\n    var message;\n    if (message = prompt('enter a commit message')) {\n        endpoint.schema('bundle').function('commit', [bundle.get('name'), message])\n        .then(function() {\n            w.trigger('close_tab', { tab_id: 'commit' });\n        }).catch(function(e) {\n            alert ('fail! '+e);\n        });\n    }\n});\n\n\n// untracked rows\n/*\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\n\nwidget.sync(untracked_rows, w.find('.untracked_rows'), function(schema) {\n    return widget('ide:bundle_untracked_row_by_schema', { schema: schema, bundle: bundle });\n});\n*/\n\nw.bind('reload_commit_dialog', function() {\n    w.replaceWith(widget('ide:commit_dialog', { bundle: bundle }));\n});\n\n
\\x9edff668a3e7cd0e1c1b4e54c6d87a920d521869f5c764ebe75a339880b1da75	var w = $("#"+id);\n\n\n// changes\nbundle.related_rows('id','bundle.head_db_stage_changed','bundle_id', {\n    /* first staged, then unstaged modified, then unstaged deleted */\n    order_by: [{\n        column: 'staged'\n    }, {\n        column: 'change_type'\n    }]\n}).then(function(changes) {\n    widget.sync(changes, w.find('.changes'), function(change) {\n        return widget('ide:commit_dialog_changed_row', { bundle: bundle, change: change });\n    });\n});\n\n// commit button handler\nw.find('button.do_commit').click(function() {\n    var message;\n    if (message = prompt('enter a commit message')) {\n        endpoint.schema('bundle').function('commit', [bundle.get('name'), message])\n        .then(function() {\n            w.trigger('close_tab', { tab_id: 'commit' });\n        }).catch(function(e) {\n            alert ('fail! '+e);\n        });\n    }\n});\n\n\n// untracked rows\n/*\nvar untracked_rows = endpoint.schema('bundle').view('untracked_row_by_schema').rows();\n\nwidget.sync(untracked_rows, w.find('.untracked_rows'), function(schema) {\n    return widget('ide:bundle_untracked_row_by_schema', { schema: schema, bundle: bundle });\n});\n*/\n\nw.bind('reload_commit_dialog', function() {\n    w.replaceWith(widget('ide:commit_dialog', { bundle: bundle }));\n});\n\n
\\xa05888b6d78d604177de9df555a03707ebe002c2f25767b95e6ff134dc9e6f6a	<div id="{{= id }}" class="{{= name }}">\n    <input class='fileUpload' type='file'>\n</div>
\\xa05888b6d78d604177de9df555a03707ebe002c2f25767b95e6ff134dc9e6f6a	<div id="{{= id }}" class="{{= name }}">\n    <input class='fileUpload' type='file'>\n</div>
\\xa0eee7444fe9193c0ffe33bfef833a47541f79f19afc80ea86ad748b296dfd4f	<div id="{{= id }}" class="{{= name }}">\n    {{= message }}\n</div>
\\xa0eee7444fe9193c0ffe33bfef833a47541f79f19afc80ea86ad748b296dfd4f	<div id="{{= id }}" class="{{= name }}">\n    {{= message }}\n</div>
\\xa11a75e0feeecc1a9eff682b06ef0b1461ed4ee7a4d6da4ae333bdc1041d9d51	option
\\xa11a75e0feeecc1a9eff682b06ef0b1461ed4ee7a4d6da4ae333bdc1041d9d51	option
\\xa14b24cb47e213c0bda7883afaba1d328251239a90e06af0f00900455e09dd91	9ba8e45a-4173-4c55-9bc2-97395897498f
\\xa14b24cb47e213c0bda7883afaba1d328251239a90e06af0f00900455e09dd91	9ba8e45a-4173-4c55-9bc2-97395897498f
\\xa150d3d3bfc5604de5b622c6de92362e7114322ae5244d8dce21c4cb63b9a7f5	f522acae-3fc3-4b9b-83a0-f4990a384210
\\xa150d3d3bfc5604de5b622c6de92362e7114322ae5244d8dce21c4cb63b9a7f5	f522acae-3fc3-4b9b-83a0-f4990a384210
\\xa15c04004f170a69b7b5d7b55d7c30e2b1619e0108bdd4962aff893edc9f06cd	sem_fkey_many_to_many
\\xa15c04004f170a69b7b5d7b55d7c30e2b1619e0108bdd4962aff893edc9f06cd	sem_fkey_many_to_many
\\xa353c7639fbb6a8353a248a6dc843b09f119631603d41fa039323361f4abda68	fc2bee4e-a43c-431c-95fe-0cdc61d5c437
\\xa353c7639fbb6a8353a248a6dc843b09f119631603d41fa039323361f4abda68	fc2bee4e-a43c-431c-95fe-0cdc61d5c437
\\xa37e21d2cbfa7a4ed78703023ae72ecc6048c7234a4eb18bdb175506e0e45a87	commit_dialog_staged_field
\\xa37e21d2cbfa7a4ed78703023ae72ecc6048c7234a4eb18bdb175506e0e45a87	commit_dialog_staged_field
\\xa4a0d0f35b7c7209c75f97dc5c4f9ddf69ceee89de31eee999211eda29042e39	\n/*\n * jwerty - Awesome handling of keyboard events\n *\n * jwerty is a JS lib which allows you to bind, fire and assert key combination\n * strings against elements and events. It normalises the poor std api into\n * something easy to use and clear.\n *\n * This code is licensed under the MIT\n * For the full license see: http://keithamus.mit-license.org/\n * For more information see: http://keithamus.github.com/jwerty\n *\n * @author Keith Cirkel ('keithamus') <jwerty@keithcirkel.co.uk>\n * @license http://keithamus.mit-license.org/\n * @copyright Copyright © 2011, Keith Cirkel\n *\n */\n(function (global, exports) {\n\n    // Try require external librairies in Node.js context\n    function tryRequire(mod) {\n        if (typeof require == 'function' && typeof module !== 'undefined' && module.exports) {\n            try {\n                return require(mod.toLowerCase());\n            } catch (err) {}\n        } else {\n            return global[mod];\n        }\n    }\n\n    // Helper methods & vars:\n    var $d = global.document,\n        $ = (tryRequire('jQuery') || tryRequire('Zepto') || tryRequire('ender') || $d),\n        $$, // Element selector function\n        $b, // Event binding function\n        $u, // Event unbinding function\n        $f, // Event firing function\n        ke = 'keydown';\n\n    function realTypeOf(v, s) {\n        return (v === null) ? s === 'null'\n        : (v === undefined) ? s === 'undefined'\n        : (v.is && v instanceof $) ? s === 'element'\n        : Object.prototype.toString.call(v).toLowerCase().indexOf(s) > 7;\n    }\n\n    if ($ === $d) {\n        $$ = function (selector, context) {\n            return selector ? $.querySelector(selector, context || $) : $;\n        };\n        $b = function (e, fn) { e.addEventListener(ke, fn, false); };\n        $u = function (e, fn) { e.removeEventListener(ke, fn, false); };\n        $f = function (e, jwertyEv) {\n            var ret = $d.createEvent('Event'),\n            i;\n\n            ret.initEvent(ke, true, true);\n\n            for (i in jwertyEv) ret[i] = jwertyEv[i];\n\n            return (e || $).dispatchEvent(ret);\n        };\n    } else {\n        $$ = function (selector, context) { return $(selector || $d, context); };\n        $b = function (e, fn) { $(e).bind(ke + '.jwerty', fn); };\n        $u = function (e, fn) { $(e).unbind(ke + '.jwerty', fn) };\n        $f = function (e, ob) { $(e || $d).trigger($.Event(ke, ob)); };\n    }\n\n    // Private\n    var _modProps = { 16: 'shiftKey', 17: 'ctrlKey', 18: 'altKey', 91: 'metaKey' };\n\n    // Generate key mappings for common keys that are not printable.\n    var _keys = {\n\n        // MOD aka toggleable keys\n        mods: {\n            // Shift key, ⇧\n            '⇧': 16,\n            shift: 16,\n            // CTRL key, on Mac: ⌃\n            '⌃': 17,\n            ctrl: 17,\n            // ALT key, on Mac: ⌥ (Alt)\n            '⌥': 18,\n            alt: 18,\n            option: 18,\n            // META, on Mac: ⌘ (CMD), on Windows (Win), on Linux (Super)\n            '⌘': 91,\n            meta: 91,\n            cmd: 91,\n            'super': 91,\n            win: 91\n        },\n\n        // Normal keys\n        keys: {\n            // Backspace key, on Mac: ⌫ (Backspace)\n            '⌫': 8,\n            backspace: 8,\n            // Tab Key, on Mac: ⇥ (Tab), on Windows ⇥⇥\n            '⇥': 9,\n            '⇆': 9,\n            tab: 9,\n            // Return key, ↩\n            '↩': 13,\n            'return': 13,\n            enter: 13,\n            '⌅': 13,\n            // Pause/Break key\n            'pause': 19,\n            'pause-break': 19,\n            // Caps Lock key, ⇪\n            '⇪': 20,\n            caps: 20,\n            'caps-lock': 20,\n            // Escape key, on Mac: ⎋, on Windows: Esc\n            '⎋': 27,\n            escape: 27,\n            esc: 27,\n            // Space key\n            space: 32,\n            // Page-Up key, or pgup, on Mac: ↖\n            '↖': 33,\n            pgup: 33,\n            'page-up': 33,\n            // Page-Down key, or pgdown, on Mac: ↘\n            '↘': 34,\n            pgdown: 34,\n            'page-down': 34,\n            // END key, on Mac: ⇟\n            '⇟': 35,\n            end: 35,\n            // HOME key, on Mac: ⇞\n            '⇞': 36,\n            home: 36,\n            // Insert key, or ins\n            ins: 45,\n            insert: 45,\n            // Delete key, on Mac: ⌫ (Delete)\n            del: 46,\n            'delete': 46,\n\n            // Left Arrow Key, or ←\n            '←': 37,\n            left: 37,\n            'arrow-left': 37,\n            // Up Arrow Key, or ↑\n            '↑': 38,\n            up: 38,\n            'arrow-up': 38,\n            // Right Arrow Key, or →\n            '→': 39,\n            right: 39,\n            'arrow-right': 39,\n            // Up Arrow Key, or ↓\n            '↓': 40,\n            down: 40,\n            'arrow-down': 40,\n\n            // odities, printing characters that come out wrong:\n            // Num-Multiply, or *\n            '*': 106,\n            star: 106,\n            asterisk: 106,\n            multiply: 106,\n            // Num-Plus or +\n            '+': 107,\n            'plus': 107,\n            // Num-Subtract, or -\n            '-': 109,\n            subtract: 109,\n            'num-.': 110,\n            'num-period': 110,\n            'num-dot': 110,\n            'num-full-stop': 110,\n            'num-delete': 110,\n            // Semicolon\n            ';': 186,\n            semicolon: 186,\n            // = or equals\n            '=': 187,\n            'equals': 187,\n            // Comma, or ,\n            ',': 188,\n            comma: 188,\n            //'-': 189, //???\n            // Period, or ., or full-stop\n            '.': 190,\n            period: 190,\n            'full-stop': 190,\n            // Slash, or /, or forward-slash\n            '/': 191,\n            slash: 191,\n            'forward-slash': 191,\n            // Tick, or `, or back-quote\n            '`': 192,\n            tick: 192,\n            'back-quote': 192,\n            // Open bracket, or [\n            '[': 219,\n            'open-bracket': 219,\n            // Back slash, or \\\n            '\\\\': 220,\n            'back-slash': 220,\n            // Close backet, or ]\n            ']': 221,\n            'close-bracket': 221,\n            // Apostraphe, or Quote, or '\n            '\\'': 222,\n            quote: 222,\n            apostraphe: 222\n        }\n\n    };\n\n    // To minimise code bloat, add all of the 0-9 and NUMPAD 0-9 keys in a loop\n    var i = 47,\n        n = 0;\n    while (++i < 106) {\n        _keys.keys[n] = i;\n        _keys.keys['num-' + n] = i + 48;\n        ++n;\n    }\n\n    // To minimise code bloat, add all of the F1-F25 keys in a loop\n    i = 111,\n    n = 1;\n    while (++i < 136) {\n        _keys.keys['f' + n] = i;\n        ++n;\n    }\n\n    // To minimise code bloat, add all of the letters of the alphabet in a loop\n    i = 64;\n    while (++i < 91) {\n        _keys.keys[String.fromCharCode(i).toLowerCase()] = i;\n    }\n\n    function JwertyCode(jwertyCode) {\n        var i,\n            c,\n            n,\n            z,\n            keyCombo,\n            optionals,\n            jwertyCodeFragment,\n            rangeMatches,\n            rangeI;\n\n        // In-case we get called with an instance of ourselves, just return that.\n        if (jwertyCode instanceof JwertyCode) return jwertyCode;\n\n        // If jwertyCode isn't an array, cast it as a string and split into array.\n        if (!realTypeOf(jwertyCode, 'array')) {\n            jwertyCode = (String(jwertyCode)).replace(/\\s/g, '').toLowerCase()\n                .match(/(?:\\+,|[^,])+/g);\n        }\n\n        // Loop through each key sequence in jwertyCode\n        for (i = 0, c = jwertyCode.length; i < c; ++i) {\n\n            // If the key combo at this part of the sequence isn't an array,\n            // cast as a string and split into an array.\n            if (!realTypeOf(jwertyCode[i], 'array')) {\n                jwertyCode[i] = String(jwertyCode[i])\n                    .match(/(?:\\+\\/|[^\\/])+/g);\n            }\n\n            // Parse the key optionals in this sequence\n            optionals = [],\n            n = jwertyCode[i].length;\n            while (n--) {\n\n                // Begin creating the object for this key combo\n                jwertyCodeFragment = jwertyCode[i][n];\n\n                keyCombo = {\n                    jwertyCombo: String(jwertyCodeFragment),\n                    shiftKey: false,\n                    ctrlKey: false,\n                    altKey: false,\n                    metaKey: false\n                };\n\n                // If jwertyCodeFragment isn't an array then cast as a string\n                // and split it into one.\n                if (!realTypeOf(jwertyCodeFragment, 'array')) {\n                    jwertyCodeFragment = String(jwertyCodeFragment).toLowerCase()\n                        .match(/(?:(?:[^\\+])+|\\+\\+|^\\+$)/g);\n                }\n\n                z = jwertyCodeFragment.length;\n                while (z--) {\n\n                    // Normalise matching errors\n                    if (jwertyCodeFragment[z] === '++') jwertyCodeFragment[z] = '+';\n\n                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo\n                    if (jwertyCodeFragment[z] in _keys.mods) {\n                        keyCombo[_modProps[_keys.mods[jwertyCodeFragment[z]]]] = true;\n                    } else if (jwertyCodeFragment[z] in _keys.keys) {\n                        keyCombo.keyCode = _keys.keys[jwertyCodeFragment[z]];\n                    } else {\n                        rangeMatches = jwertyCodeFragment[z].match(/^\\[([^-]+\\-?[^-]*)-([^-]+\\-?[^-]*)\\]$/);\n                    }\n                }\n                if (realTypeOf(keyCombo.keyCode, 'undefined')) {\n                    // If we picked up a range match earlier...\n                    if (rangeMatches && (rangeMatches[1] in _keys.keys) && (rangeMatches[2] in _keys.keys)) {\n                        rangeMatches[2] = _keys.keys[rangeMatches[2]];\n                        rangeMatches[1] = _keys.keys[rangeMatches[1]];\n\n                        // Go from match 1 and capture all key-comobs up to match 2\n                        for (rangeI = rangeMatches[1]; rangeI < rangeMatches[2]; ++rangeI) {\n                            optionals.push({\n                                altKey: keyCombo.altKey,\n                                shiftKey: keyCombo.shiftKey,\n                                metaKey: keyCombo.metaKey,\n                                ctrlKey: keyCombo.ctrlKey,\n                                keyCode: rangeI,\n                                jwertyCombo: String(jwertyCodeFragment)\n                            });\n\n                        }\n                        keyCombo.keyCode = rangeI;\n                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo\n                    } else {\n                        keyCombo.keyCode = 0;\n                    }\n                }\n                optionals.push(keyCombo);\n\n            }\n            this[i] = optionals;\n        }\n        this.length = i;\n        return this;\n    }\n\n    var jwerty = exports.jwerty = {\n        /**\n         * jwerty.event\n         *\n         * `jwerty.event` will return a function, which expects the first\n         *  argument to be a key event. When the key event matches `jwertyCode`,\n         *  `callbackFunction` is fired. `jwerty.event` is used by `jwerty.key`\n         *  to bind the function it returns. `jwerty.event` is useful for\n         *  attaching to your own event listeners. It can be used as a decorator\n         *  method to encapsulate functionality that you only want to fire after\n         *  a specific key combo. If `callbackContext` is specified then it will\n         *  be supplied as `callbackFunction`'s context - in other words, the\n         *  keyword `this` will be set to `callbackContext` inside the\n         *  `callbackFunction` function.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Function} callbackFucntion is a function (or boolean) which\n         *      is fired when jwertyCode is matched. Return false to\n         *      preventDefault()\n         *   @param {Object} callbackContext (Optional) The context to call\n         *      `callback` with (i.e this)\n         *\n         */\n        event: function (jwertyCode, callbackFunction, callbackContext /*? this */) {\n\n            // Construct a function out of callbackFunction, if it is a boolean.\n            if (realTypeOf(callbackFunction, 'boolean')) {\n                var bool = callbackFunction;\n                callbackFunction = function () { return bool; };\n            }\n\n            jwertyCode = new JwertyCode(jwertyCode);\n\n            // Initialise in-scope vars.\n            var i = 0,\n                c = jwertyCode.length - 1,\n                returnValue,\n                jwertyCodeIs;\n\n            // This is the event listener function that gets returned...\n            return function (event) {\n\n                // if jwertyCodeIs returns truthy (string)...\n                if ((jwertyCodeIs = jwerty.is(jwertyCode, event, i))) {\n                    // ... and this isn't the last key in the sequence,\n                    // incriment the key in sequence to check.\n                    if (i < c) {\n                        ++i;\n                        return;\n                    // ... and this is the last in the sequence (or the only\n                    // one in sequence), then fire the callback\n                    } else {\n                        returnValue = callbackFunction.call(\n                            callbackContext || this, event, jwertyCodeIs);\n\n                        // If the callback returned false, then we should run\n                        // preventDefault();\n                        if (returnValue === false) event.preventDefault();\n\n                        // Reset i for the next sequence to fire.\n                        i = 0;\n                        return;\n                    }\n                }\n\n                // If the event didn't hit this time, we should reset i to 0,\n                // that is, unless this combo was the first in the sequence,\n                // in which case we should reset i to 1.\n                i = jwerty.is(jwertyCode, event) ? 1 : 0;\n            };\n        },\n\n        /**\n         * jwerty.is\n         *\n         * `jwerty.is` will return a boolean value, based on if `event` matches\n         *  `jwertyCode`. `jwerty.is` is called by `jwerty.event` to check\n         *  whether or not to fire the callback. `event` can be a DOM event, or\n         *  a jQuery/Zepto/Ender manufactured event. The properties of\n         *  `jwertyCode` (speficially ctrlKey, altKey, metaKey, shiftKey and\n         *  keyCode) should match `jwertyCode`'s properties - if they do, then\n         *  `jwerty.is` will return `true`. If they don't, `jwerty.is` will\n         *  return `false`.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {KeyboardEvent} event is the KeyboardEvent to assert against\n         *   @param {Integer} i (Optional) checks the `i` key in jwertyCode\n         *      sequence\n         *\n         */\n        is: function (jwertyCode, event, i /*? 0*/) {\n            jwertyCode = new JwertyCode(jwertyCode);\n            // Default `i` to 0\n            i = i || 0;\n            // We are only interested in `i` of jwertyCode;\n            jwertyCode = jwertyCode[i];\n            // jQuery stores the *real* event in `originalEvent`, which we use\n            // because it does annoything stuff to `metaKey`\n            event = event.originalEvent || event;\n\n            // We'll look at each optional in this jwertyCode sequence...\n            var n = jwertyCode.length,\n                returnValue = false;\n\n            // Loop through each fragment of jwertyCode\n            while (n--) {\n                returnValue = jwertyCode[n].jwertyCombo;\n                // For each property in the jwertyCode object, compare to `event`\n                for (var p in jwertyCode[n]) {\n                    // ...except for jwertyCode.jwertyCombo...\n                    if (p !== 'jwertyCombo' && event[p] != jwertyCode[n][p]) returnValue = false;\n                }\n                // If this jwertyCode optional wasn't falsey, then we can return early.\n                if (returnValue !== false) return returnValue;\n            }\n            return returnValue;\n        },\n\n        /**\n         * jwerty.key\n         *\n         *  `jwerty.key` will attach an event listener and fire\n         *   `callbackFunction` when `jwertyCode` matches. The event listener is\n         *   attached to `document`, meaning it will listen for any key events\n         *   on the page (a global shortcut listener). If `callbackContext` is\n         *   specified then it will be supplied as `callbackFunction`'s context\n         *   - in other words, the keyword `this` will be set to\n         *   `callbackContext` inside the `callbackFunction` function.\n         *   returns a subscription handle `h`, by which you may undo the binding\n         *   by calling `h.unbind()`\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Function} callbackFunction is a function (or boolean) which\n         *      is fired when jwertyCode is matched. Return false to\n         *      preventDefault()\n         *   @param {Object} callbackContext (Optional) The context to call\n         *      `callback` with (i.e this)\n         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,\n         *      or an HTML*Element on which to bind the eventListener\n         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender\n         *      object, or an HTML*Element on which to scope the selector\n         *\n         */\n        key: function (jwertyCode, callbackFunction, callbackContext /*? this */, selector /*? document */, selectorContext /*? body */) {\n            // Because callbackContext is optional, we should check if the\n            // `callbackContext` is a string or element, and if it is, then the\n            // function was called without a context, and `callbackContext` is\n            // actually `selector`\n            var realSelector = realTypeOf(callbackContext, 'element') || realTypeOf(callbackContext, 'string') ? callbackContext : selector,\n            // If `callbackContext` is undefined, or if we skipped it (and\n            // therefore it is `realSelector`), set context to `global`.\n                realcallbackContext = realSelector === callbackContext ? global : callbackContext,\n            // Finally if we did skip `callbackContext`, then shift\n            // `selectorContext` to the left (take it from `selector`)\n                realSelectorContext = realSelector === callbackContext ? selector : selectorContext;\n\n            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,\n            // then just use it neat, otherwise find it in DOM using $$()\n            var element = realTypeOf(realSelector, 'element') ? realSelector : $$(realSelector, realSelectorContext);\n            var callback = jwerty.event(jwertyCode, callbackFunction, realcallbackContext);\n            $b( element, callback );\n            \n            return {unbind:function(){ $u( element, callback ) }};\n        },\n        \n        /**\n         * jwerty.fire\n         *\n         * `jwerty.fire` will construct a keyup event to fire, based on\n         *  `jwertyCode`. The event will be fired against `selector`.\n         *  `selectorContext` is used to search for `selector` within\n         *  `selectorContext`, similar to jQuery's\n         *  `$('selector', 'context')`.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,\n         *      or an HTML*Element on which to bind the eventListener\n         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender\n         *      object, or an HTML*Element on which to scope the selector\n         *\n         */\n        fire: function (jwertyCode, selector /*? document */, selectorContext /*? body */, i) {\n            jwertyCode = new JwertyCode(jwertyCode);\n            var realI = realTypeOf(selectorContext, 'number') ? selectorContext : i;\n\n            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,\n            // then just use it neat, otherwise find it in DOM using $$()\n            $f(\n                realTypeOf(selector, 'element') ? selector : $$(selector, selectorContext),\n                jwertyCode[realI || 0][0]\n            );\n        },\n\n        KEYS: _keys\n    };\n\n}(typeof global !== 'undefined' && global.window || this, (typeof module !== 'undefined' && module.exports ? module.exports : this)));\n
\\xa4a0d0f35b7c7209c75f97dc5c4f9ddf69ceee89de31eee999211eda29042e39	\n/*\n * jwerty - Awesome handling of keyboard events\n *\n * jwerty is a JS lib which allows you to bind, fire and assert key combination\n * strings against elements and events. It normalises the poor std api into\n * something easy to use and clear.\n *\n * This code is licensed under the MIT\n * For the full license see: http://keithamus.mit-license.org/\n * For more information see: http://keithamus.github.com/jwerty\n *\n * @author Keith Cirkel ('keithamus') <jwerty@keithcirkel.co.uk>\n * @license http://keithamus.mit-license.org/\n * @copyright Copyright © 2011, Keith Cirkel\n *\n */\n(function (global, exports) {\n\n    // Try require external librairies in Node.js context\n    function tryRequire(mod) {\n        if (typeof require == 'function' && typeof module !== 'undefined' && module.exports) {\n            try {\n                return require(mod.toLowerCase());\n            } catch (err) {}\n        } else {\n            return global[mod];\n        }\n    }\n\n    // Helper methods & vars:\n    var $d = global.document,\n        $ = (tryRequire('jQuery') || tryRequire('Zepto') || tryRequire('ender') || $d),\n        $$, // Element selector function\n        $b, // Event binding function\n        $u, // Event unbinding function\n        $f, // Event firing function\n        ke = 'keydown';\n\n    function realTypeOf(v, s) {\n        return (v === null) ? s === 'null'\n        : (v === undefined) ? s === 'undefined'\n        : (v.is && v instanceof $) ? s === 'element'\n        : Object.prototype.toString.call(v).toLowerCase().indexOf(s) > 7;\n    }\n\n    if ($ === $d) {\n        $$ = function (selector, context) {\n            return selector ? $.querySelector(selector, context || $) : $;\n        };\n        $b = function (e, fn) { e.addEventListener(ke, fn, false); };\n        $u = function (e, fn) { e.removeEventListener(ke, fn, false); };\n        $f = function (e, jwertyEv) {\n            var ret = $d.createEvent('Event'),\n            i;\n\n            ret.initEvent(ke, true, true);\n\n            for (i in jwertyEv) ret[i] = jwertyEv[i];\n\n            return (e || $).dispatchEvent(ret);\n        };\n    } else {\n        $$ = function (selector, context) { return $(selector || $d, context); };\n        $b = function (e, fn) { $(e).bind(ke + '.jwerty', fn); };\n        $u = function (e, fn) { $(e).unbind(ke + '.jwerty', fn) };\n        $f = function (e, ob) { $(e || $d).trigger($.Event(ke, ob)); };\n    }\n\n    // Private\n    var _modProps = { 16: 'shiftKey', 17: 'ctrlKey', 18: 'altKey', 91: 'metaKey' };\n\n    // Generate key mappings for common keys that are not printable.\n    var _keys = {\n\n        // MOD aka toggleable keys\n        mods: {\n            // Shift key, ⇧\n            '⇧': 16,\n            shift: 16,\n            // CTRL key, on Mac: ⌃\n            '⌃': 17,\n            ctrl: 17,\n            // ALT key, on Mac: ⌥ (Alt)\n            '⌥': 18,\n            alt: 18,\n            option: 18,\n            // META, on Mac: ⌘ (CMD), on Windows (Win), on Linux (Super)\n            '⌘': 91,\n            meta: 91,\n            cmd: 91,\n            'super': 91,\n            win: 91\n        },\n\n        // Normal keys\n        keys: {\n            // Backspace key, on Mac: ⌫ (Backspace)\n            '⌫': 8,\n            backspace: 8,\n            // Tab Key, on Mac: ⇥ (Tab), on Windows ⇥⇥\n            '⇥': 9,\n            '⇆': 9,\n            tab: 9,\n            // Return key, ↩\n            '↩': 13,\n            'return': 13,\n            enter: 13,\n            '⌅': 13,\n            // Pause/Break key\n            'pause': 19,\n            'pause-break': 19,\n            // Caps Lock key, ⇪\n            '⇪': 20,\n            caps: 20,\n            'caps-lock': 20,\n            // Escape key, on Mac: ⎋, on Windows: Esc\n            '⎋': 27,\n            escape: 27,\n            esc: 27,\n            // Space key\n            space: 32,\n            // Page-Up key, or pgup, on Mac: ↖\n            '↖': 33,\n            pgup: 33,\n            'page-up': 33,\n            // Page-Down key, or pgdown, on Mac: ↘\n            '↘': 34,\n            pgdown: 34,\n            'page-down': 34,\n            // END key, on Mac: ⇟\n            '⇟': 35,\n            end: 35,\n            // HOME key, on Mac: ⇞\n            '⇞': 36,\n            home: 36,\n            // Insert key, or ins\n            ins: 45,\n            insert: 45,\n            // Delete key, on Mac: ⌫ (Delete)\n            del: 46,\n            'delete': 46,\n\n            // Left Arrow Key, or ←\n            '←': 37,\n            left: 37,\n            'arrow-left': 37,\n            // Up Arrow Key, or ↑\n            '↑': 38,\n            up: 38,\n            'arrow-up': 38,\n            // Right Arrow Key, or →\n            '→': 39,\n            right: 39,\n            'arrow-right': 39,\n            // Up Arrow Key, or ↓\n            '↓': 40,\n            down: 40,\n            'arrow-down': 40,\n\n            // odities, printing characters that come out wrong:\n            // Num-Multiply, or *\n            '*': 106,\n            star: 106,\n            asterisk: 106,\n            multiply: 106,\n            // Num-Plus or +\n            '+': 107,\n            'plus': 107,\n            // Num-Subtract, or -\n            '-': 109,\n            subtract: 109,\n            'num-.': 110,\n            'num-period': 110,\n            'num-dot': 110,\n            'num-full-stop': 110,\n            'num-delete': 110,\n            // Semicolon\n            ';': 186,\n            semicolon: 186,\n            // = or equals\n            '=': 187,\n            'equals': 187,\n            // Comma, or ,\n            ',': 188,\n            comma: 188,\n            //'-': 189, //???\n            // Period, or ., or full-stop\n            '.': 190,\n            period: 190,\n            'full-stop': 190,\n            // Slash, or /, or forward-slash\n            '/': 191,\n            slash: 191,\n            'forward-slash': 191,\n            // Tick, or `, or back-quote\n            '`': 192,\n            tick: 192,\n            'back-quote': 192,\n            // Open bracket, or [\n            '[': 219,\n            'open-bracket': 219,\n            // Back slash, or \\\n            '\\\\': 220,\n            'back-slash': 220,\n            // Close backet, or ]\n            ']': 221,\n            'close-bracket': 221,\n            // Apostraphe, or Quote, or '\n            '\\'': 222,\n            quote: 222,\n            apostraphe: 222\n        }\n\n    };\n\n    // To minimise code bloat, add all of the 0-9 and NUMPAD 0-9 keys in a loop\n    var i = 47,\n        n = 0;\n    while (++i < 106) {\n        _keys.keys[n] = i;\n        _keys.keys['num-' + n] = i + 48;\n        ++n;\n    }\n\n    // To minimise code bloat, add all of the F1-F25 keys in a loop\n    i = 111,\n    n = 1;\n    while (++i < 136) {\n        _keys.keys['f' + n] = i;\n        ++n;\n    }\n\n    // To minimise code bloat, add all of the letters of the alphabet in a loop\n    i = 64;\n    while (++i < 91) {\n        _keys.keys[String.fromCharCode(i).toLowerCase()] = i;\n    }\n\n    function JwertyCode(jwertyCode) {\n        var i,\n            c,\n            n,\n            z,\n            keyCombo,\n            optionals,\n            jwertyCodeFragment,\n            rangeMatches,\n            rangeI;\n\n        // In-case we get called with an instance of ourselves, just return that.\n        if (jwertyCode instanceof JwertyCode) return jwertyCode;\n\n        // If jwertyCode isn't an array, cast it as a string and split into array.\n        if (!realTypeOf(jwertyCode, 'array')) {\n            jwertyCode = (String(jwertyCode)).replace(/\\s/g, '').toLowerCase()\n                .match(/(?:\\+,|[^,])+/g);\n        }\n\n        // Loop through each key sequence in jwertyCode\n        for (i = 0, c = jwertyCode.length; i < c; ++i) {\n\n            // If the key combo at this part of the sequence isn't an array,\n            // cast as a string and split into an array.\n            if (!realTypeOf(jwertyCode[i], 'array')) {\n                jwertyCode[i] = String(jwertyCode[i])\n                    .match(/(?:\\+\\/|[^\\/])+/g);\n            }\n\n            // Parse the key optionals in this sequence\n            optionals = [],\n            n = jwertyCode[i].length;\n            while (n--) {\n\n                // Begin creating the object for this key combo\n                jwertyCodeFragment = jwertyCode[i][n];\n\n                keyCombo = {\n                    jwertyCombo: String(jwertyCodeFragment),\n                    shiftKey: false,\n                    ctrlKey: false,\n                    altKey: false,\n                    metaKey: false\n                };\n\n                // If jwertyCodeFragment isn't an array then cast as a string\n                // and split it into one.\n                if (!realTypeOf(jwertyCodeFragment, 'array')) {\n                    jwertyCodeFragment = String(jwertyCodeFragment).toLowerCase()\n                        .match(/(?:(?:[^\\+])+|\\+\\+|^\\+$)/g);\n                }\n\n                z = jwertyCodeFragment.length;\n                while (z--) {\n\n                    // Normalise matching errors\n                    if (jwertyCodeFragment[z] === '++') jwertyCodeFragment[z] = '+';\n\n                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo\n                    if (jwertyCodeFragment[z] in _keys.mods) {\n                        keyCombo[_modProps[_keys.mods[jwertyCodeFragment[z]]]] = true;\n                    } else if (jwertyCodeFragment[z] in _keys.keys) {\n                        keyCombo.keyCode = _keys.keys[jwertyCodeFragment[z]];\n                    } else {\n                        rangeMatches = jwertyCodeFragment[z].match(/^\\[([^-]+\\-?[^-]*)-([^-]+\\-?[^-]*)\\]$/);\n                    }\n                }\n                if (realTypeOf(keyCombo.keyCode, 'undefined')) {\n                    // If we picked up a range match earlier...\n                    if (rangeMatches && (rangeMatches[1] in _keys.keys) && (rangeMatches[2] in _keys.keys)) {\n                        rangeMatches[2] = _keys.keys[rangeMatches[2]];\n                        rangeMatches[1] = _keys.keys[rangeMatches[1]];\n\n                        // Go from match 1 and capture all key-comobs up to match 2\n                        for (rangeI = rangeMatches[1]; rangeI < rangeMatches[2]; ++rangeI) {\n                            optionals.push({\n                                altKey: keyCombo.altKey,\n                                shiftKey: keyCombo.shiftKey,\n                                metaKey: keyCombo.metaKey,\n                                ctrlKey: keyCombo.ctrlKey,\n                                keyCode: rangeI,\n                                jwertyCombo: String(jwertyCodeFragment)\n                            });\n\n                        }\n                        keyCombo.keyCode = rangeI;\n                    // Inject either keyCode or ctrl/meta/shift/altKey into keyCombo\n                    } else {\n                        keyCombo.keyCode = 0;\n                    }\n                }\n                optionals.push(keyCombo);\n\n            }\n            this[i] = optionals;\n        }\n        this.length = i;\n        return this;\n    }\n\n    var jwerty = exports.jwerty = {\n        /**\n         * jwerty.event\n         *\n         * `jwerty.event` will return a function, which expects the first\n         *  argument to be a key event. When the key event matches `jwertyCode`,\n         *  `callbackFunction` is fired. `jwerty.event` is used by `jwerty.key`\n         *  to bind the function it returns. `jwerty.event` is useful for\n         *  attaching to your own event listeners. It can be used as a decorator\n         *  method to encapsulate functionality that you only want to fire after\n         *  a specific key combo. If `callbackContext` is specified then it will\n         *  be supplied as `callbackFunction`'s context - in other words, the\n         *  keyword `this` will be set to `callbackContext` inside the\n         *  `callbackFunction` function.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Function} callbackFucntion is a function (or boolean) which\n         *      is fired when jwertyCode is matched. Return false to\n         *      preventDefault()\n         *   @param {Object} callbackContext (Optional) The context to call\n         *      `callback` with (i.e this)\n         *\n         */\n        event: function (jwertyCode, callbackFunction, callbackContext /*? this */) {\n\n            // Construct a function out of callbackFunction, if it is a boolean.\n            if (realTypeOf(callbackFunction, 'boolean')) {\n                var bool = callbackFunction;\n                callbackFunction = function () { return bool; };\n            }\n\n            jwertyCode = new JwertyCode(jwertyCode);\n\n            // Initialise in-scope vars.\n            var i = 0,\n                c = jwertyCode.length - 1,\n                returnValue,\n                jwertyCodeIs;\n\n            // This is the event listener function that gets returned...\n            return function (event) {\n\n                // if jwertyCodeIs returns truthy (string)...\n                if ((jwertyCodeIs = jwerty.is(jwertyCode, event, i))) {\n                    // ... and this isn't the last key in the sequence,\n                    // incriment the key in sequence to check.\n                    if (i < c) {\n                        ++i;\n                        return;\n                    // ... and this is the last in the sequence (or the only\n                    // one in sequence), then fire the callback\n                    } else {\n                        returnValue = callbackFunction.call(\n                            callbackContext || this, event, jwertyCodeIs);\n\n                        // If the callback returned false, then we should run\n                        // preventDefault();\n                        if (returnValue === false) event.preventDefault();\n\n                        // Reset i for the next sequence to fire.\n                        i = 0;\n                        return;\n                    }\n                }\n\n                // If the event didn't hit this time, we should reset i to 0,\n                // that is, unless this combo was the first in the sequence,\n                // in which case we should reset i to 1.\n                i = jwerty.is(jwertyCode, event) ? 1 : 0;\n            };\n        },\n\n        /**\n         * jwerty.is\n         *\n         * `jwerty.is` will return a boolean value, based on if `event` matches\n         *  `jwertyCode`. `jwerty.is` is called by `jwerty.event` to check\n         *  whether or not to fire the callback. `event` can be a DOM event, or\n         *  a jQuery/Zepto/Ender manufactured event. The properties of\n         *  `jwertyCode` (speficially ctrlKey, altKey, metaKey, shiftKey and\n         *  keyCode) should match `jwertyCode`'s properties - if they do, then\n         *  `jwerty.is` will return `true`. If they don't, `jwerty.is` will\n         *  return `false`.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {KeyboardEvent} event is the KeyboardEvent to assert against\n         *   @param {Integer} i (Optional) checks the `i` key in jwertyCode\n         *      sequence\n         *\n         */\n        is: function (jwertyCode, event, i /*? 0*/) {\n            jwertyCode = new JwertyCode(jwertyCode);\n            // Default `i` to 0\n            i = i || 0;\n            // We are only interested in `i` of jwertyCode;\n            jwertyCode = jwertyCode[i];\n            // jQuery stores the *real* event in `originalEvent`, which we use\n            // because it does annoything stuff to `metaKey`\n            event = event.originalEvent || event;\n\n            // We'll look at each optional in this jwertyCode sequence...\n            var n = jwertyCode.length,\n                returnValue = false;\n\n            // Loop through each fragment of jwertyCode\n            while (n--) {\n                returnValue = jwertyCode[n].jwertyCombo;\n                // For each property in the jwertyCode object, compare to `event`\n                for (var p in jwertyCode[n]) {\n                    // ...except for jwertyCode.jwertyCombo...\n                    if (p !== 'jwertyCombo' && event[p] != jwertyCode[n][p]) returnValue = false;\n                }\n                // If this jwertyCode optional wasn't falsey, then we can return early.\n                if (returnValue !== false) return returnValue;\n            }\n            return returnValue;\n        },\n\n        /**\n         * jwerty.key\n         *\n         *  `jwerty.key` will attach an event listener and fire\n         *   `callbackFunction` when `jwertyCode` matches. The event listener is\n         *   attached to `document`, meaning it will listen for any key events\n         *   on the page (a global shortcut listener). If `callbackContext` is\n         *   specified then it will be supplied as `callbackFunction`'s context\n         *   - in other words, the keyword `this` will be set to\n         *   `callbackContext` inside the `callbackFunction` function.\n         *   returns a subscription handle `h`, by which you may undo the binding\n         *   by calling `h.unbind()`\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Function} callbackFunction is a function (or boolean) which\n         *      is fired when jwertyCode is matched. Return false to\n         *      preventDefault()\n         *   @param {Object} callbackContext (Optional) The context to call\n         *      `callback` with (i.e this)\n         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,\n         *      or an HTML*Element on which to bind the eventListener\n         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender\n         *      object, or an HTML*Element on which to scope the selector\n         *\n         */\n        key: function (jwertyCode, callbackFunction, callbackContext /*? this */, selector /*? document */, selectorContext /*? body */) {\n            // Because callbackContext is optional, we should check if the\n            // `callbackContext` is a string or element, and if it is, then the\n            // function was called without a context, and `callbackContext` is\n            // actually `selector`\n            var realSelector = realTypeOf(callbackContext, 'element') || realTypeOf(callbackContext, 'string') ? callbackContext : selector,\n            // If `callbackContext` is undefined, or if we skipped it (and\n            // therefore it is `realSelector`), set context to `global`.\n                realcallbackContext = realSelector === callbackContext ? global : callbackContext,\n            // Finally if we did skip `callbackContext`, then shift\n            // `selectorContext` to the left (take it from `selector`)\n                realSelectorContext = realSelector === callbackContext ? selector : selectorContext;\n\n            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,\n            // then just use it neat, otherwise find it in DOM using $$()\n            var element = realTypeOf(realSelector, 'element') ? realSelector : $$(realSelector, realSelectorContext);\n            var callback = jwerty.event(jwertyCode, callbackFunction, realcallbackContext);\n            $b( element, callback );\n            \n            return {unbind:function(){ $u( element, callback ) }};\n        },\n        \n        /**\n         * jwerty.fire\n         *\n         * `jwerty.fire` will construct a keyup event to fire, based on\n         *  `jwertyCode`. The event will be fired against `selector`.\n         *  `selectorContext` is used to search for `selector` within\n         *  `selectorContext`, similar to jQuery's\n         *  `$('selector', 'context')`.\n         *\n         *   @param {Mixed} jwertyCode can be an array, or string of key\n         *      combinations, which includes optinals and or sequences\n         *   @param {Mixed} selector can be a string, jQuery/Zepto/Ender object,\n         *      or an HTML*Element on which to bind the eventListener\n         *   @param {Mixed} selectorContext can be a string, jQuery/Zepto/Ender\n         *      object, or an HTML*Element on which to scope the selector\n         *\n         */\n        fire: function (jwertyCode, selector /*? document */, selectorContext /*? body */, i) {\n            jwertyCode = new JwertyCode(jwertyCode);\n            var realI = realTypeOf(selectorContext, 'number') ? selectorContext : i;\n\n            // If `realSelector` is already a jQuery/Zepto/Ender/DOM element,\n            // then just use it neat, otherwise find it in DOM using $$()\n            $f(\n                realTypeOf(selector, 'element') ? selector : $$(selector, selectorContext),\n                jwertyCode[realI || 0][0]\n            );\n        },\n\n        KEYS: _keys\n    };\n\n}(typeof global !== 'undefined' && global.window || this, (typeof module !== 'undefined' && module.exports ? module.exports : this)));\n
\\xa4e8c05ab714b81466d49dc41aba1513959e42e40d8189aa182b34d2f72d9978	var w = $('#'+id);\n\nw.find('.content').append(content);\n\nfunction dismiss(e) {\n    e.stopPropagation();\n    w.fadeOut('fast').remove(); \n    return false;\n}\n\nw.on('click done dismiss close_modal', dismiss);\nw.find('.content').on('click', function(e) {\n    e.stopPropagation();\n});\njwerty.key('esc', dismiss);\n
\\xa4e8c05ab714b81466d49dc41aba1513959e42e40d8189aa182b34d2f72d9978	var w = $('#'+id);\n\nw.find('.content').append(content);\n\nfunction dismiss(e) {\n    e.stopPropagation();\n    w.fadeOut('fast').remove(); \n    return false;\n}\n\nw.on('click done dismiss close_modal', dismiss);\nw.find('.content').on('click', function(e) {\n    e.stopPropagation();\n});\njwerty.key('esc', dismiss);\n
\\xa584f5231af372cbd8fd8268799ec16041db6894d3240a595a84fa3187b81da3	<div id="{{= id }}" class="{{= name }}">\n    <div class="overlay"></div>\n    <div class="content"></div>\n</div>
\\xa584f5231af372cbd8fd8268799ec16041db6894d3240a595a84fa3187b81da3	<div id="{{= id }}" class="{{= name }}">\n    <div class="overlay"></div>\n    <div class="content"></div>\n</div>
\\xa5f41780ca09418705e702e25a837c3fe12c6e7032f69af50fe2703beb61ac99	d6e22ebd-0168-4efa-80c9-5f9c097734d2
\\xa5f41780ca09418705e702e25a837c3fe12c6e7032f69af50fe2703beb61ac99	d6e22ebd-0168-4efa-80c9-5f9c097734d2
\\xa8ae5aa90a94d908fc7ab35b18702a301e9378f83386f49d4b1dc63c0502a34f	<div id="{{= id }}" class="{{= name }}">\n</div>
\\xa8ae5aa90a94d908fc7ab35b18702a301e9378f83386f49d4b1dc63c0502a34f	<div id="{{= id }}" class="{{= name }}">\n</div>
\\xa8ae5aa90a94d908fc7ab35b18702a301e9378f83386f49d4b1dc63c0502a34f	<div id="{{= id }}" class="{{= name }}">\n</div>
\\xa8ae5aa90a94d908fc7ab35b18702a301e9378f83386f49d4b1dc63c0502a34f	<div id="{{= id }}" class="{{= name }}">\n</div>
\\xa95fa9d7ca9a4b526db69b856e1b4dc987ff5662545f7c4ba6ed904f00b7f317	.{{= name }} {\n    border: 1px solid white;\n    height: 100%;\n    overflow: auto;\n}
\\xa95fa9d7ca9a4b526db69b856e1b4dc987ff5662545f7c4ba6ed904f00b7f317	.{{= name }} {\n    border: 1px solid white;\n    height: 100%;\n    overflow: auto;\n}
\\xaa29e89828d1fb82ed3daf1877c82eac7587275b371196043cd5a410f0280b0b	29b4e0ef-4a15-43a7-930c-21e5f1653e76
\\xaa29e89828d1fb82ed3daf1877c82eac7587275b371196043cd5a410f0280b0b	29b4e0ef-4a15-43a7-930c-21e5f1653e76
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xaad587a81dcb3976f93f725a8e8b5ef15abf3809b128082b797c6e9aa33e2e5a	.{{= name }} {\n}\n
\\xaebaf1439501b42864cfe817c374e95d5dcc64599d793c19867ad2f15c7d2030	<div id="{{= id }}" class="{{= name }}">\n    <nav><!--\n        {{ Object.keys(tabs).forEach(function(tab_name) { }}\n\t\t--><a {{ if(typeof base_url != 'undefined') { }}\n      \t\t\thref='{{= base_url + "/" + tab_name }}' }}\n    \t  {{ } }} data-tab="{{= tab_name }}">{{= tab_name }}</a><!--\n        {{ }); }}\n    --></nav>\n    <div class="content"></div>\n</div>
\\xaebaf1439501b42864cfe817c374e95d5dcc64599d793c19867ad2f15c7d2030	<div id="{{= id }}" class="{{= name }}">\n    <nav><!--\n        {{ Object.keys(tabs).forEach(function(tab_name) { }}\n\t\t--><a {{ if(typeof base_url != 'undefined') { }}\n      \t\t\thref='{{= base_url + "/" + tab_name }}' }}\n    \t  {{ } }} data-tab="{{= tab_name }}">{{= tab_name }}</a><!--\n        {{ }); }}\n    --></nav>\n    <div class="content"></div>\n</div>
\\xaee20f8e464a1cbbd0dded06988a071a7fc5fa37b8468d8e6dd21bf404ae845e	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td class='change_type'>\n        <span title='This row has been modified' class='icon modified'>&Delta;<span class='modified_link'>(diff)</span></span>\n        <span title='This row has been deleted' class='icon deleted'>-</span>\n        <span title='This row has been added' class='icon added'>+</span>\n        <span title='This row has been tracked' class='icon tracked'>&#128065;</span>\n    </td>\n    <td>\n        <div class='unstaged'>\n            <button class='stage'>stage →</button>\n        </div>\n        <div class='unstaged_fields'>\n        </div>\n    </td>    \n    <td>\n        <div class='staged'>\n            <button class='unstage'>← unstage</button>\n        </div>\n        <div class='staged_fields'>\n        </div>\n    </td>\n    <td>{{= change.get('row_exists') }}</td>\n</tr>
\\xaee20f8e464a1cbbd0dded06988a071a7fc5fa37b8468d8e6dd21bf404ae845e	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td class='change_type'>\n        <span title='This row has been modified' class='icon modified'>&Delta;<span class='modified_link'>(diff)</span></span>\n        <span title='This row has been deleted' class='icon deleted'>-</span>\n        <span title='This row has been added' class='icon added'>+</span>\n        <span title='This row has been tracked' class='icon tracked'>&#128065;</span>\n    </td>\n    <td>\n        <div class='unstaged'>\n            <button class='stage'>stage →</button>\n        </div>\n        <div class='unstaged_fields'>\n        </div>\n    </td>    \n    <td>\n        <div class='staged'>\n            <button class='unstage'>← unstage</button>\n        </div>\n        <div class='staged_fields'>\n        </div>\n    </td>\n    <td>{{= change.get('row_exists') }}</td>\n</tr>
\\xaf30c3b388d83f333b6d8fa7139e563ac246c3d683cc5e085eeb7167ed9fe842	.{{= name }} div.unstaged {\n    display: none;\n    background-color: pink;\n}\n\n.{{= name }} div.staged {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} div.unstaged_fields {\n    display: none;\n    background-color: pink;\n}\n.{{= name }} div.staged_fields {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.modified_link {\n    font-size: 72%;\n}\n.{{= name }} span.modified_link:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n
\\xaf30c3b388d83f333b6d8fa7139e563ac246c3d683cc5e085eeb7167ed9fe842	.{{= name }} div.unstaged {\n    display: none;\n    background-color: pink;\n}\n\n.{{= name }} div.staged {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} div.unstaged_fields {\n    display: none;\n    background-color: pink;\n}\n.{{= name }} div.staged_fields {\n    display: none;\n    background-color: lightgreen;\n}\n\n.{{= name }} span.icon {\n    display: none;\n    font-size: 120%;\n}\n\n.{{= name }} span.modified {\n    color: yellow;\n}\n\n\n.{{= name }} span.added {\n    color: green;\n}\n\n\n.{{= name }} span.deleted {\n    color: red;\n}\n\n.{{= name }} span.modified_link {\n    font-size: 72%;\n}\n.{{= name }} span.modified_link:hover {\n    cursor: pointer;\n    text-decoration: underline;\n}\n
\\xafaf792781fe012ca176eaef28bea67e00024afefb87ea89f7112cdc1985ded9	var w = $("#"+id);\n\nfunction toggle_show() {\n    if (w.find('.debugger_container').is(':visible')) {\n        w.find('.debugger_container').hide();\n        w.find('input:checkbox').prop('checked', false);\n        ///w.find('.debugger3').data('disable')();\n    }\n    else {\n        w.find('.debugger_container').show();\n        w.find('.debugger_container').html(widget('debugger3'));\n        w.find('input:checkbox').prop('checked', true);\n    }\n}\n\njwerty.key('ctrl+alt+x', toggle_show);\nw.find('input').change(toggle_show)\n\nif ( typeof show != 'undefined' && show == true) {\n    toggle_show();\n}
\\xafaf792781fe012ca176eaef28bea67e00024afefb87ea89f7112cdc1985ded9	var w = $("#"+id);\n\nfunction toggle_show() {\n    if (w.find('.debugger_container').is(':visible')) {\n        w.find('.debugger_container').hide();\n        w.find('input:checkbox').prop('checked', false);\n        ///w.find('.debugger3').data('disable')();\n    }\n    else {\n        w.find('.debugger_container').show();\n        w.find('.debugger_container').html(widget('debugger3'));\n        w.find('input:checkbox').prop('checked', true);\n    }\n}\n\njwerty.key('ctrl+alt+x', toggle_show);\nw.find('input').change(toggle_show)\n\nif ( typeof show != 'undefined' && show == true) {\n    toggle_show();\n}
\\xb275126432f5699d6f82f0b6108cea4add07ed46511c0a314736d5bd8876baec	<div id="{{= id }}" class="{{= name }}">\n    <div class='header'>\n        <button class='select_bundles'>Change bundles</button>\n        <span class='bundle_manager_container'></span>\n        {{= widget('core:auth') }}\n    </div>\n    <div class='content bundle_list'></div>\n    <div class='content bundle_workspace'></div>\n    <div class='status_container'></div>\n    {{= widget('core:debugger') }}\n</div>
\\xb275126432f5699d6f82f0b6108cea4add07ed46511c0a314736d5bd8876baec	<div id="{{= id }}" class="{{= name }}">\n    <div class='header'>\n        <button class='select_bundles'>Change bundles</button>\n        <span class='bundle_manager_container'></span>\n        {{= widget('core:auth') }}\n    </div>\n    <div class='content bundle_list'></div>\n    <div class='content bundle_workspace'></div>\n    <div class='status_container'></div>\n    {{= widget('core:debugger') }}\n</div>
\\xb2a1f3f59177e418b542dcbbfa86e32b4be1458b8393a343a2371b8a19863692	.{{= name }} {\n    cursor: pointer;\n}\n\n.{{= name }} > .open:hover {\n    text-decoration: underline;\n}
\\xb2a1f3f59177e418b542dcbbfa86e32b4be1458b8393a343a2371b8a19863692	.{{= name }} {\n    cursor: pointer;\n}\n\n.{{= name }} > .open:hover {\n    text-decoration: underline;\n}
\\xb3653e538a52c0ea0c0bbc014000092cb769fd92d1095517f01495c1d5c54f46	var w = $("#"+id);\n\n\nvar show_bundles = function() {\n\n    var retrieved = false;\n\n    return function() {\n        \n        w.removeClass('bundle_edit');\n\n        if (!retrieved) {\n            retrieved = true;\n            endpoint.schema('bundle').table('bundle').rows({ order_by: {\n                column: 'name',\n                direction: 'asc'\n            }}).then(function(bundles) {\n                w.find('.bundle_list').append(widget('core:list_view_gateway', {\n                    datum: bundles\n                }));\n            });\n        }\n    };\n}();\n\n\n\n/* URL */\n// When continue button in list_view_gateway is pressed,\n//   get the bundles and place in url\nw.on('list_view_select', function(e, bundles) {\n    var bundle_names = bundles.map(function(e) {\n        return e.get('name');\n    }).sort().join(',');\n    window.location.href = '#/' + encodeURIComponent(bundle_names);\n});\n\nvar current_state = null;\n    \nfunction select_state() {\n    \n    var slugs = window.location.hash.split('/').slice(1);\n    var new_state = null;\n    if (slugs.length) {\n        new_state = decodeURIComponent(slugs[0]);\n    }\n\n    if (new_state == null) {\n        w.data('bundles', null);\n        return show_bundles();\n    }\n    \n    w.addClass('bundle_edit');\n    if (new_state != current_state) {\n        \n        var bundles = new_state.split(',');\n        w.data('bundles', bundles);\n        \n        w.find('> .bundle_workspace').empty().html(\n            widget('dev_workspace', { base_url: '#/' + slugs[0], url_parts: slugs.slice(1) })\n        );\n        w.find('.bundle_manager_container').empty().append(\n            widget('bundle', { bundles: bundles })\n        );\n        current_state = new_state;\n    }\n\n    $('html, body').animate({\n        scrollTop: 0\n    }, 'fast');\n    \n    // Do nothing if states are the same\n    // Let the widget handle back/forward within itself\n    \n}\n$(window).on('popstate', select_state);\nselect_state();\n\n\nw.find('.select_bundles').on('click', show_bundles);\n\n\n\n/* STATUS */\nw.on('status', add_status);\n\nfunction add_status(e, message, type) {\n    e.stopPropagation();\n    w.find('.status_container').append(widget('status', { message: message, type, type }));\n}\n\n
\\xb3653e538a52c0ea0c0bbc014000092cb769fd92d1095517f01495c1d5c54f46	var w = $("#"+id);\n\n\nvar show_bundles = function() {\n\n    var retrieved = false;\n\n    return function() {\n        \n        w.removeClass('bundle_edit');\n\n        if (!retrieved) {\n            retrieved = true;\n            endpoint.schema('bundle').table('bundle').rows({ order_by: {\n                column: 'name',\n                direction: 'asc'\n            }}).then(function(bundles) {\n                w.find('.bundle_list').append(widget('core:list_view_gateway', {\n                    datum: bundles\n                }));\n            });\n        }\n    };\n}();\n\n\n\n/* URL */\n// When continue button in list_view_gateway is pressed,\n//   get the bundles and place in url\nw.on('list_view_select', function(e, bundles) {\n    var bundle_names = bundles.map(function(e) {\n        return e.get('name');\n    }).sort().join(',');\n    window.location.href = '#/' + encodeURIComponent(bundle_names);\n});\n\nvar current_state = null;\n    \nfunction select_state() {\n    \n    var slugs = window.location.hash.split('/').slice(1);\n    var new_state = null;\n    if (slugs.length) {\n        new_state = decodeURIComponent(slugs[0]);\n    }\n\n    if (new_state == null) {\n        w.data('bundles', null);\n        return show_bundles();\n    }\n    \n    w.addClass('bundle_edit');\n    if (new_state != current_state) {\n        \n        var bundles = new_state.split(',');\n        w.data('bundles', bundles);\n        \n        w.find('> .bundle_workspace').empty().html(\n            widget('dev_workspace', { base_url: '#/' + slugs[0], url_parts: slugs.slice(1) })\n        );\n        w.find('.bundle_manager_container').empty().append(\n            widget('bundle', { bundles: bundles })\n        );\n        current_state = new_state;\n    }\n\n    $('html, body').animate({\n        scrollTop: 0\n    }, 'fast');\n    \n    // Do nothing if states are the same\n    // Let the widget handle back/forward within itself\n    \n}\n$(window).on('popstate', select_state);\nselect_state();\n\n\nw.find('.select_bundles').on('click', show_bundles);\n\n\n\n/* STATUS */\nw.on('status', add_status);\n\nfunction add_status(e, message, type) {\n    e.stopPropagation();\n    w.find('.status_container').append(widget('status', { message: message, type, type }));\n}\n\n
\\xb3ca587645d5e53ea3a30ba74e31c06e333c339b5fbb1f197f6cc3a8886ad43e	var w = $("#"+id);\n\nw.change(function() {\n    if(!!to_js) {\n        field.value = to_js($(this).val());\n    }\n    else {\n        field.value = $(this).val();\n    }\n    \n    w.trigger("saved");\n});\n\nwidget.sync(\n    rows,\n    w,\n    function(row) {\n        return widget('editable_field_fkey_select_option', {\n            row: row,\n            key_maker: key_maker,\n            current_value: field.value,\n            labeler: labeler\n        });\n    }\n);
\\xb3ca587645d5e53ea3a30ba74e31c06e333c339b5fbb1f197f6cc3a8886ad43e	var w = $("#"+id);\n\nw.change(function() {\n    if(!!to_js) {\n        field.value = to_js($(this).val());\n    }\n    else {\n        field.value = $(this).val();\n    }\n    \n    w.trigger("saved");\n});\n\nwidget.sync(\n    rows,\n    w,\n    function(row) {\n        return widget('editable_field_fkey_select_option', {\n            row: row,\n            key_maker: key_maker,\n            current_value: field.value,\n            labeler: labeler\n        });\n    }\n);
\\xb3f09ec5fe711f120fc65581e54039199d4e21c833290f0c3820bcc011526309	.{{= name }} .head_commit {\n    display: none;\n    color: yellow;\n    font-size: 200%;\n}\n\n.{{= name }} td.date {\n    white-space:nowrap;  \n}
\\xb3f09ec5fe711f120fc65581e54039199d4e21c833290f0c3820bcc011526309	.{{= name }} .head_commit {\n    display: none;\n    color: yellow;\n    font-size: 200%;\n}\n\n.{{= name }} td.date {\n    white-space:nowrap;  \n}
\\xb41e5e4919fea7a435803a999ba668ba87fbf46d2a35ab7b12fd93b4e27ab6ab	<span id="{{= id }}" class="{{= name }} highlighted">\n    <nobr>\n        <span class="label">{{= label }}</span>\n    \t<span class="close">&#10006;</span\n    ></nobr\n></span>
\\xb41e5e4919fea7a435803a999ba668ba87fbf46d2a35ab7b12fd93b4e27ab6ab	<span id="{{= id }}" class="{{= name }} highlighted">\n    <nobr>\n        <span class="label">{{= label }}</span>\n    \t<span class="close">&#10006;</span\n    ></nobr\n></span>
\\xb5005d87f01b369a80f9895804002ec54e6a1bdf5a55e0d15d682c5ff608dc98	bundle_selector
\\xb5005d87f01b369a80f9895804002ec54e6a1bdf5a55e0d15d682c5ff608dc98	bundle_selector
\\xb5d285806f38080086517955b7fd1b5e0ff1abf8648fb77cf7b07d33360091a3	461cd150-e88f-4215-8a32-03476084baf4
\\xb5d285806f38080086517955b7fd1b5e0ff1abf8648fb77cf7b07d33360091a3	461cd150-e88f-4215-8a32-03476084baf4
\\xb63f7d08db443cbe9aed0cad224b1ec9a3ade107cae630dbc064fc90ef71aad7	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.unstage').click(function() {\n    endpoint.schema('bundle').function('unstage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function() {\n        w.trigger('reload_commit_dialog');\n    })\n    .catch(function() {\n        alert('unstage failed');\n        console.error('unstage failed');\n    });\n    \n});
\\xb63f7d08db443cbe9aed0cad224b1ec9a3ade107cae630dbc064fc90ef71aad7	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.unstage').click(function() {\n    endpoint.schema('bundle').function('unstage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function() {\n        w.trigger('reload_commit_dialog');\n    })\n    .catch(function() {\n        alert('unstage failed');\n        console.error('unstage failed');\n    });\n    \n});
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb759721d70233a8787e55df98fbc38778b70d9610931c406fd18fb5bfb161d0d	666d5961-1263-4290-b672-e7d58d8b078e
\\xb776afbe511a51d0685821119dcbeba4fdba81e61e9187993a4a37ba821e0a6e	commit_history_dialog
\\xb776afbe511a51d0685821119dcbeba4fdba81e61e9187993a4a37ba821e0a6e	commit_history_dialog
\\xb816e141776579d435ae6eb97a2f4bfc19e4b85c4fb152f8d194a8d56c1fdbf7	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\nfunction load_options() {\n    var content = "<option value='none' selected>[ None ]</option>";\n    \n    if (typeof new_enabled != 'undefined' && new_enabled == true) {\n        content += "<option class='new' value='new'>[ Create New ]</option>";\n    }\n    \n    w.find('select').empty().html(content);\n    \n    var to_rows = order_by_function(to_relation.rows());\n    widget.sync(to_rows, w.find('select'), function(to_row) {\n        return widget('option', {\n            label: label_function(to_row),\n            value: to_row.get(to_column),\n            selected: from_row.get(from_column) == to_row.get(to_column)\n        });\n    });\n}\nload_options();\n\n\n// find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    schema_name: to_relation.schema.name,\n    name: to_relation.name\n}).result(function(to_relation_obj) {\n\n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n\n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n\n\n    w.find('select').change(function() {\n\n        var val = w.find('select').val();\n\n        if(val == 'new') {\n            \n            w.append(\n                widget('modal_overlay', {\n                    content: widget(new_row_widget, { \n                        relation: to_relation_obj,\n                        context_data: context_data\n                    })\n                })\n            );\n            \n        }\n        else if (val == 'none') {\n\n            \n            from_row.set(from_column, null);\n\n            from_row.update()\n            .done(function() {\n\n                console.log('Fkey updated');\n                w.trigger('fkey_updated');\n\n            });\n            \n        }\n        else {\n            \n            from_row.set(from_column, val);\n\n            from_row.update()\n            .done(function() {\n\n                console.log('Fkey updated');\n                w.trigger('fkey_updated');\n\n            });\n        }\n    });\n\n});\n\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n});\n\nw.on('new_row', function(e, payload) {\n    \n    from_row.set(from_column, payload.new_row.get(to_column));\n    from_row.update()\n    .done(function() {\n        \n        console.log('Fkey updated');\n        w.trigger('fkey_updated');\n        load_options();\n        \n    });\n});
\\xb816e141776579d435ae6eb97a2f4bfc19e4b85c4fb152f8d194a8d56c1fdbf7	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\nif (typeof context_data == 'undefined') {\n    context_data = {};\n}\n\nif (typeof order_by_function == 'undefined') {\n    order_by_function = function(rows) {\n        return rows;\n    };\n}\n\nif (typeof label_function == 'undefined' || label_function == false) {\n    label_function = function(to_row) {\n        return to_row.get('name');\n    };\n}\n\nfunction load_options() {\n    var content = "<option value='none' selected>[ None ]</option>";\n    \n    if (typeof new_enabled != 'undefined' && new_enabled == true) {\n        content += "<option class='new' value='new'>[ Create New ]</option>";\n    }\n    \n    w.find('select').empty().html(content);\n    \n    var to_rows = order_by_function(to_relation.rows());\n    widget.sync(to_rows, w.find('select'), function(to_row) {\n        return widget('option', {\n            label: label_function(to_row),\n            value: to_row.get(to_column),\n            selected: from_row.get(from_column) == to_row.get(to_column)\n        });\n    });\n}\nload_options();\n\n\n// find semantic override for sem_list_item_new\nendpoint.schema('meta').view('relation').row().where({\n    schema_name: to_relation.schema.name,\n    name: to_relation.name\n}).result(function(to_relation_obj) {\n\n    var new_row_widget = $(document).find('.semantics_manager').data('get_relation_field')(to_relation_obj.get('id'), 'new_row_widget_id');\n\n    if (new_row_widget == null) {\n        new_row_widget = 'sem_list_item_new';\n    }\n\n\n    w.find('select').change(function() {\n\n        var val = w.find('select').val();\n\n        if(val == 'new') {\n            \n            w.append(\n                widget('modal_overlay', {\n                    content: widget(new_row_widget, { \n                        relation: to_relation_obj,\n                        context_data: context_data\n                    })\n                })\n            );\n            \n        }\n        else if (val == 'none') {\n\n            \n            from_row.set(from_column, null);\n\n            from_row.update()\n            .done(function() {\n\n                console.log('Fkey updated');\n                w.trigger('fkey_updated');\n\n            });\n            \n        }\n        else {\n            \n            from_row.set(from_column, val);\n\n            from_row.update()\n            .done(function() {\n\n                console.log('Fkey updated');\n                w.trigger('fkey_updated');\n\n            });\n        }\n    });\n\n});\n\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n});\n\nw.on('new_row', function(e, payload) {\n    \n    from_row.set(from_column, payload.new_row.get(to_column));\n    from_row.update()\n    .done(function() {\n        \n        console.log('Fkey updated');\n        w.trigger('fkey_updated');\n        load_options();\n        \n    });\n});
\\xba40494e8bfd3e48b307867797b6fd1327d23faf8c219483146856e4f970e855	<div id="{{= id }}" class="{{= name }}">\n    <nav>\n        {{ Object.keys(tabs).forEach(function(tab_name) { }}<a data-tab="{{= tab_name }}">{{= tab_name }}</a>{{ }); }}\n    </nav>\n    \n    <div class="content">\n    </div>\n</div>
\\xba40494e8bfd3e48b307867797b6fd1327d23faf8c219483146856e4f970e855	<div id="{{= id }}" class="{{= name }}">\n    <nav>\n        {{ Object.keys(tabs).forEach(function(tab_name) { }}<a data-tab="{{= tab_name }}">{{= tab_name }}</a>{{ }); }}\n    </nav>\n    \n    <div class="content">\n    </div>\n</div>
\\xba66371919b9ccf49b39a4f393bf006664ee6d7c00d1c4dcabbe52624b230724	62282f67-1366-4313-9585-ea52d8b8fea8
\\xba66371919b9ccf49b39a4f393bf006664ee6d7c00d1c4dcabbe52624b230724	62282f67-1366-4313-9585-ea52d8b8fea8
\\xbb0e72c61b393df8915d128c09ab8d8a89ed92497499eb20bb8d80a6180c2746	<div id="{{= id }}" class="{{= name }}">\n    <h2>Commit History</h2>\n    \n    <table class="commits" border=1>\n        <tr>\n            <th></th>\n            <th>author</th>\n            <th>commit time</th>\n            <th>message</th>\n            <th></th>\n        </tr>\n    </table>\n</div>
\\xbb0e72c61b393df8915d128c09ab8d8a89ed92497499eb20bb8d80a6180c2746	<div id="{{= id }}" class="{{= name }}">\n    <h2>Commit History</h2>\n    \n    <table class="commits" border=1>\n        <tr>\n            <th></th>\n            <th>author</th>\n            <th>commit time</th>\n            <th>message</th>\n            <th></th>\n        </tr>\n    </table>\n</div>
\\xbc807eae5388d6e243d8e4a9623373052515bbd85e44515a63865d61bd9e19c3	<div id="{{= id }}" class="{{= name }}">\n    <span class='field_name'></span><button class='stage'>stage</button>\n</div>
\\xbc807eae5388d6e243d8e4a9623373052515bbd85e44515a63865d61bd9e19c3	<div id="{{= id }}" class="{{= name }}">\n    <span class='field_name'></span><button class='stage'>stage</button>\n</div>
\\xbc817d81409eb52fc7103d853f61f5f8631899afc9d8d21ab820387dc43706d0	var w = $("#"+id);\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'schema': 9881,\n    'data': 9883,\n    'semantics': 7784\n};\n\n\nvar widget_fn = {\n    'schema': function() {\n        \n        // TODO: endpoint.suffix_clause should support complex types in where clause\n        \n        return widget('semantics/grid_view', endpoint.schema('meta').table('column').rows({\n            where: [{\n                name: 'relation_name',\n                op: '=',\n                value: datum.get('name')\n            }, {\n                name: 'schema_name',\n                op: '=',\n                value: datum.get('schema_name')\n            }],\n            order_by: {\n                column: 'name'\n            },\n            exclude: ['id', 'relation_id', 'schema_name', 'relation_name']\n        }), {\n            context: {\n                relation_id: datum.get('id')\n            }\n        });\n    },\n    'data': function() {\n        return widget('semantics/grid_view', endpoint.schema(datum.get('schema_name')).table(datum.get('name')).rows({\n//            limit: 10\n        }));\n    },\n    'semantics': function() {\n\n        return widget('semantics/grid_view', endpoint.schema('semantics').table('relation').rows({\n            where: {\n                name: 'relation_id',\n                op: '=',\n                value: datum.get('id')\n            }\n        }), {\n            context: {\n                relation_id: datum.get('id')\n            }\n        });\n    }\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\nw.find('.section').on('click', function() {\n    w.find('.section').removeClass('selected');\n    $(this).addClass('selected');\n    w.find('.content').empty().append(\n        widget_fn[$(this).attr('data-section')]()\n    );\n});\n\nw.find('.content').append(\n    widget_fn[w.find('.section.selected').attr('data-section')]()\n);\n
\\xbc817d81409eb52fc7103d853f61f5f8631899afc9d8d21ab820387dc43706d0	var w = $("#"+id);\n\n/* ICONS */\n// FIXME: gear icons hack, cause unicode breaks save\nvar icons = {\n    'schema': 9881,\n    'data': 9883,\n    'semantics': 7784\n};\n\n\nvar widget_fn = {\n    'schema': function() {\n        \n        // TODO: endpoint.suffix_clause should support complex types in where clause\n        \n        return widget('semantics/grid_view', endpoint.schema('meta').table('column').rows({\n            where: [{\n                name: 'relation_name',\n                op: '=',\n                value: datum.get('name')\n            }, {\n                name: 'schema_name',\n                op: '=',\n                value: datum.get('schema_name')\n            }],\n            order_by: {\n                column: 'name'\n            },\n            exclude: ['id', 'relation_id', 'schema_name', 'relation_name']\n        }), {\n            context: {\n                relation_id: datum.get('id')\n            }\n        });\n    },\n    'data': function() {\n        return widget('semantics/grid_view', endpoint.schema(datum.get('schema_name')).table(datum.get('name')).rows({\n//            limit: 10\n        }));\n    },\n    'semantics': function() {\n\n        return widget('semantics/grid_view', endpoint.schema('semantics').table('relation').rows({\n            where: {\n                name: 'relation_id',\n                op: '=',\n                value: datum.get('id')\n            }\n        }), {\n            context: {\n                relation_id: datum.get('id')\n            }\n        });\n    }\n};\n\nfor (var i in icons) {\n    w.find('.'+i).append('<div class="icon">&#' + icons[i] + ';</div>');\n}\n\nw.find('.section').on('click', function() {\n    w.find('.section').removeClass('selected');\n    $(this).addClass('selected');\n    w.find('.content').empty().append(\n        widget_fn[$(this).attr('data-section')]()\n    );\n});\n\nw.find('.content').append(\n    widget_fn[w.find('.section.selected').attr('data-section')]()\n);\n
\\xbd6e0c26f04cc07572679f9e710aee5483abe433d527a4d52eb4a0cf96e02c2f	<div id="{{= id }}" class="{{= name }}">\n    <div class="toggle">\n        <label><input type="checkbox" />debugger</label>\n    </div>\n    \n    <div class="debugger_container"></div>\n</div>
\\xbd6e0c26f04cc07572679f9e710aee5483abe433d527a4d52eb4a0cf96e02c2f	<div id="{{= id }}" class="{{= name }}">\n    <div class="toggle">\n        <label><input type="checkbox" />debugger</label>\n    </div>\n    \n    <div class="debugger_container"></div>\n</div>
\\xbde547ddef2c736ae127e5a4790d550762c58aa78e0b12e527aeb298d8cf3319	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('semantics_manager') }}\n    <!--<p>Testing beehive.practice row from semantics.relation</p>-->\n    <p>Testing sem_fkey_one_to_many with<br>mickey.post row 'words mickey says' referenced by fkeys in mickey.blah</p>\n</div>
\\xbde547ddef2c736ae127e5a4790d550762c58aa78e0b12e527aeb298d8cf3319	<div id="{{= id }}" class="{{= name }}">\n    {{= widget('semantics_manager') }}\n    <!--<p>Testing beehive.practice row from semantics.relation</p>-->\n    <p>Testing sem_fkey_one_to_many with<br>mickey.post row 'words mickey says' referenced by fkeys in mickey.blah</p>\n</div>
\\xbdf49c3c3882102fc017ffb661108c63a836d065888a4093994398cc55c2ea2f	auth
\\xbdf49c3c3882102fc017ffb661108c63a836d065888a4093994398cc55c2ea2f	auth
\\xbe06aaa88f4d184b99ca5a36048993ab846c4bc29754124680fc639dbb5abc12	05642077-3e03-40e9-b1e0-c679b283f6a4
\\xbe06aaa88f4d184b99ca5a36048993ab846c4bc29754124680fc639dbb5abc12	05642077-3e03-40e9-b1e0-c679b283f6a4
\\xc0996be32d4eee2e31be61e6c587f9f87c07f69bff4fd64bce7e7b276c9b7ea1	17ad7fc1-e56f-4fd0-9c0a-342174a44e79
\\xc0996be32d4eee2e31be61e6c587f9f87c07f69bff4fd64bce7e7b276c9b7ea1	17ad7fc1-e56f-4fd0-9c0a-342174a44e79
\\xc139ed3026ed995bade4532ff22047650962ca141d31bc59525137c458f78a3d	form_field_css
\\xc139ed3026ed995bade4532ff22047650962ca141d31bc59525137c458f78a3d	form_field_css
\\xc3b51901ccb5ba013c9923c4ed7aa7d12fa3c88ba56f8c1454bac18b7227b33d	b2ec28ca-3747-4afb-9096-be88eb2a67f0
\\xc3b51901ccb5ba013c9923c4ed7aa7d12fa3c88ba56f8c1454bac18b7227b33d	b2ec28ca-3747-4afb-9096-be88eb2a67f0
\\xc44e584e33460b6ceaa02ad99a8faf41bf872c827c992327d376938985df0f7c	<div id="{{= id }}" class="{{= name }}">\n    <h2>Bundle Config</h2>\n    \n    <h3>Rename</h3>\n    \n    <p>Change the name of this bundle.</p>\n    \n    <button class='rename'>Rename</button>\n    \n        \n        \n    \n    <h3 style='color: red'>DESTRUCTION</h3>\n    \n    <p>Delete this bundle and remove it from the database permanently.</p>\n    \n    <button class='delete_bundle_oh_no'>DELETE</button>\n</div>
\\xc44e584e33460b6ceaa02ad99a8faf41bf872c827c992327d376938985df0f7c	<div id="{{= id }}" class="{{= name }}">\n    <h2>Bundle Config</h2>\n    \n    <h3>Rename</h3>\n    \n    <p>Change the name of this bundle.</p>\n    \n    <button class='rename'>Rename</button>\n    \n        \n        \n    \n    <h3 style='color: red'>DESTRUCTION</h3>\n    \n    <p>Delete this bundle and remove it from the database permanently.</p>\n    \n    <button class='delete_bundle_oh_no'>DELETE</button>\n</div>
\\xc5803a6e4daa6af400e8af0ae417ff6d7c55a86d11ba4a0cf6d443c15ce6fac5	modal
\\xc5803a6e4daa6af400e8af0ae417ff6d7c55a86d11ba4a0cf6d443c15ce6fac5	modal
\\xc5a2087477e54fa9d92356dd50105897b9d345f25b2892bcf9a717c59fbe17dd	var w = $("#"+id);\nvar tab_links = w.find('> nav > a');\nvar content = w.find('.content');\n\n\n// tab colors\ntab_links.each(function() {\n    var tab_name = $(this).attr('data-tab');\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n\t    $(this).css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\n\ntab_links.click(function() {\n    tab_links.removeClass('selected');\n    var tab_name = $(this).attr('data-tab');\n    w.data('selected_tab', $(this));\n\n    content.html(tabs[$(this).addClass('selected').attr('data-tab')]());\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n        w.css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\ntab_links.filter(':first').click();\n\n\n\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n    content.html(tabs[w.data('selected_tab').attr('data-tab')]());\n});
\\xc5a2087477e54fa9d92356dd50105897b9d345f25b2892bcf9a717c59fbe17dd	var w = $("#"+id);\nvar tab_links = w.find('> nav > a');\nvar content = w.find('.content');\n\n\n// tab colors\ntab_links.each(function() {\n    var tab_name = $(this).attr('data-tab');\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n\t    $(this).css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\n\ntab_links.click(function() {\n    tab_links.removeClass('selected');\n    var tab_name = $(this).attr('data-tab');\n    w.data('selected_tab', $(this));\n\n    content.html(tabs[$(this).addClass('selected').attr('data-tab')]());\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n        w.css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\ntab_links.filter(':first').click();\n\n\n\nw.on('reload_tab', function(e) {\n    e.stopPropagation();\n    content.html(tabs[w.data('selected_tab').attr('data-tab')]());\n});
\\xc5ebc82e3ed1571e199e15d2dcaabd0f9e8122b07b7469a74877bc79a2c0ccd9	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});\n\nw.find('.edit').on('click', function(e) {\n    e.stopPropagation();\n    w.append(widget('core:modal', {\n        content: widget('semantics/row_detail', row)\n    }));\n});\n\nw.on('form_field_save', function() {\n    e.stopPropagation();\n    w.replaceWith('semantics/list_item', row)\n});\n
\\xc5ebc82e3ed1571e199e15d2dcaabd0f9e8122b07b7469a74877bc79a2c0ccd9	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});\n\nw.find('.edit').on('click', function(e) {\n    e.stopPropagation();\n    w.append(widget('core:modal', {\n        content: widget('semantics/row_detail', row)\n    }));\n});\n\nw.on('form_field_save', function() {\n    e.stopPropagation();\n    w.replaceWith('semantics/list_item', row)\n});\n
\\xc603706564ce13158c3b92ac4eac39fe8b5480c9f4e88c987c80544e1ee8124d	list_item_with_version
\\xc603706564ce13158c3b92ac4eac39fe8b5480c9f4e88c987c80544e1ee8124d	list_item_with_version
\\xc6929c0578e6e8a568f7f465eb7306c115271572933748121879ffea61b09451	bundle_selection
\\xc6929c0578e6e8a568f7f465eb7306c115271572933748121879ffea61b09451	bundle_selection
\\xc711896c6f77c7be0f5de215e9d0c61dcd55c1b0654dfc458821a4ef9d31e0a3	modal_overlay
\\xc711896c6f77c7be0f5de215e9d0c61dcd55c1b0654dfc458821a4ef9d31e0a3	modal_overlay
\\xc7dae8d072bd424528ce065b14bc772c478b4b97e8df4871605e6aaf94dbed9c	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar where_obj = {};\nwhere_obj[to_column] = from_row.get(from_column);\n\nto_relation.row().where(where_obj).result(function(row) {\n    \n    /*\n    console.log(row);\n    \n    if (row != 'undefined') {\n    }\n    */\n    \n    w.find('.open').html(label_function(row));\n    \n});\n\nw.on('fkey_updated', function(e, payload) {\n    \n    w.find('.open').html(label_function(payload));\n    \n});\n\nw.on('fkey_deleted', function(e, payload) {\n    \n    w.find('.open').html('Click to select');\n    \n});\n\nw.find('.open').click(function() {\n    w.append(widget('modal_dialog', {\n        content: widget('sem_fkey_autocomplete_form', {\n            from_row: from_row,\n            from_column: from_column,\n            to_relation: to_relation,\n            to_column: to_column,\n            label_function: label_function,\n            order_by_function: order_by_function,\n            new_enabled: new_enabled\n        })\n    }));\n});\n
\\xc7dae8d072bd424528ce065b14bc772c478b4b97e8df4871605e6aaf94dbed9c	/*\n * ARGUMENTS\n * -----------\n * context_data: {Object} for compatibility with sem_list_item_new\n * from_row: {Row} row to join\n * from_column: {String} fkey column of from_row\n * to_relation: {Table} relation to join to\n * to_column: {String} column of to_relation fkey references\n * order_by_function: {Function}\n *\t- takes a rowset and returns the rowset after performing order_by clause\n * label_function: {Function}\n *\t- takes a ‘to_row’ and returns the human-readable label\n * new_enabled: {Boolean} whether to include 'new row' functionality\n */\n\nvar w = $("#"+id);\n\n\nvar where_obj = {};\nwhere_obj[to_column] = from_row.get(from_column);\n\nto_relation.row().where(where_obj).result(function(row) {\n    \n    /*\n    console.log(row);\n    \n    if (row != 'undefined') {\n    }\n    */\n    \n    w.find('.open').html(label_function(row));\n    \n});\n\nw.on('fkey_updated', function(e, payload) {\n    \n    w.find('.open').html(label_function(payload));\n    \n});\n\nw.on('fkey_deleted', function(e, payload) {\n    \n    w.find('.open').html('Click to select');\n    \n});\n\nw.find('.open').click(function() {\n    w.append(widget('modal_dialog', {\n        content: widget('sem_fkey_autocomplete_form', {\n            from_row: from_row,\n            from_column: from_column,\n            to_relation: to_relation,\n            to_column: to_column,\n            label_function: label_function,\n            order_by_function: order_by_function,\n            new_enabled: new_enabled\n        })\n    }));\n});\n
\\xc902016231ffc38e85e9085f221a902d8e1163721fa19509097dcd14727b8538	<div id="{{= id }}" class="{{= name }}">\n    <p class='title'>\n        <span class='path'></span>\n        <a class='path_link' target='_blank'><button>Go to <span class='path_button'>page</span></button></a>\n    </p>\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <div class='section_content'></div>\n    </div>\n</div>
\\xc902016231ffc38e85e9085f221a902d8e1163721fa19509097dcd14727b8538	<div id="{{= id }}" class="{{= name }}">\n    <p class='title'>\n        <span class='path'></span>\n        <a class='path_link' target='_blank'><button>Go to <span class='path_button'>page</span></button></a>\n    </p>\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <div class='section_content'></div>\n    </div>\n</div>
\\xc9722ced797b7c66b514260e0899893cf7474127b9b0182753efb27b0eadb8db	<div id="{{= id }}" class="{{= name }}">\n    <label><span class='label'></span>&nbsp;<select><option value='null'>null</option></select></label>&nbsp;\n    <div class='error'><small>Invalid input</small></div>\n</div>
\\xc9722ced797b7c66b514260e0899893cf7474127b9b0182753efb27b0eadb8db	<div id="{{= id }}" class="{{= name }}">\n    <label><span class='label'></span>&nbsp;<select><option value='null'>null</option></select></label>&nbsp;\n    <div class='error'><small>Invalid input</small></div>\n</div>
\\xc9722ced797b7c66b514260e0899893cf7474127b9b0182753efb27b0eadb8db	<div id="{{= id }}" class="{{= name }}">\n    <label><span class='label'></span>&nbsp;<select><option value='null'>null</option></select></label>&nbsp;\n    <div class='error'><small>Invalid input</small></div>\n</div>
\\xc9722ced797b7c66b514260e0899893cf7474127b9b0182753efb27b0eadb8db	<div id="{{= id }}" class="{{= name }}">\n    <label><span class='label'></span>&nbsp;<select><option value='null'>null</option></select></label>&nbsp;\n    <div class='error'><small>Invalid input</small></div>\n</div>
\\xc9f98bc2e1797a91a42344c0c9ad83127275529aa6bc72cac28df3dbaee48b41	ee286dbd-aebe-46a7-b4c6-57c14e75eff8
\\xc9f98bc2e1797a91a42344c0c9ad83127275529aa6bc72cac28df3dbaee48b41	ee286dbd-aebe-46a7-b4c6-57c14e75eff8
\\xca781da0ea3a5b291bbb04c54c7ce19baa41853a69609fa505259f23f40859b9	6622e339-25e4-458e-a147-54b67a50fc8a
\\xca781da0ea3a5b291bbb04c54c7ce19baa41853a69609fa505259f23f40859b9	6622e339-25e4-458e-a147-54b67a50fc8a
\\xcb72123e1b694cc32bc87dd6acfce5da583d207407a646a7501f41876b767eb2	fba92725-3bb8-4f3c-bec0-9367df38060c
\\xcb72123e1b694cc32bc87dd6acfce5da583d207407a646a7501f41876b767eb2	fba92725-3bb8-4f3c-bec0-9367df38060c
\\xcb9875eb69ed036dc4175828fca4e12ee363fcd444136fede6a4c42ef23c0c38	0c47b0ff-a846-450b-bee9-6cfe3777ae11
\\xcb9875eb69ed036dc4175828fca4e12ee363fcd444136fede6a4c42ef23c0c38	0c47b0ff-a846-450b-bee9-6cfe3777ae11
\\xce307f848f5e4c4d01b38db2c67a78675e18f58fe97656cc8ef49e31e3044c5f	new_field_fkey_name
\\xce307f848f5e4c4d01b38db2c67a78675e18f58fe97656cc8ef49e31e3044c5f	new_field_fkey_name
\\xd014c65e4175bf62bc7cd1c7a9324868cd854985418f29b37a85d7b0d6b7a27c	84335014-52fd-45d8-9a38-3d789aeb1939
\\xd014c65e4175bf62bc7cd1c7a9324868cd854985418f29b37a85d7b0d6b7a27c	84335014-52fd-45d8-9a38-3d789aeb1939
\\xd13751ec05d815b753d0d16a64d58d5d63c7ae0d176a2f14246b20f0a852c992	.{{= name }} {\n\theight: 100%;\n    width: 100%;\n}\n\n.{{= name }} > nav {\n    height: 1.5rem;\n    border-bottom: 0.15rem solid #333;\n}\n\n.{{= name }} > nav a {\n    color: #666;\n    cursor: pointer;\n    padding: 0 .5em 1px 0.5em;\n    display: inline-block;\n    transition: background 200ms ease-in;\n    text-decoration: none;\n}\n\n.{{= name }} > nav a.selected {\n    background: #333;\n    color: white;\n}\n\n.{{= name }} > .content {\n    height: calc(100% - 1.5rem);\n}\n
\\xd13751ec05d815b753d0d16a64d58d5d63c7ae0d176a2f14246b20f0a852c992	.{{= name }} {\n\theight: 100%;\n    width: 100%;\n}\n\n.{{= name }} > nav {\n    height: 1.5rem;\n    border-bottom: 0.15rem solid #333;\n}\n\n.{{= name }} > nav a {\n    color: #666;\n    cursor: pointer;\n    padding: 0 .5em 1px 0.5em;\n    display: inline-block;\n    transition: background 200ms ease-in;\n    text-decoration: none;\n}\n\n.{{= name }} > nav a.selected {\n    background: #333;\n    color: white;\n}\n\n.{{= name }} > .content {\n    height: calc(100% - 1.5rem);\n}\n
\\xd24a92b0175dc151c30ac79f189e479e354cbf30dfa06a365acd1db59d0c70ac	/ide
\\xd3d44900a2e96f3867e65591795f396ad995b1383984b833a255bc23154b2011	var w = $("#"+id);\n\nif (typeof row_id != 'undefined') {\n    $.when(endpoint.schema(row_id.pk_column_id.relation_id.schema_id.name).table(row_id.pk_column_id.relation_id.name).row().where({\n        id: row_id.pk_value\n    })).then(function(mimetype) {\n\t\tdoit(mimetype);\n    });\n} else {\n\tif (typeof row != 'undefined') {\n    \tdoit(row);\n    } else {\n        console.log("No row or row_id passed into semantics_mimetype_listitem_identifier.");\n    }\n}\n\nfunction doit(row) {\n    w.html('widget.widget: '+row.get('name'));\n}\n
\\xd3d44900a2e96f3867e65591795f396ad995b1383984b833a255bc23154b2011	var w = $("#"+id);\n\nif (typeof row_id != 'undefined') {\n    $.when(endpoint.schema(row_id.pk_column_id.relation_id.schema_id.name).table(row_id.pk_column_id.relation_id.name).row().where({\n        id: row_id.pk_value\n    })).then(function(mimetype) {\n\t\tdoit(mimetype);\n    });\n} else {\n\tif (typeof row != 'undefined') {\n    \tdoit(row);\n    } else {\n        console.log("No row or row_id passed into semantics_mimetype_listitem_identifier.");\n    }\n}\n\nfunction doit(row) {\n    w.html('widget.widget: '+row.get('name'));\n}\n
\\xd3e25706465fac81dea80e5a2f951c9a3043dad58a65e794773558944c0785fc	\n\n/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n
\\xd3e25706465fac81dea80e5a2f951c9a3043dad58a65e794773558944c0785fc	\n\n/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n
\\xd4ac13daf116c28eba8520f900072d93e0f8ebe68a3e98645dcf3ba7b10c42be	7d5ba057-2b25-4083-80e7-c37200e20786
\\xd4ac13daf116c28eba8520f900072d93e0f8ebe68a3e98645dcf3ba7b10c42be	7d5ba057-2b25-4083-80e7-c37200e20786
\\xd4c008656d1f2b36141f13b9bcef5ad66396d893eaf558cb500ee79d47e97bfa	4e8942d3-1efa-45ec-8ed3-86b2c8a115c5
\\xd4c008656d1f2b36141f13b9bcef5ad66396d893eaf558cb500ee79d47e97bfa	4e8942d3-1efa-45ec-8ed3-86b2c8a115c5
\\xd50a37066b1348aaf9623ab7341876f42016d2cbaa6c17c29531935080cbbf65	widget-util
\\xd50a37066b1348aaf9623ab7341876f42016d2cbaa6c17c29531935080cbbf65	widget-util
\\xd5279ef2adc4c52b4f481a14ee5e97b72a852ba58113555870ad0e4036f8016b	46741261-c826-4f49-8c41-d51fec861ea0
\\xd5279ef2adc4c52b4f481a14ee5e97b72a852ba58113555870ad0e4036f8016b	46741261-c826-4f49-8c41-d51fec861ea0
\\xd54c446836750c61535b5d8298a6d50a8349b1751f8d0f6eee2e3769d8770289	list_item_expandable
\\xd54c446836750c61535b5d8298a6d50a8349b1751f8d0f6eee2e3769d8770289	list_item_expandable
\\xd5bd045f6bcb0e986364ab6e34ca8270af4373658a6cce7b077798830b839421	form_field_html
\\xd5bd045f6bcb0e986364ab6e34ca8270af4373658a6cce7b077798830b839421	form_field_html
\\xd60a0fa6ea2fe111ea61f217791f888ce3ae4790d47e51cacdc5bb5c14df8bfe	var w = $("#"+id);\n\nvar bundles = endpoint.schema('bundle').table('bundle').rows({\n    order_by: {\n        column: 'name'\n    }\n})\nwidget.sync(bundles, w.find('.bundles'), function(bundle) {\n    return widget('bundle_selection', { bundle: bundle });\n});\n\nw.find('.bundles .select').on('click', function() {\n    w.trigger('bundle_selected', { bundle_name: w.find(':checked').val() });\n});\n\n\nw.find('.bundles .new').on('click', function() {\n    var name;\n    if (name = prompt('enter bundle name')) {\n        endpoint.schema('bundle').table('bundle').insert({\n            name: name\n        }).then(function() {\n            w.replaceWith(widget('ide:bundle_selector'));\n        }).catch(function(e,o) {\n            console.log('error creating bundle: ', e, o);\n        });\n    }\n});\n\n\n\n\nw.find('.tabs .untracked').click(function() {\n    var untracked = endpoint.schema('bundle').table('untracked_row').rows();\n    w.find('.bundles').html(widget('ide:bundle_untracked', { untracked: untracked }));\n\n    \n});
\\xd60a0fa6ea2fe111ea61f217791f888ce3ae4790d47e51cacdc5bb5c14df8bfe	var w = $("#"+id);\n\nvar bundles = endpoint.schema('bundle').table('bundle').rows({\n    order_by: {\n        column: 'name'\n    }\n})\nwidget.sync(bundles, w.find('.bundles'), function(bundle) {\n    return widget('bundle_selection', { bundle: bundle });\n});\n\nw.find('.bundles .select').on('click', function() {\n    w.trigger('bundle_selected', { bundle_name: w.find(':checked').val() });\n});\n\n\nw.find('.bundles .new').on('click', function() {\n    var name;\n    if (name = prompt('enter bundle name')) {\n        endpoint.schema('bundle').table('bundle').insert({\n            name: name\n        }).then(function() {\n            w.replaceWith(widget('ide:bundle_selector'));\n        }).catch(function(e,o) {\n            console.log('error creating bundle: ', e, o);\n        });\n    }\n});\n\n\n\n\nw.find('.tabs .untracked').click(function() {\n    var untracked = endpoint.schema('bundle').table('untracked_row').rows();\n    w.find('.bundles').html(widget('ide:bundle_untracked', { untracked: untracked }));\n\n    \n});
\\xd641771fd9c44c8625dd75ecf07c31aa45ce6e53e902ceeca6ab34190dc8832b	d8e8c142-1fb4-4298-b6a0-ac5d07b1749c
\\xd641771fd9c44c8625dd75ecf07c31aa45ce6e53e902ceeca6ab34190dc8832b	d8e8c142-1fb4-4298-b6a0-ac5d07b1749c
\\xd6daa69ecb323f5d2fa9f73a609add57a715697bdb2375520bc2550bc59d6775	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td>{{= change.get('change_type') }}</td>\n    <td>{{= change.get('row_exists') }}</td>\n    <td>\n        <button class='unstage'>unstage</button>\n    </td>\n</tr>
\\xd6daa69ecb323f5d2fa9f73a609add57a715697bdb2375520bc2550bc59d6775	<tr id="{{= id }}" class="{{= name }}">\n    <td class='text_id'></td>\n    <td>{{= change.get('change_type') }}</td>\n    <td>{{= change.get('row_exists') }}</td>\n    <td>\n        <button class='unstage'>unstage</button>\n    </td>\n</tr>
\\xd76c6dc6aa6cc98e7fa37d45afb748d882fc28ca6b401b032ef1eae5d7b28886	workspace_tab
\\xd76c6dc6aa6cc98e7fa37d45afb748d882fc28ca6b401b032ef1eae5d7b28886	workspace_tab
\\xd7e1977adb399906843850536db6b42659c2f68dffa0c5d52292902226de850c	tabbed_layout
\\xd7e1977adb399906843850536db6b42659c2f68dffa0c5d52292902226de850c	tabbed_layout
\\xd7f5451f74d98130774837f8fcae2e481fb5feb206637deaee38bcbd012999ed	<section id="{{= id }}" class="{{= name }}">\n    <header>\n        <nobr>\n            <a href="/ide">a q u a m e t a</a>\n        </nobr>\n        <h1><span class='title'></span></h1>\n    </header>\n\n    <div class="content">\n        <div class='row_list_section'/>\n        <div class='workspace_section'/>\n    </div>\n    \n    <footer>\n        Aquameta\n    </footer>\n</section>
\\xd888130ed284a864891dba5defdbf0c360cac35787871149c125f4b3a56323e4	.{{= name }} {\n} \n\n.{{= name }}:not(.invalid) .error {\n    display: none;\n}\n\n.{{= name }} .error {\n    color: red;\n}
\\xd888130ed284a864891dba5defdbf0c360cac35787871149c125f4b3a56323e4	.{{= name }} {\n} \n\n.{{= name }}:not(.invalid) .error {\n    display: none;\n}\n\n.{{= name }} .error {\n    color: red;\n}
\\xd888130ed284a864891dba5defdbf0c360cac35787871149c125f4b3a56323e4	.{{= name }} {\n} \n\n.{{= name }}:not(.invalid) .error {\n    display: none;\n}\n\n.{{= name }} .error {\n    color: red;\n}
\\xd888130ed284a864891dba5defdbf0c360cac35787871149c125f4b3a56323e4	.{{= name }} {\n} \n\n.{{= name }}:not(.invalid) .error {\n    display: none;\n}\n\n.{{= name }} .error {\n    color: red;\n}
\\xd8eb8d51a933a05ff9da7fead99f2062f87b99a5e7c5ea8aab4da418953b36d0	bc92c925-2114-4e0e-ae01-f2ecbeda6017
\\xd8eb8d51a933a05ff9da7fead99f2062f87b99a5e7c5ea8aab4da418953b36d0	bc92c925-2114-4e0e-ae01-f2ecbeda6017
\\xda0390ce078a68a4d18b1c4e5a8e96e44972abf397d3c38eb1fd1cbf4a64ef21	commit_history_commit
\\xda0390ce078a68a4d18b1c4e5a8e96e44972abf397d3c38eb1fd1cbf4a64ef21	commit_history_commit
\\xda0402fc3e90113e0b5f74a5fbbbe38b17dca9ff5b31e499c0957a8e6a2b5172	<div id="{{= id }}" class="{{= name }}">\n    <p>{{= widget('semantics/form_field', row.field('name')) }}</p>\n    <div class="top">\n        <div class="sections">\n            <div class="section schema selected" data-section='schema'>schema</div>\n            <div class="section data" data-section='data'>data</div>\n            <div class="section semantics" data-section='semantics'>semantics</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="delete">Delete</button>\n            </div>\n            <div class="content"></div>\n        </div>\n    </div>\n</div>
\\xda0402fc3e90113e0b5f74a5fbbbe38b17dca9ff5b31e499c0957a8e6a2b5172	<div id="{{= id }}" class="{{= name }}">\n    <p>{{= widget('semantics/form_field', row.field('name')) }}</p>\n    <div class="top">\n        <div class="sections">\n            <div class="section schema selected" data-section='schema'>schema</div>\n            <div class="section data" data-section='data'>data</div>\n            <div class="section semantics" data-section='semantics'>semantics</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="delete">Delete</button>\n            </div>\n            <div class="content"></div>\n        </div>\n    </div>\n</div>
\\xda7ea0df9b133400ecd8877ff59d8e5ece3d507ca844c1add7bcdccfda4173f9	var w = $("#"+id);\n\n\nfor (var i=0;i<offstage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:commit_dialog_unstaged_field', {\n        field: offstage_field_changes[i],\n        old_val: offstage_field_changes_old_vals[i],\n        new_val: offstage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}
\\xda7ea0df9b133400ecd8877ff59d8e5ece3d507ca844c1add7bcdccfda4173f9	var w = $("#"+id);\n\n\nfor (var i=0;i<offstage_field_changes.length;i++) {\n    w.find('.fields').append(widget('ide:commit_dialog_unstaged_field', {\n        field: offstage_field_changes[i],\n        old_val: offstage_field_changes_old_vals[i],\n        new_val: offstage_field_changes_new_vals[i],\n        bundle: bundle\n    }));\n}
\\xdad02962e99de15c6e47223dcda4bb6bab96d5d43b2e5c19379678c079981233	226aedab-05e0-4963-965e-914a55625753
\\xdad02962e99de15c6e47223dcda4bb6bab96d5d43b2e5c19379678c079981233	226aedab-05e0-4963-965e-914a55625753
\\xdb142c56a62ca8bd60f8f4e4a06a1d13f4904167adf4ff6dfab4f6b4d527eb8d	row_detail_resource
\\xdb142c56a62ca8bd60f8f4e4a06a1d13f4904167adf4ff6dfab4f6b4d527eb8d	row_detail_resource
\\xdb26df4a9ffca7c416d5c38d87596494c82c846d1b50500f573a1d38dc6665d7	<div id="{{= id }}" class="{{= name }}">\n    <p class='name'></p><span class='widget_id'></span>\n    <div class="top">\n        <div class="sections">\n            <div class="section code selected">code</div>\n            <div class="section data">data</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="save">Save</button>\n                <button class="copy">Copy</button>\n                <button class="delete">Delete</button>\n            </div>\n            <div class="tabs"></div>\n        </div>\n    </div>\n</div>
\\xdb26df4a9ffca7c416d5c38d87596494c82c846d1b50500f573a1d38dc6665d7	<div id="{{= id }}" class="{{= name }}">\n    <p class='name'></p><span class='widget_id'></span>\n    <div class="top">\n        <div class="sections">\n            <div class="section code selected">code</div>\n            <div class="section data">data</div>\n        </div>\n        <div class="section_content">\n            <div class="buttons">\n                <button class="save">Save</button>\n                <button class="copy">Copy</button>\n                <button class="delete">Delete</button>\n            </div>\n            <div class="tabs"></div>\n        </div>\n    </div>\n</div>
\\xdd2741e2734916143a6dbf1d1939cbc04396f10356faf54aba282066cec41b5f	944b5a05-be70-45a1-a549-1301d38799e4
\\xdd2741e2734916143a6dbf1d1939cbc04396f10356faf54aba282066cec41b5f	944b5a05-be70-45a1-a549-1301d38799e4
\\xdd2741e2734916143a6dbf1d1939cbc04396f10356faf54aba282066cec41b5f	944b5a05-be70-45a1-a549-1301d38799e4
\\xdd2741e2734916143a6dbf1d1939cbc04396f10356faf54aba282066cec41b5f	944b5a05-be70-45a1-a549-1301d38799e4
\\xdd2741e2734916143a6dbf1d1939cbc04396f10356faf54aba282066cec41b5f	944b5a05-be70-45a1-a549-1301d38799e4
\\xde10528e6f0be56f24707680d0dc75f512c31b9a30ec8a6b4a3af40aac1326c9	.{{= name }} {\n\theight: 100%;\n    display: flex;\n    flex-flow: column;\n}\n\n.{{= name }} .tab_contents {\n    flex: 1;\n    overflow: hidden;\n}
\\xde10528e6f0be56f24707680d0dc75f512c31b9a30ec8a6b4a3af40aac1326c9	.{{= name }} {\n\theight: 100%;\n    display: flex;\n    flex-flow: column;\n}\n\n.{{= name }} .tab_contents {\n    flex: 1;\n    overflow: hidden;\n}
\\xde339938e5ec0a1585a8801ae1ba6c8c3f515fad8a14feb788fe0e191e362c84	list_item_with_schema
\\xde339938e5ec0a1585a8801ae1ba6c8c3f515fad8a14feb788fe0e191e362c84	list_item_with_schema
\\xdf3b43a64503272cba04e9d9037c4a827b1199fb4df10557e5cf67904df167cb	new_field_fkey_purpose
\\xdf3b43a64503272cba04e9d9037c4a827b1199fb4df10557e5cf67904df167cb	new_field_fkey_purpose
\\xdf63cf21ff81e6dab636f93e7417cb0bf71c0429c21b03bbc7cde5ef363f0105	.{{= name }} {\n    margin: 3px;\n}\n\n.{{= name }} .filters {\n    padding: 5px 0px;\n}\n\n.{{= name }} .filters .tab {\n    border-color: #888;\n    border-style: solid;\n    border-width: 1px 1px 1px 0px;\n    padding: 0px 1em 0px 1em;\n}\n\n.{{= name }} .filters .tab:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} .filters .tab.highlighted {\n    background-color: #077;\n}
\\xdf63cf21ff81e6dab636f93e7417cb0bf71c0429c21b03bbc7cde5ef363f0105	.{{= name }} {\n    margin: 3px;\n}\n\n.{{= name }} .filters {\n    padding: 5px 0px;\n}\n\n.{{= name }} .filters .tab {\n    border-color: #888;\n    border-style: solid;\n    border-width: 1px 1px 1px 0px;\n    padding: 0px 1em 0px 1em;\n}\n\n.{{= name }} .filters .tab:hover {\n    background-color: #777;\n    cursor: pointer;\n}\n\n.{{= name }} .filters .tab.highlighted {\n    background-color: #077;\n}
\\xdf6dbdb75fd52394cb0d820229eef691ba293f479cd6a49069b543369e2e8665	<div id="{{= id }}" class="{{= name }}">\n    <a href="/dev" target="_blank" style="color: white;">Developer Tools</a>\n    <div class="tabs"></div>\n</div>
\\xdf6dbdb75fd52394cb0d820229eef691ba293f479cd6a49069b543369e2e8665	<div id="{{= id }}" class="{{= name }}">\n    <a href="/dev" target="_blank" style="color: white;">Developer Tools</a>\n    <div class="tabs"></div>\n</div>
\\xdfd48e36f8b3eefe58179b35181705f61905bcada913d46ec36af7841b042476	<div id="{{= id }}" class="{{= name }}">\n    <div class='tab_headers'/>\n    <div class='tab_contents'/>\n</div>
\\xdfd48e36f8b3eefe58179b35181705f61905bcada913d46ec36af7841b042476	<div id="{{= id }}" class="{{= name }}">\n    <div class='tab_headers'/>\n    <div class='tab_contents'/>\n</div>
\\xe174d21ece6d48ae67f946df8b5efaa7d4414568d4b6cf48fcf780c2249a3c1f	88fccadf-0885-4819-bacb-9359a27a7fc7
\\xe174d21ece6d48ae67f946df8b5efaa7d4414568d4b6cf48fcf780c2249a3c1f	88fccadf-0885-4819-bacb-9359a27a7fc7
\\xe174d21ece6d48ae67f946df8b5efaa7d4414568d4b6cf48fcf780c2249a3c1f	88fccadf-0885-4819-bacb-9359a27a7fc7
\\xe174d21ece6d48ae67f946df8b5efaa7d4414568d4b6cf48fcf780c2249a3c1f	88fccadf-0885-4819-bacb-9359a27a7fc7
\\xe201e36780b1fcbd4046d981a7dcc879f0a74fc5ab7749e029ca20dfbb77cd18	var w = $('#'+id);\n\nvar editor = CodeMirror(w.get(0), {\n    value: field.value,\n    mode:  language,\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\n\nw.data('codemirror', editor);\n\nfunction change_handler(doc) {\n    field.set(doc.getValue());\n    w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor.on('change', change_handler);\n\n/*\nw.data('disable_code_change_evt', function() { editor.off('change',change_handler); });\nw.data('enable_code_change_evt', function() { editor.on('change',change_handler); });\nw.trigger('code_changed', { codemirror: editor, field: field });\n*/
\\xe201e36780b1fcbd4046d981a7dcc879f0a74fc5ab7749e029ca20dfbb77cd18	var w = $('#'+id);\n\nvar editor = CodeMirror(w.get(0), {\n    value: field.value,\n    mode:  language,\n    indentUnit: 4,\n    lineNumbers: true,\n    lineWrapping: true,\n    theme: 'blackboard',\n    autofocus: true\n});\n\n\nw.data('codemirror', editor);\n\nfunction change_handler(doc) {\n    field.set(doc.getValue());\n    w.trigger('code_changed', { codemirror: editor, field: field });\n}\n\neditor.on('change', change_handler);\n\n/*\nw.data('disable_code_change_evt', function() { editor.off('change',change_handler); });\nw.data('enable_code_change_evt', function() { editor.on('change',change_handler); });\nw.trigger('code_changed', { codemirror: editor, field: field });\n*/
\\xe2ca231bedf67d636e309d60978dfeace0ab01e188f92a9d941e85cc85e67276	<div id="{{= id }}" class="{{= name }}">\n    <select>\n    </select>\n</div>
\\xe2ca231bedf67d636e309d60978dfeace0ab01e188f92a9d941e85cc85e67276	<div id="{{= id }}" class="{{= name }}">\n    <select>\n    </select>\n</div>
\\xe39400ffe2faa986e99b11ea7e12af8906d586c9f8bd4f642a947aeef1af11e8	<div id="{{= id }}" class="{{= name }}">\n    <ul class='fkeys'></ul>\n    <button class='new'>New</button>\n</div>
\\xe39400ffe2faa986e99b11ea7e12af8906d586c9f8bd4f642a947aeef1af11e8	<div id="{{= id }}" class="{{= name }}">\n    <ul class='fkeys'></ul>\n    <button class='new'>New</button>\n</div>
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855	
\\xe3dccee3ffa77e89772f64c4114ccff051008538451d923a31fb810647c75c23	967ec665-f37e-470e-b5c9-a2eac0eb9c89
\\xe3dccee3ffa77e89772f64c4114ccff051008538451d923a31fb810647c75c23	967ec665-f37e-470e-b5c9-a2eac0eb9c89
\\xe40b8664a81a3eceb8a60921cf70d6b2924e6587c1c78996c789b9233a1a298d	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation;\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\xe40b8664a81a3eceb8a60921cf70d6b2924e6587c1c78996c789b9233a1a298d	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation;\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\xe49a0c72fe93f29d84871a01ba65d6b34140c8eda18e086e3f49d2d5cdf06970	var w = $("#"+id);\n\nw.find('> .tabs').html(widget('ide:workspace_tabs', { bundle: bundle }));\n\n// config button\nw.find('.tools .config_button').click(function() {\n    console.log('config clicked');\n    w.trigger('open_tab', { tab_id: 'bundle_config' });\n});
\\xe49a0c72fe93f29d84871a01ba65d6b34140c8eda18e086e3f49d2d5cdf06970	var w = $("#"+id);\n\nw.find('> .tabs').html(widget('ide:workspace_tabs', { bundle: bundle }));\n\n// config button\nw.find('.tools .config_button').click(function() {\n    console.log('config clicked');\n    w.trigger('open_tab', { tab_id: 'bundle_config' });\n});
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe4b08665b2511bc86ca7cf1116f4a4df34ec5c7f0a19329e166cd8a00e862382	return {};
\\xe55082b120a35c6728fb6f29159ed00b1f9cc7766ef42a52337ac3c09b0fe077	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    padding-left: 10rem;\n    \n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    padding: 1.5rem;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .sections {\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: 2rem 0.5rem;\n}\n\n.{{= name }} .section {\n    cursor: pointer;\n    cursor: hand;\n    padding: 20px;\n    text-align: center;\n    border: 1px solid gray;\n    color: gray;\n    width: 9em;\n    box-sizing: border-box;\n}\n\n.{{= name }} .icon {\n    font-size: 300%;\n}\n\n.{{= name }} .section:hover {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} .section.selected {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} .section_content > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\xe55082b120a35c6728fb6f29159ed00b1f9cc7766ef42a52337ac3c09b0fe077	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    padding-left: 10rem;\n    \n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    padding: 1.5rem;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .sections {\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: 2rem 0.5rem;\n}\n\n.{{= name }} .section {\n    cursor: pointer;\n    cursor: hand;\n    padding: 20px;\n    text-align: center;\n    border: 1px solid gray;\n    color: gray;\n    width: 9em;\n    box-sizing: border-box;\n}\n\n.{{= name }} .icon {\n    font-size: 300%;\n}\n\n.{{= name }} .section:hover {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} .section.selected {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} .section_content > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\xe55082b120a35c6728fb6f29159ed00b1f9cc7766ef42a52337ac3c09b0fe077	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    padding-left: 10rem;\n    \n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    padding: 1.5rem;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .sections {\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: 2rem 0.5rem;\n}\n\n.{{= name }} .section {\n    cursor: pointer;\n    cursor: hand;\n    padding: 20px;\n    text-align: center;\n    border: 1px solid gray;\n    color: gray;\n    width: 9em;\n    box-sizing: border-box;\n}\n\n.{{= name }} .icon {\n    font-size: 300%;\n}\n\n.{{= name }} .section:hover {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} .section.selected {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} .section_content > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\xe55082b120a35c6728fb6f29159ed00b1f9cc7766ef42a52337ac3c09b0fe077	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    padding-left: 10rem;\n    \n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    padding: 1.5rem;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .sections {\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: 2rem 0.5rem;\n}\n\n.{{= name }} .section {\n    cursor: pointer;\n    cursor: hand;\n    padding: 20px;\n    text-align: center;\n    border: 1px solid gray;\n    color: gray;\n    width: 9em;\n    box-sizing: border-box;\n}\n\n.{{= name }} .icon {\n    font-size: 300%;\n}\n\n.{{= name }} .section:hover {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} .section.selected {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} .section_content > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\xe55082b120a35c6728fb6f29159ed00b1f9cc7766ef42a52337ac3c09b0fe077	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    padding-left: 10rem;\n    \n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    padding: 1.5rem;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .sections {\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: 2rem 0.5rem;\n}\n\n.{{= name }} .section {\n    cursor: pointer;\n    cursor: hand;\n    padding: 20px;\n    text-align: center;\n    border: 1px solid gray;\n    color: gray;\n    width: 9em;\n    box-sizing: border-box;\n}\n\n.{{= name }} .icon {\n    font-size: 300%;\n}\n\n.{{= name }} .section:hover {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} .section.selected {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} .section_content > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\xe55082b120a35c6728fb6f29159ed00b1f9cc7766ef42a52337ac3c09b0fe077	.{{= name }} {\n    position: relative;\n    box-sizing: border-box;\n    height: 100%;\n    padding-left: 10rem;\n    \n    text-align: left;\n    color: white;\n    overflow: auto;\n}\n\n.{{= name }} > p {\n    padding: 1.5rem;\n    margin: 0;\n    font-size: 1.5rem;\n    height: 4.5rem;\n}\n\n.{{= name }} > .top {\n    min-height: calc(100% - 4.5rem);\n}\n\n.{{= name }} > .top > .sections {\n    position: absolute;\n    top: 0;\n    left: 0;\n    padding: 2rem 0.5rem;\n}\n\n.{{= name }} .section {\n    cursor: pointer;\n    cursor: hand;\n    padding: 20px;\n    text-align: center;\n    border: 1px solid gray;\n    color: gray;\n    width: 9em;\n    box-sizing: border-box;\n}\n\n.{{= name }} .icon {\n    font-size: 300%;\n}\n\n.{{= name }} .section:hover {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} .section.selected {\n    color: white;\n    border: 1px 1px 1px 1px solid white;\n}\n\n.{{= name }} > .top > .section_content {\n    width: 100%;\n    height: 100%;\n}\n\n.{{= name }} .section_content > .buttons {\n    height: 1.75rem;\n    padding-right: 1rem;\n    text-align: right;\n}\n\n.{{= name }} > .top > .section_content > .tabs {\n    height: calc(100% - 1.75rem);\n}\n
\\xe5c8d4011fa5c9855a8338ca2102b54b9bde74e2de911160e3ad2852e0262f9e	4a7f3178-5d7b-4fab-a1ec-aadb2d2d21fa
\\xe5c8d4011fa5c9855a8338ca2102b54b9bde74e2de911160e3ad2852e0262f9e	4a7f3178-5d7b-4fab-a1ec-aadb2d2d21fa
\\xe720a1abb1b786bf08e43c5bbe861915676e69db72a0f21cb2d15e04f8baf073	.{{= name }} {\n} \n\n.{{= name }}:not(.displaying) > .display {\n    display: none;\n}\n\n.{{= name }} > .display:hover {\n    text-decoration: underline;\n    cursor: hand;\n    cursor: pointer;\n}\n\n.{{= name }}:not(.editing) > .edit {\n    display: none;\n}\n\n.{{= name }}:not(.saving) > .save {\n    display: none;\n}\n
\\xe720a1abb1b786bf08e43c5bbe861915676e69db72a0f21cb2d15e04f8baf073	.{{= name }} {\n} \n\n.{{= name }}:not(.displaying) > .display {\n    display: none;\n}\n\n.{{= name }} > .display:hover {\n    text-decoration: underline;\n    cursor: hand;\n    cursor: pointer;\n}\n\n.{{= name }}:not(.editing) > .edit {\n    display: none;\n}\n\n.{{= name }}:not(.saving) > .save {\n    display: none;\n}\n
\\xe8478dba635e75d3ada40502a942f72d2529ed408734de3075a055cdc7499256	<li id="{{= id }}" class="{{= name }}">\n    {{= label_function(row) }} <button class='delete'>[ X ]</button>\n</li>
\\xe8478dba635e75d3ada40502a942f72d2529ed408734de3075a055cdc7499256	<li id="{{= id }}" class="{{= name }}">\n    {{= label_function(row) }} <button class='delete'>[ X ]</button>\n</li>
\\xe8478dba635e75d3ada40502a942f72d2529ed408734de3075a055cdc7499256	<li id="{{= id }}" class="{{= name }}">\n    {{= label_function(row) }} <button class='delete'>[ X ]</button>\n</li>
\\xe8478dba635e75d3ada40502a942f72d2529ed408734de3075a055cdc7499256	<li id="{{= id }}" class="{{= name }}">\n    {{= label_function(row) }} <button class='delete'>[ X ]</button>\n</li>
\\xea495ce09ad42dce0c81b890fc9c8f41488fbf027e2d8aa711a74485d6d6d112	e74a4129-6e37-49d2-9391-0f6d99d8fd79
\\xea495ce09ad42dce0c81b890fc9c8f41488fbf027e2d8aa711a74485d6d6d112	e74a4129-6e37-49d2-9391-0f6d99d8fd79
\\xecab2d79b46cef08ab0e7bb533710433f428c220cc6d0cf6b2f0eb0342a33abf	/// HACKED IN, this should be called via widget-util dep when deps work again\n\n\n\n/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n\n\n\n\nvar w = $("#"+id);\n\n////////////////////////////////////////////////////////////////////\n// clearable timeout - http://stackoverflow.com/questions/5226578/check-if-a-timeout-has-been-cleared\n////////////////////////////////////////////////////////////////////\n\nfunction Timeout(fn, interval, scope, args) {\n    scope = scope || window;\n    var self = this;\n    var wrap = function(){\n        self.clear();\n        fn.apply(scope, args || arguments);\n    }\n    this.id = setTimeout(wrap, interval);\n}\n\n\nTimeout.prototype.id = null\nTimeout.prototype.cleared = false;\nTimeout.prototype.clear = function () {\n    clearTimeout(this.id);\n    this.cleared = true;\n    this.id = null;\n};\n\n////////////////////////////////////////////////////////////////////\n// draw the tree\n////////////////////////////////////////////////////////////////////\n\nfunction draw_tree() {\n    if (timer && !timer.cleared) {\n        timer.clear();\n    }\n\n    \n    var widget_tree = get_widget_tree($('body')[0]);\n    var agg_tree = get_aggregate_widget_tree(widget_tree);\n\n    var c = w.find('.tree_container').empty();\n    for (var widget_name in agg_tree) {\n\n        c.append(widget('debugger3_widgets_tree', { \n            widget_name: widget_name,\n            properties: agg_tree[widget_name],\n            depth: 0\n        }));\n    }\n}\n\nfunction delayed_redraw(e, payload) {\n    var widg = payload.widget.get(0);\n    // don't redraw for any debugger widget loadings\n    if (widg.className.indexOf('debugger3_widgets_tree') != -1) return;\n    \n    if (!timer || timer.cleared) {\n        // console.log('setting up delayed redraw....'+widg.className);\n        timer = new Timeout(draw_tree, 100);\n    }\n    else { \n        // console.log('.....no go on '+widg.className); \n    }\n}\n\nvar timer = false;\ndraw_tree();\n$(document).bind('widget_loaded', delayed_redraw);\n\n\n\n/////////////////////////////////////////////////////////////////////\n// show all\n/////////////////////////////////////////////////////////////////////\n\nw.find('div.show_all').bind('mouseover', function(e) {\n    $("[data-widget]").addClass('debugger3_widget_highlight');\n    e.stopPropagation();    \n}).bind('mouseout', function(e) {\n    $("[data-widget]").removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n\n\n\n/////////////////////////////////////////////////////////////////////\n// new_widget\n/////////////////////////////////////////////////////////////////////\n\nw.find('.new_widget').click(function() {\n    w.append(widget('modal', { \n        content: widget ('widget_new', { \n            widget_table: endpoint.schema('widget').table('widget') \n        })\n    }));\n});
\\xecab2d79b46cef08ab0e7bb533710433f428c220cc6d0cf6b2f0eb0342a33abf	/// HACKED IN, this should be called via widget-util dep when deps work again\n\n\n\n/***************************************************************************\n\nWIDGET TREE TRAVERSAL FUNCTIONS\n\n***************************************************************************/\n\n// returns a object tree that mirrors the widget tree\nfunction get_widget_tree(element) {\n    var widget_node = {};\n    \n    // first (non-widget?) element\n    if (!$(element).attr('data-widget')) {\n        widget_node.name = "[non-widget]";\n        widget_node.id = 'n/a';\n    } else {\n        widget_node.name = $(element).attr('data-widget');\n        widget_node.id = $(element).attr('id');\n    }\n    \n    var children = {}\n    $(element).closestDescendant('[data-widget]', true).each(function(i,e) {\n        children[i] = get_widget_tree($(e));\n    });\n    widget_node.children = children;\n\n    return widget_node;\n}\n\n// returns an object tree that combines parallel widgets of the same name, with a count var\nfunction get_aggregate_widget_tree(bigtree) {\n    var smalltree = {}\n    if (bigtree.children) {\n        for (var i in bigtree.children) {\n            var child = bigtree.children[i];\n            var name = child.name;\n            var children = get_aggregate_widget_tree(child); \n            \n            smalltree[name] = smalltree[name] ? smalltree[name] : {};\n            \n            // SETUP PROPERTIES\n            \n            // count\n            smalltree[name]['count'] = smalltree[name]['count'] ? smalltree[name]['count'] +1 : 1;\n            \n            // ids\n            if (typeof smalltree[name]['ids'] != 'undefined') {\n                smalltree[name]['ids'].push(child.id);\n            } else {\n                smalltree[name]['ids']=Array(child.id);\n            }\n            \n            // children\n            if (typeof smalltree[name]['children'] != 'undefined' && smalltree[name]['children'].length > 0) {\n                console.log("EDGE CASE!", smalltree[name]['children']);\n                // TODO: there's an edge case to flesh out here, with inter-woven widget trees\n                // console.log('need to add ', children, ' to ', kids[name][children]);\n            } else {\n\t\t\t\tsmalltree[name]['children'] = children;\n            }\n        }\n    }\n    return smalltree;\n}\n\n\n\n\nvar w = $("#"+id);\n\n////////////////////////////////////////////////////////////////////\n// clearable timeout - http://stackoverflow.com/questions/5226578/check-if-a-timeout-has-been-cleared\n////////////////////////////////////////////////////////////////////\n\nfunction Timeout(fn, interval, scope, args) {\n    scope = scope || window;\n    var self = this;\n    var wrap = function(){\n        self.clear();\n        fn.apply(scope, args || arguments);\n    }\n    this.id = setTimeout(wrap, interval);\n}\n\n\nTimeout.prototype.id = null\nTimeout.prototype.cleared = false;\nTimeout.prototype.clear = function () {\n    clearTimeout(this.id);\n    this.cleared = true;\n    this.id = null;\n};\n\n////////////////////////////////////////////////////////////////////\n// draw the tree\n////////////////////////////////////////////////////////////////////\n\nfunction draw_tree() {\n    if (timer && !timer.cleared) {\n        timer.clear();\n    }\n\n    \n    var widget_tree = get_widget_tree($('body')[0]);\n    var agg_tree = get_aggregate_widget_tree(widget_tree);\n\n    var c = w.find('.tree_container').empty();\n    for (var widget_name in agg_tree) {\n\n        c.append(widget('debugger3_widgets_tree', { \n            widget_name: widget_name,\n            properties: agg_tree[widget_name],\n            depth: 0\n        }));\n    }\n}\n\nfunction delayed_redraw(e, payload) {\n    var widg = payload.widget.get(0);\n    // don't redraw for any debugger widget loadings\n    if (widg.className.indexOf('debugger3_widgets_tree') != -1) return;\n    \n    if (!timer || timer.cleared) {\n        // console.log('setting up delayed redraw....'+widg.className);\n        timer = new Timeout(draw_tree, 100);\n    }\n    else { \n        // console.log('.....no go on '+widg.className); \n    }\n}\n\nvar timer = false;\ndraw_tree();\n$(document).bind('widget_loaded', delayed_redraw);\n\n\n\n/////////////////////////////////////////////////////////////////////\n// show all\n/////////////////////////////////////////////////////////////////////\n\nw.find('div.show_all').bind('mouseover', function(e) {\n    $("[data-widget]").addClass('debugger3_widget_highlight');\n    e.stopPropagation();    \n}).bind('mouseout', function(e) {\n    $("[data-widget]").removeClass('debugger3_widget_highlight');\n    e.stopPropagation();\n});\n\n\n\n\n/////////////////////////////////////////////////////////////////////\n// new_widget\n/////////////////////////////////////////////////////////////////////\n\nw.find('.new_widget').click(function() {\n    w.append(widget('modal', { \n        content: widget ('widget_new', { \n            widget_table: endpoint.schema('widget').table('widget') \n        })\n    }));\n});
\\xed08f26bc4c6c1973fc0a8c69f7139d52dea2aad6fce2bb6e6021f52b4d91be7	129c7484-653d-4206-b81a-a703e87a491a
\\xed08f26bc4c6c1973fc0a8c69f7139d52dea2aad6fce2bb6e6021f52b4d91be7	129c7484-653d-4206-b81a-a703e87a491a
\\xed866cc4841c70ebe74a6ca6b8a4c292102ddcf46de19227ac53802837527663	<div id="{{= id }}" class="{{= name }}">\n    <!--<p>For the time being, use copy to create a new row in this table instead</p>\n\n    <small>Press ESC to return</small>\n    <button class='exit'>Exit</button>\n    <p>You really should have just copied this... but anyway</p>\n-->\n    <input class='path' type='text' placeholder='/my_new_resource'>\n    <select class='mimetype'></select>\n    <button class='save'>Save</button>\n</div>
\\xed866cc4841c70ebe74a6ca6b8a4c292102ddcf46de19227ac53802837527663	<div id="{{= id }}" class="{{= name }}">\n    <!--<p>For the time being, use copy to create a new row in this table instead</p>\n\n    <small>Press ESC to return</small>\n    <button class='exit'>Exit</button>\n    <p>You really should have just copied this... but anyway</p>\n-->\n    <input class='path' type='text' placeholder='/my_new_resource'>\n    <select class='mimetype'></select>\n    <button class='save'>Save</button>\n</div>
\\xef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567	dev
\\xef260e9aa3c673af240d17a2660480361a8e081d1ffeca2a5ed0e3219fc18567	dev
\\xef980b97c7fcc4153f6987bee0a2ee50d29d02da69ba07e483b9c61844cfdee0	var w = $("#"+id);\n\nw.find('.delete_bundle_oh_no').click(function() {\n    if(confirm('Are you sure you really want to PERMANTENTLY DELETE this bundle?')) {\n        bundle.delete().then(function() {\n            alert ('gone.');\n        }).catch(function() {\n            alert('failed.');\n        });\n    }\n});\n\n\nw.find('.rename').click(function() {\n    alert('coming soon....');\n});\n\n\n
\\xef980b97c7fcc4153f6987bee0a2ee50d29d02da69ba07e483b9c61844cfdee0	var w = $("#"+id);\n\nw.find('.delete_bundle_oh_no').click(function() {\n    if(confirm('Are you sure you really want to PERMANTENTLY DELETE this bundle?')) {\n        bundle.delete().then(function() {\n            alert ('gone.');\n        }).catch(function() {\n            alert('failed.');\n        });\n    }\n});\n\n\nw.find('.rename').click(function() {\n    alert('coming soon....');\n});\n\n\n
\\xefc6a7155a884bc7d2a153b03e3200b00e51d995119828ad4a689f56e7367804	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.1', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:file_input'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n
\\xefc6a7155a884bc7d2a153b03e3200b00e51d995119828ad4a689f56e7367804	<!DOCTYPE html>\n<html lang="en">\n    <head>\n        <script src='/system.js'></script>\n        <title>Aquameta</title>\n        <meta http-equiv="Content-type" content="text/html; charset=utf-8">\n        <meta name="viewport" content="width=device-width">\n        \n        <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>\n        <style>\n            html {\n                box-sizing: border-box;\n                background-color: black;\n                color: white;\n            }\n            *, *:before, *:after {\n                box-sizing: inherit;\n            }\n            body {\n                font-family: 'Open Sans', sans-serif;\n            }\n            html, body {\n                height: 100%;\n                margin: 0;\n            }\n        </style>\n    </head>\n    <body></body>\n    <script>\n        System.import('/widget.js').then(function(widget) {\n            \n            var db = new AQ.Database('/endpoint/0.1', { evented: 'no' });\n            window.endpoint = db;\n            \n            AQ.Widget.import('org.aquameta.core.ide', 'core', db);\n            AQ.Widget.import('org.aquameta.core.ide', 'ide', db);\n            \n            $('body').append(widget('ide:file_input'));\n            $('body').append(widget('ide:debugger3_manager'));\n            \n        });\n    </script>\n</html>\n
\\xefdd3043fbbbe26ed596c9768485d84b5bd88a440022d1f215b5104527bac43f	206646d9-7fe3-45c2-8db1-56fa22bc62c6
\\xefdd3043fbbbe26ed596c9768485d84b5bd88a440022d1f215b5104527bac43f	206646d9-7fe3-45c2-8db1-56fa22bc62c6
\\xf0365e10595918f36ccf08e105de338d821e34b5ed928ed9d8d937367ebd80f8	<div id="{{= id }}" class="{{= name }}">\n    <h2>Push/Pull</h2>\n    \n    <h2>Remotes</h2>\n    \n    <div class='remotes'>\n    </div>\n</div>
\\xf0365e10595918f36ccf08e105de338d821e34b5ed928ed9d8d937367ebd80f8	<div id="{{= id }}" class="{{= name }}">\n    <h2>Push/Pull</h2>\n    \n    <h2>Remotes</h2>\n    \n    <div class='remotes'>\n    </div>\n</div>
\\xf056fbc142b96c3a3c13788124ada8bd5b4078f10f321ec744fed08d82bbdf12	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}\n\n.{{= name }} > .edit {\n    display: none;\n    padding: 0.25rem;\n    float: right;\n}\n\n.{{= name }}:hover > .edit {\n    display: initial;\n}\n
\\xf056fbc142b96c3a3c13788124ada8bd5b4078f10f321ec744fed08d82bbdf12	.{{= name }} {\n    position: relative;\n    padding: 0.5rem;\n    color: #333;\n    background-color: #888;\n    text-overflow: ellipsis;\n    overflow: hidden;\n}\n\n.{{= name }} {\n    border-top: 1px solid #333;\n}\n\n.{{= name }}:hover {\n    background-color: #666;\n}\n\n.{{= name }}:active {\n    top: 1px;\n    background-color: lightyellow !important;\n}\n\n.{{= name }}.selected {\n    background-color: #333;\n    color: #aaa;\n}\n\n.{{= name }} > .edit {\n    display: none;\n    padding: 0.25rem;\n    float: right;\n}\n\n.{{= name }}:hover > .edit {\n    display: initial;\n}\n
\\xf0d6bddd4ddfc3cdeba394416cc389bbb98fd1b2a8d4344f97c2bf30da238935	.{{= name }} {\n    position: relative;\n    height: 100%;\n    text-align: left;\n}\n\n\n/* BASICS */\n.CodeMirror {\n    /* Set height, width, borders, and global font properties here */\n    height: 100% !important;\n    font-family: monospace;\n    height: auto;\n}\n\n.CodeMirror-scroll {\n    /* Set scrolling behaviour here */\n    overflow-y: hidden;\n    overflow-x: auto;\n}\n\n.CodeMirror-hscrollbar {\n    display: none;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n    padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre {\n    padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler {\n    background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n    border-right: 1px solid #ddd;\n    background-color: #f7f7f7;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n    padding: 0 3px 0 5px;\n    min-width: 20px;\n    text-align: right;\n    color: #999;\n}\n\n/* CURSOR */\n\n.CodeMirror div.CodeMirror-cursor {\n    border-left: 1px solid black;\n    z-index: 3;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n    border-left: 1px solid silver;\n}\n.CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor {\n    width: auto;\n    border: 0;\n    background: #7e7;\n    z-index: 1;\n}\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror div.CodeMirror-cursor.CodeMirror-overwrite {}\n\n.cm-tab { display: inline-block; }\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable {color: black;}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3 {color: #085;}\n.cm-s-default .cm-property {color: black;}\n.cm-s-default .cm-operator {color: black;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-error {color: #f00;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n\n.cm-invalidchar {color: #f00;}\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\nthe editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n    line-height: 1;\n    position: relative;\n    overflow: hidden;\n    background: white;\n    color: black;\n}\n\n.CodeMirror-scroll {\n    /* 30px is the magic margin used to hide the element's real scrollbars */\n    /* See overflow: hidden in .CodeMirror */\n    margin-bottom: -30px; margin-right: -30px;\n    padding-bottom: 30px; padding-right: 30px;\n    height: 100%;\n    outline: none; /* Prevent dragging from highlighting the element */\n    position: relative;\n}\n.CodeMirror-sizer {\n    position: relative;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\nbefore actuall scrolling happens, thus preventing shaking and\nflickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler {\n    position: absolute;\n    z-index: 6;\n    display: none;\n}\n.CodeMirror-vscrollbar {\n    right: 0; top: 0;\n    overflow-x: hidden;\n    overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n    bottom: 0; left: 0;\n    overflow-y: hidden;\n    overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n    right: 0; bottom: 0;\n    z-index: 6;\n}\n\n.CodeMirror-gutters {\n    position: absolute; left: 0; top: 0;\n    height: 100%;\n    padding-bottom: 30px;\n    z-index: 3;\n}\n.CodeMirror-gutter {\n    height: 100%;\n    padding-bottom: 30px;\n    margin-bottom: -32px;\n    display: inline-block;\n    /* Hack to make IE7 behave */\n    *zoom:1;\n    *display:inline;\n}\n.CodeMirror-gutter-elt {\n    position: absolute;\n    cursor: default;\n    z-index: 4;\n}\n\n.CodeMirror-lines {\n    cursor: text;\n}\n.CodeMirror pre {\n    /* Reset some styles that the rest of the page might have set */\n    -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n    border-width: 0;\n    background: transparent;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    white-space: pre;\n    word-wrap: normal;\n    line-height: inherit;\n    color: inherit;\n    z-index: 2;\n    position: relative;\n    overflow: visible;\n}\n.CodeMirror-wrap pre {\n    word-wrap: break-word;\n    white-space: pre-wrap;\n    word-break: normal;\n}\n.CodeMirror-linebackground {\n    position: absolute;\n    left: 0; right: 0; top: 0; bottom: 0;\n    z-index: 0;\n}\n\n.CodeMirror-linewidget {\n    position: relative;\n    z-index: 2;\n    overflow: auto;\n}\n\n.CodeMirror-widget {\n    display: inline-block;\n}\n\n.CodeMirror-wrap .CodeMirror-scroll {\n    overflow-x: hidden;\n}\n\n.CodeMirror-measure {\n    position: absolute;\n    width: 100%; height: 0px;\n    overflow: hidden;\n    visibility: hidden;\n}\n.CodeMirror-measure pre { position: static; }\n\n.CodeMirror div.CodeMirror-cursor {\n    position: absolute;\n    visibility: hidden;\n    border-right: none;\n    width: 0;\n}\n.CodeMirror-focused div.CodeMirror-cursor {\n    visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n\n.cm-searching {\n    background: #ffa;\n    background: rgba(255, 255, 0, .4);\n}\n\n/* IE7 hack to prevent it from returning funny offsetTops on the spans */\n.CodeMirror span { *vertical-align: text-bottom; }\n\n@media print {\n    /* Hide the cursor when printing */\n    .CodeMirror div.CodeMirror-cursor {\n        visibility: hidden;\n    }\n}\n\n\n\n/* Based on Sublime Text's Monokai theme */\n\n.cm-s-monokai.CodeMirror {background: #272822; color: #f8f8f2;}\n.cm-s-monokai div.CodeMirror-selected {background: #49483E !important;}\n.cm-s-monokai .CodeMirror-gutters {background: #272822; border-right: 0px;}\n.cm-s-monokai .CodeMirror-linenumber {color: #d0d0d0;}\n.cm-s-monokai .CodeMirror-cursor {border-left: 1px solid #f8f8f0 !important;}\n\n.cm-s-monokai span.cm-comment {color: #75715e;}\n.cm-s-monokai span.cm-atom {color: #ae81ff;}\n.cm-s-monokai span.cm-number {color: #ae81ff;}\n\n.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute {color: #a6e22e;}\n.cm-s-monokai span.cm-keyword {color: #f92672;}\n.cm-s-monokai span.cm-string {color: #e6db74;}\n\n.cm-s-monokai span.cm-variable {color: #a6e22e;}\n.cm-s-monokai span.cm-variable-2 {color: #9effff;}\n.cm-s-monokai span.cm-def {color: #fd971f;}\n.cm-s-monokai span.cm-error {background: #f92672; color: #f8f8f0;}\n.cm-s-monokai span.cm-bracket {color: #f8f8f2;}\n.cm-s-monokai span.cm-tag {color: #f92672;}\n.cm-s-monokai span.cm-link {color: #ae81ff;}\n\n.cm-s-monokai .CodeMirror-matchingbracket {\n    text-decoration: underline;\n    color: white !important;\n}\n\n\n.cm-s-blackboard.CodeMirror { background: #0C1021; color: #F8F8F8; }\n.cm-s-blackboard .CodeMirror-selected { background: #253B76 !important; }\n.cm-s-blackboard .CodeMirror-gutters { background: #0C1021; border-right: 0; }\n.cm-s-blackboard .CodeMirror-linenumber { color: #888; }\n.cm-s-blackboard .CodeMirror-cursor { border-left: 1px solid #A7A7A7 !important; }\n\n.cm-s-blackboard .cm-keyword { color: #FBDE2D; }\n.cm-s-blackboard .cm-atom { color: #D8FA3C; }\n.cm-s-blackboard .cm-number { color: #D8FA3C; }\n.cm-s-blackboard .cm-def { color: #8DA6CE; }\n.cm-s-blackboard .cm-variable { color: #FF6400; }\n.cm-s-blackboard .cm-operator { color: #FBDE2D;}\n.cm-s-blackboard .cm-comment { color: #AEAEAE; }\n.cm-s-blackboard .cm-string { color: #61CE3C; }\n.cm-s-blackboard .cm-string-2 { color: #61CE3C; }\n.cm-s-blackboard .cm-meta { color: #D8FA3C; }\n.cm-s-blackboard .cm-error { background: #9D1E15; color: #F8F8F8; }\n.cm-s-blackboard .cm-builtin { color: #8DA6CE; }\n.cm-s-blackboard .cm-tag { color: #8DA6CE; }\n.cm-s-blackboard .cm-attribute { color: #8DA6CE; }\n.cm-s-blackboard .cm-header { color: #FF6400; }\n.cm-s-blackboard .cm-hr { color: #AEAEAE; }\n.cm-s-blackboard .cm-link { color: #8DA6CE; }
\\xf0d6bddd4ddfc3cdeba394416cc389bbb98fd1b2a8d4344f97c2bf30da238935	.{{= name }} {\n    position: relative;\n    height: 100%;\n    text-align: left;\n}\n\n\n/* BASICS */\n.CodeMirror {\n    /* Set height, width, borders, and global font properties here */\n    height: 100% !important;\n    font-family: monospace;\n    height: auto;\n}\n\n.CodeMirror-scroll {\n    /* Set scrolling behaviour here */\n    overflow-y: hidden;\n    overflow-x: auto;\n}\n\n.CodeMirror-hscrollbar {\n    display: none;\n}\n\n/* PADDING */\n\n.CodeMirror-lines {\n    padding: 4px 0; /* Vertical padding around content */\n}\n.CodeMirror pre {\n    padding: 0 4px; /* Horizontal padding of content */\n}\n\n.CodeMirror-scrollbar-filler {\n    background-color: white; /* The little square between H and V scrollbars */\n}\n\n/* GUTTER */\n\n.CodeMirror-gutters {\n    border-right: 1px solid #ddd;\n    background-color: #f7f7f7;\n}\n.CodeMirror-linenumbers {}\n.CodeMirror-linenumber {\n    padding: 0 3px 0 5px;\n    min-width: 20px;\n    text-align: right;\n    color: #999;\n}\n\n/* CURSOR */\n\n.CodeMirror div.CodeMirror-cursor {\n    border-left: 1px solid black;\n    z-index: 3;\n}\n/* Shown when moving in bi-directional text */\n.CodeMirror div.CodeMirror-secondarycursor {\n    border-left: 1px solid silver;\n}\n.CodeMirror.cm-keymap-fat-cursor div.CodeMirror-cursor {\n    width: auto;\n    border: 0;\n    background: #7e7;\n    z-index: 1;\n}\n/* Can style cursor different in overwrite (non-insert) mode */\n.CodeMirror div.CodeMirror-cursor.CodeMirror-overwrite {}\n\n.cm-tab { display: inline-block; }\n\n/* DEFAULT THEME */\n\n.cm-s-default .cm-keyword {color: #708;}\n.cm-s-default .cm-atom {color: #219;}\n.cm-s-default .cm-number {color: #164;}\n.cm-s-default .cm-def {color: #00f;}\n.cm-s-default .cm-variable {color: black;}\n.cm-s-default .cm-variable-2 {color: #05a;}\n.cm-s-default .cm-variable-3 {color: #085;}\n.cm-s-default .cm-property {color: black;}\n.cm-s-default .cm-operator {color: black;}\n.cm-s-default .cm-comment {color: #a50;}\n.cm-s-default .cm-string {color: #a11;}\n.cm-s-default .cm-string-2 {color: #f50;}\n.cm-s-default .cm-meta {color: #555;}\n.cm-s-default .cm-error {color: #f00;}\n.cm-s-default .cm-qualifier {color: #555;}\n.cm-s-default .cm-builtin {color: #30a;}\n.cm-s-default .cm-bracket {color: #997;}\n.cm-s-default .cm-tag {color: #170;}\n.cm-s-default .cm-attribute {color: #00c;}\n.cm-s-default .cm-header {color: blue;}\n.cm-s-default .cm-quote {color: #090;}\n.cm-s-default .cm-hr {color: #999;}\n.cm-s-default .cm-link {color: #00c;}\n\n.cm-negative {color: #d44;}\n.cm-positive {color: #292;}\n.cm-header, .cm-strong {font-weight: bold;}\n.cm-em {font-style: italic;}\n.cm-link {text-decoration: underline;}\n\n.cm-invalidchar {color: #f00;}\n\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0f0;}\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #f22;}\n\n/* STOP */\n\n/* The rest of this file contains styles related to the mechanics of\nthe editor. You probably shouldn't touch them. */\n\n.CodeMirror {\n    line-height: 1;\n    position: relative;\n    overflow: hidden;\n    background: white;\n    color: black;\n}\n\n.CodeMirror-scroll {\n    /* 30px is the magic margin used to hide the element's real scrollbars */\n    /* See overflow: hidden in .CodeMirror */\n    margin-bottom: -30px; margin-right: -30px;\n    padding-bottom: 30px; padding-right: 30px;\n    height: 100%;\n    outline: none; /* Prevent dragging from highlighting the element */\n    position: relative;\n}\n.CodeMirror-sizer {\n    position: relative;\n}\n\n/* The fake, visible scrollbars. Used to force redraw during scrolling\nbefore actuall scrolling happens, thus preventing shaking and\nflickering artifacts. */\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler {\n    position: absolute;\n    z-index: 6;\n    display: none;\n}\n.CodeMirror-vscrollbar {\n    right: 0; top: 0;\n    overflow-x: hidden;\n    overflow-y: scroll;\n}\n.CodeMirror-hscrollbar {\n    bottom: 0; left: 0;\n    overflow-y: hidden;\n    overflow-x: scroll;\n}\n.CodeMirror-scrollbar-filler {\n    right: 0; bottom: 0;\n    z-index: 6;\n}\n\n.CodeMirror-gutters {\n    position: absolute; left: 0; top: 0;\n    height: 100%;\n    padding-bottom: 30px;\n    z-index: 3;\n}\n.CodeMirror-gutter {\n    height: 100%;\n    padding-bottom: 30px;\n    margin-bottom: -32px;\n    display: inline-block;\n    /* Hack to make IE7 behave */\n    *zoom:1;\n    *display:inline;\n}\n.CodeMirror-gutter-elt {\n    position: absolute;\n    cursor: default;\n    z-index: 4;\n}\n\n.CodeMirror-lines {\n    cursor: text;\n}\n.CodeMirror pre {\n    /* Reset some styles that the rest of the page might have set */\n    -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\n    border-width: 0;\n    background: transparent;\n    font-family: inherit;\n    font-size: inherit;\n    margin: 0;\n    white-space: pre;\n    word-wrap: normal;\n    line-height: inherit;\n    color: inherit;\n    z-index: 2;\n    position: relative;\n    overflow: visible;\n}\n.CodeMirror-wrap pre {\n    word-wrap: break-word;\n    white-space: pre-wrap;\n    word-break: normal;\n}\n.CodeMirror-linebackground {\n    position: absolute;\n    left: 0; right: 0; top: 0; bottom: 0;\n    z-index: 0;\n}\n\n.CodeMirror-linewidget {\n    position: relative;\n    z-index: 2;\n    overflow: auto;\n}\n\n.CodeMirror-widget {\n    display: inline-block;\n}\n\n.CodeMirror-wrap .CodeMirror-scroll {\n    overflow-x: hidden;\n}\n\n.CodeMirror-measure {\n    position: absolute;\n    width: 100%; height: 0px;\n    overflow: hidden;\n    visibility: hidden;\n}\n.CodeMirror-measure pre { position: static; }\n\n.CodeMirror div.CodeMirror-cursor {\n    position: absolute;\n    visibility: hidden;\n    border-right: none;\n    width: 0;\n}\n.CodeMirror-focused div.CodeMirror-cursor {\n    visibility: visible;\n}\n\n.CodeMirror-selected { background: #d9d9d9; }\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\n\n.cm-searching {\n    background: #ffa;\n    background: rgba(255, 255, 0, .4);\n}\n\n/* IE7 hack to prevent it from returning funny offsetTops on the spans */\n.CodeMirror span { *vertical-align: text-bottom; }\n\n@media print {\n    /* Hide the cursor when printing */\n    .CodeMirror div.CodeMirror-cursor {\n        visibility: hidden;\n    }\n}\n\n\n\n/* Based on Sublime Text's Monokai theme */\n\n.cm-s-monokai.CodeMirror {background: #272822; color: #f8f8f2;}\n.cm-s-monokai div.CodeMirror-selected {background: #49483E !important;}\n.cm-s-monokai .CodeMirror-gutters {background: #272822; border-right: 0px;}\n.cm-s-monokai .CodeMirror-linenumber {color: #d0d0d0;}\n.cm-s-monokai .CodeMirror-cursor {border-left: 1px solid #f8f8f0 !important;}\n\n.cm-s-monokai span.cm-comment {color: #75715e;}\n.cm-s-monokai span.cm-atom {color: #ae81ff;}\n.cm-s-monokai span.cm-number {color: #ae81ff;}\n\n.cm-s-monokai span.cm-property, .cm-s-monokai span.cm-attribute {color: #a6e22e;}\n.cm-s-monokai span.cm-keyword {color: #f92672;}\n.cm-s-monokai span.cm-string {color: #e6db74;}\n\n.cm-s-monokai span.cm-variable {color: #a6e22e;}\n.cm-s-monokai span.cm-variable-2 {color: #9effff;}\n.cm-s-monokai span.cm-def {color: #fd971f;}\n.cm-s-monokai span.cm-error {background: #f92672; color: #f8f8f0;}\n.cm-s-monokai span.cm-bracket {color: #f8f8f2;}\n.cm-s-monokai span.cm-tag {color: #f92672;}\n.cm-s-monokai span.cm-link {color: #ae81ff;}\n\n.cm-s-monokai .CodeMirror-matchingbracket {\n    text-decoration: underline;\n    color: white !important;\n}\n\n\n.cm-s-blackboard.CodeMirror { background: #0C1021; color: #F8F8F8; }\n.cm-s-blackboard .CodeMirror-selected { background: #253B76 !important; }\n.cm-s-blackboard .CodeMirror-gutters { background: #0C1021; border-right: 0; }\n.cm-s-blackboard .CodeMirror-linenumber { color: #888; }\n.cm-s-blackboard .CodeMirror-cursor { border-left: 1px solid #A7A7A7 !important; }\n\n.cm-s-blackboard .cm-keyword { color: #FBDE2D; }\n.cm-s-blackboard .cm-atom { color: #D8FA3C; }\n.cm-s-blackboard .cm-number { color: #D8FA3C; }\n.cm-s-blackboard .cm-def { color: #8DA6CE; }\n.cm-s-blackboard .cm-variable { color: #FF6400; }\n.cm-s-blackboard .cm-operator { color: #FBDE2D;}\n.cm-s-blackboard .cm-comment { color: #AEAEAE; }\n.cm-s-blackboard .cm-string { color: #61CE3C; }\n.cm-s-blackboard .cm-string-2 { color: #61CE3C; }\n.cm-s-blackboard .cm-meta { color: #D8FA3C; }\n.cm-s-blackboard .cm-error { background: #9D1E15; color: #F8F8F8; }\n.cm-s-blackboard .cm-builtin { color: #8DA6CE; }\n.cm-s-blackboard .cm-tag { color: #8DA6CE; }\n.cm-s-blackboard .cm-attribute { color: #8DA6CE; }\n.cm-s-blackboard .cm-header { color: #FF6400; }\n.cm-s-blackboard .cm-hr { color: #AEAEAE; }\n.cm-s-blackboard .cm-link { color: #8DA6CE; }
\\xf0fb8f51aa4c0bca032e44a39c94cd847fd05ec1d09ad0c9c0cf8d50b20a52f3	<div id="{{= id }}" class="{{= name }}">\n    <span>Logged in</span>\n    <div class='dropdown'>\n        <div class='username'></div>\n        <div class='logout'>Logout</div>\n    </div>\n</div>\n
\\xf0fb8f51aa4c0bca032e44a39c94cd847fd05ec1d09ad0c9c0cf8d50b20a52f3	<div id="{{= id }}" class="{{= name }}">\n    <span>Logged in</span>\n    <div class='dropdown'>\n        <div class='username'></div>\n        <div class='logout'>Logout</div>\n    </div>\n</div>\n
\\xf17960e717ae9160d4e72ed5c485d5e0d60d90f370541cc87c62a61aaec6bf70	0d106cc7-33b0-4afe-9472-3aca86e66bbb
\\xf17960e717ae9160d4e72ed5c485d5e0d60d90f370541cc87c62a61aaec6bf70	0d106cc7-33b0-4afe-9472-3aca86e66bbb
\\xf1aaa2dc142b42e5a44edc01c95d7e187b1449e175baa360c469c4c2d3d7ce3b	<div id="{{= id }}" class="{{= name }}">\n    <p class='title'>\n        <span class='name'></span>\n        <span class='version'>Version:</span>\n    </p>\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <div class='section_content'></div>\n    </div>\n</div>
\\xf1aaa2dc142b42e5a44edc01c95d7e187b1449e175baa360c469c4c2d3d7ce3b	<div id="{{= id }}" class="{{= name }}">\n    <p class='title'>\n        <span class='name'></span>\n        <span class='version'>Version:</span>\n    </p>\n    <div class='top'>\n        <div class='buttons'>\n            <button class="save">Save</button>\n            <button class="copy">Copy</button>\n            <button class="delete">Delete</button>\n        </div>\n        <div class='section_content'></div>\n    </div>\n</div>
\\xf3498573b89bfc70aefc01efb96fbae34cdc097e0669c98777f900478813626d	486d1939-8093-40b9-b790-a6d1675727c8
\\xf3498573b89bfc70aefc01efb96fbae34cdc097e0669c98777f900478813626d	486d1939-8093-40b9-b790-a6d1675727c8
\\xf3704cb0c092b867a28c4dc81c3c9b26a47288bb1755af9698970f8e89842874	290a4947-989a-41fb-bfbb-94e4fe59ebc8
\\xf3ccbbf2f88909c1cb63bfe2e0b7e7291dc281a62814b7da7cc2530eb2da879e	.{{= name }} .toggle {\n\tposition: fixed;\n    bottom: 0;\n    right: 1em;\n}\n\n.{{= name }} .debugger_container {\n    display: none;\n}
\\xf3ccbbf2f88909c1cb63bfe2e0b7e7291dc281a62814b7da7cc2530eb2da879e	.{{= name }} .toggle {\n\tposition: fixed;\n    bottom: 0;\n    right: 1em;\n}\n\n.{{= name }} .debugger_container {\n    display: none;\n}
\\xf3e4f44290db4f289df8aa4f1c342048590b37cb000dd310e2cca7eccde852c0	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\xf3e4f44290db4f289df8aa4f1c342048590b37cb000dd310e2cca7eccde852c0	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\xf3e4f44290db4f289df8aa4f1c342048590b37cb000dd310e2cca7eccde852c0	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\xf3e4f44290db4f289df8aa4f1c342048590b37cb000dd310e2cca7eccde852c0	var w = $('#'+id);\n\nw.data('datum', row);\nw.data('row', row);\n\n// Assign all triggers\n['click'].forEach(function(trig) {\n    w.on(trig, function(e) {\n        e.stopPropagation();\n        w.trigger('list_item_' + trig, [row, w]);\n    });\n});
\\xf6b2ac3a36101b6ee151bf4c0b01c1c23269f51e5bae8fba8096525ef7816c99	d5ff5f93-b643-49f7-87b3-5909b35ad026
\\xf6b2ac3a36101b6ee151bf4c0b01c1c23269f51e5bae8fba8096525ef7816c99	d5ff5f93-b643-49f7-87b3-5909b35ad026
\\xf8e96f7a888e247eee11f275e88415f93bf5e2319de54d624e0ab6558231f3cc	.{{= name }} {\n    display: inline-block;\n    width: 50%;\n    padding: 5rem 3rem;\n    background-color: #333;\n    border: 0.25rem solid #222;\n}\n\n.{{= name }} > * {\n    display: block;\n    margin: 0.5rem;\n}\n\n.{{= name }} > input {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > input:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > input:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}
\\xf8e96f7a888e247eee11f275e88415f93bf5e2319de54d624e0ab6558231f3cc	.{{= name }} {\n    display: inline-block;\n    width: 50%;\n    padding: 5rem 3rem;\n    background-color: #333;\n    border: 0.25rem solid #222;\n}\n\n.{{= name }} > * {\n    display: block;\n    margin: 0.5rem;\n}\n\n.{{= name }} > input {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > input:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > input:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}
\\xf8e96f7a888e247eee11f275e88415f93bf5e2319de54d624e0ab6558231f3cc	.{{= name }} {\n    display: inline-block;\n    width: 50%;\n    padding: 5rem 3rem;\n    background-color: #333;\n    border: 0.25rem solid #222;\n}\n\n.{{= name }} > * {\n    display: block;\n    margin: 0.5rem;\n}\n\n.{{= name }} > input {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > input:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > input:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}
\\xf8e96f7a888e247eee11f275e88415f93bf5e2319de54d624e0ab6558231f3cc	.{{= name }} {\n    display: inline-block;\n    width: 50%;\n    padding: 5rem 3rem;\n    background-color: #333;\n    border: 0.25rem solid #222;\n}\n\n.{{= name }} > * {\n    display: block;\n    margin: 0.5rem;\n}\n\n.{{= name }} > input {\n    width: 100%;\n    padding: 0.5rem;\n    margin: 0.25rem 0;\n    border: 1px solid #aaa;\n}\n\n.{{= name }} > input:hover {\n    border: 1px solid #666;\n}\n\n.{{= name }} > input:focus {\n    outline: 2px inset rgba(0, 0, 100, 0.6);\n}
\\xf9453243de260974f29858e3bcc94d7b688933892ef60f9118c4b99d312af9e2	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.stage').click(function() {\n    endpoint.schema('bundle').function('stage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function(e, o) {\n        console.log(e, o);\n        w.trigger('reload_commit_dialog');\n    })\n    .catch(function() {\n        alert('stage failed');\n        console.error('stage failed');\n    });\n    \n});
\\xf9453243de260974f29858e3bcc94d7b688933892ef60f9118c4b99d312af9e2	var w = $("#"+id);\n\nw.find('.field_name').html(field.column_id.name);\n\nw.find('button.stage').click(function() {\n    endpoint.schema('bundle').function('stage_field_change', [\n        // bundle_name text, schema_name text, relation_name text, pk_column_name text, pk_value text, column_name text\n        bundle.get('name'),\n        field.row_id.pk_column_id.relation_id.schema_id.name,\n        field.row_id.pk_column_id.relation_id.name,\n        field.row_id.pk_column_id.name,\n        field.row_id.pk_value,\n        field.column_id.name\n    ])\n    .then(function(e, o) {\n        console.log(e, o);\n        w.trigger('reload_commit_dialog');\n    })\n    .catch(function() {\n        alert('stage failed');\n        console.error('stage failed');\n    });\n    \n});
\\xfa8985c904915f60fc5d56f7fdebdee4df5886dd7feebd8fd90f2af0a1094785	<div id="{{= id }}" class="{{= name }}">\n    <nobr>\n        <span class='label'></span>\n        <span class='changes'>\n            <span title='This row has been modified' class='icon modified'>&Delta;</span>\n            <span title='This row has been deleted' class='icon deleted'>-</span>\n            <span title='This row has been added' class='icon added'>+</span>\n            <span title='This row has been added' class='icon tracked'>&#128065;</span>\n            <span title='This row does not exist in the live database' class='icon doesnt_exist'>&#x1f5d1;</span>\n        </span>\n    </nobr>\n</div>
\\xfa8985c904915f60fc5d56f7fdebdee4df5886dd7feebd8fd90f2af0a1094785	<div id="{{= id }}" class="{{= name }}">\n    <nobr>\n        <span class='label'></span>\n        <span class='changes'>\n            <span title='This row has been modified' class='icon modified'>&Delta;</span>\n            <span title='This row has been deleted' class='icon deleted'>-</span>\n            <span title='This row has been added' class='icon added'>+</span>\n            <span title='This row has been added' class='icon tracked'>&#128065;</span>\n            <span title='This row does not exist in the live database' class='icon doesnt_exist'>&#x1f5d1;</span>\n        </span>\n    </nobr>\n</div>
\\xfadb7d95346980c50d40361007f0c36bb621357ee35f9b1c79576be298b6c453	var w = $("#"+id);\nvar tab_links = w.find('> nav > a');\nvar content = w.find('.content');\n\n// tab colors\ntab_links.each(function() {\n    var tab_name = $(this).attr('data-tab');\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n\t    $(this).css('border-left', '10px solid ' + tab_colors[tab_name]);\n    }\n});\n\n\ntab_links.on('click', function() {\n    tab_links.removeClass('selected');\n    var tab_name = $(this).attr('data-tab');\n    w.data('selected_tab', $(this));\n\n    content.html(tabs[$(this).addClass('selected').attr('data-tab')]());\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n        w.css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\n\nif (typeof selected == 'undefined') {\n    tab_links.filter(':first').get(0).click();\n}\nelse {\n    tab_links.filter('[data-tab="' + selected + '"]').get(0).click();\n}\n
\\xfadb7d95346980c50d40361007f0c36bb621357ee35f9b1c79576be298b6c453	var w = $("#"+id);\nvar tab_links = w.find('> nav > a');\nvar content = w.find('.content');\n\n// tab colors\ntab_links.each(function() {\n    var tab_name = $(this).attr('data-tab');\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n\t    $(this).css('border-left', '10px solid ' + tab_colors[tab_name]);\n    }\n});\n\n\ntab_links.on('click', function() {\n    tab_links.removeClass('selected');\n    var tab_name = $(this).attr('data-tab');\n    w.data('selected_tab', $(this));\n\n    content.html(tabs[$(this).addClass('selected').attr('data-tab')]());\n    if (typeof tab_colors != 'undefined' && typeof tab_colors[tab_name] != 'undefined') {\n        w.css('border-left', '10px solid '+tab_colors[tab_name]);\n    }\n});\n\n\nif (typeof selected == 'undefined') {\n    tab_links.filter(':first').get(0).click();\n}\nelse {\n    tab_links.filter('[data-tab="' + selected + '"]').get(0).click();\n}\n
\\xfc8679f396432bf7fbfbadac7e52f586ad1d65727c543dfebe42ab2e057fbdfe	var w = $("#"+id);\n\n/* Flushes current styles \n    so initial opacity/background-color/visibility take effect\n      before adding "fade" class */\nw.css('opacity');\n\nw.addClass(type + ' fade');\n\nsetTimeout(function() {\n    w.remove();\n}, 2000);\n
\\xfc8679f396432bf7fbfbadac7e52f586ad1d65727c543dfebe42ab2e057fbdfe	var w = $("#"+id);\n\n/* Flushes current styles \n    so initial opacity/background-color/visibility take effect\n      before adding "fade" class */\nw.css('opacity');\n\nw.addClass(type + ' fade');\n\nsetTimeout(function() {\n    w.remove();\n}, 2000);\n
\\xfcc7c9cd6722536c56afd1d10c85ed24f7738893f9701b7bff1dbf5239bee0ef	semantics_widget_widget_listitem_identifier
\\xfcc7c9cd6722536c56afd1d10c85ed24f7738893f9701b7bff1dbf5239bee0ef	semantics_widget_widget_listitem_identifier
\\xfe2d1542a0f1789e9c595873307bd708cab0f32944257d21a5ed2bcf11c7c5ab	<div id="{{= id }}" class="{{= name }}">\n    <div class="show_all">show all</div>\n    <div class="tree_container">\n        \n    </div>\n    <li class="new_widget">new widget</li>\n</div>
\\xfe2d1542a0f1789e9c595873307bd708cab0f32944257d21a5ed2bcf11c7c5ab	<div id="{{= id }}" class="{{= name }}">\n    <div class="show_all">show all</div>\n    <div class="tree_container">\n        \n    </div>\n    <li class="new_widget">new widget</li>\n</div>
\\xff740900365b409052b9a27822712c359cb837baf4d6dfe6076c93cf25d7f72d	row_detail_dependency_js
\\xff740900365b409052b9a27822712c359cb837baf4d6dfe6076c93cf25d7f72d	row_detail_dependency_js
\\xff968e48f617a279b6f35fc595e6ccbc6460809ab2d0bcf762705caaaa3ed116	var w = $("#"+id);\n\nvar rel_name = datum.schema.name + '.' + datum.name;\nw.find('.rel_name').text(rel_name);\n\nfunction save(save_as_null) {\n    var val = w.find('.name').val().trim();\n\n    if (save_as_null) {\n        val = null;\n    }\n\n    datum.insert({\n        name: val\n    })\n    .then(function() {\n        w.trigger('status', ['New row on ' + rel_name, 'success']);\n        w.trigger('done');\n    }).catch(function() {\n        w.trigger('status', ['Failed insert on ' + rel_name, 'fail']);\n    });\n}\n\n\n/* TRIGGERS */\nw.find('.save_as_null').on('click', save.bind(this, true));\n\nw.find('.name').on('keyup', function(e) {\n    e.stopPropagation();\n    if (e.key == 13) {\n        save(false);\n    }\n});\n\nw.find('.save').on('click', save.bind(this, false));\nw.on('keydown', jwerty.event('ctrl+s', save.bind(this, false)));\n
\\xff968e48f617a279b6f35fc595e6ccbc6460809ab2d0bcf762705caaaa3ed116	var w = $("#"+id);\n\nvar rel_name = datum.schema.name + '.' + datum.name;\nw.find('.rel_name').text(rel_name);\n\nfunction save(save_as_null) {\n    var val = w.find('.name').val().trim();\n\n    if (save_as_null) {\n        val = null;\n    }\n\n    datum.insert({\n        name: val\n    })\n    .then(function() {\n        w.trigger('status', ['New row on ' + rel_name, 'success']);\n        w.trigger('done');\n    }).catch(function() {\n        w.trigger('status', ['Failed insert on ' + rel_name, 'fail']);\n    });\n}\n\n\n/* TRIGGERS */\nw.find('.save_as_null').on('click', save.bind(this, true));\n\nw.find('.name').on('keyup', function(e) {\n    e.stopPropagation();\n    if (e.key == 13) {\n        save(false);\n    }\n});\n\nw.find('.save').on('click', save.bind(this, false));\nw.on('keydown', jwerty.event('ctrl+s', save.bind(this, false)));\n
\\xffbecc06a7cc2b5c212136159b4ade752fd56887a3a0e337772cdf60d8adeaf9	<span id="{{= id }}" class="{{= name }} displaying">\n    <span class='display'></span>\n    <span class='edit'>\n        <input type='text' value='{{= field.value }}'>\n        <button class='save'>Save</button>\n        <button class='cancel'>Cancel</button>\n        <button class='save_as_null'>Save as null</button>\n    </span>\n    <span class='save'>\n        saving...\n    </span>\n</span>\n
\\xffbecc06a7cc2b5c212136159b4ade752fd56887a3a0e337772cdf60d8adeaf9	<span id="{{= id }}" class="{{= name }} displaying">\n    <span class='display'></span>\n    <span class='edit'>\n        <input type='text' value='{{= field.value }}'>\n        <button class='save'>Save</button>\n        <button class='cancel'>Cancel</button>\n        <button class='save_as_null'>Save as null</button>\n    </span>\n    <span class='save'>\n        saving...\n    </span>\n</span>\n
\\xffc33aef281d43764c9171c68082c834ab442a606c486f4dd4cf1937e46c410b	a1a8b72b-59ed-45dc-ac50-dfa5dbb71f43
\\xffc33aef281d43764c9171c68082c834ab442a606c486f4dd4cf1937e46c410b	a1a8b72b-59ed-45dc-ac50-dfa5dbb71f43
\\xffd1fc1b2ff4eea6ad49b247f7365cede4676c636364eb7864359598abadf437	sem_fkey_one_to_many_li
\\xffd1fc1b2ff4eea6ad49b247f7365cede4676c636364eb7864359598abadf437	sem_fkey_one_to_many_li
